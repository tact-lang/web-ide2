/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function() {
var __m = ["exports","require","vs/base/common/uri","vs/platform/instantiation/common/instantiation","vs/base/common/lifecycle","vs/workbench/api/common/extHost.protocol","vs/base/common/event","vs/workbench/api/common/extHostTypes","vs/workbench/api/common/extHostTypeConverters","vs/nls","vs/base/common/async","vs/platform/log/common/log","vs/base/common/strings","vs/base/common/errors","vs/base/common/types","vs/base/common/network","vs/workbench/api/common/extHostRpcService","vs/base/common/arrays","vs/platform/extensions/common/extensions","vs/base/common/path","vs/base/common/platform","vs/base/common/cancellation","vs/base/common/buffer","vs/base/common/resources","vs/workbench/services/extensions/common/extensions","vs/base/common/objects","vs/workbench/api/common/extHostInitDataService","vs/base/common/charCode","vs/base/common/map","vs/platform/files/common/files","vs/platform/registry/common/platform","vs/platform/contextkey/common/contextkey","vs/editor/common/core/range","vs/workbench/api/common/extHostCommands","vs/base/common/themables","vs/base/common/severity","vs/base/common/marshalling","vs/base/common/marshallingIds","vs/base/common/uuid","vs/workbench/services/extensions/common/proxyIdentifier","vs/base/common/iterator","vs/base/common/glob","vs/base/common/errorMessage","vs/platform/configuration/common/configuration","vs/workbench/services/search/common/search","vs/workbench/api/common/extHostWorkspace","vs/workbench/api/common/extHostConfiguration","vs/workbench/api/common/extHostExtensionService","vs/base/common/lazy","vs/platform/workspace/common/workspace","vs/workbench/api/common/extHostFileSystemInfo","vs/base/common/extpath","vs/editor/common/model","vs/platform/configuration/common/configurationRegistry","vs/workbench/contrib/testing/common/testId","vs/workbench/contrib/testing/common/testTypes","vs/workbench/api/common/extHostTerminalService","vs/workbench/api/common/extHostDocumentsAndEditors","vs/base/common/ternarySearchTree","vs/base/common/htmlContent","vs/platform/instantiation/common/extensions","vs/base/common/assert","vs/platform/remote/common/remoteHosts","vs/platform/telemetry/common/telemetryUtils","vs/base/common/performance","vs/workbench/api/common/extHostUriTransformerService","vs/workbench/api/common/extHostTelemetry","vs/workbench/api/common/extHostWebview","vs/workbench/api/common/extHostFileSystemConsumer","vs/base/common/stopwatch","vs/workbench/api/common/extHostEditorTabs","vs/base/common/decorators","vs/base/common/mime","vs/platform/instantiation/common/descriptors","vs/platform/instantiation/common/serviceCollection","vs/base/common/hash","vs/platform/progress/common/progress","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/base/common/process","vs/workbench/api/common/cache","vs/workbench/contrib/debug/common/debug","vs/workbench/contrib/testing/common/testItemCollection","vs/workbench/contrib/webview/common/webview","vs/workbench/services/extensions/common/extensionHostProtocol","vs/workbench/api/common/extHostApiDeprecationService","vs/workbench/api/common/extHostLocalizationService","vs/workbench/api/common/extHostManagedSockets","vs/workbench/api/common/extHostSecretState","vs/workbench/api/common/extHostStorage","vs/workbench/contrib/notebook/common/notebookCommon","vs/workbench/api/common/extHostAuthentication","vs/workbench/api/common/extHostStoragePaths","vs/workbench/api/common/extHostTunnelService","vs/editor/common/languages","vs/workbench/api/common/extHostLanguageModels","vs/workbench/api/common/extHostTesting","vs/base/common/idGenerator","vs/base/common/codicons","vs/base/common/iconLabels","vs/base/common/labels","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase","vs/editor/common/core/position","vs/editor/common/model/textModelSearch","vs/editor/common/services/semanticTokensDto","vs/platform/extensions/common/extensionsApiProposals","vs/editor/common/config/editorOptions","vs/platform/environment/common/environment","vs/platform/markers/common/markers","vs/platform/product/common/productService","vs/platform/remote/common/remoteAuthorityResolver","vs/platform/extensionManagement/common/extensionManagement","vs/platform/extensionManagement/common/implicitActivationEvents","vs/platform/telemetry/common/telemetry","vs/platform/userDataProfile/common/userDataProfile","vs/workbench/common/editor","vs/workbench/contrib/chat/common/chatAgents","vs/workbench/api/common/extHostTestingPrivateApi","vs/workbench/services/authentication/common/authentication","vs/workbench/services/editor/common/editorGroupsService","vs/workbench/services/extensions/common/extensionDescriptionRegistry","vs/workbench/services/extensions/common/extensionsRegistry","vs/workbench/api/common/extHostWindow","vs/workbench/api/common/extHostDecorations","vs/workbench/api/common/extHostDocumentData","vs/workbench/api/common/extHostNotebookEditor","vs/workbench/api/common/extHostTestItem","vs/workbench/api/common/extHostTerminalShellIntegration","vs/workbench/api/common/extHostTextEditor","vs/workbench/api/common/extHostOutput","vs/workbench/services/remote/common/remoteAgentService","vs/workbench/services/search/common/searchExtTypes","vs/workbench/api/common/extHostTask","vs/workbench/api/common/extHostVariableResolverService","vs/workbench/api/common/extHostDebugService","vs/workbench/api/common/extHostSearch","vs/base/common/equals","vs/base/common/json","vs/base/common/jsonSchema","vs/base/common/marked/marked","vs/base/common/naturalLanguage/korean","vs/base/common/numbers","vs/base/common/observableInternal/debugName","vs/base/common/observableInternal/logging","vs/base/common/observableInternal/base","vs/base/common/prefixTree","vs/base/common/comparers","vs/base/common/scrollable","vs/base/common/stream","vs/base/common/symbols","vs/base/common/filters","vs/base/common/uriIpc","vs/base/common/dataTransfer","vs/base/parts/storage/common/storage","vs/editor/common/core/eolCounter","vs/editor/common/core/stringBuilder","vs/editor/common/core/textChange","vs/editor/common/core/textModelDefaults","vs/editor/common/languageSelector","vs/editor/common/languages/languageConfiguration","vs/editor/common/encodedTokenAttributes","vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer","vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder","vs/editor/common/services/treeViewsDnd","vs/base/common/actions","vs/base/common/date","vs/platform/contextkey/common/scanner","vs/platform/instantiation/common/graph","vs/platform/accessibility/common/accessibility","vs/editor/common/core/wordHelper","vs/platform/instantiation/common/instantiationService","vs/base/common/linkedList","vs/platform/log/common/logService","vs/platform/notification/common/notification","vs/platform/configuration/common/configurationModels","vs/platform/extensions/common/extensionValidator","vs/platform/request/common/request","vs/platform/telemetry/common/commonProperties","vs/platform/extensionManagement/common/extensionManagementUtil","vs/platform/terminal/common/environmentVariableShared","vs/platform/terminal/common/terminal","vs/platform/terminal/common/terminalDataBuffering","vs/platform/theme/common/iconRegistry","vs/platform/tunnel/common/tunnel","vs/platform/uriIdentity/common/uriIdentity","vs/platform/workspace/common/editSessions","vs/platform/workspace/common/virtualWorkspace","vs/platform/storage/common/storage","vs/workbench/api/common/extHostLogService","vs/workbench/api/common/extHostMemento","vs/workbench/api/common/extHostNotebookDocuments","vs/workbench/api/common/extHostSecrets","vs/workbench/common/views","vs/workbench/contrib/chat/common/chatContextKeys","vs/workbench/contrib/chat/common/chatService","vs/workbench/contrib/debug/common/abstractDebugAdapter","vs/workbench/contrib/debug/common/debugUtils","vs/workbench/contrib/notebook/common/notebookExecutionService","vs/workbench/contrib/notebook/common/notebookKernelService","vs/workbench/contrib/search/common/cellSearchModel","vs/workbench/contrib/testing/common/constants","vs/workbench/api/common/extHostCodeInsets","vs/workbench/services/configurationResolver/common/configurationResolver","vs/workbench/services/configurationResolver/common/variableResolver","vs/workbench/services/editor/common/editorService","vs/workbench/services/environment/common/environmentService","vs/workbench/api/common/extHostExtensionActivator","vs/workbench/contrib/chat/common/languageModels","vs/workbench/contrib/tasks/common/taskDefinitionRegistry","vs/workbench/contrib/tasks/common/tasks","vs/workbench/services/extensions/common/lazyPromise","vs/workbench/api/common/extHostClipboard","vs/workbench/api/common/extHostConsoleForwarder","vs/workbench/api/common/extHostDialogs","vs/workbench/api/common/extHostEmbedding","vs/workbench/api/common/extHostLabelService","vs/workbench/api/common/extHostLoggerService","vs/workbench/api/common/extHostMessageService","vs/workbench/api/common/extHostProfileContentHandler","vs/workbench/api/common/extHostSpeech","vs/workbench/api/common/extHostUriOpener","vs/workbench/api/common/extHostUrls","vs/workbench/api/common/extHostWebviewMessaging","vs/workbench/api/worker/extHostConsoleForwarder","vs/workbench/services/extensions/common/rpcProtocol","vs/workbench/services/extensions/worker/polyfillNestedWorker","vs/workbench/services/notebook/common/notebookDocumentService","vs/workbench/api/common/extHostAiRelatedInformation","vs/workbench/api/common/extHostDocumentContentProviders","vs/workbench/api/common/extHostEmbeddingVector","vs/workbench/api/common/extHostTheming","vs/base/common/functional","vs/workbench/api/common/extHostBulkEdits","vs/workbench/api/common/extHostChatAgents2","vs/workbench/api/common/extHostChatVariables","vs/workbench/api/common/extHostComments","vs/workbench/api/common/extHostCustomEditors","vs/workbench/api/common/extHostDiagnostics","vs/workbench/api/common/extHostDocumentSaveParticipant","vs/workbench/api/common/extHostDocuments","vs/base/common/collections","vs/workbench/api/common/extHostFileSystem","vs/workbench/api/common/extHostFileSystemEventService","vs/workbench/api/common/extHostLanguageFeatures","vs/workbench/api/common/extHostLanguageModelTools","vs/workbench/api/common/extHostLanguages","vs/workbench/api/common/extHostNotebookDocument","vs/workbench/api/common/extHostNotebookDocumentSaveParticipant","vs/workbench/api/common/extHostNotebookEditors","vs/workbench/api/common/extHostNotebookRenderers","vs/workbench/api/common/extHostProgress","vs/workbench/api/common/extHostQuickDiff","vs/workbench/api/common/extHostQuickOpen","vs/workbench/api/common/extHostSCM","vs/workbench/api/common/extHostShare","vs/workbench/api/common/extHostStatusBar","vs/workbench/api/common/extHostApiCommands","vs/workbench/api/common/extHostInteractive","vs/workbench/api/common/extHostNotebookKernels","vs/workbench/api/common/extHostTextEditors","vs/workbench/api/common/extHostTimeline","vs/workbench/api/common/extHostTreeViews","vs/workbench/api/common/extHostWebviewPanels","vs/workbench/api/common/extHostWebviewView","vs/workbench/services/output/common/output","vs/workbench/common/configuration","vs/workbench/services/editor/common/editorResolverService","vs/workbench/services/path/common/pathService","vs/workbench/contrib/search/common/searchNotebookHelpers","vs/workbench/api/common/extHostNotebook","vs/workbench/services/search/common/fileSearchManager","vs/workbench/services/search/common/queryBuilder","vs/workbench/services/extensions/common/workspaceContains","vs/workbench/api/common/extHostRequireInterceptor","vs/workbench/api/common/extensionHostMain","vs/workbench/services/search/common/textSearchManager","vs/workbench/api/common/extHost.api.impl","vs/workbench/api/common/extHost.common.services","vs/workbench/api/worker/extHostExtensionService","vs/workbench/api/worker/extHost.worker.services","vs/base/common/uint","vs/base/common/semver/semver","vs/base/common/codiconsUtil","vs/base/common/arraysFind","vs/editor/common/model/mirrorTextModel","vs/editor/common/languages/linkComputer","vs/editor/common/core/selection","vs/workbench/api/worker/extensionHostWorker"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[71/*vs/base/common/decorators*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$0h = $0h;
    exports.$$h = $$h;
    exports.$_h = $_h;
    function createDecorator(mapFn) {
        return (target, key, descriptor) => {
            let fnKey = null;
            let fn = null;
            if (typeof descriptor.value === 'function') {
                fnKey = 'value';
                fn = descriptor.value;
            }
            else if (typeof descriptor.get === 'function') {
                fnKey = 'get';
                fn = descriptor.get;
            }
            if (!fn) {
                throw new Error('not supported');
            }
            descriptor[fnKey] = mapFn(fn, key);
        };
    }
    function $0h(_target, key, descriptor) {
        let fnKey = null;
        let fn = null;
        if (typeof descriptor.value === 'function') {
            fnKey = 'value';
            fn = descriptor.value;
            if (fn.length !== 0) {
                console.warn('Memoize should only be used in functions with zero parameters');
            }
        }
        else if (typeof descriptor.get === 'function') {
            fnKey = 'get';
            fn = descriptor.get;
        }
        if (!fn) {
            throw new Error('not supported');
        }
        const memoizeKey = `$memoize$${key}`;
        descriptor[fnKey] = function (...args) {
            if (!this.hasOwnProperty(memoizeKey)) {
                Object.defineProperty(this, memoizeKey, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: fn.apply(this, args)
                });
            }
            return this[memoizeKey];
        };
    }
    function $$h(delay, reducer, initialValueProvider) {
        return createDecorator((fn, key) => {
            const timerKey = `$debounce$${key}`;
            const resultKey = `$debounce$result$${key}`;
            return function (...args) {
                if (!this[resultKey]) {
                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                }
                clearTimeout(this[timerKey]);
                if (reducer) {
                    this[resultKey] = reducer(this[resultKey], ...args);
                    args = [this[resultKey]];
                }
                this[timerKey] = setTimeout(() => {
                    fn.apply(this, args);
                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                }, delay);
            };
        });
    }
    function $_h(delay, reducer, initialValueProvider) {
        return createDecorator((fn, key) => {
            const timerKey = `$throttle$timer$${key}`;
            const resultKey = `$throttle$result$${key}`;
            const lastRunKey = `$throttle$lastRun$${key}`;
            const pendingKey = `$throttle$pending$${key}`;
            return function (...args) {
                if (!this[resultKey]) {
                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                }
                if (this[lastRunKey] === null || this[lastRunKey] === undefined) {
                    this[lastRunKey] = -Number.MAX_VALUE;
                }
                if (reducer) {
                    this[resultKey] = reducer(this[resultKey], ...args);
                }
                if (this[pendingKey]) {
                    return;
                }
                const nextTime = this[lastRunKey] + delay;
                if (nextTime <= Date.now()) {
                    this[lastRunKey] = Date.now();
                    fn.apply(this, [this[resultKey]]);
                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                }
                else {
                    this[pendingKey] = true;
                    this[timerKey] = setTimeout(() => {
                        this[pendingKey] = false;
                        this[lastRunKey] = Date.now();
                        fn.apply(this, [this[resultKey]]);
                        this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                    }, nextTime - Date.now());
                }
            };
        });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
define(__m[135/*vs/base/common/equals*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/]), function (require, exports, arrays) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$6c = void 0;
    exports.$7c = $7c;
    exports.$8c = $8c;
    exports.$9c = $9c;
    exports.$0c = $0c;
    exports.$$c = $$c;
    exports.$_c = $_c;
    arrays = __importStar(arrays);
    /**
     * Compares two items for equality using strict equality.
    */
    const $6c = (a, b) => a === b;
    exports.$6c = $6c;
    /**
     * Checks if the items of two arrays are equal.
     * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.
     */
    function $7c(itemEquals = exports.$6c) {
        return (a, b) => arrays.$tb(a, b, itemEquals);
    }
    /**
     * Two items are considered equal, if their stringified representations are equal.
    */
    function $8c() {
        return (a, b) => JSON.stringify(a) === JSON.stringify(b);
    }
    /**
     * Uses `item.equals(other)` to determine equality.
     */
    function $9c() {
        return (a, b) => a.equals(b);
    }
    function $0c(equalsOrV1, v2, equals) {
        if (equals !== undefined) {
            const v1 = equalsOrV1;
            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {
                return v2 === v1;
            }
            return equals(v1, v2);
        }
        else {
            const equals = equalsOrV1;
            return (v1, v2) => {
                if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {
                    return v2 === v1;
                }
                return equals(v1, v2);
            };
        }
    }
    /**
     * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.
    */
    function $$c(a, b) {
        if (a === b) {
            return true;
        }
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                if (!$$c(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        if (a && typeof a === 'object' && b && typeof b === 'object') {
            if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {
                const aObj = a;
                const bObj = b;
                const keysA = Object.keys(aObj);
                const keysB = Object.keys(bObj);
                const keysBSet = new Set(keysB);
                if (keysA.length !== keysB.length) {
                    return false;
                }
                for (const key of keysA) {
                    if (!keysBSet.has(key)) {
                        return false;
                    }
                    if (!$$c(aObj[key], bObj[key])) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
    /**
     * `getStructuralKey(a) === getStructuralKey(b) <=> structuralEquals(a, b)`
     * (assuming that a and b are not cyclic structures and nothing extends globalThis Array).
    */
    function $_c(t) {
        return JSON.stringify(toNormalizedJsonStructure(t));
    }
    let objectId = 0;
    const objIds = new WeakMap();
    function toNormalizedJsonStructure(t) {
        if (Array.isArray(t)) {
            return t.map(toNormalizedJsonStructure);
        }
        if (t && typeof t === 'object') {
            if (Object.getPrototypeOf(t) === Object.prototype) {
                const tObj = t;
                const res = Object.create(null);
                for (const key of Object.keys(tObj).sort()) {
                    res[key] = toNormalizedJsonStructure(tObj[key]);
                }
                return res;
            }
            else {
                let objId = objIds.get(t);
                if (objId === undefined) {
                    objId = objectId++;
                    objIds.set(t, objId);
                }
                // Random string to prevent collisions
                return objId + '----2b76a038c20c4bcc';
            }
        }
        return t;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[96/*vs/base/common/idGenerator*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$qQ = exports.$pQ = void 0;
    class $pQ {
        constructor(prefix) {
            this.a = prefix;
            this.b = 0;
        }
        nextId() {
            return this.a + (++this.b);
        }
    }
    exports.$pQ = $pQ;
    exports.$qQ = new $pQ('id#');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[136/*vs/base/common/json*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParseOptions = exports.ParseErrorCode = exports.SyntaxKind = exports.ScanError = void 0;
    exports.$Wn = $Wn;
    exports.$Xn = $Xn;
    exports.$Yn = $Yn;
    exports.$Zn = $Zn;
    exports.$1n = $1n;
    exports.$2n = $2n;
    exports.$3n = $3n;
    exports.$4n = $4n;
    exports.$5n = $5n;
    exports.$6n = $6n;
    exports.$7n = $7n;
    var ScanError;
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
        ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError || (exports.ScanError = ScanError = {}));
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
        SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
    })(SyntaxKind || (exports.SyntaxKind = SyntaxKind = {}));
    var ParseErrorCode;
    (function (ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
        ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
        ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
        ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
        ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
    })(ParseErrorCode || (exports.ParseErrorCode = ParseErrorCode = {}));
    var ParseOptions;
    (function (ParseOptions) {
        ParseOptions.DEFAULT = {
            allowTrailingComma: true
        };
    })(ParseOptions || (exports.ParseOptions = ParseOptions = {}));
    /**
     * Creates a JSON scanner on the given text.
     * If ignoreTrivia is set, whitespaces or comments are ignored.
     */
    function $Wn(text, ignoreTrivia = false) {
        let pos = 0;
        const len = text.length;
        let value = '';
        let tokenOffset = 0;
        let token = SyntaxKind.Unknown;
        let scanError = ScanError.None;
        function scanHexDigits(count) {
            let digits = 0;
            let hexValue = 0;
            while (digits < count) {
                const ch = text.charCodeAt(pos);
                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {
                    hexValue = hexValue * 16 + ch - CharacterCodes._0;
                }
                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {
                    hexValue = hexValue * 16 + ch - CharacterCodes.A + 10;
                }
                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {
                    hexValue = hexValue * 16 + ch - CharacterCodes.a + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                hexValue = -1;
            }
            return hexValue;
        }
        function setPosition(newPosition) {
            pos = newPosition;
            value = '';
            tokenOffset = 0;
            token = SyntaxKind.Unknown;
            scanError = ScanError.None;
        }
        function scanNumber() {
            const start = pos;
            if (text.charCodeAt(pos) === CharacterCodes._0) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                    return text.substring(start, pos);
                }
            }
            let end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            let result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                const ch = text.charCodeAt(pos);
                if (ch === CharacterCodes.doubleQuote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === CharacterCodes.backslash) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    const ch2 = text.charCodeAt(pos++);
                    switch (ch2) {
                        case CharacterCodes.doubleQuote:
                            result += '\"';
                            break;
                        case CharacterCodes.backslash:
                            result += '\\';
                            break;
                        case CharacterCodes.slash:
                            result += '/';
                            break;
                        case CharacterCodes.b:
                            result += '\b';
                            break;
                        case CharacterCodes.f:
                            result += '\f';
                            break;
                        case CharacterCodes.n:
                            result += '\n';
                            break;
                        case CharacterCodes.r:
                            result += '\r';
                            break;
                        case CharacterCodes.t:
                            result += '\t';
                            break;
                        case CharacterCodes.u: {
                            const ch3 = scanHexDigits(4);
                            if (ch3 >= 0) {
                                result += String.fromCharCode(ch3);
                            }
                            else {
                                scanError = ScanError.InvalidUnicode;
                            }
                            break;
                        }
                        default:
                            scanError = ScanError.InvalidEscapeCharacter;
                    }
                    start = pos;
                    continue;
                }
                if (ch >= 0 && ch <= 0x1F) {
                    if (isLineBreak(ch)) {
                        result += text.substring(start, pos);
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    else {
                        scanError = ScanError.InvalidCharacter;
                        // mark as error but continue with string
                    }
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = ScanError.None;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = SyntaxKind.EOF;
            }
            let code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhitespace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhitespace(code));
                return token = SyntaxKind.Trivia;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {
                    pos++;
                    value += '\n';
                }
                return token = SyntaxKind.LineBreakTrivia;
            }
            switch (code) {
                // tokens: []{}:,
                case CharacterCodes.openBrace:
                    pos++;
                    return token = SyntaxKind.OpenBraceToken;
                case CharacterCodes.closeBrace:
                    pos++;
                    return token = SyntaxKind.CloseBraceToken;
                case CharacterCodes.openBracket:
                    pos++;
                    return token = SyntaxKind.OpenBracketToken;
                case CharacterCodes.closeBracket:
                    pos++;
                    return token = SyntaxKind.CloseBracketToken;
                case CharacterCodes.colon:
                    pos++;
                    return token = SyntaxKind.ColonToken;
                case CharacterCodes.comma:
                    pos++;
                    return token = SyntaxKind.CommaToken;
                // strings
                case CharacterCodes.doubleQuote:
                    pos++;
                    value = scanString();
                    return token = SyntaxKind.StringLiteral;
                // comments
                case CharacterCodes.slash: {
                    const start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.LineCommentTrivia;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {
                        pos += 2;
                        const safeLength = len - 1; // For lookahead.
                        let commentClosed = false;
                        while (pos < safeLength) {
                            const ch = text.charCodeAt(pos);
                            if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = ScanError.UnexpectedEndOfComment;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.BlockCommentTrivia;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
                }
                // numbers
                case CharacterCodes.minus:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = SyntaxKind.Unknown;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case CharacterCodes._0:
                case CharacterCodes._1:
                case CharacterCodes._2:
                case CharacterCodes._3:
                case CharacterCodes._4:
                case CharacterCodes._5:
                case CharacterCodes._6:
                case CharacterCodes._7:
                case CharacterCodes._8:
                case CharacterCodes._9:
                    value += scanNumber();
                    return token = SyntaxKind.NumericLiteral;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = SyntaxKind.TrueKeyword;
                            case 'false': return token = SyntaxKind.FalseKeyword;
                            case 'null': return token = SyntaxKind.NullKeyword;
                        }
                        return token = SyntaxKind.Unknown;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhitespace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case CharacterCodes.closeBrace:
                case CharacterCodes.closeBracket:
                case CharacterCodes.openBrace:
                case CharacterCodes.openBracket:
                case CharacterCodes.doubleQuote:
                case CharacterCodes.colon:
                case CharacterCodes.comma:
                case CharacterCodes.slash:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            let result;
            do {
                result = scanNext();
            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);
            return result;
        }
        return {
            setPosition: setPosition,
            getPosition: () => pos,
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: () => token,
            getTokenValue: () => value,
            getTokenOffset: () => tokenOffset,
            getTokenLength: () => pos - tokenOffset,
            getTokenError: () => scanError
        };
    }
    function isWhitespace(ch) {
        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||
            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||
            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;
    }
    function isLineBreak(ch) {
        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;
    }
    function isDigit(ch) {
        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    /**
     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
     */
    function $Xn(text, position) {
        const segments = []; // strings or numbers
        const earlyReturnException = new Object();
        let previousNode = undefined;
        const previousNodeInst = {
            value: {},
            offset: 0,
            length: 0,
            type: 'object',
            parent: undefined
        };
        let isAtPropertyKey = false;
        function setPreviousNode(value, offset, length, type) {
            previousNodeInst.value = value;
            previousNodeInst.offset = offset;
            previousNodeInst.length = length;
            previousNodeInst.type = type;
            previousNodeInst.colonOffset = undefined;
            previousNode = previousNodeInst;
        }
        try {
            $6n(text, {
                onObjectBegin: (offset, length) => {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = undefined;
                    isAtPropertyKey = position > offset;
                    segments.push(''); // push a placeholder (will be replaced)
                },
                onObjectProperty: (name, offset, length) => {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(name, offset, length, 'property');
                    segments[segments.length - 1] = name;
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onObjectEnd: (offset, length) => {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = undefined;
                    segments.pop();
                },
                onArrayBegin: (offset, length) => {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = undefined;
                    segments.push(0);
                },
                onArrayEnd: (offset, length) => {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = undefined;
                    segments.pop();
                },
                onLiteralValue: (value, offset, length) => {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(value, offset, length, $7n(value));
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onSeparator: (sep, offset, length) => {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    if (sep === ':' && previousNode && previousNode.type === 'property') {
                        previousNode.colonOffset = offset;
                        isAtPropertyKey = false;
                        previousNode = undefined;
                    }
                    else if (sep === ',') {
                        const last = segments[segments.length - 1];
                        if (typeof last === 'number') {
                            segments[segments.length - 1] = last + 1;
                        }
                        else {
                            isAtPropertyKey = true;
                            segments[segments.length - 1] = '';
                        }
                        previousNode = undefined;
                    }
                }
            });
        }
        catch (e) {
            if (e !== earlyReturnException) {
                throw e;
            }
        }
        return {
            path: segments,
            previousNode,
            isAtPropertyKey,
            matches: (pattern) => {
                let k = 0;
                for (let i = 0; k < pattern.length && i < segments.length; i++) {
                    if (pattern[k] === segments[i] || pattern[k] === '*') {
                        k++;
                    }
                    else if (pattern[k] !== '**') {
                        return false;
                    }
                }
                return k === pattern.length;
            }
        };
    }
    /**
     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     * Therefore always check the errors list to find out if the input was valid.
     */
    function $Yn(text, errors = [], options = ParseOptions.DEFAULT) {
        let currentProperty = null;
        let currentParent = [];
        const previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty !== null) {
                currentParent[currentProperty] = value;
            }
        }
        const visitor = {
            onObjectBegin: () => {
                const object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: (name) => {
                currentProperty = name;
            },
            onObjectEnd: () => {
                currentParent = previousParents.pop();
            },
            onArrayBegin: () => {
                const array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: () => {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: (error, offset, length) => {
                errors.push({ error, offset, length });
            }
        };
        $6n(text, visitor, options);
        return currentParent[0];
    }
    /**
     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     */
    function $Zn(text, errors = [], options = ParseOptions.DEFAULT) {
        let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root
        function ensurePropertyComplete(endOffset) {
            if (currentParent.type === 'property') {
                currentParent.length = endOffset - currentParent.offset;
                currentParent = currentParent.parent;
            }
        }
        function onValue(valueNode) {
            currentParent.children.push(valueNode);
            return valueNode;
        }
        const visitor = {
            onObjectBegin: (offset) => {
                currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });
            },
            onObjectProperty: (name, offset, length) => {
                currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });
                currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });
            },
            onObjectEnd: (offset, length) => {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onArrayBegin: (offset, length) => {
                currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });
            },
            onArrayEnd: (offset, length) => {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onLiteralValue: (value, offset, length) => {
                onValue({ type: $7n(value), offset, length, parent: currentParent, value });
                ensurePropertyComplete(offset + length);
            },
            onSeparator: (sep, offset, length) => {
                if (currentParent.type === 'property') {
                    if (sep === ':') {
                        currentParent.colonOffset = offset;
                    }
                    else if (sep === ',') {
                        ensurePropertyComplete(offset);
                    }
                }
            },
            onError: (error, offset, length) => {
                errors.push({ error, offset, length });
            }
        };
        $6n(text, visitor, options);
        const result = currentParent.children[0];
        if (result) {
            delete result.parent;
        }
        return result;
    }
    /**
     * Finds the node at the given path in a JSON DOM.
     */
    function $1n(root, path) {
        if (!root) {
            return undefined;
        }
        let node = root;
        for (const segment of path) {
            if (typeof segment === 'string') {
                if (node.type !== 'object' || !Array.isArray(node.children)) {
                    return undefined;
                }
                let found = false;
                for (const propertyNode of node.children) {
                    if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
                        node = propertyNode.children[1];
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return undefined;
                }
            }
            else {
                const index = segment;
                if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                    return undefined;
                }
                node = node.children[index];
            }
        }
        return node;
    }
    /**
     * Gets the JSON path of the given JSON DOM node
     */
    function $2n(node) {
        if (!node.parent || !node.parent.children) {
            return [];
        }
        const path = $2n(node.parent);
        if (node.parent.type === 'property') {
            const key = node.parent.children[0].value;
            path.push(key);
        }
        else if (node.parent.type === 'array') {
            const index = node.parent.children.indexOf(node);
            if (index !== -1) {
                path.push(index);
            }
        }
        return path;
    }
    /**
     * Evaluates the JavaScript object of the given JSON DOM node
     */
    function $3n(node) {
        switch (node.type) {
            case 'array':
                return node.children.map($3n);
            case 'object': {
                const obj = Object.create(null);
                for (const prop of node.children) {
                    const valueNode = prop.children[1];
                    if (valueNode) {
                        obj[prop.children[0].value] = $3n(valueNode);
                    }
                }
                return obj;
            }
            case 'null':
            case 'string':
            case 'number':
            case 'boolean':
                return node.value;
            default:
                return undefined;
        }
    }
    function $4n(node, offset, includeRightBound = false) {
        return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
    }
    /**
     * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
     */
    function $5n(node, offset, includeRightBound = false) {
        if ($4n(node, offset, includeRightBound)) {
            const children = node.children;
            if (Array.isArray(children)) {
                for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
                    const item = $5n(children[i], offset, includeRightBound);
                    if (item) {
                        return item;
                    }
                }
            }
            return node;
        }
        return undefined;
    }
    /**
     * Parses the given text and invokes the visitor functions for each object, array and literal reached.
     */
    function $6n(text, visitor, options = ParseOptions.DEFAULT) {
        const _scanner = $Wn(text, false);
        function toNoArgVisit(visitFunction) {
            return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
        }
        function toOneArgVisit(visitFunction) {
            return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;
        }
        const onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
        const disallowComments = options && options.disallowComments;
        const allowTrailingComma = options && options.allowTrailingComma;
        function scanNext() {
            while (true) {
                const token = _scanner.scan();
                switch (_scanner.getTokenError()) {
                    case ScanError.InvalidUnicode:
                        handleError(ParseErrorCode.InvalidUnicode);
                        break;
                    case ScanError.InvalidEscapeCharacter:
                        handleError(ParseErrorCode.InvalidEscapeCharacter);
                        break;
                    case ScanError.UnexpectedEndOfNumber:
                        handleError(ParseErrorCode.UnexpectedEndOfNumber);
                        break;
                    case ScanError.UnexpectedEndOfComment:
                        if (!disallowComments) {
                            handleError(ParseErrorCode.UnexpectedEndOfComment);
                        }
                        break;
                    case ScanError.UnexpectedEndOfString:
                        handleError(ParseErrorCode.UnexpectedEndOfString);
                        break;
                    case ScanError.InvalidCharacter:
                        handleError(ParseErrorCode.InvalidCharacter);
                        break;
                }
                switch (token) {
                    case SyntaxKind.LineCommentTrivia:
                    case SyntaxKind.BlockCommentTrivia:
                        if (disallowComments) {
                            handleError(ParseErrorCode.InvalidCommentToken);
                        }
                        else {
                            onComment();
                        }
                        break;
                    case SyntaxKind.Unknown:
                        handleError(ParseErrorCode.InvalidSymbol);
                        break;
                    case SyntaxKind.Trivia:
                    case SyntaxKind.LineBreakTrivia:
                        break;
                    default:
                        return token;
                }
            }
        }
        function handleError(error, skipUntilAfter = [], skipUntil = []) {
            onError(error);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                let token = _scanner.getToken();
                while (token !== SyntaxKind.EOF) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString(isValue) {
            const value = _scanner.getTokenValue();
            if (isValue) {
                onLiteralValue(value);
            }
            else {
                onObjectProperty(value);
            }
            scanNext();
            return true;
        }
        function parseLiteral() {
            switch (_scanner.getToken()) {
                case SyntaxKind.NumericLiteral: {
                    let value = 0;
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(ParseErrorCode.InvalidNumberFormat);
                            value = 0;
                        }
                    }
                    catch (e) {
                        handleError(ParseErrorCode.InvalidNumberFormat);
                    }
                    onLiteralValue(value);
                    break;
                }
                case SyntaxKind.NullKeyword:
                    onLiteralValue(null);
                    break;
                case SyntaxKind.TrueKeyword:
                    onLiteralValue(true);
                    break;
                case SyntaxKind.FalseKeyword:
                    onLiteralValue(false);
                    break;
                default:
                    return false;
            }
            scanNext();
            return true;
        }
        function parseProperty() {
            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {
                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                return false;
            }
            parseString(false);
            if (_scanner.getToken() === SyntaxKind.ColonToken) {
                onSeparator(':');
                scanNext(); // consume colon
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
            }
            else {
                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
            return true;
        }
        function parseObject() {
            onObjectBegin();
            scanNext(); // consume open brace
            let needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === SyntaxKind.CloseBraceToken && allowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseProperty()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onObjectEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {
                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return true;
        }
        function parseArray() {
            onArrayBegin();
            scanNext(); // consume open bracket
            let needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === SyntaxKind.CloseBracketToken && allowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onArrayEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {
                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return true;
        }
        function parseValue() {
            switch (_scanner.getToken()) {
                case SyntaxKind.OpenBracketToken:
                    return parseArray();
                case SyntaxKind.OpenBraceToken:
                    return parseObject();
                case SyntaxKind.StringLiteral:
                    return parseString(true);
                default:
                    return parseLiteral();
            }
        }
        scanNext();
        if (_scanner.getToken() === SyntaxKind.EOF) {
            if (options.allowEmptyContent) {
                return true;
            }
            handleError(ParseErrorCode.ValueExpected, [], []);
            return false;
        }
        if (!parseValue()) {
            handleError(ParseErrorCode.ValueExpected, [], []);
            return false;
        }
        if (_scanner.getToken() !== SyntaxKind.EOF) {
            handleError(ParseErrorCode.EndOfFileExpected, [], []);
        }
        return true;
    }
    function $7n(value) {
        switch (typeof value) {
            case 'boolean': return 'boolean';
            case 'number': return 'number';
            case 'string': return 'string';
            case 'object': {
                if (!value) {
                    return 'null';
                }
                else if (Array.isArray(value)) {
                    return 'array';
                }
                return 'object';
            }
            default: return 'null';
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[137/*vs/base/common/jsonSchema*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$8j = $8j;
    function $8j(schema) {
        let hasDups = false;
        // visit all schema nodes and collect the ones that are equal
        const equalsByString = new Map();
        const nodeToEquals = new Map();
        const visitSchemas = (next) => {
            if (schema === next) {
                return true;
            }
            const val = JSON.stringify(next);
            if (val.length < 30) {
                // the $ref takes around 25 chars, so we don't save anything
                return true;
            }
            const eq = equalsByString.get(val);
            if (!eq) {
                const newEq = { schemas: [next] };
                equalsByString.set(val, newEq);
                nodeToEquals.set(next, newEq);
                return true;
            }
            eq.schemas.push(next);
            nodeToEquals.set(next, eq);
            hasDups = true;
            return false;
        };
        traverseNodes(schema, visitSchemas);
        equalsByString.clear();
        if (!hasDups) {
            return JSON.stringify(schema);
        }
        let defNodeName = '$defs';
        while (schema.hasOwnProperty(defNodeName)) {
            defNodeName += '_';
        }
        // used to collect all schemas that are later put in `$defs`. The index in the array is the id of the schema.
        const definitions = [];
        function stringify(root) {
            return JSON.stringify(root, (_key, value) => {
                if (value !== root) {
                    const eq = nodeToEquals.get(value);
                    if (eq && eq.schemas.length > 1) {
                        if (!eq.id) {
                            eq.id = `_${definitions.length}`;
                            definitions.push(eq.schemas[0]);
                        }
                        return { $ref: `#/${defNodeName}/${eq.id}` };
                    }
                }
                return value;
            });
        }
        // stringify the schema and replace duplicate subtrees with $ref
        // this will add new items to the definitions array
        const str = stringify(schema);
        // now stringify the definitions. Each invication of stringify cann add new items to the definitions array, so the length can grow while we iterate
        const defStrings = [];
        for (let i = 0; i < definitions.length; i++) {
            defStrings.push(`"_${i}":${stringify(definitions[i])}`);
        }
        if (defStrings.length) {
            return `${str.substring(0, str.length - 1)},"${defNodeName}":{${defStrings.join(',')}}}`;
        }
        return str;
    }
    function isObject(thing) {
        return typeof thing === 'object' && thing !== null;
    }
    /*
     * Traverse a JSON schema and visit each schema node
    */
    function traverseNodes(root, visit) {
        if (!root || typeof root !== 'object') {
            return;
        }
        const collectEntries = (...entries) => {
            for (const entry of entries) {
                if (isObject(entry)) {
                    toWalk.push(entry);
                }
            }
        };
        const collectMapEntries = (...maps) => {
            for (const map of maps) {
                if (isObject(map)) {
                    for (const key in map) {
                        const entry = map[key];
                        if (isObject(entry)) {
                            toWalk.push(entry);
                        }
                    }
                }
            }
        };
        const collectArrayEntries = (...arrays) => {
            for (const array of arrays) {
                if (Array.isArray(array)) {
                    for (const entry of array) {
                        if (isObject(entry)) {
                            toWalk.push(entry);
                        }
                    }
                }
            }
        };
        const collectEntryOrArrayEntries = (items) => {
            if (Array.isArray(items)) {
                for (const entry of items) {
                    if (isObject(entry)) {
                        toWalk.push(entry);
                    }
                }
            }
            else if (isObject(items)) {
                toWalk.push(items);
            }
        };
        const toWalk = [root];
        let next = toWalk.pop();
        while (next) {
            const visitChildern = visit(next);
            if (visitChildern) {
                collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);
                collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);
                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);
                collectEntryOrArrayEntries(next.items);
            }
            next = toWalk.pop();
        }
    }
});

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2022, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

// ESM-uncomment-begin
// let __marked_exports = {};
// (function() {
//   function define(deps, factory) {
//     factory(__marked_exports);
//   }
//   define.amd = true;
// ESM-uncomment-end

 (function (global, factory) {
  typeof define === 'function' && define.amd ? define(__m[138/*vs/base/common/marked/marked*/], __M([0/*exports*/]), factory) :
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));
})(this, (function (exports) { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function getDefaults() {
    return {
      async: false,
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  exports.defaults = getDefaults();
  function changeDefaults(newDefaults) {
    exports.defaults = newDefaults;
  }

  /**
   * Helpers
   */
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  var getEscapeReplacement = function getEscapeReplacement(ch) {
    return escapeReplacements[ch];
  };

  function escape(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }

    return html;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  /**
   * @param {string} html
   */

  function unescape(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(unescapeTest, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';

      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }

      return '';
    });
  }
  var caret = /(^|[^\[])\^/g;
  /**
   * @param {string | RegExp} regex
   * @param {string} opt
   */

  function edit(regex, opt) {
    regex = typeof regex === 'string' ? regex : regex.source;
    opt = opt || '';
    var obj = {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }
  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  /**
   * @param {boolean} sanitize
   * @param {string} base
   * @param {string} href
   */

  function cleanUrl(sanitize, base, href) {
    if (sanitize) {
      var prot;

      try {
        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
      } catch (e) {
        return null;
      }

      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return null;
      }
    }

    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }

    try {
      href = encodeURI(href).replace(/%25/g, '%');
    } catch (e) {
      return null;
    }

    return href;
  }
  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  /**
   * @param {string} base
   * @param {string} href
   */

  function resolveUrl(base, href) {
    if (!baseUrls[' ' + base]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (justDomain.test(base)) {
        baseUrls[' ' + base] = base + '/';
      } else {
        baseUrls[' ' + base] = rtrim(base, '/', true);
      }
    }

    base = baseUrls[' ' + base];
    var relativeBase = base.indexOf(':') === -1;

    if (href.substring(0, 2) === '//') {
      if (relativeBase) {
        return href;
      }

      return base.replace(protocol, '$1') + href;
    } else if (href.charAt(0) === '/') {
      if (relativeBase) {
        return href;
      }

      return base.replace(domain, '$1') + href;
    } else {
      return base + href;
    }
  }
  var noopTest = {
    exec: function noopTest() {}
  };
  function merge(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];

      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }
  function splitCells(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }

      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/);
    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe

    if (!cells[0].trim()) {
      cells.shift();
    }

    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leading or trailing whitespace is ignored per the gfm spec
      cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }

    return cells;
  }
  /**
   * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
   * /c*$/ is vulnerable to REDOS.
   *
   * @param {string} str
   * @param {string} c
   * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
   */

  function rtrim(str, c, invert) {
    var l = str.length;

    if (l === 0) {
      return '';
    } // Length of suffix matching the invert condition.


    var suffLen = 0; // Step left until we fail to match the invert condition.

    while (suffLen < l) {
      var currChar = str.charAt(l - suffLen - 1);

      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }

    return str.slice(0, l - suffLen);
  }
  function findClosingBracket(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }

    var l = str.length;
    var level = 0,
        i = 0;

    for (; i < l; i++) {
      if (str[i] === '\\') {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;

        if (level < 0) {
          return i;
        }
      }
    }

    return -1;
  }
  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
    }
  } // copied from https://stackoverflow.com/a/5450113/806777

  /**
   * @param {string} pattern
   * @param {number} count
   */

  function repeatString(pattern, count) {
    if (count < 1) {
      return '';
    }

    var result = '';

    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }

      count >>= 1;
      pattern += pattern;
    }

    return result + pattern;
  }

  function outputLink(cap, link, raw, lexer) {
    var href = link.href;
    var title = link.title ? escape(link.title) : null;
    var text = cap[1].replace(/\\([\[\]])/g, '$1');

    if (cap[0].charAt(0) !== '!') {
      lexer.state.inLink = true;
      var token = {
        type: 'link',
        raw: raw,
        href: href,
        title: title,
        text: text,
        tokens: lexer.inlineTokens(text)
      };
      lexer.state.inLink = false;
      return token;
    }

    return {
      type: 'image',
      raw: raw,
      href: href,
      title: title,
      text: escape(text)
    };
  }

  function indentCodeCompensation(raw, text) {
    var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

    if (matchIndentToCode === null) {
      return text;
    }

    var indentToCode = matchIndentToCode[1];
    return text.split('\n').map(function (node) {
      var matchIndentInNode = node.match(/^\s+/);

      if (matchIndentInNode === null) {
        return node;
      }

      var indentInNode = matchIndentInNode[0];

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    }).join('\n');
  }
  /**
   * Tokenizer
   */


  var Tokenizer = /*#__PURE__*/function () {
    function Tokenizer(options) {
      this.options = options || exports.defaults;
    }

    var _proto = Tokenizer.prototype;

    _proto.space = function space(src) {
      var cap = this.rules.block.newline.exec(src);

      if (cap && cap[0].length > 0) {
        return {
          type: 'space',
          raw: cap[0]
        };
      }
    };

    _proto.code = function code(src) {
      var cap = this.rules.block.code.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ {1,4}/gm, '');
        return {
          type: 'code',
          raw: cap[0],
          codeBlockStyle: 'indented',
          text: !this.options.pedantic ? rtrim(text, '\n') : text
        };
      }
    };

    _proto.fences = function fences(src) {
      var cap = this.rules.block.fences.exec(src);

      if (cap) {
        var raw = cap[0];
        var text = indentCodeCompensation(raw, cap[3] || '');
        return {
          type: 'code',
          raw: raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: text
        };
      }
    };

    _proto.heading = function heading(src) {
      var cap = this.rules.block.heading.exec(src);

      if (cap) {
        var text = cap[2].trim(); // remove trailing #s

        if (/#$/.test(text)) {
          var trimmed = rtrim(text, '#');

          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            // CommonMark requires space before trailing #s
            text = trimmed.trim();
          }
        }

        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[1].length,
          text: text,
          tokens: this.lexer.inline(text)
        };
      }
    };

    _proto.hr = function hr(src) {
      var cap = this.rules.block.hr.exec(src);

      if (cap) {
        return {
          type: 'hr',
          raw: cap[0]
        };
      }
    };

    _proto.blockquote = function blockquote(src) {
      var cap = this.rules.block.blockquote.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ *>[ \t]?/gm, '');
        return {
          type: 'blockquote',
          raw: cap[0],
          tokens: this.lexer.blockTokens(text, []),
          text: text
        };
      }
    };

    _proto.list = function list(src) {
      var cap = this.rules.block.list.exec(src);

      if (cap) {
        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
        var bull = cap[1].trim();
        var isordered = bull.length > 1;
        var list = {
          type: 'list',
          raw: '',
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : '',
          loose: false,
          items: []
        };
        bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;

        if (this.options.pedantic) {
          bull = isordered ? bull : '[*+-]';
        } // Get next list item


        var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[\t ][^\\n]*)?(?:\\n|$))"); // Check if current bullet point can start a new List Item

        while (src) {
          endEarly = false;

          if (!(cap = itemRegex.exec(src))) {
            break;
          }

          if (this.rules.block.hr.test(src)) {
            // End list if bullet was actually HR (possibly move into itemRegex?)
            break;
          }

          raw = cap[0];
          src = src.substring(raw.length);
          line = cap[2].split('\n', 1)[0];
          nextLine = src.split('\n', 1)[0];

          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimLeft();
          } else {
            indent = cap[2].search(/[^ ]/); // Find first non-space char

            indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent

            itemContents = line.slice(indent);
            indent += cap[1].length;
          }

          blankLine = false;

          if (!line && /^ *$/.test(nextLine)) {
            // Items begin with at most one blank line
            raw += nextLine + '\n';
            src = src.substring(nextLine.length + 1);
            endEarly = true;
          }

          if (!endEarly) {
            var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))");
            var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
            var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
            var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#"); // Check if following lines should be included in List Item

            while (src) {
              rawLine = src.split('\n', 1)[0];
              line = rawLine; // Re-align to follow commonmark nesting rules

              if (this.options.pedantic) {
                line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
              } // End list item if found code fences


              if (fencesBeginRegex.test(line)) {
                break;
              } // End list item if found start of new heading


              if (headingBeginRegex.test(line)) {
                break;
              } // End list item if found start of new bullet


              if (nextBulletRegex.test(line)) {
                break;
              } // Horizontal rule found


              if (hrRegex.test(src)) {
                break;
              }

              if (line.search(/[^ ]/) >= indent || !line.trim()) {
                // Dedent if possible
                itemContents += '\n' + line.slice(indent);
              } else if (!blankLine) {
                // Until blank line, item doesn't need indentation
                itemContents += '\n' + line;
              } else {
                // Otherwise, improper indentation ends this item
                break;
              }

              if (!blankLine && !line.trim()) {
                // Check if current line is blank
                blankLine = true;
              }

              raw += rawLine + '\n';
              src = src.substring(rawLine.length + 1);
            }
          }

          if (!list.loose) {
            // If the previous item ended with a blank line, the list is loose
            if (endsWithBlankLine) {
              list.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          } // Check for task list items


          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);

            if (istask) {
              ischecked = istask[0] !== '[ ] ';
              itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
            }
          }

          list.items.push({
            type: 'list_item',
            raw: raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents
          });
          list.raw += raw;
        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic


        list.items[list.items.length - 1].raw = raw.trimRight();
        list.items[list.items.length - 1].text = itemContents.trimRight();
        list.raw = list.raw.trimRight();
        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first

        for (i = 0; i < l; i++) {
          this.lexer.state.top = false;
          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
          var spacers = list.items[i].tokens.filter(function (t) {
            return t.type === 'space';
          });
          var hasMultipleLineBreaks = spacers.every(function (t) {
            var chars = t.raw.split('');
            var lineBreaks = 0;

            for (var _iterator = _createForOfIteratorHelperLoose(chars), _step; !(_step = _iterator()).done;) {
              var _char = _step.value;

              if (_char === '\n') {
                lineBreaks += 1;
              }

              if (lineBreaks > 1) {
                return true;
              }
            }

            return false;
          });

          if (!list.loose && spacers.length && hasMultipleLineBreaks) {
            // Having a single line break doesn't mean a list is loose. A single line break is terminating the last list item
            list.loose = true;
            list.items[i].loose = true;
          }
        }

        return list;
      }
    };

    _proto.html = function html(src) {
      var cap = this.rules.block.html.exec(src);

      if (cap) {
        var token = {
          type: 'html',
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: cap[0]
        };

        if (this.options.sanitize) {
          var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
          token.type = 'paragraph';
          token.text = text;
          token.tokens = this.lexer.inline(text);
        }

        return token;
      }
    };

    _proto.def = function def(src) {
      var cap = this.rules.block.def.exec(src);

      if (cap) {
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
        return {
          type: 'def',
          tag: tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    };

    _proto.table = function table(src) {
      var cap = this.rules.block.table.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells(cap[1]).map(function (c) {
            return {
              text: c
            };
          }),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          var l = item.align.length;
          var i, j, k, row;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.rows.length;

          for (i = 0; i < l; i++) {
            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {
              return {
                text: c
              };
            });
          } // parse child tokens inside headers and cells
          // header child tokens


          l = item.header.length;

          for (j = 0; j < l; j++) {
            item.header[j].tokens = this.lexer.inline(item.header[j].text);
          } // cell child tokens


          l = item.rows.length;

          for (j = 0; j < l; j++) {
            row = item.rows[j];

            for (k = 0; k < row.length; k++) {
              row[k].tokens = this.lexer.inline(row[k].text);
            }
          }

          return item;
        }
      }
    };

    _proto.lheading = function lheading(src) {
      var cap = this.rules.block.lheading.exec(src);

      if (cap) {
        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[2].charAt(0) === '=' ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    };

    _proto.paragraph = function paragraph(src) {
      var cap = this.rules.block.paragraph.exec(src);

      if (cap) {
        var text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
        return {
          type: 'paragraph',
          raw: cap[0],
          text: text,
          tokens: this.lexer.inline(text)
        };
      }
    };

    _proto.text = function text(src) {
      var cap = this.rules.block.text.exec(src);

      if (cap) {
        return {
          type: 'text',
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    };

    _proto.escape = function escape$1(src) {
      var cap = this.rules.inline.escape.exec(src);

      if (cap) {
        return {
          type: 'escape',
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    };

    _proto.tag = function tag(src) {
      var cap = this.rules.inline.tag.exec(src);

      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }

        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }

        return {
          type: this.options.sanitize ? 'text' : 'html',
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.link = function link(src) {
      var cap = this.rules.inline.link.exec(src);

      if (cap) {
        var trimmedUrl = cap[2].trim();

        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          // commonmark requires matching angle brackets
          if (!/>$/.test(trimmedUrl)) {
            return;
          } // ending angle bracket cannot be escaped


          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');

          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          // find closing parenthesis
          var lastParenIndex = findClosingBracket(cap[2], '()');

          if (lastParenIndex > -1) {
            var start = cap[0].indexOf('!') === 0 ? 5 : 4;
            var linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
        }

        var href = cap[2];
        var title = '';

        if (this.options.pedantic) {
          // split pedantic href and title
          var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : '';
        }

        href = href.trim();

        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            // pedantic allows starting angle bracket without ending angle bracket
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }

        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
          title: title ? title.replace(this.rules.inline._escapes, '$1') : title
        }, cap[0], this.lexer);
      }
    };

    _proto.reflink = function reflink(src, links) {
      var cap;

      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = links[link.toLowerCase()];

        if (!link || !link.href) {
          var text = cap[0].charAt(0);
          return {
            type: 'text',
            raw: text,
            text: text
          };
        }

        return outputLink(cap, link, cap[0], this.lexer);
      }
    };

    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = '';
      }

      var match = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
      var nextChar = match[1] || match[2] || '';

      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
        var lLength = match[0].length - 1;
        var rDelim,
            rLength,
            delimTotal = lLength,
            midDelimTotal = 0;
        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)

        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue; // skip single * in __abc*abc__

          rLength = rDelim.length;

          if (match[3] || match[4]) {
            // found another Left Delim
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            // either Left or Right Delim
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue; // CommonMark Emphasis Rules 9-10
            }
          }

          delimTotal -= rLength;
          if (delimTotal > 0) continue; // Haven't found enough closing delimiters
          // Remove extra characters. *a*** -> *a*

          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***

          if (Math.min(lLength, rLength) % 2) {
            var _text = src.slice(1, lLength + match.index + rLength);

            return {
              type: 'em',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: _text,
              tokens: this.lexer.inlineTokens(_text)
            };
          } // Create 'strong' if smallest delimiter has even char count. **a***


          var text = src.slice(2, lLength + match.index + rLength - 1);
          return {
            type: 'strong',
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    };

    _proto.codespan = function codespan(src) {
      var cap = this.rules.inline.code.exec(src);

      if (cap) {
        var text = cap[2].replace(/\n/g, ' ');
        var hasNonSpaceChars = /[^ ]/.test(text);
        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }

        text = escape(text, true);
        return {
          type: 'codespan',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.br = function br(src) {
      var cap = this.rules.inline.br.exec(src);

      if (cap) {
        return {
          type: 'br',
          raw: cap[0]
        };
      }
    };

    _proto.del = function del(src) {
      var cap = this.rules.inline.del.exec(src);

      if (cap) {
        return {
          type: 'del',
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    };

    _proto.autolink = function autolink(src, mangle) {
      var cap = this.rules.inline.autolink.exec(src);

      if (cap) {
        var text, href;

        if (cap[2] === '@') {
          text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = 'mailto:' + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.url = function url(src, mangle) {
      var cap;

      if (cap = this.rules.inline.url.exec(src)) {
        var text, href;

        if (cap[2] === '@') {
          text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          var prevCapZero;

          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);

          text = escape(cap[0]);

          if (cap[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.inlineText = function inlineText(src, smartypants) {
      var cap = this.rules.inline.text.exec(src);

      if (cap) {
        var text;

        if (this.lexer.state.inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }

        return {
          type: 'text',
          raw: cap[0],
          text: text
        };
      }
    };

    return Tokenizer;
  }();

  /**
   * Block-Level Grammar
   */

  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
    + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
    + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();
  /**
   * Normal Block Grammar
   */

  block.normal = merge({}, block);
  /**
   * GFM Block Grammar
   */

  block.gfm = merge({}, block.normal, {
    table: '^ *([^\\n ].*\\|.*)\\n' // Header
    + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
    + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

  });
  block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('table', block.gfm.table) // interrupt paragraphs with table
  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */

  block.pedantic = merge({}, block.normal, {
    html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
  });
  /**
   * Inline-Level Grammar
   */

  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //          () Skip orphan inside strong  () Consume to delim (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
      rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
      rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _

    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  }; // list of punctuation marks from CommonMark spec
  // without * and _ to handle the different emphasis markers * and _

  inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

  inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline.escapedEmSt = /\\\*|\\_/g;
  inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
  inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
  inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
  inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();
  /**
   * Normal Inline Grammar
   */

  inline.normal = merge({}, inline);
  /**
   * Pedantic Inline Grammar
   */

  inline.pedantic = merge({}, inline.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
  });
  /**
   * GFM Inline Grammar
   */

  inline.gfm = merge({}, inline.normal, {
    escape: edit(inline.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  });
  inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline.breaks = merge({}, inline.gfm, {
    br: edit(inline.br).replace('{2,}', '*').getRegex(),
    text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
  });

  /**
   * smartypants text replacement
   * @param {string} text
   */

  function smartypants(text) {
    return text // em-dashes
    .replace(/---/g, "\u2014") // en-dashes
    .replace(/--/g, "\u2013") // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
    .replace(/'/g, "\u2019") // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replace(/"/g, "\u201D") // ellipses
    .replace(/\.{3}/g, "\u2026");
  }
  /**
   * mangle email addresses
   * @param {string} text
   */


  function mangle(text) {
    var out = '',
        i,
        ch;
    var l = text.length;

    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);

      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  }
  /**
   * Block Lexer
   */


  var Lexer = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || exports.defaults;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      var rules = {
        block: block.normal,
        inline: inline.normal
      };

      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;

        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }

      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */


    /**
     * Static Lex Method
     */
    Lexer.lex = function lex(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    ;

    Lexer.lexInline = function lexInline(src, options) {
      var lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    ;

    var _proto = Lexer.prototype;

    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, '\n');
      this.blockTokens(src, this.tokens);
      var next;

      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }

      return this.tokens;
    }
    /**
     * Lexing
     */
    ;

    _proto.blockTokens = function blockTokens(src, tokens) {
      var _this = this;

      if (tokens === void 0) {
        tokens = [];
      }

      if (this.options.pedantic) {
        src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
      } else {
        src = src.replace(/^( *)(\t+)/gm, function (_, leading, tabs) {
          return leading + '    '.repeat(tabs.length);
        });
      }

      var token, lastToken, cutSrc, lastParagraphClipped;

      while (src) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {
          if (token = extTokenizer.call({
            lexer: _this
          }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }

          return false;
        })) {
          continue;
        } // newline


        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);

          if (token.raw.length === 1 && tokens.length > 0) {
            // if there's a single \n as a spacer, it's terminating the last line,
            // so move it there so that we don't get unecessary paragraph tags
            tokens[tokens.length - 1].raw += '\n';
          } else {
            tokens.push(token);
          }

          continue;
        } // code


        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // fences


        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // heading


        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // hr


        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // blockquote


        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // list


        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // html


        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // def


        if (token = this.tokenizer.def(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }

          continue;
        } // table (gfm)


        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // lheading


        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // top-level paragraph
        // prevent paragraph consuming extensions by clipping 'src' to extension start


        cutSrc = src;

        if (this.options.extensions && this.options.extensions.startBlock) {
          (function () {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;

            _this.options.extensions.startBlock.forEach(function (getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);

              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });

            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }

        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];

          if (lastParagraphClipped && lastToken.type === 'paragraph') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }

          lastParagraphClipped = cutSrc.length !== src.length;
          src = src.substring(token.raw.length);
          continue;
        } // text


        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      this.state.top = true;
      return tokens;
    };

    _proto.inline = function inline(src, tokens) {
      if (tokens === void 0) {
        tokens = [];
      }

      this.inlineQueue.push({
        src: src,
        tokens: tokens
      });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    ;

    _proto.inlineTokens = function inlineTokens(src, tokens) {
      var _this2 = this;

      if (tokens === void 0) {
        tokens = [];
      }

      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong

      var maskedSrc = src;
      var match;
      var keepPrevChar, prevChar; // Mask out reflinks

      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);

        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      } // Mask out other blocks


      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      } // Mask out escaped em & strong delimiters


      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      }

      while (src) {
        if (!keepPrevChar) {
          prevChar = '';
        }

        keepPrevChar = false; // extensions

        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {
          if (token = extTokenizer.call({
            lexer: _this2
          }, src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
          }

          return false;
        })) {
          continue;
        } // escape


        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // tag


        if (token = this.tokenizer.tag(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && token.type === 'text' && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // link


        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // reflink, nolink


        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && token.type === 'text' && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // em & strong


        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // code


        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // br


        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // del (gfm)


        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // autolink


        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // url (gfm)


        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text
        // prevent inlineText consuming extensions by clipping 'src' to extension start


        cutSrc = src;

        if (this.options.extensions && this.options.extensions.startInline) {
          (function () {
            var startIndex = Infinity;
            var tempSrc = src.slice(1);
            var tempStart = void 0;

            _this2.options.extensions.startInline.forEach(function (getStartIndex) {
              tempStart = getStartIndex.call({
                lexer: this
              }, tempSrc);

              if (typeof tempStart === 'number' && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });

            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          })();
        }

        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src = src.substring(token.raw.length);

          if (token.raw.slice(-1) !== '_') {
            // Track prevChar before string of ____ started
            prevChar = token.raw.slice(-1);
          }

          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _createClass(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block,
          inline: inline
        };
      }
    }]);

    return Lexer;
  }();

  /**
   * Renderer
   */

  var Renderer = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || exports.defaults;
    }

    var _proto = Renderer.prototype;

    _proto.code = function code(_code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];

      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang);

        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }

      _code = _code.replace(/\n$/, '') + '\n';

      if (!lang) {
        return '<pre><code>' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
      }

      return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
    }
    /**
     * @param {string} quote
     */
    ;

    _proto.blockquote = function blockquote(quote) {
      return "<blockquote>\n" + quote + "</blockquote>\n";
    };

    _proto.html = function html(_html) {
      return _html;
    }
    /**
     * @param {string} text
     * @param {string} level
     * @param {string} raw
     * @param {any} slugger
     */
    ;

    _proto.heading = function heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        var id = this.options.headerPrefix + slugger.slug(raw);
        return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
      } // ignore IDs


      return "<h" + level + ">" + text + "</h" + level + ">\n";
    };

    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    _proto.list = function list(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    }
    /**
     * @param {string} text
     */
    ;

    _proto.listitem = function listitem(text) {
      return "<li>" + text + "</li>\n";
    };

    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    }
    /**
     * @param {string} text
     */
    ;

    _proto.paragraph = function paragraph(text) {
      return "<p>" + text + "</p>\n";
    }
    /**
     * @param {string} header
     * @param {string} body
     */
    ;

    _proto.table = function table(header, body) {
      if (body) body = "<tbody>" + body + "</tbody>";
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    }
    /**
     * @param {string} content
     */
    ;

    _proto.tablerow = function tablerow(content) {
      return "<tr>\n" + content + "</tr>\n";
    };

    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? "<" + type + " align=\"" + flags.align + "\">" : "<" + type + ">";
      return tag + content + ("</" + type + ">\n");
    }
    /**
     * span level renderer
     * @param {string} text
     */
    ;

    _proto.strong = function strong(text) {
      return "<strong>" + text + "</strong>";
    }
    /**
     * @param {string} text
     */
    ;

    _proto.em = function em(text) {
      return "<em>" + text + "</em>";
    }
    /**
     * @param {string} text
     */
    ;

    _proto.codespan = function codespan(text) {
      return "<code>" + text + "</code>";
    };

    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    }
    /**
     * @param {string} text
     */
    ;

    _proto.del = function del(text) {
      return "<del>" + text + "</del>";
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    ;

    _proto.link = function link(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<a href="' + escape(href) + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += '>' + text + '</a>';
      return out;
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    ;

    _proto.image = function image(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = "<img src=\"" + href + "\" alt=\"" + text + "\"";

      if (title) {
        out += " title=\"" + title + "\"";
      }

      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    return Renderer;
  }();

  /**
   * TextRenderer
   * returns only the textual part of the token
   */
  var TextRenderer = /*#__PURE__*/function () {
    function TextRenderer() {}

    var _proto = TextRenderer.prototype;

    // no need for block level renderers
    _proto.strong = function strong(text) {
      return text;
    };

    _proto.em = function em(text) {
      return text;
    };

    _proto.codespan = function codespan(text) {
      return text;
    };

    _proto.del = function del(text) {
      return text;
    };

    _proto.html = function html(text) {
      return text;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    _proto.link = function link(href, title, text) {
      return '' + text;
    };

    _proto.image = function image(href, title, text) {
      return '' + text;
    };

    _proto.br = function br() {
      return '';
    };

    return TextRenderer;
  }();

  /**
   * Slugger generates header id
   */
  var Slugger = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }
    /**
     * @param {string} value
     */


    var _proto = Slugger.prototype;

    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim() // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
    }
    /**
     * Finds the next safe (unique) slug to use
     * @param {string} originalSlug
     * @param {boolean} isDryRun
     */
    ;

    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;

      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];

        do {
          occurenceAccumulator++;
          slug = originalSlug + '-' + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }

      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }

      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} [options]
     * @param {boolean} [options.dryrun] Generates the next unique slug without
     * updating the internal accumulator.
     */
    ;

    _proto.slug = function slug(value, options) {
      if (options === void 0) {
        options = {};
      }

      var slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    };

    return Slugger;
  }();

  /**
   * Parsing & Compiling
   */

  var Parser = /*#__PURE__*/function () {
    function Parser(options) {
      this.options = options || exports.defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    /**
     * Static Parse Method
     */


    Parser.parse = function parse(tokens, options) {
      var parser = new Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    ;

    Parser.parseInline = function parseInline(tokens, options) {
      var parser = new Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    ;

    var _proto = Parser.prototype;

    _proto.parse = function parse(tokens, top) {
      if (top === void 0) {
        top = true;
      }

      var out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox,
          ret;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i]; // Run any renderer extensions

        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({
            parser: this
          }, token);

          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
            out += ret || '';
            continue;
          }
        }

        switch (token.type) {
          case 'space':
            {
              continue;
            }

          case 'hr':
            {
              out += this.renderer.hr();
              continue;
            }

          case 'heading':
            {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }

          case 'code':
            {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }

          case 'table':
            {
              header = ''; // header

              cell = '';
              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                  header: true,
                  align: token.align[j]
                });
              }

              header += this.renderer.tablerow(cell);
              body = '';
              l2 = token.rows.length;

              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = '';
                l3 = row.length;

                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                    header: false,
                    align: token.align[k]
                  });
                }

                body += this.renderer.tablerow(cell);
              }

              out += this.renderer.table(header, body);
              continue;
            }

          case 'blockquote':
            {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }

          case 'list':
            {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = '';

              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = '';

                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);

                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }

          case 'html':
            {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }

          case 'paragraph':
            {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }

          case 'text':
            {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;

              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }

              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    }
    /**
     * Parse Inline Tokens
     */
    ;

    _proto.parseInline = function parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      var out = '',
          i,
          token,
          ret;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i]; // Run any renderer extensions

        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({
            parser: this
          }, token);

          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
            out += ret || '';
            continue;
          }
        }

        switch (token.type) {
          case 'escape':
            {
              out += renderer.text(token.text);
              break;
            }

          case 'html':
            {
              out += renderer.html(token.text);
              break;
            }

          case 'link':
            {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }

          case 'image':
            {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }

          case 'strong':
            {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'em':
            {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'codespan':
            {
              out += renderer.codespan(token.text);
              break;
            }

          case 'br':
            {
              out += renderer.br();
              break;
            }

          case 'del':
            {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'text':
            {
              out += renderer.text(token.text);
              break;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    };

    return Parser;
  }();

  /**
   * Marked
   */

  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    if (callback) {
      var highlight = opt.highlight;
      var tokens;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      var done = function done(err) {
        var out;

        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }

            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    function onError(e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }

    try {
      var _tokens = Lexer.lex(src, opt);

      if (opt.walkTokens) {
        if (opt.async) {
          return Promise.all(marked.walkTokens(_tokens, opt.walkTokens)).then(function () {
            return Parser.parse(_tokens, opt);
          })["catch"](onError);
        }

        marked.walkTokens(_tokens, opt.walkTokens);
      }

      return Parser.parse(_tokens, opt);
    } catch (e) {
      onError(e);
    }
  }
  /**
   * Options
   */

  marked.options = marked.setOptions = function (opt) {
    merge(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };

  marked.getDefaults = getDefaults;
  marked.defaults = exports.defaults;
  /**
   * Use Extension
   */

  marked.use = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var opts = merge.apply(void 0, [{}].concat(args));
    var extensions = marked.defaults.extensions || {
      renderers: {},
      childTokens: {}
    };
    var hasExtensions;
    args.forEach(function (pack) {
      // ==-- Parse "addon" extensions --== //
      if (pack.extensions) {
        hasExtensions = true;
        pack.extensions.forEach(function (ext) {
          if (!ext.name) {
            throw new Error('extension name required');
          }

          if (ext.renderer) {
            // Renderer extensions
            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;

            if (prevRenderer) {
              // Replace extension with func to run new extension but fall back if false
              extensions.renderers[ext.name] = function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                var ret = ext.renderer.apply(this, args);

                if (ret === false) {
                  ret = prevRenderer.apply(this, args);
                }

                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }

          if (ext.tokenizer) {
            // Tokenizer Extensions
            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
              throw new Error("extension level must be 'block' or 'inline'");
            }

            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }

            if (ext.start) {
              // Function to check for start of token
              if (ext.level === 'block') {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === 'inline') {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }

          if (ext.childTokens) {
            // Child tokens to be visited by walkTokens
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
      } // ==-- Parse "overwrite" extensions --== //


      if (pack.renderer) {
        (function () {
          var renderer = marked.defaults.renderer || new Renderer();

          var _loop = function _loop(prop) {
            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false

            renderer[prop] = function () {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }

              var ret = pack.renderer[prop].apply(renderer, args);

              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }

              return ret;
            };
          };

          for (var prop in pack.renderer) {
            _loop(prop);
          }

          opts.renderer = renderer;
        })();
      }

      if (pack.tokenizer) {
        (function () {
          var tokenizer = marked.defaults.tokenizer || new Tokenizer();

          var _loop2 = function _loop2(prop) {
            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false

            tokenizer[prop] = function () {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }

              var ret = pack.tokenizer[prop].apply(tokenizer, args);

              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }

              return ret;
            };
          };

          for (var prop in pack.tokenizer) {
            _loop2(prop);
          }

          opts.tokenizer = tokenizer;
        })();
      } // ==-- Parse WalkTokens extensions --== //


      if (pack.walkTokens) {
        var _walkTokens = marked.defaults.walkTokens;

        opts.walkTokens = function (token) {
          var values = [];
          values.push(pack.walkTokens.call(this, token));

          if (_walkTokens) {
            values = values.concat(_walkTokens.call(this, token));
          }

          return values;
        };
      }

      if (hasExtensions) {
        opts.extensions = extensions;
      }

      marked.setOptions(opts);
    });
  };
  /**
   * Run callback for every token
   */


  marked.walkTokens = function (tokens, callback) {
    var values = [];

    var _loop3 = function _loop3() {
      var token = _step.value;
      values = values.concat(callback.call(marked, token));

      switch (token.type) {
        case 'table':
          {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
              var cell = _step2.value;
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }

            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {
              var row = _step3.value;

              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                var _cell = _step4.value;
                values = values.concat(marked.walkTokens(_cell.tokens, callback));
              }
            }

            break;
          }

        case 'list':
          {
            values = values.concat(marked.walkTokens(token.items, callback));
            break;
          }

        default:
          {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              // Walk any extensions
              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
                values = values.concat(marked.walkTokens(token[childTokens], callback));
              });
            } else if (token.tokens) {
              values = values.concat(marked.walkTokens(token.tokens, callback));
            }
          }
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
      _loop3();
    }

    return values;
  };
  /**
   * Parse Inline
   * @param {string} src
   */


  marked.parseInline = function (src, opt) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked.parseInline(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    try {
      var tokens = Lexer.lexInline(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }

      return Parser.parseInline(tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  };
  /**
   * Expose
   */


  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parse = marked;
  var parser = Parser.parse;
  var lexer = Lexer.lex;

  exports.Lexer = Lexer;
  exports.Parser = Parser;
  exports.Renderer = Renderer;
  exports.Slugger = Slugger;
  exports.TextRenderer = TextRenderer;
  exports.Tokenizer = Tokenizer;
  exports.getDefaults = getDefaults;
  exports.lexer = lexer;
  exports.marked = marked;
  exports.options = options;
  exports.parse = parse;
  exports.parseInline = parseInline;
  exports.parser = parser;
  exports.setOptions = setOptions;
  exports.use = use;
  exports.walkTokens = walkTokens;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

// ESM-uncomment-begin
// })();
// export var Lexer = (__marked_exports.Lexer || exports.Lexer);
// export var Parser = (__marked_exports.Parser || exports.Parser);
// export var Renderer = (__marked_exports.Renderer || exports.Renderer);
// export var Slugger = (__marked_exports.Slugger || exports.Slugger);
// export var TextRenderer = (__marked_exports.TextRenderer || exports.TextRenderer);
// export var Tokenizer = (__marked_exports.Tokenizer || exports.Tokenizer);
// export var getDefaults = (__marked_exports.getDefaults || exports.getDefaults);
// export var lexer = (__marked_exports.lexer || exports.lexer);
// export var marked = (__marked_exports.marked || exports.marked);
// export var options = (__marked_exports.options || exports.options);
// export var parse = (__marked_exports.parse || exports.parse);
// export var parseInline = (__marked_exports.parseInline || exports.parseInline);
// export var parser = (__marked_exports.parser || exports.parser);
// export var setOptions = (__marked_exports.setOptions || exports.setOptions);
// export var use = (__marked_exports.use || exports.use);
// export var walkTokens = (__marked_exports.walkTokens || exports.walkTokens);
// ESM-uncomment-end

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[139/*vs/base/common/naturalLanguage/korean*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Fk = $Fk;
    // allow-any-unicode-comment-file
    /**
     * Gets alternative Korean characters for the character code. This will return the ascii
     * character code(s) that a Hangul character may have been input with using a qwerty layout.
     *
     * This only aims to cover modern (not archaic) Hangul syllables.
     *
     * @param code The character code to get alternate characters for
     */
    function $Fk(code) {
        const result = disassembleKorean(code);
        if (result && result.length > 0) {
            return new Uint32Array(result);
        }
        return undefined;
    }
    let codeBufferLength = 0;
    const codeBuffer = new Uint32Array(10);
    function disassembleKorean(code) {
        codeBufferLength = 0;
        // Initial consonants (초성)
        getCodesFromArray(code, modernConsonants, HangulRangeStartCode.InitialConsonant);
        if (codeBufferLength > 0) {
            return codeBuffer.subarray(0, codeBufferLength);
        }
        // Vowels (중성)
        getCodesFromArray(code, modernVowels, HangulRangeStartCode.Vowel);
        if (codeBufferLength > 0) {
            return codeBuffer.subarray(0, codeBufferLength);
        }
        // Final consonants (종성)
        getCodesFromArray(code, modernFinalConsonants, HangulRangeStartCode.FinalConsonant);
        if (codeBufferLength > 0) {
            return codeBuffer.subarray(0, codeBufferLength);
        }
        // Hangul Compatibility Jamo
        getCodesFromArray(code, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
        if (codeBufferLength) {
            return codeBuffer.subarray(0, codeBufferLength);
        }
        // Hangul Syllables
        if (code >= 0xAC00 && code <= 0xD7A3) {
            const hangulIndex = code - 0xAC00;
            const vowelAndFinalConsonantProduct = hangulIndex % 588;
            // 0-based starting at 0x1100
            const initialConsonantIndex = Math.floor(hangulIndex / 588);
            // 0-based starting at 0x1161
            const vowelIndex = Math.floor(vowelAndFinalConsonantProduct / 28);
            // 0-based starting at 0x11A8
            // Subtract 1 as the standard algorithm uses the 0 index to represent no
            // final consonant
            const finalConsonantIndex = vowelAndFinalConsonantProduct % 28 - 1;
            if (initialConsonantIndex < modernConsonants.length) {
                getCodesFromArray(initialConsonantIndex, modernConsonants, 0);
            }
            else if (HangulRangeStartCode.InitialConsonant + initialConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {
                getCodesFromArray(HangulRangeStartCode.InitialConsonant + initialConsonantIndex, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
            }
            if (vowelIndex < modernVowels.length) {
                getCodesFromArray(vowelIndex, modernVowels, 0);
            }
            else if (HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {
                getCodesFromArray(HangulRangeStartCode.Vowel + vowelIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
            }
            if (finalConsonantIndex >= 0) {
                if (finalConsonantIndex < modernFinalConsonants.length) {
                    getCodesFromArray(finalConsonantIndex, modernFinalConsonants, 0);
                }
                else if (HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo < compatibilityJamo.length) {
                    getCodesFromArray(HangulRangeStartCode.FinalConsonant + finalConsonantIndex - HangulRangeStartCode.CompatibilityJamo, compatibilityJamo, HangulRangeStartCode.CompatibilityJamo);
                }
            }
            if (codeBufferLength > 0) {
                return codeBuffer.subarray(0, codeBufferLength);
            }
        }
        return undefined;
    }
    function getCodesFromArray(code, array, arrayStartIndex) {
        // Verify the code is within the array's range
        if (code >= arrayStartIndex && code < arrayStartIndex + array.length) {
            addCodesToBuffer(array[code - arrayStartIndex]);
        }
    }
    function addCodesToBuffer(codes) {
        // NUL is ignored, this is used for archaic characters to avoid using a Map
        // for the data
        if (codes === AsciiCode.NUL) {
            return;
        }
        // Number stored in format: OptionalThirdCode << 16 | OptionalSecondCode << 8 | Code
        codeBuffer[codeBufferLength++] = codes & 0xFF;
        if (codes >> 8) {
            codeBuffer[codeBufferLength++] = (codes >> 8) & 0xFF;
        }
        if (codes >> 16) {
            codeBuffer[codeBufferLength++] = (codes >> 16) & 0xFF;
        }
    }
    var HangulRangeStartCode;
    (function (HangulRangeStartCode) {
        HangulRangeStartCode[HangulRangeStartCode["InitialConsonant"] = 4352] = "InitialConsonant";
        HangulRangeStartCode[HangulRangeStartCode["Vowel"] = 4449] = "Vowel";
        HangulRangeStartCode[HangulRangeStartCode["FinalConsonant"] = 4520] = "FinalConsonant";
        HangulRangeStartCode[HangulRangeStartCode["CompatibilityJamo"] = 12593] = "CompatibilityJamo";
    })(HangulRangeStartCode || (HangulRangeStartCode = {}));
    var AsciiCode;
    (function (AsciiCode) {
        AsciiCode[AsciiCode["NUL"] = 0] = "NUL";
        AsciiCode[AsciiCode["A"] = 65] = "A";
        AsciiCode[AsciiCode["B"] = 66] = "B";
        AsciiCode[AsciiCode["C"] = 67] = "C";
        AsciiCode[AsciiCode["D"] = 68] = "D";
        AsciiCode[AsciiCode["E"] = 69] = "E";
        AsciiCode[AsciiCode["F"] = 70] = "F";
        AsciiCode[AsciiCode["G"] = 71] = "G";
        AsciiCode[AsciiCode["H"] = 72] = "H";
        AsciiCode[AsciiCode["I"] = 73] = "I";
        AsciiCode[AsciiCode["J"] = 74] = "J";
        AsciiCode[AsciiCode["K"] = 75] = "K";
        AsciiCode[AsciiCode["L"] = 76] = "L";
        AsciiCode[AsciiCode["M"] = 77] = "M";
        AsciiCode[AsciiCode["N"] = 78] = "N";
        AsciiCode[AsciiCode["O"] = 79] = "O";
        AsciiCode[AsciiCode["P"] = 80] = "P";
        AsciiCode[AsciiCode["Q"] = 81] = "Q";
        AsciiCode[AsciiCode["R"] = 82] = "R";
        AsciiCode[AsciiCode["S"] = 83] = "S";
        AsciiCode[AsciiCode["T"] = 84] = "T";
        AsciiCode[AsciiCode["U"] = 85] = "U";
        AsciiCode[AsciiCode["V"] = 86] = "V";
        AsciiCode[AsciiCode["W"] = 87] = "W";
        AsciiCode[AsciiCode["X"] = 88] = "X";
        AsciiCode[AsciiCode["Y"] = 89] = "Y";
        AsciiCode[AsciiCode["Z"] = 90] = "Z";
        AsciiCode[AsciiCode["a"] = 97] = "a";
        AsciiCode[AsciiCode["b"] = 98] = "b";
        AsciiCode[AsciiCode["c"] = 99] = "c";
        AsciiCode[AsciiCode["d"] = 100] = "d";
        AsciiCode[AsciiCode["e"] = 101] = "e";
        AsciiCode[AsciiCode["f"] = 102] = "f";
        AsciiCode[AsciiCode["g"] = 103] = "g";
        AsciiCode[AsciiCode["h"] = 104] = "h";
        AsciiCode[AsciiCode["i"] = 105] = "i";
        AsciiCode[AsciiCode["j"] = 106] = "j";
        AsciiCode[AsciiCode["k"] = 107] = "k";
        AsciiCode[AsciiCode["l"] = 108] = "l";
        AsciiCode[AsciiCode["m"] = 109] = "m";
        AsciiCode[AsciiCode["n"] = 110] = "n";
        AsciiCode[AsciiCode["o"] = 111] = "o";
        AsciiCode[AsciiCode["p"] = 112] = "p";
        AsciiCode[AsciiCode["q"] = 113] = "q";
        AsciiCode[AsciiCode["r"] = 114] = "r";
        AsciiCode[AsciiCode["s"] = 115] = "s";
        AsciiCode[AsciiCode["t"] = 116] = "t";
        AsciiCode[AsciiCode["u"] = 117] = "u";
        AsciiCode[AsciiCode["v"] = 118] = "v";
        AsciiCode[AsciiCode["w"] = 119] = "w";
        AsciiCode[AsciiCode["x"] = 120] = "x";
        AsciiCode[AsciiCode["y"] = 121] = "y";
        AsciiCode[AsciiCode["z"] = 122] = "z";
    })(AsciiCode || (AsciiCode = {}));
    /**
     * Numbers that represent multiple ascii codes. These are precomputed at compile time to reduce
     * bundle and runtime overhead.
     */
    var AsciiCodeCombo;
    (function (AsciiCodeCombo) {
        AsciiCodeCombo[AsciiCodeCombo["fa"] = 24934] = "fa";
        AsciiCodeCombo[AsciiCodeCombo["fg"] = 26470] = "fg";
        AsciiCodeCombo[AsciiCodeCombo["fq"] = 29030] = "fq";
        AsciiCodeCombo[AsciiCodeCombo["fr"] = 29286] = "fr";
        AsciiCodeCombo[AsciiCodeCombo["ft"] = 29798] = "ft";
        AsciiCodeCombo[AsciiCodeCombo["fv"] = 30310] = "fv";
        AsciiCodeCombo[AsciiCodeCombo["fx"] = 30822] = "fx";
        AsciiCodeCombo[AsciiCodeCombo["hk"] = 27496] = "hk";
        AsciiCodeCombo[AsciiCodeCombo["hl"] = 27752] = "hl";
        AsciiCodeCombo[AsciiCodeCombo["ho"] = 28520] = "ho";
        AsciiCodeCombo[AsciiCodeCombo["ml"] = 27757] = "ml";
        AsciiCodeCombo[AsciiCodeCombo["nj"] = 27246] = "nj";
        AsciiCodeCombo[AsciiCodeCombo["nl"] = 27758] = "nl";
        AsciiCodeCombo[AsciiCodeCombo["np"] = 28782] = "np";
        AsciiCodeCombo[AsciiCodeCombo["qt"] = 29809] = "qt";
        AsciiCodeCombo[AsciiCodeCombo["rt"] = 29810] = "rt";
        AsciiCodeCombo[AsciiCodeCombo["sg"] = 26483] = "sg";
        AsciiCodeCombo[AsciiCodeCombo["sw"] = 30579] = "sw";
    })(AsciiCodeCombo || (AsciiCodeCombo = {}));
    /**
     * Hangul Jamo - Modern consonants #1
     *
     * Range U+1100..U+1112
     *
     * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
     * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
     * | U+110x | ᄀ | ᄁ | ᄂ | ᄃ | ᄄ | ᄅ | ᄆ | ᄇ | ᄈ | ᄉ | ᄊ | ᄋ | ᄌ | ᄍ | ᄎ | ᄏ |
     * | U+111x | ᄐ | ᄑ | ᄒ |
     */
    const modernConsonants = new Uint8Array([
        AsciiCode.r, // ㄱ
        AsciiCode.R, // ㄲ
        AsciiCode.s, // ㄴ
        AsciiCode.e, // ㄷ
        AsciiCode.E, // ㄸ
        AsciiCode.f, // ㄹ
        AsciiCode.a, // ㅁ
        AsciiCode.q, // ㅂ
        AsciiCode.Q, // ㅃ
        AsciiCode.t, // ㅅ
        AsciiCode.T, // ㅆ
        AsciiCode.d, // ㅇ
        AsciiCode.w, // ㅈ
        AsciiCode.W, // ㅉ
        AsciiCode.c, // ㅊ
        AsciiCode.z, // ㅋ
        AsciiCode.x, // ㅌ
        AsciiCode.v, // ㅍ
        AsciiCode.g, // ㅎ
    ]);
    /**
     * Hangul Jamo - Modern Vowels
     *
     * Range U+1161..U+1175
     *
     * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
     * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
     * | U+116x |   | ᅡ | ᅢ | ᅣ | ᅤ | ᅥ | ᅦ | ᅧ | ᅨ | ᅩ | ᅪ | ᅫ | ᅬ | ᅭ | ᅮ | ᅯ |
     * | U+117x | ᅰ | ᅱ | ᅲ | ᅳ | ᅴ | ᅵ |
     */
    const modernVowels = new Uint16Array([
        AsciiCode.k, //  -> ㅏ
        AsciiCode.o, //  -> ㅐ
        AsciiCode.i, //  -> ㅑ
        AsciiCode.O, //  -> ㅒ
        AsciiCode.j, //  -> ㅓ
        AsciiCode.p, //  -> ㅔ
        AsciiCode.u, //  -> ㅕ
        AsciiCode.P, //  -> ㅖ
        AsciiCode.h, //  -> ㅗ
        AsciiCodeCombo.hk, //  -> ㅘ
        AsciiCodeCombo.ho, //  -> ㅙ
        AsciiCodeCombo.hl, //  -> ㅚ
        AsciiCode.y, //  -> ㅛ
        AsciiCode.n, //  -> ㅜ
        AsciiCodeCombo.nj, //  -> ㅝ
        AsciiCodeCombo.np, //  -> ㅞ
        AsciiCodeCombo.nl, //  -> ㅟ
        AsciiCode.b, //  -> ㅠ
        AsciiCode.m, //  -> ㅡ
        AsciiCodeCombo.ml, //  -> ㅢ
        AsciiCode.l, //  -> ㅣ
    ]);
    /**
     * Hangul Jamo - Modern Consonants #2
     *
     * Range U+11A8..U+11C2
     *
     * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
     * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
     * | U+11Ax |   |   |   |   |   |   |   |   | ᆨ | ᆩ | ᆪ | ᆫ | ᆬ | ᆭ | ᆮ | ᆯ |
     * | U+11Bx | ᆰ | ᆱ | ᆲ | ᆳ | ᆴ | ᆵ | ᆶ | ᆷ | ᆸ | ᆹ | ᆺ | ᆻ | ᆼ | ᆽ | ᆾ | ᆿ |
     * | U+11Cx | ᇀ | ᇁ | ᇂ |
     */
    const modernFinalConsonants = new Uint16Array([
        AsciiCode.r, // ㄱ
        AsciiCode.R, // ㄲ
        AsciiCodeCombo.rt, // ㄳ
        AsciiCode.s, // ㄴ
        AsciiCodeCombo.sw, // ㄵ
        AsciiCodeCombo.sg, // ㄶ
        AsciiCode.e, // ㄷ
        AsciiCode.f, // ㄹ
        AsciiCodeCombo.fr, // ㄺ
        AsciiCodeCombo.fa, // ㄻ
        AsciiCodeCombo.fq, // ㄼ
        AsciiCodeCombo.ft, // ㄽ
        AsciiCodeCombo.fx, // ㄾ
        AsciiCodeCombo.fv, // ㄿ
        AsciiCodeCombo.fg, // ㅀ
        AsciiCode.a, // ㅁ
        AsciiCode.q, // ㅂ
        AsciiCodeCombo.qt, // ㅄ
        AsciiCode.t, // ㅅ
        AsciiCode.T, // ㅆ
        AsciiCode.d, // ㅇ
        AsciiCode.w, // ㅈ
        AsciiCode.c, // ㅊ
        AsciiCode.z, // ㅋ
        AsciiCode.x, // ㅌ
        AsciiCode.v, // ㅍ
        AsciiCode.g, // ㅎ
    ]);
    /**
     * Hangul Compatibility Jamo
     *
     * Range U+3131..U+318F
     *
     * This includes range includes archaic jamo which we don't consider, these are
     * given the NUL character code in order to be ignored.
     *
     * |        | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |
     * |--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
     * | U+313x |   | ㄱ | ㄲ | ㄳ | ㄴ | ㄵ | ㄶ | ㄷ | ㄸ | ㄹ | ㄺ | ㄻ | ㄼ | ㄽ | ㄾ | ㄿ |
     * | U+314x | ㅀ | ㅁ | ㅂ | ㅃ | ㅄ | ㅅ | ㅆ | ㅇ | ㅈ | ㅉ | ㅊ | ㅋ | ㅌ | ㅍ | ㅎ | ㅏ |
     * | U+315x | ㅐ | ㅑ | ㅒ | ㅓ | ㅔ | ㅕ | ㅖ | ㅗ | ㅘ | ㅙ | ㅚ | ㅛ | ㅜ | ㅝ | ㅞ | ㅟ |
     * | U+316x | ㅠ | ㅡ | ㅢ | ㅣ | HF | ㅥ | ㅦ | ㅧ | ㅨ | ㅩ | ㅪ | ㅫ | ㅬ | ㅭ | ㅮ | ㅯ |
     * | U+317x | ㅰ | ㅱ | ㅲ | ㅳ | ㅴ | ㅵ | ㅶ | ㅷ | ㅸ | ㅹ | ㅺ | ㅻ | ㅼ | ㅽ | ㅾ | ㅿ |
     * | U+318x | ㆀ | ㆁ | ㆂ | ㆃ | ㆄ | ㆅ | ㆆ | ㆇ | ㆈ | ㆉ | ㆊ | ㆋ | ㆌ | ㆍ | ㆎ |
     */
    const compatibilityJamo = new Uint16Array([
        AsciiCode.r, // ㄱ
        AsciiCode.R, // ㄲ
        AsciiCodeCombo.rt, // ㄳ
        AsciiCode.s, // ㄴ
        AsciiCodeCombo.sw, // ㄵ
        AsciiCodeCombo.sg, // ㄶ
        AsciiCode.e, // ㄷ
        AsciiCode.E, // ㄸ
        AsciiCode.f, // ㄹ
        AsciiCodeCombo.fr, // ㄺ
        AsciiCodeCombo.fa, // ㄻ
        AsciiCodeCombo.fq, // ㄼ
        AsciiCodeCombo.ft, // ㄽ
        AsciiCodeCombo.fx, // ㄾ
        AsciiCodeCombo.fv, // ㄿ
        AsciiCodeCombo.fg, // ㅀ
        AsciiCode.a, // ㅁ
        AsciiCode.q, // ㅂ
        AsciiCode.Q, // ㅃ
        AsciiCodeCombo.qt, // ㅄ
        AsciiCode.t, // ㅅ
        AsciiCode.T, // ㅆ
        AsciiCode.d, // ㅇ
        AsciiCode.w, // ㅈ
        AsciiCode.W, // ㅉ
        AsciiCode.c, // ㅊ
        AsciiCode.z, // ㅋ
        AsciiCode.x, // ㅌ
        AsciiCode.v, // ㅍ
        AsciiCode.g, // ㅎ
        AsciiCode.k, // ㅏ
        AsciiCode.o, // ㅐ
        AsciiCode.i, // ㅑ
        AsciiCode.O, // ㅒ
        AsciiCode.j, // ㅓ
        AsciiCode.p, // ㅔ
        AsciiCode.u, // ㅕ
        AsciiCode.P, // ㅖ
        AsciiCode.h, // ㅗ
        AsciiCodeCombo.hk, // ㅘ
        AsciiCodeCombo.ho, // ㅙ
        AsciiCodeCombo.hl, // ㅚ
        AsciiCode.y, // ㅛ
        AsciiCode.n, // ㅜ
        AsciiCodeCombo.nj, // ㅝ
        AsciiCodeCombo.np, // ㅞ
        AsciiCodeCombo.nl, // ㅟ
        AsciiCode.b, // ㅠ
        AsciiCode.m, // ㅡ
        AsciiCodeCombo.ml, // ㅢ
        AsciiCode.l, // ㅣ
        // HF: Hangul Filler (everything after this is archaic)
        // ㅥ
        // ㅦ
        // ㅧ
        // ㅨ
        // ㅩ
        // ㅪ
        // ㅫ
        // ㅬ
        // ㅮ
        // ㅯ
        // ㅰ
        // ㅱ
        // ㅲ
        // ㅳ
        // ㅴ
        // ㅵ
        // ㅶ
        // ㅷ
        // ㅸ
        // ㅹ
        // ㅺ
        // ㅻ
        // ㅼ
        // ㅽ
        // ㅾ
        // ㅿ
        // ㆀ
        // ㆁ
        // ㆂ
        // ㆃ
        // ㆄ
        // ㆅ
        // ㆆ
        // ㆇ
        // ㆈ
        // ㆉ
        // ㆊ
        // ㆋ
        // ㆌ
        // ㆍ
        // ㆎ
    ]);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[140/*vs/base/common/numbers*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Pm = exports.$Om = exports.$Nm = void 0;
    exports.$Lm = $Lm;
    exports.rot = rot;
    exports.$Qm = $Qm;
    function $Lm(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    function rot(index, modulo) {
        return (modulo + (index % modulo)) % modulo;
    }
    class $Nm {
        constructor() {
            this.a = 0;
        }
        getNext() {
            return this.a++;
        }
    }
    exports.$Nm = $Nm;
    class $Om {
        constructor() {
            this.a = 1;
            this.b = 0;
        }
        update(value) {
            this.b = this.b + (value - this.b) / this.a;
            this.a += 1;
            return this.b;
        }
        get value() {
            return this.b;
        }
    }
    exports.$Om = $Om;
    class $Pm {
        constructor(size) {
            this.a = 0;
            this.b = 0;
            this.c = [];
            this.d = 0;
            this.e = 0;
            this.c = new Array(size);
            this.c.fill(0, 0, size);
        }
        update(value) {
            const oldValue = this.c[this.d];
            this.c[this.d] = value;
            this.d = (this.d + 1) % this.c.length;
            this.e -= oldValue;
            this.e += value;
            if (this.a < this.c.length) {
                this.a += 1;
            }
            this.b = this.e / this.a;
            return this.b;
        }
        get value() {
            return this.b;
        }
    }
    exports.$Pm = $Pm;
    /** Returns whether the point is within the triangle formed by the following 6 x/y point pairs */
    function $Qm(x, y, ax, ay, bx, by, cx, cy) {
        const v0x = cx - ax;
        const v0y = cy - ay;
        const v1x = bx - ax;
        const v1y = by - ay;
        const v2x = x - ax;
        const v2y = y - ay;
        const dot00 = v0x * v0x + v0y * v0y;
        const dot01 = v0x * v1x + v0y * v1y;
        const dot02 = v0x * v2x + v0y * v2y;
        const dot11 = v1x * v1x + v1y * v1y;
        const dot12 = v1x * v2x + v1y * v2y;
        const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u >= 0 && v >= 0 && u + v < 1;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[141/*vs/base/common/observableInternal/debugName*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ad = void 0;
    exports.$bd = $bd;
    exports.$cd = $cd;
    class $ad {
        constructor(owner, debugNameSource, referenceFn) {
            this.owner = owner;
            this.debugNameSource = debugNameSource;
            this.referenceFn = referenceFn;
        }
        getDebugName(target) {
            return $bd(target, this);
        }
    }
    exports.$ad = $ad;
    const countPerName = new Map();
    const cachedDebugName = new WeakMap();
    function $bd(target, data) {
        const cached = cachedDebugName.get(target);
        if (cached) {
            return cached;
        }
        const dbgName = computeDebugName(target, data);
        if (dbgName) {
            let count = countPerName.get(dbgName) ?? 0;
            count++;
            countPerName.set(dbgName, count);
            const result = count === 1 ? dbgName : `${dbgName}#${count}`;
            cachedDebugName.set(target, result);
            return result;
        }
        return undefined;
    }
    function computeDebugName(self, data) {
        const cached = cachedDebugName.get(self);
        if (cached) {
            return cached;
        }
        const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';
        let result;
        const debugNameSource = data.debugNameSource;
        if (debugNameSource !== undefined) {
            if (typeof debugNameSource === 'function') {
                result = debugNameSource();
                if (result !== undefined) {
                    return ownerStr + result;
                }
            }
            else {
                return ownerStr + debugNameSource;
            }
        }
        const referenceFn = data.referenceFn;
        if (referenceFn !== undefined) {
            result = $cd(referenceFn);
            if (result !== undefined) {
                return ownerStr + result;
            }
        }
        if (data.owner !== undefined) {
            const key = findKey(data.owner, self);
            if (key !== undefined) {
                return ownerStr + key;
            }
        }
        return undefined;
    }
    function findKey(obj, value) {
        for (const key in obj) {
            if (obj[key] === value) {
                return key;
            }
        }
        return undefined;
    }
    const countPerClassName = new Map();
    const ownerId = new WeakMap();
    function formatOwner(owner) {
        const id = ownerId.get(owner);
        if (id) {
            return id;
        }
        const className = getClassName(owner);
        let count = countPerClassName.get(className) ?? 0;
        count++;
        countPerClassName.set(className, count);
        const result = count === 1 ? className : `${className}#${count}`;
        ownerId.set(owner, result);
        return result;
    }
    function getClassName(obj) {
        const ctor = obj.constructor;
        if (ctor) {
            return ctor.name;
        }
        return 'Object';
    }
    function $cd(fn) {
        const fnSrc = fn.toString();
        // Pattern: /** @description ... */
        const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
        const match = regexp.exec(fnSrc);
        const result = match ? match[1] : undefined;
        return result?.trim();
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[142/*vs/base/common/observableInternal/logging*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Md = void 0;
    exports.$Kd = $Kd;
    exports.$Ld = $Ld;
    let globalObservableLogger;
    function $Kd(logger) {
        globalObservableLogger = logger;
    }
    function $Ld() {
        return globalObservableLogger;
    }
    class $Md {
        constructor() {
            this.a = 0;
            this.d = new WeakMap();
        }
        b(text) {
            return consoleTextToArgs([
                normalText(repeat('|  ', this.a)),
                text,
            ]);
        }
        c(info) {
            if (!info.hadValue) {
                return [
                    normalText(` `),
                    styled(formatValue(info.newValue, 60), {
                        color: 'green',
                    }),
                    normalText(` (initial)`),
                ];
            }
            return info.didChange
                ? [
                    normalText(` `),
                    styled(formatValue(info.oldValue, 70), {
                        color: 'red',
                        strikeThrough: true,
                    }),
                    normalText(` `),
                    styled(formatValue(info.newValue, 60), {
                        color: 'green',
                    }),
                ]
                : [normalText(` (unchanged)`)];
        }
        handleObservableChanged(observable, info) {
            console.log(...this.b([
                formatKind('observable value changed'),
                styled(observable.debugName, { color: 'BlueViolet' }),
                ...this.c(info),
            ]));
        }
        formatChanges(changes) {
            if (changes.size === 0) {
                return undefined;
            }
            return styled(' (changed deps: ' +
                [...changes].map((o) => o.debugName).join(', ') +
                ')', { color: 'gray' });
        }
        handleDerivedCreated(derived) {
            const existingHandleChange = derived.handleChange;
            this.d.set(derived, new Set());
            derived.handleChange = (observable, change) => {
                this.d.get(derived).add(observable);
                return existingHandleChange.apply(derived, [observable, change]);
            };
        }
        handleDerivedRecomputed(derived, info) {
            const changedObservables = this.d.get(derived);
            console.log(...this.b([
                formatKind('derived recomputed'),
                styled(derived.debugName, { color: 'BlueViolet' }),
                ...this.c(info),
                this.formatChanges(changedObservables),
                { data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }
            ]));
            changedObservables.clear();
        }
        handleFromEventObservableTriggered(observable, info) {
            console.log(...this.b([
                formatKind('observable from event triggered'),
                styled(observable.debugName, { color: 'BlueViolet' }),
                ...this.c(info),
                { data: [{ fn: observable._getValue }] }
            ]));
        }
        handleAutorunCreated(autorun) {
            const existingHandleChange = autorun.handleChange;
            this.d.set(autorun, new Set());
            autorun.handleChange = (observable, change) => {
                this.d.get(autorun).add(observable);
                return existingHandleChange.apply(autorun, [observable, change]);
            };
        }
        handleAutorunTriggered(autorun) {
            const changedObservables = this.d.get(autorun);
            console.log(...this.b([
                formatKind('autorun'),
                styled(autorun.debugName, { color: 'BlueViolet' }),
                this.formatChanges(changedObservables),
                { data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }
            ]));
            changedObservables.clear();
            this.a++;
        }
        handleAutorunFinished(autorun) {
            this.a--;
        }
        handleBeginTransaction(transaction) {
            let transactionName = transaction.getDebugName();
            if (transactionName === undefined) {
                transactionName = '';
            }
            console.log(...this.b([
                formatKind('transaction'),
                styled(transactionName, { color: 'BlueViolet' }),
                { data: [{ fn: transaction._fn }] }
            ]));
            this.a++;
        }
        handleEndTransaction() {
            this.a--;
        }
    }
    exports.$Md = $Md;
    function consoleTextToArgs(text) {
        const styles = new Array();
        const data = [];
        let firstArg = '';
        function process(t) {
            if ('length' in t) {
                for (const item of t) {
                    if (item) {
                        process(item);
                    }
                }
            }
            else if ('text' in t) {
                firstArg += `%c${t.text}`;
                styles.push(t.style);
                if (t.data) {
                    data.push(...t.data);
                }
            }
            else if ('data' in t) {
                data.push(...t.data);
            }
        }
        process(text);
        const result = [firstArg, ...styles];
        result.push(...data);
        return result;
    }
    function normalText(text) {
        return styled(text, { color: 'black' });
    }
    function formatKind(kind) {
        return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });
    }
    function styled(text, options = {
        color: 'black',
    }) {
        function objToCss(styleObj) {
            return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {
                return `${styleString}${propName}:${propValue};`;
            }, '');
        }
        const style = {
            color: options.color,
        };
        if (options.strikeThrough) {
            style['text-decoration'] = 'line-through';
        }
        if (options.bold) {
            style['font-weight'] = 'bold';
        }
        return {
            text,
            style: objToCss(style),
        };
    }
    function formatValue(value, availableLen) {
        switch (typeof value) {
            case 'number':
                return '' + value;
            case 'string':
                if (value.length + 2 <= availableLen) {
                    return `"${value}"`;
                }
                return `"${value.substr(0, availableLen - 7)}"+...`;
            case 'boolean':
                return value ? 'true' : 'false';
            case 'undefined':
                return 'undefined';
            case 'object':
                if (value === null) {
                    return 'null';
                }
                if (Array.isArray(value)) {
                    return formatArray(value, availableLen);
                }
                return formatObject(value, availableLen);
            case 'symbol':
                return value.toString();
            case 'function':
                return `[[Function${value.name ? ' ' + value.name : ''}]]`;
            default:
                return '' + value;
        }
    }
    function formatArray(value, availableLen) {
        let result = '[ ';
        let first = true;
        for (const val of value) {
            if (!first) {
                result += ', ';
            }
            if (result.length - 5 > availableLen) {
                result += '...';
                break;
            }
            first = false;
            result += `${formatValue(val, availableLen - result.length)}`;
        }
        result += ' ]';
        return result;
    }
    function formatObject(value, availableLen) {
        let result = '{ ';
        let first = true;
        for (const [key, val] of Object.entries(value)) {
            if (!first) {
                result += ', ';
            }
            if (result.length - 5 > availableLen) {
                result += '...';
                break;
            }
            first = false;
            result += `${key}: ${formatValue(val, availableLen - result.length)}`;
        }
        result += ' }';
        return result;
    }
    function repeat(str, count) {
        let result = '';
        for (let i = 1; i <= count; i++) {
            result += str;
        }
        return result;
    }
    function padStr(str, length) {
        while (str.length < length) {
            str += ' ';
        }
        return str;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[143/*vs/base/common/observableInternal/base*/], __M([1/*require*/,0/*exports*/,135/*vs/base/common/equals*/,141/*vs/base/common/observableInternal/debugName*/,142/*vs/base/common/observableInternal/logging*/]), function (require, exports, equals_1, debugName_1, logging_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$9d = exports.$7d = exports.$5d = exports.$Zd = exports.$Yd = void 0;
    exports.$Vd = $Vd;
    exports.$Wd = $Wd;
    exports.$Xd = $Xd;
    exports.$1d = $1d;
    exports.$2d = $2d;
    exports.$3d = $3d;
    exports.$4d = $4d;
    exports.$6d = $6d;
    exports.$8d = $8d;
    let _recomputeInitiallyAndOnChange;
    function $Vd(recomputeInitiallyAndOnChange) {
        _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;
    }
    let _keepObserved;
    function $Wd(keepObserved) {
        _keepObserved = keepObserved;
    }
    let _derived;
    /**
     * @internal
     * This is to allow splitting files.
    */
    function $Xd(derived) {
        _derived = derived;
    }
    class $Yd {
        get TChange() { return null; }
        reportChanges() {
            this.get();
        }
        /** @sealed */
        read(reader) {
            if (reader) {
                return reader.readObservable(this);
            }
            else {
                return this.get();
            }
        }
        map(fnOrOwner, fnOrUndefined) {
            const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;
            const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;
            return _derived({
                owner,
                debugName: () => {
                    const name = (0, debugName_1.$cd)(fn);
                    if (name !== undefined) {
                        return name;
                    }
                    // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):
                    const regexp = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/;
                    const match = regexp.exec(fn.toString());
                    if (match) {
                        return `${this.debugName}.${match[2]}`;
                    }
                    if (!owner) {
                        return `${this.debugName} (mapped)`;
                    }
                    return undefined;
                },
                debugReferenceFn: fn,
            }, (reader) => fn(this.read(reader), reader));
        }
        /**
         * @sealed
         * Converts an observable of an observable value into a direct observable of the value.
        */
        flatten() {
            return _derived({
                owner: undefined,
                debugName: () => `${this.debugName} (flattened)`,
            }, (reader) => this.read(reader).read(reader));
        }
        recomputeInitiallyAndOnChange(store, handleValue) {
            store.add(_recomputeInitiallyAndOnChange(this, handleValue));
            return this;
        }
        /**
         * Ensures that this observable is observed. This keeps the cache alive.
         * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
         * Use `recomputeInitiallyAndOnChange` for eager evaluation.
         */
        keepObserved(store) {
            store.add(_keepObserved(this));
            return this;
        }
        get a() {
            return this.get();
        }
    }
    exports.$Yd = $Yd;
    class $Zd extends $Yd {
        constructor() {
            super(...arguments);
            this.b = new Set();
        }
        addObserver(observer) {
            const len = this.b.size;
            this.b.add(observer);
            if (len === 0) {
                this.c();
            }
        }
        removeObserver(observer) {
            const deleted = this.b.delete(observer);
            if (deleted && this.b.size === 0) {
                this.f();
            }
        }
        c() { }
        f() { }
    }
    exports.$Zd = $Zd;
    /**
     * Starts a transaction in which many observables can be changed at once.
     * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.
     * Reaction run on demand or when the transaction ends.
     */
    function $1d(fn, getDebugName) {
        const tx = new $5d(fn, getDebugName);
        try {
            fn(tx);
        }
        finally {
            tx.finish();
        }
    }
    let _globalTransaction = undefined;
    function $2d(fn) {
        if (_globalTransaction) {
            fn(_globalTransaction);
        }
        else {
            const tx = new $5d(fn, undefined);
            _globalTransaction = tx;
            try {
                fn(tx);
            }
            finally {
                tx.finish(); // During finish, more actions might be added to the transaction.
                // Which is why we only clear the global transaction after finish.
                _globalTransaction = undefined;
            }
        }
    }
    async function $3d(fn, getDebugName) {
        const tx = new $5d(fn, getDebugName);
        try {
            await fn(tx);
        }
        finally {
            tx.finish();
        }
    }
    /**
     * Allows to chain transactions.
     */
    function $4d(tx, fn, getDebugName) {
        if (!tx) {
            $1d(fn, getDebugName);
        }
        else {
            fn(tx);
        }
    }
    class $5d {
        constructor(_fn, b) {
            this._fn = _fn;
            this.b = b;
            this.a = [];
            (0, logging_1.$Ld)()?.handleBeginTransaction(this);
        }
        getDebugName() {
            if (this.b) {
                return this.b();
            }
            return (0, debugName_1.$cd)(this._fn);
        }
        updateObserver(observer, observable) {
            // When this gets called while finish is active, they will still get considered
            this.a.push({ observer, observable });
            observer.beginUpdate(observable);
        }
        finish() {
            const updatingObservers = this.a;
            for (let i = 0; i < updatingObservers.length; i++) {
                const { observer, observable } = updatingObservers[i];
                observer.endUpdate(observable);
            }
            // Prevent anyone from updating observers from now on.
            this.a = null;
            (0, logging_1.$Ld)()?.handleEndTransaction();
        }
    }
    exports.$5d = $5d;
    function $6d(nameOrOwner, initialValue) {
        let debugNameData;
        if (typeof nameOrOwner === 'string') {
            debugNameData = new debugName_1.$ad(undefined, nameOrOwner, undefined);
        }
        else {
            debugNameData = new debugName_1.$ad(nameOrOwner, undefined, undefined);
        }
        return new $7d(debugNameData, initialValue, equals_1.$6c);
    }
    class $7d extends $Zd {
        get debugName() {
            return this.e.getDebugName(this) ?? 'ObservableValue';
        }
        constructor(e, initialValue, g) {
            super();
            this.e = e;
            this.g = g;
            this.d = initialValue;
        }
        get() {
            return this.d;
        }
        set(value, tx, change) {
            if (change === undefined && this.g(this.d, value)) {
                return;
            }
            let _tx;
            if (!tx) {
                tx = _tx = new $5d(() => { }, () => `Setting ${this.debugName}`);
            }
            try {
                const oldValue = this.d;
                this.h(value);
                (0, logging_1.$Ld)()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });
                for (const observer of this.b) {
                    tx.updateObserver(observer, this);
                    observer.handleChange(this, change);
                }
            }
            finally {
                if (_tx) {
                    _tx.finish();
                }
            }
        }
        toString() {
            return `${this.debugName}: ${this.d}`;
        }
        h(newValue) {
            this.d = newValue;
        }
    }
    exports.$7d = $7d;
    /**
     * A disposable observable. When disposed, its value is also disposed.
     * When a new value is set, the previous value is disposed.
     */
    function $8d(nameOrOwner, initialValue) {
        let debugNameData;
        if (typeof nameOrOwner === 'string') {
            debugNameData = new debugName_1.$ad(undefined, nameOrOwner, undefined);
        }
        else {
            debugNameData = new debugName_1.$ad(nameOrOwner, undefined, undefined);
        }
        return new $9d(debugNameData, initialValue, equals_1.$6c);
    }
    class $9d extends $7d {
        h(newValue) {
            if (this.d === newValue) {
                return;
            }
            if (this.d) {
                this.d.dispose();
            }
            this.d = newValue;
        }
        dispose() {
            this.d?.dispose();
        }
    }
    exports.$9d = $9d;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

//@ts-check
'use strict';

// ESM-uncomment-begin
// const module = { exports: {} };
// ESM-uncomment-end

(function () {

	/**
	 * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}
	 */
	function _definePolyfillMarks(timeOrigin) {

		const _data = [];
		if (typeof timeOrigin === 'number') {
			_data.push('code/timeOrigin', timeOrigin);
		}

		function mark(name) {
			_data.push(name, Date.now());
		}
		function getMarks() {
			const result = [];
			for (let i = 0; i < _data.length; i += 2) {
				result.push({
					name: _data[i],
					startTime: _data[i + 1],
				});
			}
			return result;
		}
		return { mark, getMarks };
	}

	/**
	 * @returns {{mark(name:string):void, getMarks():{name:string, startTime:number}[]}}
	 */
	function _define() {

		// Identify browser environment when following property is not present
		// https://nodejs.org/dist/latest-v16.x/docs/api/perf_hooks.html#performancenodetiming
		// @ts-ignore
		if (typeof performance === 'object' && typeof performance.mark === 'function' && !performance.nodeTiming) {
			// in a browser context, reuse performance-util

			if (typeof performance.timeOrigin !== 'number' && !performance.timing) {
				// safari & webworker: because there is no timeOrigin and no workaround
				// we use the `Date.now`-based polyfill.
				return _definePolyfillMarks();

			} else {
				// use "native" performance for mark and getMarks
				return {
					mark(name) {
						performance.mark(name);
					},
					getMarks() {
						let timeOrigin = performance.timeOrigin;
						if (typeof timeOrigin !== 'number') {
							// safari: there is no timerOrigin but in renderers there is the timing-property
							// see https://bugs.webkit.org/show_bug.cgi?id=174862
							timeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
						}
						const result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];
						for (const entry of performance.getEntriesByType('mark')) {
							result.push({
								name: entry.name,
								startTime: Math.round(timeOrigin + entry.startTime)
							});
						}
						return result;
					}
				};
			}

		} else if (typeof process === 'object') {
			// node.js: use the normal polyfill but add the timeOrigin
			// from the node perf_hooks API as very first mark
			const timeOrigin = performance?.timeOrigin ?? Math.round((require.__$__nodeRequire || require)('perf_hooks').performance.timeOrigin);
			return _definePolyfillMarks(timeOrigin);

		} else {
			// unknown environment
			console.trace('perf-util loaded in UNKNOWN environment');
			return _definePolyfillMarks();
		}
	}

	function _factory(sharedObj) {
		if (!sharedObj.MonacoPerformanceMarks) {
			sharedObj.MonacoPerformanceMarks = _define();
		}
		return sharedObj.MonacoPerformanceMarks;
	}

	// This module can be loaded in an amd and commonjs-context.
	// Because we want both instances to use the same perf-data
	// we store them globally

	// eslint-disable-next-line no-var
	var sharedObj;
	if (typeof global === 'object') {
		// nodejs
		sharedObj = global;
	} else if (typeof self === 'object') {
		// browser
		sharedObj = self;
	} else {
		sharedObj = {};
	}

	if (typeof define === 'function') {
		// amd
		define("vs/base/common/performance", [], function () { return _factory(sharedObj); });
	} else if (typeof module === 'object' && typeof module.exports === 'object') {
		// commonjs
		module.exports = _factory(sharedObj);
	} else {
		console.trace('perf-util defined in UNKNOWN context (neither requirejs or commonjs)');
		// @ts-ignore
		sharedObj.perf = _factory(sharedObj);
	}

})();

// ESM-uncomment-begin
// export const mark = module.exports.mark;
// export const getMarks = module.exports.getMarks;
// ESM-uncomment-end

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[144/*vs/base/common/prefixTree*/], __M([1/*require*/,0/*exports*/,40/*vs/base/common/iterator*/]), function (require, exports, iterator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$6I = void 0;
    const unset = Symbol('unset');
    /**
     * A simple prefix tree implementation where a value is stored based on
     * well-defined prefix segments.
     */
    class $6I {
        constructor() {
            this.a = new Node();
            this.b = 0;
        }
        get size() {
            return this.b;
        }
        /** Gets the top-level nodes of the tree */
        get nodes() {
            return this.a.children?.values() || iterator_1.Iterable.empty();
        }
        /** Gets the top-level nodes of the tree */
        get entries() {
            return this.a.children?.entries() || iterator_1.Iterable.empty();
        }
        /**
         * Inserts a new value in the prefix tree.
         * @param onNode - called for each node as we descend to the insertion point,
         * including the insertion point itself.
         */
        insert(key, value, onNode) {
            this.d(key, n => n._value = value, onNode);
        }
        /** Mutates a value in the prefix tree. */
        mutate(key, mutate) {
            this.d(key, n => n._value = mutate(n._value === unset ? undefined : n._value));
        }
        /** Mutates nodes along the path in the prefix tree. */
        mutatePath(key, mutate) {
            this.d(key, () => { }, n => mutate(n));
        }
        /** Deletes a node from the prefix tree, returning the value it contained. */
        delete(key) {
            const path = this.c(key);
            if (!path) {
                return;
            }
            let i = path.length - 1;
            const value = path[i].node._value;
            if (value === unset) {
                return; // not actually a real node
            }
            this.b--;
            path[i].node._value = unset;
            for (; i > 0; i--) {
                const { node, part } = path[i];
                if (node.children?.size || node._value !== unset) {
                    break;
                }
                path[i - 1].node.children.delete(part);
            }
            return value;
        }
        /** Deletes a subtree from the prefix tree, returning the values they contained. */
        *deleteRecursive(key) {
            const path = this.c(key);
            if (!path) {
                return;
            }
            const subtree = path[path.length - 1].node;
            // important: run the deletion before we start to yield results, so that
            // it still runs even if the caller doesn't consumer the iterator
            for (let i = path.length - 1; i > 0; i--) {
                const parent = path[i - 1];
                parent.node.children.delete(path[i].part);
                if (parent.node.children.size > 0 || parent.node._value !== unset) {
                    break;
                }
            }
            for (const node of bfsIterate(subtree)) {
                if (node._value !== unset) {
                    this.b--;
                    yield node._value;
                }
            }
        }
        /** Gets a value from the tree. */
        find(key) {
            let node = this.a;
            for (const segment of key) {
                const next = node.children?.get(segment);
                if (!next) {
                    return undefined;
                }
                node = next;
            }
            return node._value === unset ? undefined : node._value;
        }
        /** Gets whether the tree has the key, or a parent of the key, already inserted. */
        hasKeyOrParent(key) {
            let node = this.a;
            for (const segment of key) {
                const next = node.children?.get(segment);
                if (!next) {
                    return false;
                }
                if (next._value !== unset) {
                    return true;
                }
                node = next;
            }
            return false;
        }
        /** Gets whether the tree has the given key or any children. */
        hasKeyOrChildren(key) {
            let node = this.a;
            for (const segment of key) {
                const next = node.children?.get(segment);
                if (!next) {
                    return false;
                }
                node = next;
            }
            return true;
        }
        /** Gets whether the tree has the given key. */
        hasKey(key) {
            let node = this.a;
            for (const segment of key) {
                const next = node.children?.get(segment);
                if (!next) {
                    return false;
                }
                node = next;
            }
            return node._value !== unset;
        }
        c(key) {
            const path = [{ part: '', node: this.a }];
            let i = 0;
            for (const part of key) {
                const node = path[i].node.children?.get(part);
                if (!node) {
                    return; // node not in tree
                }
                path.push({ part, node });
                i++;
            }
            return path;
        }
        d(key, fn, onDescend) {
            let node = this.a;
            for (const part of key) {
                if (!node.children) {
                    const next = new Node();
                    node.children = new Map([[part, next]]);
                    node = next;
                }
                else if (!node.children.has(part)) {
                    const next = new Node();
                    node.children.set(part, next);
                    node = next;
                }
                else {
                    node = node.children.get(part);
                }
                onDescend?.(node);
            }
            const sizeBefore = node._value === unset ? 0 : 1;
            fn(node);
            const sizeAfter = node._value === unset ? 0 : 1;
            this.b += sizeAfter - sizeBefore;
        }
        /** Returns an iterable of the tree values in no defined order. */
        *values() {
            for (const { _value } of bfsIterate(this.a)) {
                if (_value !== unset) {
                    yield _value;
                }
            }
        }
    }
    exports.$6I = $6I;
    function* bfsIterate(root) {
        const stack = [root];
        while (stack.length > 0) {
            const node = stack.pop();
            yield node;
            if (node.children) {
                for (const child of node.children.values()) {
                    stack.push(child);
                }
            }
        }
    }
    class Node {
        constructor() {
            this._value = unset;
        }
        get value() {
            return this._value === unset ? undefined : this._value;
        }
        set value(value) {
            this._value = value === undefined ? unset : value;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[145/*vs/base/common/comparers*/], __M([1/*require*/,0/*exports*/,48/*vs/base/common/lazy*/,19/*vs/base/common/path*/]), function (require, exports, lazy_1, path_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ar = $Ar;
    exports.$Br = $Br;
    exports.$Cr = $Cr;
    exports.$Dr = $Dr;
    exports.$Er = $Er;
    exports.$Fr = $Fr;
    exports.$Gr = $Gr;
    exports.$Hr = $Hr;
    exports.$Ir = $Ir;
    exports.$Jr = $Jr;
    exports.$Kr = $Kr;
    exports.$Lr = $Lr;
    exports.$Mr = $Mr;
    // When comparing large numbers of strings it's better for performance to create an
    // Intl.Collator object and use the function provided by its compare property
    // than it is to use String.prototype.localeCompare()
    // A collator with numeric sorting enabled, and no sensitivity to case, accents or diacritics.
    const intlFileNameCollatorBaseNumeric = new lazy_1.$T(() => {
        const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
        return {
            collator,
            collatorIsNumeric: collator.resolvedOptions().numeric
        };
    });
    // A collator with numeric sorting enabled.
    const intlFileNameCollatorNumeric = new lazy_1.$T(() => {
        const collator = new Intl.Collator(undefined, { numeric: true });
        return {
            collator
        };
    });
    // A collator with numeric sorting enabled, and sensitivity to accents and diacritics but not case.
    const intlFileNameCollatorNumericCaseInsensitive = new lazy_1.$T(() => {
        const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'accent' });
        return {
            collator
        };
    });
    /** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */
    function $Ar(one, other, caseSensitive = false) {
        const a = one || '';
        const b = other || '';
        const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);
        // Using the numeric option will make compare(`foo1`, `foo01`) === 0. Disambiguate.
        if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {
            return a < b ? -1 : 1;
        }
        return result;
    }
    /** Compares full filenames without grouping by case. */
    function $Br(one, other) {
        const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
        one = one || '';
        other = other || '';
        return compareAndDisambiguateByLength(collatorNumeric, one, other);
    }
    /** Compares full filenames grouping uppercase names before lowercase. */
    function $Cr(one, other) {
        const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
        one = one || '';
        other = other || '';
        return compareCaseUpperFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);
    }
    /** Compares full filenames grouping lowercase names before uppercase. */
    function $Dr(one, other) {
        const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
        one = one || '';
        other = other || '';
        return compareCaseLowerFirst(one, other) || compareAndDisambiguateByLength(collatorNumeric, one, other);
    }
    /** Compares full filenames by unicode value. */
    function $Er(one, other) {
        one = one || '';
        other = other || '';
        if (one === other) {
            return 0;
        }
        return one < other ? -1 : 1;
    }
    /** Compares filenames by extension, then by name. Disambiguates by unicode comparison. */
    function $Fr(one, other) {
        const [oneName, oneExtension] = extractNameAndExtension(one);
        const [otherName, otherExtension] = extractNameAndExtension(other);
        let result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneExtension, otherExtension);
        if (result === 0) {
            // Using the numeric option will  make compare(`foo1`, `foo01`) === 0. Disambiguate.
            if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && oneExtension !== otherExtension) {
                return oneExtension < otherExtension ? -1 : 1;
            }
            // Extensions are equal, compare filenames
            result = intlFileNameCollatorBaseNumeric.value.collator.compare(oneName, otherName);
            if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && oneName !== otherName) {
                return oneName < otherName ? -1 : 1;
            }
        }
        return result;
    }
    /** Compares filenames by extension, then by full filename. Mixes uppercase and lowercase names together. */
    function $Gr(one, other) {
        one = one || '';
        other = other || '';
        const oneExtension = extractExtension(one);
        const otherExtension = extractExtension(other);
        const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
        const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
        return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
            compareAndDisambiguateByLength(collatorNumeric, one, other);
    }
    /** Compares filenames by extension, then case, then full filename. Groups uppercase names before lowercase. */
    function $Hr(one, other) {
        one = one || '';
        other = other || '';
        const oneExtension = extractExtension(one);
        const otherExtension = extractExtension(other);
        const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
        const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
        return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
            compareCaseUpperFirst(one, other) ||
            compareAndDisambiguateByLength(collatorNumeric, one, other);
    }
    /** Compares filenames by extension, then case, then full filename. Groups lowercase names before uppercase. */
    function $Ir(one, other) {
        one = one || '';
        other = other || '';
        const oneExtension = extractExtension(one);
        const otherExtension = extractExtension(other);
        const collatorNumeric = intlFileNameCollatorNumeric.value.collator;
        const collatorNumericCaseInsensitive = intlFileNameCollatorNumericCaseInsensitive.value.collator;
        return compareAndDisambiguateByLength(collatorNumericCaseInsensitive, oneExtension, otherExtension) ||
            compareCaseLowerFirst(one, other) ||
            compareAndDisambiguateByLength(collatorNumeric, one, other);
    }
    /** Compares filenames by case-insensitive extension unicode value, then by full filename unicode value. */
    function $Jr(one, other) {
        one = one || '';
        other = other || '';
        const oneExtension = extractExtension(one).toLowerCase();
        const otherExtension = extractExtension(other).toLowerCase();
        // Check for extension differences
        if (oneExtension !== otherExtension) {
            return oneExtension < otherExtension ? -1 : 1;
        }
        // Check for full filename differences.
        if (one !== other) {
            return one < other ? -1 : 1;
        }
        return 0;
    }
    const FileNameMatch = /^(.*?)(\.([^.]*))?$/;
    /** Extracts the name and extension from a full filename, with optional special handling for dotfiles */
    function extractNameAndExtension(str, dotfilesAsNames = false) {
        const match = str ? FileNameMatch.exec(str) : [];
        let result = [(match && match[1]) || '', (match && match[3]) || ''];
        // if the dotfilesAsNames option is selected, treat an empty filename with an extension
        // or a filename that starts with a dot, as a dotfile name
        if (dotfilesAsNames && (!result[0] && result[1] || result[0] && result[0].charAt(0) === '.')) {
            result = [result[0] + '.' + result[1], ''];
        }
        return result;
    }
    /** Extracts the extension from a full filename. Treats dotfiles as names, not extensions. */
    function extractExtension(str) {
        const match = str ? FileNameMatch.exec(str) : [];
        return (match && match[1] && match[1].charAt(0) !== '.' && match[3]) || '';
    }
    function compareAndDisambiguateByLength(collator, one, other) {
        // Check for differences
        const result = collator.compare(one, other);
        if (result !== 0) {
            return result;
        }
        // In a numeric comparison, `foo1` and `foo01` will compare as equivalent.
        // Disambiguate by sorting the shorter string first.
        if (one.length !== other.length) {
            return one.length < other.length ? -1 : 1;
        }
        return 0;
    }
    /** @returns `true` if the string is starts with a lowercase letter. Otherwise, `false`. */
    function startsWithLower(string) {
        const character = string.charAt(0);
        return (character.toLocaleUpperCase() !== character) ? true : false;
    }
    /** @returns `true` if the string starts with an uppercase letter. Otherwise, `false`. */
    function startsWithUpper(string) {
        const character = string.charAt(0);
        return (character.toLocaleLowerCase() !== character) ? true : false;
    }
    /**
     * Compares the case of the provided strings - lowercase before uppercase
     *
     * @returns
     * ```text
     *   -1 if one is lowercase and other is uppercase
     *    1 if one is uppercase and other is lowercase
     *    0 otherwise
     * ```
     */
    function compareCaseLowerFirst(one, other) {
        if (startsWithLower(one) && startsWithUpper(other)) {
            return -1;
        }
        return (startsWithUpper(one) && startsWithLower(other)) ? 1 : 0;
    }
    /**
     * Compares the case of the provided strings - uppercase before lowercase
     *
     * @returns
     * ```text
     *   -1 if one is uppercase and other is lowercase
     *    1 if one is lowercase and other is uppercase
     *    0 otherwise
     * ```
     */
    function compareCaseUpperFirst(one, other) {
        if (startsWithUpper(one) && startsWithLower(other)) {
            return -1;
        }
        return (startsWithLower(one) && startsWithUpper(other)) ? 1 : 0;
    }
    function comparePathComponents(one, other, caseSensitive = false) {
        if (!caseSensitive) {
            one = one && one.toLowerCase();
            other = other && other.toLowerCase();
        }
        if (one === other) {
            return 0;
        }
        return one < other ? -1 : 1;
    }
    function $Kr(one, other, caseSensitive = false) {
        const oneParts = one.split(path_1.sep);
        const otherParts = other.split(path_1.sep);
        const lastOne = oneParts.length - 1;
        const lastOther = otherParts.length - 1;
        let endOne, endOther;
        for (let i = 0;; i++) {
            endOne = lastOne === i;
            endOther = lastOther === i;
            if (endOne && endOther) {
                return $Ar(oneParts[i], otherParts[i], caseSensitive);
            }
            else if (endOne) {
                return -1;
            }
            else if (endOther) {
                return 1;
            }
            const result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
            if (result !== 0) {
                return result;
            }
        }
    }
    function $Lr(one, other, lookFor) {
        const elementAName = one.toLowerCase();
        const elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        const prefixCompare = $Mr(one, other, lookFor);
        if (prefixCompare) {
            return prefixCompare;
        }
        // Sort suffix matches over non suffix matches
        const elementASuffixMatch = elementAName.endsWith(lookFor);
        const elementBSuffixMatch = elementBName.endsWith(lookFor);
        if (elementASuffixMatch !== elementBSuffixMatch) {
            return elementASuffixMatch ? -1 : 1;
        }
        // Understand file names
        const r = $Ar(elementAName, elementBName);
        if (r !== 0) {
            return r;
        }
        // Compare by name
        return elementAName.localeCompare(elementBName);
    }
    function $Mr(one, other, lookFor) {
        const elementAName = one.toLowerCase();
        const elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        const elementAPrefixMatch = elementAName.startsWith(lookFor);
        const elementBPrefixMatch = elementBName.startsWith(lookFor);
        if (elementAPrefixMatch !== elementBPrefixMatch) {
            return elementAPrefixMatch ? -1 : 1;
        }
        // Same prefix: Sort shorter matches to the top to have those on top that match more precisely
        else if (elementAPrefixMatch && elementBPrefixMatch) {
            if (elementAName.length < elementBName.length) {
                return -1;
            }
            if (elementAName.length > elementBName.length) {
                return 1;
            }
        }
        return 0;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[72/*vs/base/common/mime*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/path*/]), function (require, exports, path_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$$s = void 0;
    exports.$_s = $_s;
    exports.$at = $at;
    exports.$bt = $bt;
    exports.$ct = $ct;
    exports.$$s = Object.freeze({
        text: 'text/plain',
        binary: 'application/octet-stream',
        unknown: 'application/unknown',
        markdown: 'text/markdown',
        latex: 'text/latex',
        uriList: 'text/uri-list',
    });
    const mapExtToTextMimes = {
        '.css': 'text/css',
        '.csv': 'text/csv',
        '.htm': 'text/html',
        '.html': 'text/html',
        '.ics': 'text/calendar',
        '.js': 'text/javascript',
        '.mjs': 'text/javascript',
        '.txt': 'text/plain',
        '.xml': 'text/xml'
    };
    // Known media mimes that we can handle
    const mapExtToMediaMimes = {
        '.aac': 'audio/x-aac',
        '.avi': 'video/x-msvideo',
        '.bmp': 'image/bmp',
        '.flv': 'video/x-flv',
        '.gif': 'image/gif',
        '.ico': 'image/x-icon',
        '.jpe': 'image/jpg',
        '.jpeg': 'image/jpg',
        '.jpg': 'image/jpg',
        '.m1v': 'video/mpeg',
        '.m2a': 'audio/mpeg',
        '.m2v': 'video/mpeg',
        '.m3a': 'audio/mpeg',
        '.mid': 'audio/midi',
        '.midi': 'audio/midi',
        '.mk3d': 'video/x-matroska',
        '.mks': 'video/x-matroska',
        '.mkv': 'video/x-matroska',
        '.mov': 'video/quicktime',
        '.movie': 'video/x-sgi-movie',
        '.mp2': 'audio/mpeg',
        '.mp2a': 'audio/mpeg',
        '.mp3': 'audio/mpeg',
        '.mp4': 'video/mp4',
        '.mp4a': 'audio/mp4',
        '.mp4v': 'video/mp4',
        '.mpe': 'video/mpeg',
        '.mpeg': 'video/mpeg',
        '.mpg': 'video/mpeg',
        '.mpg4': 'video/mp4',
        '.mpga': 'audio/mpeg',
        '.oga': 'audio/ogg',
        '.ogg': 'audio/ogg',
        '.opus': 'audio/opus',
        '.ogv': 'video/ogg',
        '.png': 'image/png',
        '.psd': 'image/vnd.adobe.photoshop',
        '.qt': 'video/quicktime',
        '.spx': 'audio/ogg',
        '.svg': 'image/svg+xml',
        '.tga': 'image/x-tga',
        '.tif': 'image/tiff',
        '.tiff': 'image/tiff',
        '.wav': 'audio/x-wav',
        '.webm': 'video/webm',
        '.webp': 'image/webp',
        '.wma': 'audio/x-ms-wma',
        '.wmv': 'video/x-ms-wmv',
        '.woff': 'application/font-woff',
    };
    function $_s(path) {
        const ext = (0, path_1.$oc)(path);
        const textMime = mapExtToTextMimes[ext.toLowerCase()];
        if (textMime !== undefined) {
            return textMime;
        }
        else {
            return $at(path);
        }
    }
    function $at(path) {
        const ext = (0, path_1.$oc)(path);
        return mapExtToMediaMimes[ext.toLowerCase()];
    }
    function $bt(mimeType) {
        for (const extension in mapExtToMediaMimes) {
            if (mapExtToMediaMimes[extension] === mimeType) {
                return extension;
            }
        }
        return undefined;
    }
    const _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
    function $ct(mimeType, strict) {
        const match = _simplePattern.exec(mimeType);
        if (!match) {
            return strict
                ? undefined
                : mimeType;
        }
        // https://datatracker.ietf.org/doc/html/rfc2045#section-5.1
        // media and subtype must ALWAYS be lowercase, parameter not
        return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;
    }
});

/**
 * Semver UMD module
 * Copyright (c) Isaac Z. Schlueter and Contributors
 * https://github.com/npm/node-semver
 */

/**
 * DO NOT EDIT THIS FILE
 */

// ESM-uncomment-begin
// const exports = {};
// const module = { exports };
// ESM-uncomment-end

!function(e,r){if("object"==typeof exports&&"object"==typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define("vs/base/common/semver/semver", [],r);else{var t=r();for(var n in t)("object"==typeof exports?exports:e)[n]=t[n]}}("undefined"!=typeof self?self:this,(function(){return function(e){var r={};function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var o in e)t.d(n,o,function(r){return e[r]}.bind(null,o));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=0)}([function(e,r,t){(function(t){var n;r=e.exports=H,n="object"==typeof t&&t.env&&t.env.NODE_DEBUG&&/\bsemver\b/i.test(t.env.NODE_DEBUG)?function(){var e=Array.prototype.slice.call(arguments,0);e.unshift("SEMVER"),console.log.apply(console,e)}:function(){},r.SEMVER_SPEC_VERSION="2.0.0";var o=256,i=Number.MAX_SAFE_INTEGER||9007199254740991,s=r.re=[],a=r.src=[],u=0,c=u++;a[c]="0|[1-9]\\d*";var p=u++;a[p]="[0-9]+";var f=u++;a[f]="\\d*[a-zA-Z-][a-zA-Z0-9-]*";var l=u++;a[l]="("+a[c]+")\\.("+a[c]+")\\.("+a[c]+")";var h=u++;a[h]="("+a[p]+")\\.("+a[p]+")\\.("+a[p]+")";var v=u++;a[v]="(?:"+a[c]+"|"+a[f]+")";var m=u++;a[m]="(?:"+a[p]+"|"+a[f]+")";var w=u++;a[w]="(?:-("+a[v]+"(?:\\."+a[v]+")*))";var g=u++;a[g]="(?:-?("+a[m]+"(?:\\."+a[m]+")*))";var y=u++;a[y]="[0-9A-Za-z-]+";var d=u++;a[d]="(?:\\+("+a[y]+"(?:\\."+a[y]+")*))";var b=u++,j="v?"+a[l]+a[w]+"?"+a[d]+"?";a[b]="^"+j+"$";var E="[v=\\s]*"+a[h]+a[g]+"?"+a[d]+"?",T=u++;a[T]="^"+E+"$";var x=u++;a[x]="((?:<|>)?=?)";var $=u++;a[$]=a[p]+"|x|X|\\*";var k=u++;a[k]=a[c]+"|x|X|\\*";var S=u++;a[S]="[v=\\s]*("+a[k]+")(?:\\.("+a[k]+")(?:\\.("+a[k]+")(?:"+a[w]+")?"+a[d]+"?)?)?";var R=u++;a[R]="[v=\\s]*("+a[$]+")(?:\\.("+a[$]+")(?:\\.("+a[$]+")(?:"+a[g]+")?"+a[d]+"?)?)?";var I=u++;a[I]="^"+a[x]+"\\s*"+a[S]+"$";var _=u++;a[_]="^"+a[x]+"\\s*"+a[R]+"$";var O=u++;a[O]="(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";var A=u++;a[A]="(?:~>?)";var M=u++;a[M]="(\\s*)"+a[A]+"\\s+",s[M]=new RegExp(a[M],"g");var V=u++;a[V]="^"+a[A]+a[S]+"$";var P=u++;a[P]="^"+a[A]+a[R]+"$";var C=u++;a[C]="(?:\\^)";var L=u++;a[L]="(\\s*)"+a[C]+"\\s+",s[L]=new RegExp(a[L],"g");var N=u++;a[N]="^"+a[C]+a[S]+"$";var q=u++;a[q]="^"+a[C]+a[R]+"$";var D=u++;a[D]="^"+a[x]+"\\s*("+E+")$|^$";var X=u++;a[X]="^"+a[x]+"\\s*("+j+")$|^$";var z=u++;a[z]="(\\s*)"+a[x]+"\\s*("+E+"|"+a[S]+")",s[z]=new RegExp(a[z],"g");var G=u++;a[G]="^\\s*("+a[S]+")\\s+-\\s+("+a[S]+")\\s*$";var Z=u++;a[Z]="^\\s*("+a[R]+")\\s+-\\s+("+a[R]+")\\s*$";var B=u++;a[B]="(<|>)?=?\\s*\\*";for(var U=0;U<35;U++)n(U,a[U]),s[U]||(s[U]=new RegExp(a[U]));function F(e,r){if(e instanceof H)return e;if("string"!=typeof e)return null;if(e.length>o)return null;if(!(r?s[T]:s[b]).test(e))return null;try{return new H(e,r)}catch(e){return null}}function H(e,r){if(e instanceof H){if(e.loose===r)return e;e=e.version}else if("string"!=typeof e)throw new TypeError("Invalid Version: "+e);if(e.length>o)throw new TypeError("version is longer than "+o+" characters");if(!(this instanceof H))return new H(e,r);n("SemVer",e,r),this.loose=r;var t=e.trim().match(r?s[T]:s[b]);if(!t)throw new TypeError("Invalid Version: "+e);if(this.raw=e,this.major=+t[1],this.minor=+t[2],this.patch=+t[3],this.major>i||this.major<0)throw new TypeError("Invalid major version");if(this.minor>i||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>i||this.patch<0)throw new TypeError("Invalid patch version");t[4]?this.prerelease=t[4].split(".").map((function(e){if(/^[0-9]+$/.test(e)){var r=+e;if(r>=0&&r<i)return r}return e})):this.prerelease=[],this.build=t[5]?t[5].split("."):[],this.format()}r.parse=F,r.valid=function(e,r){var t=F(e,r);return t?t.version:null},r.clean=function(e,r){var t=F(e.trim().replace(/^[=v]+/,""),r);return t?t.version:null},r.SemVer=H,H.prototype.format=function(){return this.version=this.major+"."+this.minor+"."+this.patch,this.prerelease.length&&(this.version+="-"+this.prerelease.join(".")),this.version},H.prototype.toString=function(){return this.version},H.prototype.compare=function(e){return n("SemVer.compare",this.version,this.loose,e),e instanceof H||(e=new H(e,this.loose)),this.compareMain(e)||this.comparePre(e)},H.prototype.compareMain=function(e){return e instanceof H||(e=new H(e,this.loose)),K(this.major,e.major)||K(this.minor,e.minor)||K(this.patch,e.patch)},H.prototype.comparePre=function(e){if(e instanceof H||(e=new H(e,this.loose)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;var r=0;do{var t=this.prerelease[r],o=e.prerelease[r];if(n("prerelease compare",r,t,o),void 0===t&&void 0===o)return 0;if(void 0===o)return 1;if(void 0===t)return-1;if(t!==o)return K(t,o)}while(++r)},H.prototype.inc=function(e,r){switch(e){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",r);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",r);break;case"prepatch":this.prerelease.length=0,this.inc("patch",r),this.inc("pre",r);break;case"prerelease":0===this.prerelease.length&&this.inc("patch",r),this.inc("pre",r);break;case"major":0===this.minor&&0===this.patch&&0!==this.prerelease.length||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":0===this.patch&&0!==this.prerelease.length||this.minor++,this.patch=0,this.prerelease=[];break;case"patch":0===this.prerelease.length&&this.patch++,this.prerelease=[];break;case"pre":if(0===this.prerelease.length)this.prerelease=[0];else{for(var t=this.prerelease.length;--t>=0;)"number"==typeof this.prerelease[t]&&(this.prerelease[t]++,t=-2);-1===t&&this.prerelease.push(0)}r&&(this.prerelease[0]===r?isNaN(this.prerelease[1])&&(this.prerelease=[r,0]):this.prerelease=[r,0]);break;default:throw new Error("invalid increment argument: "+e)}return this.format(),this.raw=this.version,this},r.inc=function(e,r,t,n){"string"==typeof t&&(n=t,t=void 0);try{return new H(e,t).inc(r,n).version}catch(e){return null}},r.diff=function(e,r){if(ee(e,r))return null;var t=F(e),n=F(r);if(t.prerelease.length||n.prerelease.length){for(var o in t)if(("major"===o||"minor"===o||"patch"===o)&&t[o]!==n[o])return"pre"+o;return"prerelease"}for(var o in t)if(("major"===o||"minor"===o||"patch"===o)&&t[o]!==n[o])return o},r.compareIdentifiers=K;var J=/^[0-9]+$/;function K(e,r){var t=J.test(e),n=J.test(r);return t&&n&&(e=+e,r=+r),t&&!n?-1:n&&!t?1:e<r?-1:e>r?1:0}function Q(e,r,t){return new H(e,t).compare(new H(r,t))}function W(e,r,t){return Q(e,r,t)>0}function Y(e,r,t){return Q(e,r,t)<0}function ee(e,r,t){return 0===Q(e,r,t)}function re(e,r,t){return 0!==Q(e,r,t)}function te(e,r,t){return Q(e,r,t)>=0}function ne(e,r,t){return Q(e,r,t)<=0}function oe(e,r,t,n){var o;switch(r){case"===":"object"==typeof e&&(e=e.version),"object"==typeof t&&(t=t.version),o=e===t;break;case"!==":"object"==typeof e&&(e=e.version),"object"==typeof t&&(t=t.version),o=e!==t;break;case"":case"=":case"==":o=ee(e,t,n);break;case"!=":o=re(e,t,n);break;case">":o=W(e,t,n);break;case">=":o=te(e,t,n);break;case"<":o=Y(e,t,n);break;case"<=":o=ne(e,t,n);break;default:throw new TypeError("Invalid operator: "+r)}return o}function ie(e,r){if(e instanceof ie){if(e.loose===r)return e;e=e.value}if(!(this instanceof ie))return new ie(e,r);n("comparator",e,r),this.loose=r,this.parse(e),this.semver===se?this.value="":this.value=this.operator+this.semver.version,n("comp",this)}r.rcompareIdentifiers=function(e,r){return K(r,e)},r.major=function(e,r){return new H(e,r).major},r.minor=function(e,r){return new H(e,r).minor},r.patch=function(e,r){return new H(e,r).patch},r.compare=Q,r.compareLoose=function(e,r){return Q(e,r,!0)},r.rcompare=function(e,r,t){return Q(r,e,t)},r.sort=function(e,t){return e.sort((function(e,n){return r.compare(e,n,t)}))},r.rsort=function(e,t){return e.sort((function(e,n){return r.rcompare(e,n,t)}))},r.gt=W,r.lt=Y,r.eq=ee,r.neq=re,r.gte=te,r.lte=ne,r.cmp=oe,r.Comparator=ie;var se={};function ae(e,r){if(e instanceof ae)return e.loose===r?e:new ae(e.raw,r);if(e instanceof ie)return new ae(e.value,r);if(!(this instanceof ae))return new ae(e,r);if(this.loose=r,this.raw=e,this.set=e.split(/\s*\|\|\s*/).map((function(e){return this.parseRange(e.trim())}),this).filter((function(e){return e.length})),!this.set.length)throw new TypeError("Invalid SemVer Range: "+e);this.format()}function ue(e){return!e||"x"===e.toLowerCase()||"*"===e}function ce(e,r,t,n,o,i,s,a,u,c,p,f,l){return((r=ue(t)?"":ue(n)?">="+t+".0.0":ue(o)?">="+t+"."+n+".0":">="+r)+" "+(a=ue(u)?"":ue(c)?"<"+(+u+1)+".0.0":ue(p)?"<"+u+"."+(+c+1)+".0":f?"<="+u+"."+c+"."+p+"-"+f:"<="+a)).trim()}function pe(e,r){for(var t=0;t<e.length;t++)if(!e[t].test(r))return!1;if(r.prerelease.length){for(t=0;t<e.length;t++)if(n(e[t].semver),e[t].semver!==se&&e[t].semver.prerelease.length>0){var o=e[t].semver;if(o.major===r.major&&o.minor===r.minor&&o.patch===r.patch)return!0}return!1}return!0}function fe(e,r,t){try{r=new ae(r,t)}catch(e){return!1}return r.test(e)}function le(e,r,t,n){var o,i,s,a,u;switch(e=new H(e,n),r=new ae(r,n),t){case">":o=W,i=ne,s=Y,a=">",u=">=";break;case"<":o=Y,i=te,s=W,a="<",u="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(fe(e,r,n))return!1;for(var c=0;c<r.set.length;++c){var p=r.set[c],f=null,l=null;if(p.forEach((function(e){e.semver===se&&(e=new ie(">=0.0.0")),f=f||e,l=l||e,o(e.semver,f.semver,n)?f=e:s(e.semver,l.semver,n)&&(l=e)})),f.operator===a||f.operator===u)return!1;if((!l.operator||l.operator===a)&&i(e,l.semver))return!1;if(l.operator===u&&s(e,l.semver))return!1}return!0}ie.prototype.parse=function(e){var r=this.loose?s[D]:s[X],t=e.match(r);if(!t)throw new TypeError("Invalid comparator: "+e);this.operator=t[1],"="===this.operator&&(this.operator=""),t[2]?this.semver=new H(t[2],this.loose):this.semver=se},ie.prototype.toString=function(){return this.value},ie.prototype.test=function(e){return n("Comparator.test",e,this.loose),this.semver===se||("string"==typeof e&&(e=new H(e,this.loose)),oe(e,this.operator,this.semver,this.loose))},ie.prototype.intersects=function(e,r){if(!(e instanceof ie))throw new TypeError("a Comparator is required");var t;if(""===this.operator)return t=new ae(e.value,r),fe(this.value,t,r);if(""===e.operator)return t=new ae(this.value,r),fe(e.semver,t,r);var n=!(">="!==this.operator&&">"!==this.operator||">="!==e.operator&&">"!==e.operator),o=!("<="!==this.operator&&"<"!==this.operator||"<="!==e.operator&&"<"!==e.operator),i=this.semver.version===e.semver.version,s=!(">="!==this.operator&&"<="!==this.operator||">="!==e.operator&&"<="!==e.operator),a=oe(this.semver,"<",e.semver,r)&&(">="===this.operator||">"===this.operator)&&("<="===e.operator||"<"===e.operator),u=oe(this.semver,">",e.semver,r)&&("<="===this.operator||"<"===this.operator)&&(">="===e.operator||">"===e.operator);return n||o||i&&s||a||u},r.Range=ae,ae.prototype.format=function(){return this.range=this.set.map((function(e){return e.join(" ").trim()})).join("||").trim(),this.range},ae.prototype.toString=function(){return this.range},ae.prototype.parseRange=function(e){var r=this.loose;e=e.trim(),n("range",e,r);var t=r?s[Z]:s[G];e=e.replace(t,ce),n("hyphen replace",e),e=e.replace(s[z],"$1$2$3"),n("comparator trim",e,s[z]),e=(e=(e=e.replace(s[M],"$1~")).replace(s[L],"$1^")).split(/\s+/).join(" ");var o=r?s[D]:s[X],i=e.split(" ").map((function(e){return function(e,r){return n("comp",e),e=function(e,r){return e.trim().split(/\s+/).map((function(e){return function(e,r){n("caret",e,r);var t=r?s[q]:s[N];return e.replace(t,(function(r,t,o,i,s){var a;return n("caret",e,r,t,o,i,s),ue(t)?a="":ue(o)?a=">="+t+".0.0 <"+(+t+1)+".0.0":ue(i)?a="0"===t?">="+t+"."+o+".0 <"+t+"."+(+o+1)+".0":">="+t+"."+o+".0 <"+(+t+1)+".0.0":s?(n("replaceCaret pr",s),"-"!==s.charAt(0)&&(s="-"+s),a="0"===t?"0"===o?">="+t+"."+o+"."+i+s+" <"+t+"."+o+"."+(+i+1):">="+t+"."+o+"."+i+s+" <"+t+"."+(+o+1)+".0":">="+t+"."+o+"."+i+s+" <"+(+t+1)+".0.0"):(n("no pr"),a="0"===t?"0"===o?">="+t+"."+o+"."+i+" <"+t+"."+o+"."+(+i+1):">="+t+"."+o+"."+i+" <"+t+"."+(+o+1)+".0":">="+t+"."+o+"."+i+" <"+(+t+1)+".0.0"),n("caret return",a),a}))}(e,r)})).join(" ")}(e,r),n("caret",e),e=function(e,r){return e.trim().split(/\s+/).map((function(e){return function(e,r){var t=r?s[P]:s[V];return e.replace(t,(function(r,t,o,i,s){var a;return n("tilde",e,r,t,o,i,s),ue(t)?a="":ue(o)?a=">="+t+".0.0 <"+(+t+1)+".0.0":ue(i)?a=">="+t+"."+o+".0 <"+t+"."+(+o+1)+".0":s?(n("replaceTilde pr",s),"-"!==s.charAt(0)&&(s="-"+s),a=">="+t+"."+o+"."+i+s+" <"+t+"."+(+o+1)+".0"):a=">="+t+"."+o+"."+i+" <"+t+"."+(+o+1)+".0",n("tilde return",a),a}))}(e,r)})).join(" ")}(e,r),n("tildes",e),e=function(e,r){return n("replaceXRanges",e,r),e.split(/\s+/).map((function(e){return function(e,r){e=e.trim();var t=r?s[_]:s[I];return e.replace(t,(function(r,t,o,i,s,a){n("xRange",e,r,t,o,i,s,a);var u=ue(o),c=u||ue(i),p=c||ue(s);return"="===t&&p&&(t=""),u?r=">"===t||"<"===t?"<0.0.0":"*":t&&p?(c&&(i=0),p&&(s=0),">"===t?(t=">=",c?(o=+o+1,i=0,s=0):p&&(i=+i+1,s=0)):"<="===t&&(t="<",c?o=+o+1:i=+i+1),r=t+o+"."+i+"."+s):c?r=">="+o+".0.0 <"+(+o+1)+".0.0":p&&(r=">="+o+"."+i+".0 <"+o+"."+(+i+1)+".0"),n("xRange return",r),r}))}(e,r)})).join(" ")}(e,r),n("xrange",e),e=function(e,r){return n("replaceStars",e,r),e.trim().replace(s[B],"")}(e,r),n("stars",e),e}(e,r)})).join(" ").split(/\s+/);return this.loose&&(i=i.filter((function(e){return!!e.match(o)}))),i=i.map((function(e){return new ie(e,r)}))},ae.prototype.intersects=function(e,r){if(!(e instanceof ae))throw new TypeError("a Range is required");return this.set.some((function(t){return t.every((function(t){return e.set.some((function(e){return e.every((function(e){return t.intersects(e,r)}))}))}))}))},r.toComparators=function(e,r){return new ae(e,r).set.map((function(e){return e.map((function(e){return e.value})).join(" ").trim().split(" ")}))},ae.prototype.test=function(e){if(!e)return!1;"string"==typeof e&&(e=new H(e,this.loose));for(var r=0;r<this.set.length;r++)if(pe(this.set[r],e))return!0;return!1},r.satisfies=fe,r.maxSatisfying=function(e,r,t){var n=null,o=null;try{var i=new ae(r,t)}catch(e){return null}return e.forEach((function(e){i.test(e)&&(n&&-1!==o.compare(e)||(o=new H(n=e,t)))})),n},r.minSatisfying=function(e,r,t){var n=null,o=null;try{var i=new ae(r,t)}catch(e){return null}return e.forEach((function(e){i.test(e)&&(n&&1!==o.compare(e)||(o=new H(n=e,t)))})),n},r.validRange=function(e,r){try{return new ae(e,r).range||"*"}catch(e){return null}},r.ltr=function(e,r,t){return le(e,r,"<",t)},r.gtr=function(e,r,t){return le(e,r,">",t)},r.outside=le,r.prerelease=function(e,r){var t=F(e,r);return t&&t.prerelease.length?t.prerelease:null},r.intersects=function(e,r,t){return e=new ae(e,t),r=new ae(r,t),e.intersects(r)},r.coerce=function(e){if(e instanceof H)return e;if("string"!=typeof e)return null;var r=e.match(s[O]);return null==r?null:F((r[1]||"0")+"."+(r[2]||"0")+"."+(r[3]||"0"))}}).call(this,t(1))},function(e,r){var t,n,o=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function a(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:i}catch(e){t=i}try{n="function"==typeof clearTimeout?clearTimeout:s}catch(e){n=s}}();var u,c=[],p=!1,f=-1;function l(){p&&u&&(p=!1,u.length?c=u.concat(c):f=-1,c.length&&h())}function h(){if(!p){var e=a(l);p=!0;for(var r=c.length;r;){for(u=c,c=[];++f<r;)u&&u[f].run();f=-1,r=c.length}u=null,p=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(r){try{return n.call(null,e)}catch(r){return n.call(this,e)}}}(e)}}function v(e,r){this.fun=e,this.array=r}function m(){}o.nextTick=function(e){var r=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)r[t-1]=arguments[t];c.push(new v(e,r)),1!==c.length||p||a(h)},v.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=m,o.addListener=m,o.once=m,o.off=m,o.removeListener=m,o.removeAllListeners=m,o.emit=m,o.prependListener=m,o.prependOnceListener=m,o.listeners=function(e){return[]},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}}])}));

// ESM-uncomment-begin
// export const SEMVER_SPEC_VERSION = module.exports.SEMVER_SPEC_VERSION;
// export const parse = module.exports.parse;
// export const valid = module.exports.valid;
// export const coerce = module.exports.coerce;
// export const clean = module.exports.clean;
// export const inc = module.exports.inc;
// export const major = module.exports.major;
// export const minor = module.exports.minor;
// export const patch = module.exports.patch;
// export const prerelease = module.exports.prerelease;
// export const gt = module.exports.gt;
// export const gte = module.exports.gte;
// export const lt = module.exports.lt;
// export const lte = module.exports.lte;
// export const eq = module.exports.eq;
// export const neq = module.exports.neq;
// export const cmp = module.exports.cmp;
// export const compare = module.exports.compare;
// export const rcompare = module.exports.rcompare;
// export const compareIdentifiers = module.exports.compareIdentifiers;
// export const rcompareIdentifiers = module.exports.rcompareIdentifiers;
// export const compareBuild = module.exports.compareBuild;
// export const sort = module.exports.sort;
// export const rsort = module.exports.rsort;
// export const diff = module.exports.diff;
// export const validRange = module.exports.validRange;
// export const satisfies = module.exports.satisfies;
// export const maxSatisfying = module.exports.maxSatisfying;
// export const minSatisfying = module.exports.minSatisfying;
// export const minVersion = module.exports.minVersion;
// export const gtr = module.exports.gtr;
// export const ltr = module.exports.ltr;
// export const outside = module.exports.outside;
// export const intersects = module.exports.intersects;
// export const SemVer = module.exports.SemVer;
// export const Comparator = module.exports.Comparator;
// export const Range = module.exports.Range;
// ESM-uncomment-end

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[146/*vs/base/common/scrollable*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/]), function (require, exports, event_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$gt = exports.$ft = exports.$et = exports.$dt = exports.ScrollbarVisibility = void 0;
    var ScrollbarVisibility;
    (function (ScrollbarVisibility) {
        ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
        ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
    })(ScrollbarVisibility || (exports.ScrollbarVisibility = ScrollbarVisibility = {}));
    class $dt {
        constructor(c, width, scrollWidth, scrollLeft, height, scrollHeight, scrollTop) {
            this.c = c;
            this._scrollStateBrand = undefined;
            if (this.c) {
                width = width | 0;
                scrollWidth = scrollWidth | 0;
                scrollLeft = scrollLeft | 0;
                height = height | 0;
                scrollHeight = scrollHeight | 0;
                scrollTop = scrollTop | 0;
            }
            this.rawScrollLeft = scrollLeft; // before validation
            this.rawScrollTop = scrollTop; // before validation
            if (width < 0) {
                width = 0;
            }
            if (scrollLeft + width > scrollWidth) {
                scrollLeft = scrollWidth - width;
            }
            if (scrollLeft < 0) {
                scrollLeft = 0;
            }
            if (height < 0) {
                height = 0;
            }
            if (scrollTop + height > scrollHeight) {
                scrollTop = scrollHeight - height;
            }
            if (scrollTop < 0) {
                scrollTop = 0;
            }
            this.width = width;
            this.scrollWidth = scrollWidth;
            this.scrollLeft = scrollLeft;
            this.height = height;
            this.scrollHeight = scrollHeight;
            this.scrollTop = scrollTop;
        }
        equals(other) {
            return (this.rawScrollLeft === other.rawScrollLeft
                && this.rawScrollTop === other.rawScrollTop
                && this.width === other.width
                && this.scrollWidth === other.scrollWidth
                && this.scrollLeft === other.scrollLeft
                && this.height === other.height
                && this.scrollHeight === other.scrollHeight
                && this.scrollTop === other.scrollTop);
        }
        withScrollDimensions(update, useRawScrollPositions) {
            return new $dt(this.c, (typeof update.width !== 'undefined' ? update.width : this.width), (typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth), useRawScrollPositions ? this.rawScrollLeft : this.scrollLeft, (typeof update.height !== 'undefined' ? update.height : this.height), (typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight), useRawScrollPositions ? this.rawScrollTop : this.scrollTop);
        }
        withScrollPosition(update) {
            return new $dt(this.c, this.width, this.scrollWidth, (typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.rawScrollLeft), this.height, this.scrollHeight, (typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.rawScrollTop));
        }
        createScrollEvent(previous, inSmoothScrolling) {
            const widthChanged = (this.width !== previous.width);
            const scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);
            const scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);
            const heightChanged = (this.height !== previous.height);
            const scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);
            const scrollTopChanged = (this.scrollTop !== previous.scrollTop);
            return {
                inSmoothScrolling: inSmoothScrolling,
                oldWidth: previous.width,
                oldScrollWidth: previous.scrollWidth,
                oldScrollLeft: previous.scrollLeft,
                width: this.width,
                scrollWidth: this.scrollWidth,
                scrollLeft: this.scrollLeft,
                oldHeight: previous.height,
                oldScrollHeight: previous.scrollHeight,
                oldScrollTop: previous.scrollTop,
                height: this.height,
                scrollHeight: this.scrollHeight,
                scrollTop: this.scrollTop,
                widthChanged: widthChanged,
                scrollWidthChanged: scrollWidthChanged,
                scrollLeftChanged: scrollLeftChanged,
                heightChanged: heightChanged,
                scrollHeightChanged: scrollHeightChanged,
                scrollTopChanged: scrollTopChanged,
            };
        }
    }
    exports.$dt = $dt;
    class $et extends lifecycle_1.$Uc {
        constructor(options) {
            super();
            this._scrollableBrand = undefined;
            this.j = this.B(new event_1.$le());
            this.onScroll = this.j.event;
            this.c = options.smoothScrollDuration;
            this.f = options.scheduleAtNextAnimationFrame;
            this.g = new $dt(options.forceIntegerValues, 0, 0, 0, 0, 0, 0);
            this.h = null;
        }
        dispose() {
            if (this.h) {
                this.h.dispose();
                this.h = null;
            }
            super.dispose();
        }
        setSmoothScrollDuration(smoothScrollDuration) {
            this.c = smoothScrollDuration;
        }
        validateScrollPosition(scrollPosition) {
            return this.g.withScrollPosition(scrollPosition);
        }
        getScrollDimensions() {
            return this.g;
        }
        setScrollDimensions(dimensions, useRawScrollPositions) {
            const newState = this.g.withScrollDimensions(dimensions, useRawScrollPositions);
            this.n(newState, Boolean(this.h));
            // Validate outstanding animated scroll position target
            this.h?.acceptScrollDimensions(this.g);
        }
        /**
         * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
         * If no scroll animation is occurring, it will return the current scroll position instead.
         */
        getFutureScrollPosition() {
            if (this.h) {
                return this.h.to;
            }
            return this.g;
        }
        /**
         * Returns the current scroll position.
         * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
         */
        getCurrentScrollPosition() {
            return this.g;
        }
        setScrollPositionNow(update) {
            // no smooth scrolling requested
            const newState = this.g.withScrollPosition(update);
            // Terminate any outstanding smooth scrolling
            if (this.h) {
                this.h.dispose();
                this.h = null;
            }
            this.n(newState, false);
        }
        setScrollPositionSmooth(update, reuseAnimation) {
            if (this.c === 0) {
                // Smooth scrolling not supported.
                return this.setScrollPositionNow(update);
            }
            if (this.h) {
                // Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop
                update = {
                    scrollLeft: (typeof update.scrollLeft === 'undefined' ? this.h.to.scrollLeft : update.scrollLeft),
                    scrollTop: (typeof update.scrollTop === 'undefined' ? this.h.to.scrollTop : update.scrollTop)
                };
                // Validate `update`
                const validTarget = this.g.withScrollPosition(update);
                if (this.h.to.scrollLeft === validTarget.scrollLeft && this.h.to.scrollTop === validTarget.scrollTop) {
                    // No need to interrupt or extend the current animation since we're going to the same place
                    return;
                }
                let newSmoothScrolling;
                if (reuseAnimation) {
                    newSmoothScrolling = new $gt(this.h.from, validTarget, this.h.startTime, this.h.duration);
                }
                else {
                    newSmoothScrolling = this.h.combine(this.g, validTarget, this.c);
                }
                this.h.dispose();
                this.h = newSmoothScrolling;
            }
            else {
                // Validate `update`
                const validTarget = this.g.withScrollPosition(update);
                this.h = $gt.start(this.g, validTarget, this.c);
            }
            // Begin smooth scrolling animation
            this.h.animationFrameDisposable = this.f(() => {
                if (!this.h) {
                    return;
                }
                this.h.animationFrameDisposable = null;
                this.m();
            });
        }
        hasPendingScrollAnimation() {
            return Boolean(this.h);
        }
        m() {
            if (!this.h) {
                return;
            }
            const update = this.h.tick();
            const newState = this.g.withScrollPosition(update);
            this.n(newState, true);
            if (!this.h) {
                // Looks like someone canceled the smooth scrolling
                // from the scroll event handler
                return;
            }
            if (update.isDone) {
                this.h.dispose();
                this.h = null;
                return;
            }
            // Continue smooth scrolling animation
            this.h.animationFrameDisposable = this.f(() => {
                if (!this.h) {
                    return;
                }
                this.h.animationFrameDisposable = null;
                this.m();
            });
        }
        n(newState, inSmoothScrolling) {
            const oldState = this.g;
            if (oldState.equals(newState)) {
                // no change
                return;
            }
            this.g = newState;
            this.j.fire(this.g.createScrollEvent(oldState, inSmoothScrolling));
        }
    }
    exports.$et = $et;
    class $ft {
        constructor(scrollLeft, scrollTop, isDone) {
            this.scrollLeft = scrollLeft;
            this.scrollTop = scrollTop;
            this.isDone = isDone;
        }
    }
    exports.$ft = $ft;
    function createEaseOutCubic(from, to) {
        const delta = to - from;
        return function (completion) {
            return from + delta * easeOutCubic(completion);
        };
    }
    function createComposed(a, b, cut) {
        return function (completion) {
            if (completion < cut) {
                return a(completion / cut);
            }
            return b((completion - cut) / (1 - cut));
        };
    }
    class $gt {
        constructor(from, to, startTime, duration) {
            this.from = from;
            this.to = to;
            this.duration = duration;
            this.startTime = startTime;
            this.animationFrameDisposable = null;
            this.e();
        }
        e() {
            this.c = this.f(this.from.scrollLeft, this.to.scrollLeft, this.to.width);
            this.d = this.f(this.from.scrollTop, this.to.scrollTop, this.to.height);
        }
        f(from, to, viewportSize) {
            const delta = Math.abs(from - to);
            if (delta > 2.5 * viewportSize) {
                let stop1, stop2;
                if (from < to) {
                    // scroll to 75% of the viewportSize
                    stop1 = from + 0.75 * viewportSize;
                    stop2 = to - 0.75 * viewportSize;
                }
                else {
                    stop1 = from - 0.75 * viewportSize;
                    stop2 = to + 0.75 * viewportSize;
                }
                return createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);
            }
            return createEaseOutCubic(from, to);
        }
        dispose() {
            if (this.animationFrameDisposable !== null) {
                this.animationFrameDisposable.dispose();
                this.animationFrameDisposable = null;
            }
        }
        acceptScrollDimensions(state) {
            this.to = state.withScrollPosition(this.to);
            this.e();
        }
        tick() {
            return this.g(Date.now());
        }
        g(now) {
            const completion = (now - this.startTime) / this.duration;
            if (completion < 1) {
                const newScrollLeft = this.c(completion);
                const newScrollTop = this.d(completion);
                return new $ft(newScrollLeft, newScrollTop, false);
            }
            return new $ft(this.to.scrollLeft, this.to.scrollTop, true);
        }
        combine(from, to, duration) {
            return $gt.start(from, to, duration);
        }
        static start(from, to, duration) {
            // +10 / -10 : pretend the animation already started for a quicker response to a scroll request
            duration = duration + 10;
            const startTime = Date.now() - 10;
            return new $gt(from, to, startTime, duration);
        }
    }
    exports.$gt = $gt;
    function easeInCubic(t) {
        return Math.pow(t, 3);
    }
    function easeOutCubic(t) {
        return 1 - easeInCubic(1 - t);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[147/*vs/base/common/stream*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,4/*vs/base/common/lifecycle*/]), function (require, exports, errors_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ye = $ye;
    exports.$ze = $ze;
    exports.$Ae = $Ae;
    exports.$Be = $Be;
    exports.$Ce = $Ce;
    exports.$De = $De;
    exports.$Ee = $Ee;
    exports.$Fe = $Fe;
    exports.$Ge = $Ge;
    exports.$He = $He;
    exports.$Ie = $Ie;
    exports.$Je = $Je;
    exports.$Ke = $Ke;
    exports.$Le = $Le;
    exports.$Me = $Me;
    function $ye(obj) {
        const candidate = obj;
        if (!candidate) {
            return false;
        }
        return typeof candidate.read === 'function';
    }
    function $ze(obj) {
        const candidate = obj;
        if (!candidate) {
            return false;
        }
        return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');
    }
    function $Ae(obj) {
        const candidate = obj;
        if (!candidate) {
            return false;
        }
        return $ze(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';
    }
    function $Be(reducer, options) {
        return new WriteableStreamImpl(reducer, options);
    }
    class WriteableStreamImpl {
        constructor(e, f) {
            this.e = e;
            this.f = f;
            this.a = {
                flowing: false,
                ended: false,
                destroyed: false
            };
            this.b = {
                data: [],
                error: []
            };
            this.c = {
                data: [],
                error: [],
                end: []
            };
            this.d = [];
        }
        pause() {
            if (this.a.destroyed) {
                return;
            }
            this.a.flowing = false;
        }
        resume() {
            if (this.a.destroyed) {
                return;
            }
            if (!this.a.flowing) {
                this.a.flowing = true;
                // emit buffered events
                this.j();
                this.k();
                this.l();
            }
        }
        write(data) {
            if (this.a.destroyed) {
                return;
            }
            // flowing: directly send the data to listeners
            if (this.a.flowing) {
                this.g(data);
            }
            // not yet flowing: buffer data until flowing
            else {
                this.b.data.push(data);
                // highWaterMark: if configured, signal back when buffer reached limits
                if (typeof this.f?.highWaterMark === 'number' && this.b.data.length > this.f.highWaterMark) {
                    return new Promise(resolve => this.d.push(resolve));
                }
            }
        }
        error(error) {
            if (this.a.destroyed) {
                return;
            }
            // flowing: directly send the error to listeners
            if (this.a.flowing) {
                this.h(error);
            }
            // not yet flowing: buffer errors until flowing
            else {
                this.b.error.push(error);
            }
        }
        end(result) {
            if (this.a.destroyed) {
                return;
            }
            // end with data if provided
            if (typeof result !== 'undefined') {
                this.write(result);
            }
            // flowing: send end event to listeners
            if (this.a.flowing) {
                this.i();
                this.destroy();
            }
            // not yet flowing: remember state
            else {
                this.a.ended = true;
            }
        }
        g(data) {
            this.c.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event
        }
        h(error) {
            if (this.c.error.length === 0) {
                (0, errors_1.$Y)(error); // nobody listened to this error so we log it as unexpected
            }
            else {
                this.c.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event
            }
        }
        i() {
            this.c.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event
        }
        on(event, callback) {
            if (this.a.destroyed) {
                return;
            }
            switch (event) {
                case 'data':
                    this.c.data.push(callback);
                    // switch into flowing mode as soon as the first 'data'
                    // listener is added and we are not yet in flowing mode
                    this.resume();
                    break;
                case 'end':
                    this.c.end.push(callback);
                    // emit 'end' event directly if we are flowing
                    // and the end has already been reached
                    //
                    // finish() when it went through
                    if (this.a.flowing && this.l()) {
                        this.destroy();
                    }
                    break;
                case 'error':
                    this.c.error.push(callback);
                    // emit buffered 'error' events unless done already
                    // now that we know that we have at least one listener
                    if (this.a.flowing) {
                        this.k();
                    }
                    break;
            }
        }
        removeListener(event, callback) {
            if (this.a.destroyed) {
                return;
            }
            let listeners = undefined;
            switch (event) {
                case 'data':
                    listeners = this.c.data;
                    break;
                case 'end':
                    listeners = this.c.end;
                    break;
                case 'error':
                    listeners = this.c.error;
                    break;
            }
            if (listeners) {
                const index = listeners.indexOf(callback);
                if (index >= 0) {
                    listeners.splice(index, 1);
                }
            }
        }
        j() {
            if (this.b.data.length > 0) {
                const fullDataBuffer = this.e(this.b.data);
                this.g(fullDataBuffer);
                this.b.data.length = 0;
                // When the buffer is empty, resolve all pending writers
                const pendingWritePromises = [...this.d];
                this.d.length = 0;
                pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());
            }
        }
        k() {
            if (this.c.error.length > 0) {
                for (const error of this.b.error) {
                    this.h(error);
                }
                this.b.error.length = 0;
            }
        }
        l() {
            if (this.a.ended) {
                this.i();
                return this.c.end.length > 0;
            }
            return false;
        }
        destroy() {
            if (!this.a.destroyed) {
                this.a.destroyed = true;
                this.a.ended = true;
                this.b.data.length = 0;
                this.b.error.length = 0;
                this.c.data.length = 0;
                this.c.error.length = 0;
                this.c.end.length = 0;
                this.d.length = 0;
            }
        }
    }
    /**
     * Helper to fully read a T readable into a T.
     */
    function $Ce(readable, reducer) {
        const chunks = [];
        let chunk;
        while ((chunk = readable.read()) !== null) {
            chunks.push(chunk);
        }
        return reducer(chunks);
    }
    /**
     * Helper to read a T readable up to a maximum of chunks. If the limit is
     * reached, will return a readable instead to ensure all data can still
     * be read.
     */
    function $De(readable, reducer, maxChunks) {
        const chunks = [];
        let chunk = undefined;
        while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {
            chunks.push(chunk);
        }
        // If the last chunk is null, it means we reached the end of
        // the readable and return all the data at once
        if (chunk === null && chunks.length > 0) {
            return reducer(chunks);
        }
        // Otherwise, we still have a chunk, it means we reached the maxChunks
        // value and as such we return a new Readable that first returns
        // the existing read chunks and then continues with reading from
        // the underlying readable.
        return {
            read: () => {
                // First consume chunks from our array
                if (chunks.length > 0) {
                    return chunks.shift();
                }
                // Then ensure to return our last read chunk
                if (typeof chunk !== 'undefined') {
                    const lastReadChunk = chunk;
                    // explicitly use undefined here to indicate that we consumed
                    // the chunk, which could have either been null or valued.
                    chunk = undefined;
                    return lastReadChunk;
                }
                // Finally delegate back to the Readable
                return readable.read();
            }
        };
    }
    function $Ee(stream, reducer) {
        return new Promise((resolve, reject) => {
            const chunks = [];
            $Fe(stream, {
                onData: chunk => {
                    if (reducer) {
                        chunks.push(chunk);
                    }
                },
                onError: error => {
                    if (reducer) {
                        reject(error);
                    }
                    else {
                        resolve(undefined);
                    }
                },
                onEnd: () => {
                    if (reducer) {
                        resolve(reducer(chunks));
                    }
                    else {
                        resolve(undefined);
                    }
                }
            });
        });
    }
    /**
     * Helper to listen to all events of a T stream in proper order.
     */
    function $Fe(stream, listener, token) {
        stream.on('error', error => {
            if (!token?.isCancellationRequested) {
                listener.onError(error);
            }
        });
        stream.on('end', () => {
            if (!token?.isCancellationRequested) {
                listener.onEnd();
            }
        });
        // Adding the `data` listener will turn the stream
        // into flowing mode. As such it is important to
        // add this listener last (DO NOT CHANGE!)
        stream.on('data', data => {
            if (!token?.isCancellationRequested) {
                listener.onData(data);
            }
        });
    }
    /**
     * Helper to peek up to `maxChunks` into a stream. The return type signals if
     * the stream has ended or not. If not, caller needs to add a `data` listener
     * to continue reading.
     */
    function $Ge(stream, maxChunks) {
        return new Promise((resolve, reject) => {
            const streamListeners = new lifecycle_1.$Tc();
            const buffer = [];
            // Data Listener
            const dataListener = (chunk) => {
                // Add to buffer
                buffer.push(chunk);
                // We reached maxChunks and thus need to return
                if (buffer.length > maxChunks) {
                    // Dispose any listeners and ensure to pause the
                    // stream so that it can be consumed again by caller
                    streamListeners.dispose();
                    stream.pause();
                    return resolve({ stream, buffer, ended: false });
                }
            };
            // Error Listener
            const errorListener = (error) => {
                streamListeners.dispose();
                return reject(error);
            };
            // End Listener
            const endListener = () => {
                streamListeners.dispose();
                return resolve({ stream, buffer, ended: true });
            };
            streamListeners.add((0, lifecycle_1.$Sc)(() => stream.removeListener('error', errorListener)));
            stream.on('error', errorListener);
            streamListeners.add((0, lifecycle_1.$Sc)(() => stream.removeListener('end', endListener)));
            stream.on('end', endListener);
            // Important: leave the `data` listener last because
            // this can turn the stream into flowing mode and we
            // want `error` events to be received as well.
            streamListeners.add((0, lifecycle_1.$Sc)(() => stream.removeListener('data', dataListener)));
            stream.on('data', dataListener);
        });
    }
    /**
     * Helper to create a readable stream from an existing T.
     */
    function $He(t, reducer) {
        const stream = $Be(reducer);
        stream.end(t);
        return stream;
    }
    /**
     * Helper to create an empty stream
     */
    function $Ie() {
        const stream = $Be(() => { throw new Error('not supported'); });
        stream.end();
        return stream;
    }
    /**
     * Helper to convert a T into a Readable<T>.
     */
    function $Je(t) {
        let consumed = false;
        return {
            read: () => {
                if (consumed) {
                    return null;
                }
                consumed = true;
                return t;
            }
        };
    }
    /**
     * Helper to transform a readable stream into another stream.
     */
    function $Ke(stream, transformer, reducer) {
        const target = $Be(reducer);
        $Fe(stream, {
            onData: data => target.write(transformer.data(data)),
            onError: error => target.error(transformer.error ? transformer.error(error) : error),
            onEnd: () => target.end()
        });
        return target;
    }
    /**
     * Helper to take an existing readable that will
     * have a prefix injected to the beginning.
     */
    function $Le(prefix, readable, reducer) {
        let prefixHandled = false;
        return {
            read: () => {
                const chunk = readable.read();
                // Handle prefix only once
                if (!prefixHandled) {
                    prefixHandled = true;
                    // If we have also a read-result, make
                    // sure to reduce it to a single result
                    if (chunk !== null) {
                        return reducer([prefix, chunk]);
                    }
                    // Otherwise, just return prefix directly
                    return prefix;
                }
                return chunk;
            }
        };
    }
    /**
     * Helper to take an existing stream that will
     * have a prefix injected to the beginning.
     */
    function $Me(prefix, stream, reducer) {
        let prefixHandled = false;
        const target = $Be(reducer);
        $Fe(stream, {
            onData: data => {
                // Handle prefix only once
                if (!prefixHandled) {
                    prefixHandled = true;
                    return target.write(reducer([prefix, data]));
                }
                return target.write(data);
            },
            onError: error => target.error(error),
            onEnd: () => {
                // Handle prefix only once
                if (!prefixHandled) {
                    prefixHandled = true;
                    target.write(prefix);
                }
                target.end();
            }
        });
        return target;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[22/*vs/base/common/buffer*/], __M([1/*require*/,0/*exports*/,48/*vs/base/common/lazy*/,147/*vs/base/common/stream*/]), function (require, exports, lazy_1, streams) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ne = void 0;
    exports.$Oe = $Oe;
    exports.$Pe = $Pe;
    exports.$Qe = $Qe;
    exports.$Re = $Re;
    exports.$Se = $Se;
    exports.$Te = $Te;
    exports.$Ue = $Ue;
    exports.$Ve = $Ve;
    exports.$We = $We;
    exports.$Xe = $Xe;
    exports.$Ye = $Ye;
    exports.$Ze = $Ze;
    exports.$1e = $1e;
    exports.$2e = $2e;
    exports.$3e = $3e;
    exports.$4e = $4e;
    exports.$5e = $5e;
    exports.$6e = $6e;
    exports.$7e = $7e;
    exports.$8e = $8e;
    streams = __importStar(streams);
    const hasBuffer = (typeof Buffer !== 'undefined');
    const indexOfTable = new lazy_1.$T(() => new Uint8Array(256));
    let textEncoder;
    let textDecoder;
    class $Ne {
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static alloc(byteLength) {
            if (hasBuffer) {
                return new $Ne(Buffer.allocUnsafe(byteLength));
            }
            else {
                return new $Ne(new Uint8Array(byteLength));
            }
        }
        /**
         * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
         * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
         * which is not transferrable.
         */
        static wrap(actual) {
            if (hasBuffer && !(Buffer.isBuffer(actual))) {
                // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length
                // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array
                actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);
            }
            return new $Ne(actual);
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static fromString(source, options) {
            const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;
            if (!dontUseNodeBuffer && hasBuffer) {
                return new $Ne(Buffer.from(source));
            }
            else {
                if (!textEncoder) {
                    textEncoder = new TextEncoder();
                }
                return new $Ne(textEncoder.encode(source));
            }
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static fromByteArray(source) {
            const result = $Ne.alloc(source.length);
            for (let i = 0, len = source.length; i < len; i++) {
                result.buffer[i] = source[i];
            }
            return result;
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        static concat(buffers, totalLength) {
            if (typeof totalLength === 'undefined') {
                totalLength = 0;
                for (let i = 0, len = buffers.length; i < len; i++) {
                    totalLength += buffers[i].byteLength;
                }
            }
            const ret = $Ne.alloc(totalLength);
            let offset = 0;
            for (let i = 0, len = buffers.length; i < len; i++) {
                const element = buffers[i];
                ret.set(element, offset);
                offset += element.byteLength;
            }
            return ret;
        }
        constructor(buffer) {
            this.buffer = buffer;
            this.byteLength = this.buffer.byteLength;
        }
        /**
         * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
         * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
         */
        clone() {
            const result = $Ne.alloc(this.byteLength);
            result.set(this);
            return result;
        }
        toString() {
            if (hasBuffer) {
                return this.buffer.toString();
            }
            else {
                if (!textDecoder) {
                    textDecoder = new TextDecoder();
                }
                return textDecoder.decode(this.buffer);
            }
        }
        slice(start, end) {
            // IMPORTANT: use subarray instead of slice because TypedArray#slice
            // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray
            // ensures the same, performance, behaviour.
            return new $Ne(this.buffer.subarray(start, end));
        }
        set(array, offset) {
            if (array instanceof $Ne) {
                this.buffer.set(array.buffer, offset);
            }
            else if (array instanceof Uint8Array) {
                this.buffer.set(array, offset);
            }
            else if (array instanceof ArrayBuffer) {
                this.buffer.set(new Uint8Array(array), offset);
            }
            else if (ArrayBuffer.isView(array)) {
                this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);
            }
            else {
                throw new Error(`Unknown argument 'array'`);
            }
        }
        readUInt32BE(offset) {
            return $Re(this.buffer, offset);
        }
        writeUInt32BE(value, offset) {
            $Se(this.buffer, value, offset);
        }
        readUInt32LE(offset) {
            return $Te(this.buffer, offset);
        }
        writeUInt32LE(value, offset) {
            $Ue(this.buffer, value, offset);
        }
        readUInt8(offset) {
            return $Ve(this.buffer, offset);
        }
        writeUInt8(value, offset) {
            $We(this.buffer, value, offset);
        }
        indexOf(subarray, offset = 0) {
            return $Oe(this.buffer, subarray instanceof $Ne ? subarray.buffer : subarray, offset);
        }
    }
    exports.$Ne = $Ne;
    /**
     * Like String.indexOf, but works on Uint8Arrays.
     * Uses the boyer-moore-horspool algorithm to be reasonably speedy.
     */
    function $Oe(haystack, needle, offset = 0) {
        const needleLen = needle.byteLength;
        const haystackLen = haystack.byteLength;
        if (needleLen === 0) {
            return 0;
        }
        if (needleLen === 1) {
            return haystack.indexOf(needle[0]);
        }
        if (needleLen > haystackLen - offset) {
            return -1;
        }
        // find index of the subarray using boyer-moore-horspool algorithm
        const table = indexOfTable.value;
        table.fill(needle.length);
        for (let i = 0; i < needle.length; i++) {
            table[needle[i]] = needle.length - i - 1;
        }
        let i = offset + needle.length - 1;
        let j = i;
        let result = -1;
        while (i < haystackLen) {
            if (haystack[i] === needle[j]) {
                if (j === 0) {
                    result = i;
                    break;
                }
                i--;
                j--;
            }
            else {
                i += Math.max(needle.length - j, table[haystack[i]]);
                j = needle.length - 1;
            }
        }
        return result;
    }
    function $Pe(source, offset) {
        return (((source[offset + 0] << 0) >>> 0) |
            ((source[offset + 1] << 8) >>> 0));
    }
    function $Qe(destination, value, offset) {
        destination[offset + 0] = (value & 0b11111111);
        value = value >>> 8;
        destination[offset + 1] = (value & 0b11111111);
    }
    function $Re(source, offset) {
        return (source[offset] * 2 ** 24
            + source[offset + 1] * 2 ** 16
            + source[offset + 2] * 2 ** 8
            + source[offset + 3]);
    }
    function $Se(destination, value, offset) {
        destination[offset + 3] = value;
        value = value >>> 8;
        destination[offset + 2] = value;
        value = value >>> 8;
        destination[offset + 1] = value;
        value = value >>> 8;
        destination[offset] = value;
    }
    function $Te(source, offset) {
        return (((source[offset + 0] << 0) >>> 0) |
            ((source[offset + 1] << 8) >>> 0) |
            ((source[offset + 2] << 16) >>> 0) |
            ((source[offset + 3] << 24) >>> 0));
    }
    function $Ue(destination, value, offset) {
        destination[offset + 0] = (value & 0b11111111);
        value = value >>> 8;
        destination[offset + 1] = (value & 0b11111111);
        value = value >>> 8;
        destination[offset + 2] = (value & 0b11111111);
        value = value >>> 8;
        destination[offset + 3] = (value & 0b11111111);
    }
    function $Ve(source, offset) {
        return source[offset];
    }
    function $We(destination, value, offset) {
        destination[offset] = value;
    }
    function $Xe(readable) {
        return streams.$Ce(readable, chunks => $Ne.concat(chunks));
    }
    function $Ye(buffer) {
        return streams.$Je(buffer);
    }
    function $Ze(stream) {
        return streams.$Ee(stream, chunks => $Ne.concat(chunks));
    }
    async function $1e(bufferedStream) {
        if (bufferedStream.ended) {
            return $Ne.concat(bufferedStream.buffer);
        }
        return $Ne.concat([
            // Include already read chunks...
            ...bufferedStream.buffer,
            // ...and all additional chunks
            await $Ze(bufferedStream.stream)
        ]);
    }
    function $2e(buffer) {
        return streams.$He(buffer, chunks => $Ne.concat(chunks));
    }
    function $3e(stream) {
        return streams.$Ke(stream, { data: data => typeof data === 'string' ? $Ne.fromString(data) : $Ne.wrap(data) }, chunks => $Ne.concat(chunks));
    }
    function $4e(options) {
        return streams.$Be(chunks => $Ne.concat(chunks), options);
    }
    function $5e(prefix, readable) {
        return streams.$Le(prefix, readable, chunks => $Ne.concat(chunks));
    }
    function $6e(prefix, stream) {
        return streams.$Me(prefix, stream, chunks => $Ne.concat(chunks));
    }
    /** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */
    function $7e(encoded) {
        let building = 0;
        let remainder = 0;
        let bufi = 0;
        // The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,
        // but that's about 10-20x slower than this function in current Chromium versions.
        const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));
        const append = (value) => {
            switch (remainder) {
                case 3:
                    buffer[bufi++] = building | value;
                    remainder = 0;
                    break;
                case 2:
                    buffer[bufi++] = building | (value >>> 2);
                    building = value << 6;
                    remainder = 3;
                    break;
                case 1:
                    buffer[bufi++] = building | (value >>> 4);
                    building = value << 4;
                    remainder = 2;
                    break;
                default:
                    building = value << 2;
                    remainder = 1;
            }
        };
        for (let i = 0; i < encoded.length; i++) {
            const code = encoded.charCodeAt(i);
            // See https://datatracker.ietf.org/doc/html/rfc4648#section-4
            // This branchy code is about 3x faster than an indexOf on a base64 char string.
            if (code >= 65 && code <= 90) {
                append(code - 65); // A-Z starts ranges from char code 65 to 90
            }
            else if (code >= 97 && code <= 122) {
                append(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26
            }
            else if (code >= 48 && code <= 57) {
                append(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52
            }
            else if (code === 43 || code === 45) {
                append(62); // "+" or "-" for URLS
            }
            else if (code === 47 || code === 95) {
                append(63); // "/" or "_" for URLS
            }
            else if (code === 61) {
                break; // "="
            }
            else {
                throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);
            }
        }
        const unpadded = bufi;
        while (remainder > 0) {
            append(0);
        }
        // slice is needed to account for overestimation due to padding
        return $Ne.wrap(buffer).slice(0, unpadded);
    }
    const base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    /** Encodes a buffer to a base64 string. */
    function $8e({ buffer }, padded = true, urlSafe = false) {
        const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;
        let output = '';
        const remainder = buffer.byteLength % 3;
        let i = 0;
        for (; i < buffer.byteLength - remainder; i += 3) {
            const a = buffer[i + 0];
            const b = buffer[i + 1];
            const c = buffer[i + 2];
            output += dictionary[a >>> 2];
            output += dictionary[(a << 4 | b >>> 4) & 0b111111];
            output += dictionary[(b << 2 | c >>> 6) & 0b111111];
            output += dictionary[c & 0b111111];
        }
        if (remainder === 1) {
            const a = buffer[i + 0];
            output += dictionary[a >>> 2];
            output += dictionary[(a << 4) & 0b111111];
            if (padded) {
                output += '==';
            }
        }
        else if (remainder === 2) {
            const a = buffer[i + 0];
            const b = buffer[i + 1];
            output += dictionary[a >>> 2];
            output += dictionary[(a << 4 | b >>> 4) & 0b111111];
            output += dictionary[(b << 2) & 0b111111];
            if (padded) {
                output += '=';
            }
        }
        return output;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[148/*vs/base/common/symbols*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ge = void 0;
    /**
     * Can be passed into the Delayed to defer using a microtask
     * */
    exports.$ge = Symbol('MicrotaskDelay');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[34/*vs/base/common/themables*/], __M([1/*require*/,0/*exports*/,97/*vs/base/common/codicons*/]), function (require, exports, codicons_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ThemeIcon = exports.ThemeColor = void 0;
    exports.$6j = $6j;
    var ThemeColor;
    (function (ThemeColor) {
        function isThemeColor(obj) {
            return obj && typeof obj === 'object' && typeof obj.id === 'string';
        }
        ThemeColor.isThemeColor = isThemeColor;
    })(ThemeColor || (exports.ThemeColor = ThemeColor = {}));
    function $6j(id) {
        return { id };
    }
    var ThemeIcon;
    (function (ThemeIcon) {
        ThemeIcon.iconNameSegment = '[A-Za-z0-9]+';
        ThemeIcon.iconNameExpression = '[A-Za-z0-9-]+';
        ThemeIcon.iconModifierExpression = '~[A-Za-z]+';
        ThemeIcon.iconNameCharacter = '[A-Za-z0-9~-]';
        const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon.iconNameExpression})(${ThemeIcon.iconModifierExpression})?$`);
        function asClassNameArray(icon) {
            const match = ThemeIconIdRegex.exec(icon.id);
            if (!match) {
                return asClassNameArray(codicons_1.$5j.error);
            }
            const [, id, modifier] = match;
            const classNames = ['codicon', 'codicon-' + id];
            if (modifier) {
                classNames.push('codicon-modifier-' + modifier.substring(1));
            }
            return classNames;
        }
        ThemeIcon.asClassNameArray = asClassNameArray;
        function asClassName(icon) {
            return asClassNameArray(icon).join(' ');
        }
        ThemeIcon.asClassName = asClassName;
        function asCSSSelector(icon) {
            return '.' + asClassNameArray(icon).join('.');
        }
        ThemeIcon.asCSSSelector = asCSSSelector;
        function isThemeIcon(obj) {
            return obj && typeof obj === 'object' && typeof obj.id === 'string' && (typeof obj.color === 'undefined' || ThemeColor.isThemeColor(obj.color));
        }
        ThemeIcon.isThemeIcon = isThemeIcon;
        const _regexFromString = new RegExp(`^\\$\\((${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?)\\)$`);
        function fromString(str) {
            const match = _regexFromString.exec(str);
            if (!match) {
                return undefined;
            }
            const [, name] = match;
            return { id: name };
        }
        ThemeIcon.fromString = fromString;
        function fromId(id) {
            return { id };
        }
        ThemeIcon.fromId = fromId;
        function modify(icon, modifier) {
            let id = icon.id;
            const tildeIndex = id.lastIndexOf('~');
            if (tildeIndex !== -1) {
                id = id.substring(0, tildeIndex);
            }
            if (modifier) {
                id = `${id}~${modifier}`;
            }
            return { id };
        }
        ThemeIcon.modify = modify;
        function getModifier(icon) {
            const tildeIndex = icon.id.lastIndexOf('~');
            if (tildeIndex !== -1) {
                return icon.id.substring(tildeIndex + 1);
            }
            return undefined;
        }
        ThemeIcon.getModifier = getModifier;
        function isEqual(ti1, ti2) {
            return ti1.id === ti2.id && ti1.color?.id === ti2.color?.id;
        }
        ThemeIcon.isEqual = isEqual;
    })(ThemeIcon || (exports.ThemeIcon = ThemeIcon = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[51/*vs/base/common/extpath*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,19/*vs/base/common/path*/,20/*vs/base/common/platform*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/]), function (require, exports, charCode_1, path_1, platform_1, strings_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$xg = $xg;
    exports.$yg = $yg;
    exports.$zg = $zg;
    exports.$Ag = $Ag;
    exports.$Bg = $Bg;
    exports.$Cg = $Cg;
    exports.$Dg = $Dg;
    exports.$Eg = $Eg;
    exports.$Fg = $Fg;
    exports.$Gg = $Gg;
    exports.$Hg = $Hg;
    exports.$Ig = $Ig;
    exports.$Jg = $Jg;
    exports.$Kg = $Kg;
    exports.$Lg = $Lg;
    exports.$Mg = $Mg;
    exports.$Ng = $Ng;
    function $xg(code) {
        return code === charCode_1.CharCode.Slash || code === charCode_1.CharCode.Backslash;
    }
    /**
     * Takes a Windows OS path and changes backward slashes to forward slashes.
     * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).
     * Using it on a Linux or MaxOS path might change it.
     */
    function $yg(osPath) {
        return osPath.replace(/[\\/]/g, path_1.$gc.sep);
    }
    /**
     * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:
     * - turns backward slashes into forward slashes
     * - makes it absolute if it starts with a drive letter
     * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).
     * Using it on a Linux or MaxOS path might change it.
     */
    function $zg(osPath) {
        if (osPath.indexOf('/') === -1) {
            osPath = $yg(osPath);
        }
        if (/^[a-zA-Z]:(\/|$)/.test(osPath)) { // starts with a drive letter
            osPath = '/' + osPath;
        }
        return osPath;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function $Ag(path, sep = path_1.$gc.sep) {
        if (!path) {
            return '';
        }
        const len = path.length;
        const firstLetter = path.charCodeAt(0);
        if ($xg(firstLetter)) {
            if ($xg(path.charCodeAt(1))) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                if (!$xg(path.charCodeAt(2))) {
                    let pos = 3;
                    const start = pos;
                    for (; pos < len; pos++) {
                        if ($xg(path.charCodeAt(pos))) {
                            break;
                        }
                    }
                    if (start !== pos && !$xg(path.charCodeAt(pos + 1))) {
                        pos += 1;
                        for (; pos < len; pos++) {
                            if ($xg(path.charCodeAt(pos))) {
                                return path.slice(0, pos + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ($Fg(firstLetter)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === charCode_1.CharCode.Colon) {
                if ($xg(path.charCodeAt(2))) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        let pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                if ($xg(path.charCodeAt(pos))) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function $Bg(path) {
        if (!platform_1.$j) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        let code = path.charCodeAt(0);
        if (code !== charCode_1.CharCode.Backslash) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== charCode_1.CharCode.Backslash) {
            return false;
        }
        let pos = 2;
        const start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === charCode_1.CharCode.Backslash) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === charCode_1.CharCode.Backslash) {
            return false;
        }
        return true;
    }
    // Reference: https://en.wikipedia.org/wiki/Filename
    const WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
    const UNIX_INVALID_FILE_CHARS = /[/]/g;
    const WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
    function $Cg(name, isWindowsOS = platform_1.$j) {
        const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        invalidFileChars.lastIndex = 0; // the holy grail of software development
        if (invalidFileChars.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (isWindowsOS && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (isWindowsOS && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        if (name.length > 255) {
            return false; // most file systems do not allow files > 255 length
        }
        return true;
    }
    /**
     * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are
     * in a context without services, consider to pass down the `extUri` from the outside
     * or use `extUriBiasedIgnorePathCase` if you know what you are doing.
     */
    function $Dg(pathA, pathB, ignoreCase) {
        const identityEquals = (pathA === pathB);
        if (!ignoreCase || identityEquals) {
            return identityEquals;
        }
        if (!pathA || !pathB) {
            return false;
        }
        return (0, strings_1.$Ff)(pathA, pathB);
    }
    /**
     * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If
     * you are in a context without services, consider to pass down the `extUri` from the
     * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.
     */
    function $Eg(base, parentCandidate, ignoreCase, separator = path_1.sep) {
        if (base === parentCandidate) {
            return true;
        }
        if (!base || !parentCandidate) {
            return false;
        }
        if (parentCandidate.length > base.length) {
            return false;
        }
        if (ignoreCase) {
            const beginsWith = (0, strings_1.$Gf)(base, parentCandidate);
            if (!beginsWith) {
                return false;
            }
            if (parentCandidate.length === base.length) {
                return true; // same path, different casing
            }
            let sepOffset = parentCandidate.length;
            if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {
                sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
            }
            return base.charAt(sepOffset) === separator;
        }
        if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {
            parentCandidate += separator;
        }
        return base.indexOf(parentCandidate) === 0;
    }
    function $Fg(char0) {
        return char0 >= charCode_1.CharCode.A && char0 <= charCode_1.CharCode.Z || char0 >= charCode_1.CharCode.a && char0 <= charCode_1.CharCode.z;
    }
    function $Gg(candidate, cwd) {
        // Special case: allow to open a drive letter without trailing backslash
        if (platform_1.$j && candidate.endsWith(':')) {
            candidate += path_1.sep;
        }
        // Ensure absolute
        if (!(0, path_1.$ic)(candidate)) {
            candidate = (0, path_1.$jc)(cwd, candidate);
        }
        // Ensure normalized
        candidate = (0, path_1.$hc)(candidate);
        // Ensure no trailing slash/backslash
        return $Hg(candidate);
    }
    function $Hg(candidate) {
        if (platform_1.$j) {
            candidate = (0, strings_1.$nf)(candidate, path_1.sep);
            // Special case: allow to open drive root ('C:\')
            if (candidate.endsWith(':')) {
                candidate += path_1.sep;
            }
        }
        else {
            candidate = (0, strings_1.$nf)(candidate, path_1.sep);
            // Special case: allow to open root ('/')
            if (!candidate) {
                candidate = path_1.sep;
            }
        }
        return candidate;
    }
    function $Ig(path) {
        const pathNormalized = (0, path_1.$hc)(path);
        if (platform_1.$j) {
            if (path.length > 3) {
                return false;
            }
            return $Jg(pathNormalized) &&
                (path.length === 2 || pathNormalized.charCodeAt(2) === charCode_1.CharCode.Backslash);
        }
        return pathNormalized === path_1.$gc.sep;
    }
    function $Jg(path, isWindowsOS = platform_1.$j) {
        if (isWindowsOS) {
            return $Fg(path.charCodeAt(0)) && path.charCodeAt(1) === charCode_1.CharCode.Colon;
        }
        return false;
    }
    function $Kg(path, isWindowsOS = platform_1.$j) {
        return $Jg(path, isWindowsOS) ? path[0] : undefined;
    }
    function $Lg(path, candidate, ignoreCase) {
        if (candidate.length > path.length) {
            return -1;
        }
        if (path === candidate) {
            return 0;
        }
        if (ignoreCase) {
            path = path.toLowerCase();
            candidate = candidate.toLowerCase();
        }
        return path.indexOf(candidate);
    }
    function $Mg(rawPath) {
        const segments = rawPath.split(':'); // C:\file.txt:<line>:<column>
        let path = undefined;
        let line = undefined;
        let column = undefined;
        for (const segment of segments) {
            const segmentAsNumber = Number(segment);
            if (!(0, types_1.$ig)(segmentAsNumber)) {
                path = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\...)
            }
            else if (line === undefined) {
                line = segmentAsNumber;
            }
            else if (column === undefined) {
                column = segmentAsNumber;
            }
        }
        if (!path) {
            throw new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');
        }
        return {
            path,
            line: line !== undefined ? line : undefined,
            column: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set
        };
    }
    const pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';
    function $Ng(parent, prefix, randomLength = 8) {
        let suffix = '';
        for (let i = 0; i < randomLength; i++) {
            let pathCharsTouse;
            if (i === 0 && platform_1.$j && !prefix && (randomLength === 3 || randomLength === 4)) {
                // Windows has certain reserved file names that cannot be used, such
                // as AUX, CON, PRN, etc. We want to avoid generating a random name
                // that matches that pattern, so we use a different set of characters
                // for the first character of the name that does not include any of
                // the reserved names first characters.
                pathCharsTouse = windowsSafePathFirstChars;
            }
            else {
                pathCharsTouse = pathChars;
            }
            suffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));
        }
        let randomFileName;
        if (prefix) {
            randomFileName = `${prefix}-${suffix}`;
        }
        else {
            randomFileName = suffix;
        }
        if (parent) {
            return (0, path_1.$jc)(parent, randomFileName);
        }
        return randomFileName;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[149/*vs/base/common/filters*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,28/*vs/base/common/map*/,139/*vs/base/common/naturalLanguage/korean*/,12/*vs/base/common/strings*/]), function (require, exports, charCode_1, map_1, korean_1, strings) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Tk = exports.FuzzyScore = exports.$Ik = exports.$Hk = void 0;
    exports.or = or;
    exports.$Jk = $Jk;
    exports.$Kk = $Kk;
    exports.$Lk = $Lk;
    exports.$Mk = $Mk;
    exports.$Nk = $Nk;
    exports.$Ok = $Ok;
    exports.$Pk = $Pk;
    exports.$Qk = $Qk;
    exports.$Rk = $Rk;
    exports.$Sk = $Sk;
    exports.$Uk = $Uk;
    exports.$Vk = $Vk;
    exports.$Wk = $Wk;
    strings = __importStar(strings);
    // Combined filters
    /**
     * @returns A filter which combines the provided set
     * of filters with an or. The *first* filters that
     * matches defined the return value of the returned
     * filter.
     */
    function or(...filter) {
        return function (word, wordToMatchAgainst) {
            for (let i = 0, len = filter.length; i < len; i++) {
                const match = filter[i](word, wordToMatchAgainst);
                if (match) {
                    return match;
                }
            }
            return null;
        };
    }
    // Prefix
    exports.$Hk = _matchesPrefix.bind(undefined, false);
    exports.$Ik = _matchesPrefix.bind(undefined, true);
    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
        if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
            return null;
        }
        let matches;
        if (ignoreCase) {
            matches = strings.$Gf(wordToMatchAgainst, word);
        }
        else {
            matches = wordToMatchAgainst.indexOf(word) === 0;
        }
        if (!matches) {
            return null;
        }
        return word.length > 0 ? [{ start: 0, end: word.length }] : [];
    }
    // Contiguous Substring
    function $Jk(word, wordToMatchAgainst) {
        const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
        if (index === -1) {
            return null;
        }
        return [{ start: index, end: index + word.length }];
    }
    // Substring
    function $Kk(word, wordToMatchAgainst) {
        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
    }
    function _matchesSubString(word, wordToMatchAgainst, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === wordToMatchAgainst.length) {
            return null;
        }
        else {
            if (word[i] === wordToMatchAgainst[j]) {
                let result = null;
                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                    return join({ start: j, end: j + 1 }, result);
                }
                return null;
            }
            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
        }
    }
    // CamelCase
    function isLower(code) {
        return charCode_1.CharCode.a <= code && code <= charCode_1.CharCode.z;
    }
    function $Lk(code) {
        return charCode_1.CharCode.A <= code && code <= charCode_1.CharCode.Z;
    }
    function isNumber(code) {
        return charCode_1.CharCode.Digit0 <= code && code <= charCode_1.CharCode.Digit9;
    }
    function isWhitespace(code) {
        return (code === charCode_1.CharCode.Space
            || code === charCode_1.CharCode.Tab
            || code === charCode_1.CharCode.LineFeed
            || code === charCode_1.CharCode.CarriageReturn);
    }
    const wordSeparators = new Set();
    // These are chosen as natural word separators based on writen text.
    // It is a subset of the word separators used by the monaco editor.
    '()[]{}<>`\'"-/;:,.?!'
        .split('')
        .forEach(s => wordSeparators.add(s.charCodeAt(0)));
    function isWordSeparator(code) {
        return isWhitespace(code) || wordSeparators.has(code);
    }
    function charactersMatch(codeA, codeB) {
        return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));
    }
    const alternateCharsCache = new Map();
    /**
     * Gets alternative codes to the character code passed in. This comes in the
     * form of an array of character codes, all of which must match _in order_ to
     * successfully match.
     *
     * @param code The character code to check.
     */
    function getAlternateCodes(code) {
        if (alternateCharsCache.has(code)) {
            return alternateCharsCache.get(code);
        }
        // NOTE: This function is written in such a way that it can be extended in
        // the future, but right now the return type takes into account it's only
        // supported by a single "alt codes provider".
        // `ArrayLike<ArrayLike<number>>` is a more appropriate type if changed.
        let result;
        const codes = (0, korean_1.$Fk)(code);
        if (codes) {
            result = codes;
        }
        alternateCharsCache.set(code, result);
        return result;
    }
    function isAlphanumeric(code) {
        return isLower(code) || $Lk(code) || isNumber(code);
    }
    function join(head, tail) {
        if (tail.length === 0) {
            tail = [head];
        }
        else if (head.end === tail[0].start) {
            tail[0].start = head.start;
        }
        else {
            tail.unshift(head);
        }
        return tail;
    }
    function nextAnchor(camelCaseWord, start) {
        for (let i = start; i < camelCaseWord.length; i++) {
            const c = camelCaseWord.charCodeAt(i);
            if ($Lk(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return camelCaseWord.length;
    }
    function _matchesCamelCase(word, camelCaseWord, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === camelCaseWord.length) {
            return null;
        }
        else if (word[i] !== camelCaseWord[j].toLowerCase()) {
            return null;
        }
        else {
            let result = null;
            let nextUpperIndex = j + 1;
            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
                nextUpperIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camelCaseWords.
    function analyzeCamelCaseWord(word) {
        let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
        for (let i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if ($Lk(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isAlphanumeric(code)) {
                alpha++;
            }
            if (isNumber(code)) {
                numeric++;
            }
        }
        const upperPercent = upper / word.length;
        const lowerPercent = lower / word.length;
        const alphaPercent = alpha / word.length;
        const numericPercent = numeric / word.length;
        return { upperPercent, lowerPercent, alphaPercent, numericPercent };
    }
    function isUpperCaseWord(analysis) {
        const { upperPercent, lowerPercent } = analysis;
        return lowerPercent === 0 && upperPercent > 0.6;
    }
    function isCamelCaseWord(analysis) {
        const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;
        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camel case patterns.
    function isCamelCasePattern(word) {
        let upper = 0, lower = 0, code = 0, whitespace = 0;
        for (let i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if ($Lk(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isWhitespace(code)) {
                whitespace++;
            }
        }
        if ((upper === 0 || lower === 0) && whitespace === 0) {
            return word.length <= 30;
        }
        else {
            return upper <= 5;
        }
    }
    function $Mk(word, camelCaseWord) {
        if (!camelCaseWord) {
            return null;
        }
        camelCaseWord = camelCaseWord.trim();
        if (camelCaseWord.length === 0) {
            return null;
        }
        if (!isCamelCasePattern(word)) {
            return null;
        }
        // TODO: Consider removing this check
        if (camelCaseWord.length > 60) {
            camelCaseWord = camelCaseWord.substring(0, 60);
        }
        const analysis = analyzeCamelCaseWord(camelCaseWord);
        if (!isCamelCaseWord(analysis)) {
            if (!isUpperCaseWord(analysis)) {
                return null;
            }
            camelCaseWord = camelCaseWord.toLowerCase();
        }
        let result = null;
        let i = 0;
        word = word.toLowerCase();
        while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
            i = nextAnchor(camelCaseWord, i + 1);
        }
        return result;
    }
    // Matches beginning of words supporting non-ASCII languages
    // If `contiguous` is true then matches word with beginnings of the words in the target. E.g. "pul" will match "Git: Pull"
    // Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. "gp" or "g p" will match "Git: Pull"
    // Useful in cases where the target is words (e.g. command labels)
    function $Nk(word, target, contiguous = false) {
        if (!target || target.length === 0) {
            return null;
        }
        let result = null;
        let targetIndex = 0;
        word = word.toLowerCase();
        target = target.toLowerCase();
        while (targetIndex < target.length) {
            result = _matchesWords(word, target, 0, targetIndex, contiguous);
            if (result !== null) {
                break;
            }
            targetIndex = nextWord(target, targetIndex + 1);
        }
        return result;
    }
    function _matchesWords(word, target, wordIndex, targetIndex, contiguous) {
        let targetIndexOffset = 0;
        if (wordIndex === word.length) {
            return [];
        }
        else if (targetIndex === target.length) {
            return null;
        }
        else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {
            // Verify alternate characters before exiting
            const altChars = getAlternateCodes(word.charCodeAt(wordIndex));
            if (!altChars) {
                return null;
            }
            for (let k = 0; k < altChars.length; k++) {
                if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {
                    return null;
                }
            }
            targetIndexOffset += altChars.length - 1;
        }
        let result = null;
        let nextWordIndex = targetIndex + targetIndexOffset + 1;
        result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);
        if (!contiguous) {
            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
                result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);
                nextWordIndex++;
            }
        }
        if (!result) {
            return null;
        }
        // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).
        // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.
        if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {
            // Verify alternate characters before exiting
            const altChars = getAlternateCodes(word.charCodeAt(wordIndex));
            if (!altChars) {
                return result;
            }
            for (let k = 0; k < altChars.length; k++) {
                if (altChars[k] !== target.charCodeAt(targetIndex + k)) {
                    return result;
                }
            }
        }
        return join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);
    }
    function nextWord(word, start) {
        for (let i = start; i < word.length; i++) {
            if (isWordSeparator(word.charCodeAt(i)) ||
                (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return word.length;
    }
    // Fuzzy
    const fuzzyContiguousFilter = or(exports.$Ik, $Mk, $Jk);
    const fuzzySeparateFilter = or(exports.$Ik, $Mk, $Kk);
    const fuzzyRegExpCache = new map_1.$Dc(10000); // bounded to 10000 elements
    function $Ok(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {
        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
            return null; // return early for invalid input
        }
        // Form RegExp for wildcard matches
        let regexp = fuzzyRegExpCache.get(word);
        if (!regexp) {
            regexp = new RegExp(strings.$of(word), 'i');
            fuzzyRegExpCache.set(word, regexp);
        }
        // RegExp Filter
        const match = regexp.exec(wordToMatchAgainst);
        if (match) {
            return [{ start: match.index, end: match.index + match[0].length }];
        }
        // Default Filter
        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);
    }
    /**
     * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more
     * powerful than `matchesFuzzy`
     */
    function $Pk(pattern, word) {
        const score = $Uk(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });
        return score ? $Rk(score) : null;
    }
    function $Qk(pattern, lowPattern, patternPos, word, lowWord, wordPos) {
        const max = Math.min(13, pattern.length);
        for (; patternPos < max; patternPos++) {
            const result = $Uk(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });
            if (result) {
                return result;
            }
        }
        return [0, wordPos];
    }
    //#region --- fuzzyScore ---
    function $Rk(score) {
        if (typeof score === 'undefined') {
            return [];
        }
        const res = [];
        const wordPos = score[1];
        for (let i = score.length - 1; i > 1; i--) {
            const pos = score[i] + wordPos;
            const last = res[res.length - 1];
            if (last && last.end === pos) {
                last.end = pos + 1;
            }
            else {
                res.push({ start: pos, end: pos + 1 });
            }
        }
        return res;
    }
    const _maxLen = 128;
    function initTable() {
        const table = [];
        const row = [];
        for (let i = 0; i <= _maxLen; i++) {
            row[i] = 0;
        }
        for (let i = 0; i <= _maxLen; i++) {
            table.push(row.slice(0));
        }
        return table;
    }
    function initArr(maxLen) {
        const row = [];
        for (let i = 0; i <= maxLen; i++) {
            row[i] = 0;
        }
        return row;
    }
    const _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position
    const _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position
    const _diag = initTable(); // the length of a contiguous diagonal match
    const _table = initTable();
    const _arrows = initTable();
    const _debug = false;
    function printTable(table, pattern, patternLen, word, wordLen) {
        function pad(s, n, pad = ' ') {
            while (s.length < n) {
                s = pad + s;
            }
            return s;
        }
        let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\n`;
        for (let i = 0; i <= patternLen; i++) {
            if (i === 0) {
                ret += ' |';
            }
            else {
                ret += `${pattern[i - 1]}|`;
            }
            ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\n';
        }
        return ret;
    }
    function printTables(pattern, patternStart, word, wordStart) {
        pattern = pattern.substr(patternStart);
        word = word.substr(wordStart);
        console.log(printTable(_table, pattern, pattern.length, word, word.length));
        console.log(printTable(_arrows, pattern, pattern.length, word, word.length));
        console.log(printTable(_diag, pattern, pattern.length, word, word.length));
    }
    function isSeparatorAtPos(value, index) {
        if (index < 0 || index >= value.length) {
            return false;
        }
        const code = value.codePointAt(index);
        switch (code) {
            case charCode_1.CharCode.Underline:
            case charCode_1.CharCode.Dash:
            case charCode_1.CharCode.Period:
            case charCode_1.CharCode.Space:
            case charCode_1.CharCode.Slash:
            case charCode_1.CharCode.Backslash:
            case charCode_1.CharCode.SingleQuote:
            case charCode_1.CharCode.DoubleQuote:
            case charCode_1.CharCode.Colon:
            case charCode_1.CharCode.DollarSign:
            case charCode_1.CharCode.LessThan:
            case charCode_1.CharCode.GreaterThan:
            case charCode_1.CharCode.OpenParen:
            case charCode_1.CharCode.CloseParen:
            case charCode_1.CharCode.OpenSquareBracket:
            case charCode_1.CharCode.CloseSquareBracket:
            case charCode_1.CharCode.OpenCurlyBrace:
            case charCode_1.CharCode.CloseCurlyBrace:
                return true;
            case undefined:
                return false;
            default:
                if (strings.$Yf(code)) {
                    return true;
                }
                return false;
        }
    }
    function isWhitespaceAtPos(value, index) {
        if (index < 0 || index >= value.length) {
            return false;
        }
        const code = value.charCodeAt(index);
        switch (code) {
            case charCode_1.CharCode.Space:
            case charCode_1.CharCode.Tab:
                return true;
            default:
                return false;
        }
    }
    function isUpperCaseAtPos(pos, word, wordLow) {
        return word[pos] !== wordLow[pos];
    }
    function $Sk(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {
        while (patternPos < patternLen && wordPos < wordLen) {
            if (patternLow[patternPos] === wordLow[wordPos]) {
                if (fillMinWordPosArr) {
                    // Remember the min word position for each pattern position
                    _minWordMatchPos[patternPos] = wordPos;
                }
                patternPos += 1;
            }
            wordPos += 1;
        }
        return patternPos === patternLen; // pattern must be exhausted
    }
    var Arrow;
    (function (Arrow) {
        Arrow[Arrow["Diag"] = 1] = "Diag";
        Arrow[Arrow["Left"] = 2] = "Left";
        Arrow[Arrow["LeftLeft"] = 3] = "LeftLeft";
    })(Arrow || (Arrow = {}));
    var FuzzyScore;
    (function (FuzzyScore) {
        /**
         * No matches and value `-100`
         */
        FuzzyScore.Default = ([-100, 0]);
        function isDefault(score) {
            return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);
        }
        FuzzyScore.isDefault = isDefault;
    })(FuzzyScore || (exports.FuzzyScore = FuzzyScore = {}));
    class $Tk {
        static { this.default = { boostFullMatch: true, firstMatchCanBeWeak: false }; }
        constructor(firstMatchCanBeWeak, boostFullMatch) {
            this.firstMatchCanBeWeak = firstMatchCanBeWeak;
            this.boostFullMatch = boostFullMatch;
        }
    }
    exports.$Tk = $Tk;
    function $Uk(pattern, patternLow, patternStart, word, wordLow, wordStart, options = $Tk.default) {
        const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
        const wordLen = word.length > _maxLen ? _maxLen : word.length;
        if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {
            return undefined;
        }
        // Run a simple check if the characters of pattern occur
        // (in order) at all in word. If that isn't the case we
        // stop because no match will be possible
        if (!$Sk(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {
            return undefined;
        }
        // Find the max matching word position for each pattern position
        // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call
        _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);
        let row = 1;
        let column = 1;
        let patternPos = patternStart;
        let wordPos = wordStart;
        const hasStrongFirstMatch = [false];
        // There will be a match, fill in tables
        for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
            // Reduce search space to possible matching word positions and to possible access from next row
            const minWordMatchPos = _minWordMatchPos[patternPos];
            const maxWordMatchPos = _maxWordMatchPos[patternPos];
            const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);
            for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {
                let score = Number.MIN_SAFE_INTEGER;
                let canComeDiag = false;
                if (wordPos <= maxWordMatchPos) {
                    score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);
                }
                let diagScore = 0;
                if (score !== Number.MAX_SAFE_INTEGER) {
                    canComeDiag = true;
                    diagScore = score + _table[row - 1][column - 1];
                }
                const canComeLeft = wordPos > minWordMatchPos;
                const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start
                const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;
                const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start
                if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {
                    // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word
                    _table[row][column] = leftLeftScore;
                    _arrows[row][column] = Arrow.LeftLeft;
                    _diag[row][column] = 0;
                }
                else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {
                    // always prefer choosing left since that means a match is earlier in the word
                    _table[row][column] = leftScore;
                    _arrows[row][column] = Arrow.Left;
                    _diag[row][column] = 0;
                }
                else if (canComeDiag) {
                    _table[row][column] = diagScore;
                    _arrows[row][column] = Arrow.Diag;
                    _diag[row][column] = _diag[row - 1][column - 1] + 1;
                }
                else {
                    throw new Error(`not possible`);
                }
            }
        }
        if (_debug) {
            printTables(pattern, patternStart, word, wordStart);
        }
        if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {
            return undefined;
        }
        row--;
        column--;
        const result = [_table[row][column], wordStart];
        let backwardsDiagLength = 0;
        let maxMatchColumn = 0;
        while (row >= 1) {
            // Find the column where we go diagonally up
            let diagColumn = column;
            do {
                const arrow = _arrows[row][diagColumn];
                if (arrow === Arrow.LeftLeft) {
                    diagColumn = diagColumn - 2;
                }
                else if (arrow === Arrow.Left) {
                    diagColumn = diagColumn - 1;
                }
                else {
                    // found the diagonal
                    break;
                }
            } while (diagColumn >= 1);
            // Overturn the "forwards" decision if keeping the "backwards" diagonal would give a better match
            if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters
                && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally
                && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase
                && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the "forwards" contiguous match
            ) {
                diagColumn = column;
            }
            if (diagColumn === column) {
                // this is a contiguous match
                backwardsDiagLength++;
            }
            else {
                backwardsDiagLength = 1;
            }
            if (!maxMatchColumn) {
                // remember the last matched column
                maxMatchColumn = diagColumn;
            }
            row--;
            column = diagColumn - 1;
            result.push(column);
        }
        if (wordLen - wordStart === patternLen && options.boostFullMatch) {
            // the word matches the pattern with all characters!
            // giving the score a total match boost (to come up ahead other words)
            result[0] += 2;
        }
        // Add 1 penalty for each skipped character in the word
        const skippedCharsCount = maxMatchColumn - patternLen;
        result[0] -= skippedCharsCount;
        return result;
    }
    function _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {
        let patternPos = patternLen - 1;
        let wordPos = wordLen - 1;
        while (patternPos >= patternStart && wordPos >= wordStart) {
            if (patternLow[patternPos] === wordLow[wordPos]) {
                _maxWordMatchPos[patternPos] = wordPos;
                patternPos--;
            }
            wordPos--;
        }
    }
    function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {
        if (patternLow[patternPos] !== wordLow[wordPos]) {
            return Number.MIN_SAFE_INTEGER;
        }
        let score = 1;
        let isGapLocation = false;
        if (wordPos === (patternPos - patternStart)) {
            // common prefix: `foobar <-> foobaz`
            //                            ^^^^^
            score = pattern[patternPos] === word[wordPos] ? 7 : 5;
        }
        else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
            // hitting upper-case: `foo <-> forOthers`
            //                              ^^ ^
            score = pattern[patternPos] === word[wordPos] ? 7 : 5;
            isGapLocation = true;
        }
        else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
            // hitting a separator: `. <-> foo.bar`
            //                                ^
            score = 5;
        }
        else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
            // post separator: `foo <-> bar_foo`
            //                              ^^^
            score = 5;
            isGapLocation = true;
        }
        if (score > 1 && patternPos === patternStart) {
            outFirstMatchStrong[0] = true;
        }
        if (!isGapLocation) {
            isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);
        }
        //
        if (patternPos === patternStart) { // first character in pattern
            if (wordPos > wordStart) {
                // the first pattern character would match a word character that is not at the word start
                // so introduce a penalty to account for the gap preceding this match
                score -= isGapLocation ? 3 : 5;
            }
        }
        else {
            if (newMatchStart) {
                // this would be the beginning of a new match (i.e. there would be a gap before this location)
                score += isGapLocation ? 2 : 0;
            }
            else {
                // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location
                score += isGapLocation ? 0 : 1;
            }
        }
        if (wordPos + 1 === wordLen) {
            // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word
            // so pretend there is a gap after the last character in the word to normalize things
            score -= isGapLocation ? 3 : 5;
        }
        return score;
    }
    //#endregion
    //#region --- graceful ---
    function $Vk(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
        return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);
    }
    function $Wk(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {
        return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, options);
    }
    function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {
        let top = $Uk(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);
        if (top && !aggressive) {
            // when using the original pattern yield a result we`
            // return it unless we are aggressive and try to find
            // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.
            return top;
        }
        if (pattern.length >= 3) {
            // When the pattern is long enough then try a few (max 7)
            // permutations of the pattern to find a better match. The
            // permutations only swap neighbouring characters, e.g
            // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.
            const tries = Math.min(7, pattern.length - 1);
            for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
                const newPattern = nextTypoPermutation(pattern, movingPatternPos);
                if (newPattern) {
                    const candidate = $Uk(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);
                    if (candidate) {
                        candidate[0] -= 3; // permutation penalty
                        if (!top || candidate[0] > top[0]) {
                            top = candidate;
                        }
                    }
                }
            }
        }
        return top;
    }
    function nextTypoPermutation(pattern, patternPos) {
        if (patternPos + 1 >= pattern.length) {
            return undefined;
        }
        const swap1 = pattern[patternPos];
        const swap2 = pattern[patternPos + 1];
        if (swap1 === swap2) {
            return undefined;
        }
        return pattern.slice(0, patternPos)
            + swap2
            + swap1
            + pattern.slice(patternPos + 2);
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[98/*vs/base/common/iconLabels*/], __M([1/*require*/,0/*exports*/,149/*vs/base/common/filters*/,12/*vs/base/common/strings*/,34/*vs/base/common/themables*/]), function (require, exports, filters_1, strings_1, themables_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Xk = $Xk;
    exports.$Yk = $Yk;
    exports.$Zk = $Zk;
    exports.$1k = $1k;
    exports.$2k = $2k;
    exports.$3k = $3k;
    const iconStartMarker = '$(';
    const iconsRegex = new RegExp(`\\$\\(${themables_1.ThemeIcon.iconNameExpression}(?:${themables_1.ThemeIcon.iconModifierExpression})?\\)`, 'g'); // no capturing groups
    const escapeIconsRegex = new RegExp(`(\\\\)?${iconsRegex.source}`, 'g');
    function $Xk(text) {
        return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\${match}`);
    }
    const markdownEscapedIconsRegex = new RegExp(`\\\\${iconsRegex.source}`, 'g');
    function $Yk(text) {
        // Need to add an extra \ for escaping in markdown
        return text.replace(markdownEscapedIconsRegex, match => `\\${match}`);
    }
    const stripIconsRegex = new RegExp(`(\\s)?(\\\\)?${iconsRegex.source}(\\s)?`, 'g');
    /**
     * Takes a label with icons (`$(iconId)xyz`)  and strips the icons out (`xyz`)
     */
    function $Zk(text) {
        if (text.indexOf(iconStartMarker) === -1) {
            return text;
        }
        return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');
    }
    /**
     * Takes a label with icons (`$(iconId)xyz`), removes the icon syntax adds whitespace so that screen readers can read the text better.
     */
    function $1k(text) {
        if (!text) {
            return '';
        }
        return text.replace(/\$\((.*?)\)/g, (_match, codiconName) => ` ${codiconName} `).trim();
    }
    const _parseIconsRegex = new RegExp(`\\$\\(${themables_1.ThemeIcon.iconNameCharacter}+\\)`, 'g');
    /**
     * Takes a label with icons (`abc $(iconId)xyz`) and returns the text (`abc xyz`) and the offsets of the icons (`[3]`)
     */
    function $2k(input) {
        _parseIconsRegex.lastIndex = 0;
        let text = '';
        const iconOffsets = [];
        let iconsOffset = 0;
        while (true) {
            const pos = _parseIconsRegex.lastIndex;
            const match = _parseIconsRegex.exec(input);
            const chars = input.substring(pos, match?.index);
            if (chars.length > 0) {
                text += chars;
                for (let i = 0; i < chars.length; i++) {
                    iconOffsets.push(iconsOffset);
                }
            }
            if (!match) {
                break;
            }
            iconsOffset += match[0].length;
        }
        return { text, iconOffsets };
    }
    function $3k(query, target, enableSeparateSubstringMatching = false) {
        const { text, iconOffsets } = target;
        // Return early if there are no icon markers in the word to match against
        if (!iconOffsets || iconOffsets.length === 0) {
            return (0, filters_1.$Ok)(query, text, enableSeparateSubstringMatching);
        }
        // Trim the word to match against because it could have leading
        // whitespace now if the word started with an icon
        const wordToMatchAgainstWithoutIconsTrimmed = (0, strings_1.$mf)(text, ' ');
        const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;
        // match on value without icon
        const matches = (0, filters_1.$Ok)(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);
        // Map matches back to offsets with icon and trimming
        if (matches) {
            for (const match of matches) {
                const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;
                match.start += iconOffset;
                match.end += iconOffset;
            }
        }
        return matches;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[35/*vs/base/common/severity*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/strings*/]), function (require, exports, strings) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    strings = __importStar(strings);
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    (function (Severity) {
        const _error = 'error';
        const _warning = 'warning';
        const _warn = 'warn';
        const _info = 'info';
        const _ignore = 'ignore';
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.$Ff(_error, value)) {
                return Severity.Error;
            }
            if (strings.$Ff(_warning, value) || strings.$Ff(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.$Ff(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
        function toString(severity) {
            switch (severity) {
                case Severity.Error: return _error;
                case Severity.Warning: return _warning;
                case Severity.Info: return _info;
                default: return _ignore;
            }
        }
        Severity.toString = toString;
    })(Severity || (Severity = {}));
    exports.default = Severity;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[58/*vs/base/common/ternarySearchTree*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,27/*vs/base/common/charCode*/,12/*vs/base/common/strings*/]), function (require, exports, arrays_1, charCode_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Li = exports.$Ki = exports.$Ji = exports.$Ii = exports.$Hi = void 0;
    class $Hi {
        constructor() {
            this.b = '';
            this.c = 0;
        }
        reset(key) {
            this.b = key;
            this.c = 0;
            return this;
        }
        next() {
            this.c += 1;
            return this;
        }
        hasNext() {
            return this.c < this.b.length - 1;
        }
        cmp(a) {
            const aCode = a.charCodeAt(0);
            const thisCode = this.b.charCodeAt(this.c);
            return aCode - thisCode;
        }
        value() {
            return this.b[this.c];
        }
    }
    exports.$Hi = $Hi;
    class $Ii {
        constructor(e = true) {
            this.e = e;
        }
        reset(key) {
            this.b = key;
            this.c = 0;
            this.d = 0;
            return this.next();
        }
        hasNext() {
            return this.d < this.b.length;
        }
        next() {
            // this._data = key.split(/[\\/]/).filter(s => !!s);
            this.c = this.d;
            let justSeps = true;
            for (; this.d < this.b.length; this.d++) {
                const ch = this.b.charCodeAt(this.d);
                if (ch === charCode_1.CharCode.Period) {
                    if (justSeps) {
                        this.c++;
                    }
                    else {
                        break;
                    }
                }
                else {
                    justSeps = false;
                }
            }
            return this;
        }
        cmp(a) {
            return this.e
                ? (0, strings_1.$zf)(a, this.b, 0, a.length, this.c, this.d)
                : (0, strings_1.$Bf)(a, this.b, 0, a.length, this.c, this.d);
        }
        value() {
            return this.b.substring(this.c, this.d);
        }
    }
    exports.$Ii = $Ii;
    class $Ji {
        constructor(f = true, g = true) {
            this.f = f;
            this.g = g;
        }
        reset(key) {
            this.d = 0;
            this.e = 0;
            this.b = key;
            this.c = key.length;
            for (let pos = key.length - 1; pos >= 0; pos--, this.c--) {
                const ch = this.b.charCodeAt(pos);
                if (!(ch === charCode_1.CharCode.Slash || this.f && ch === charCode_1.CharCode.Backslash)) {
                    break;
                }
            }
            return this.next();
        }
        hasNext() {
            return this.e < this.c;
        }
        next() {
            // this._data = key.split(/[\\/]/).filter(s => !!s);
            this.d = this.e;
            let justSeps = true;
            for (; this.e < this.c; this.e++) {
                const ch = this.b.charCodeAt(this.e);
                if (ch === charCode_1.CharCode.Slash || this.f && ch === charCode_1.CharCode.Backslash) {
                    if (justSeps) {
                        this.d++;
                    }
                    else {
                        break;
                    }
                }
                else {
                    justSeps = false;
                }
            }
            return this;
        }
        cmp(a) {
            return this.g
                ? (0, strings_1.$zf)(a, this.b, 0, a.length, this.d, this.e)
                : (0, strings_1.$Bf)(a, this.b, 0, a.length, this.d, this.e);
        }
        value() {
            return this.b.substring(this.d, this.e);
        }
    }
    exports.$Ji = $Ji;
    var UriIteratorState;
    (function (UriIteratorState) {
        UriIteratorState[UriIteratorState["Scheme"] = 1] = "Scheme";
        UriIteratorState[UriIteratorState["Authority"] = 2] = "Authority";
        UriIteratorState[UriIteratorState["Path"] = 3] = "Path";
        UriIteratorState[UriIteratorState["Query"] = 4] = "Query";
        UriIteratorState[UriIteratorState["Fragment"] = 5] = "Fragment";
    })(UriIteratorState || (UriIteratorState = {}));
    class $Ki {
        constructor(f, g) {
            this.f = f;
            this.g = g;
            this.d = [];
            this.e = 0;
        }
        reset(key) {
            this.c = key;
            this.d = [];
            if (this.c.scheme) {
                this.d.push(UriIteratorState.Scheme);
            }
            if (this.c.authority) {
                this.d.push(UriIteratorState.Authority);
            }
            if (this.c.path) {
                this.b = new $Ji(false, !this.f(key));
                this.b.reset(key.path);
                if (this.b.value()) {
                    this.d.push(UriIteratorState.Path);
                }
            }
            if (!this.g(key)) {
                if (this.c.query) {
                    this.d.push(UriIteratorState.Query);
                }
                if (this.c.fragment) {
                    this.d.push(UriIteratorState.Fragment);
                }
            }
            this.e = 0;
            return this;
        }
        next() {
            if (this.d[this.e] === UriIteratorState.Path && this.b.hasNext()) {
                this.b.next();
            }
            else {
                this.e += 1;
            }
            return this;
        }
        hasNext() {
            return (this.d[this.e] === UriIteratorState.Path && this.b.hasNext())
                || this.e < this.d.length - 1;
        }
        cmp(a) {
            if (this.d[this.e] === UriIteratorState.Scheme) {
                return (0, strings_1.$Af)(a, this.c.scheme);
            }
            else if (this.d[this.e] === UriIteratorState.Authority) {
                return (0, strings_1.$Af)(a, this.c.authority);
            }
            else if (this.d[this.e] === UriIteratorState.Path) {
                return this.b.cmp(a);
            }
            else if (this.d[this.e] === UriIteratorState.Query) {
                return (0, strings_1.$yf)(a, this.c.query);
            }
            else if (this.d[this.e] === UriIteratorState.Fragment) {
                return (0, strings_1.$yf)(a, this.c.fragment);
            }
            throw new Error();
        }
        value() {
            if (this.d[this.e] === UriIteratorState.Scheme) {
                return this.c.scheme;
            }
            else if (this.d[this.e] === UriIteratorState.Authority) {
                return this.c.authority;
            }
            else if (this.d[this.e] === UriIteratorState.Path) {
                return this.b.value();
            }
            else if (this.d[this.e] === UriIteratorState.Query) {
                return this.c.query;
            }
            else if (this.d[this.e] === UriIteratorState.Fragment) {
                return this.c.fragment;
            }
            throw new Error();
        }
    }
    exports.$Ki = $Ki;
    class TernarySearchTreeNode {
        constructor() {
            this.height = 1;
        }
        isEmpty() {
            return !this.left && !this.mid && !this.right && !this.value;
        }
        rotateLeft() {
            const tmp = this.right;
            this.right = tmp.left;
            tmp.left = this;
            this.updateHeight();
            tmp.updateHeight();
            return tmp;
        }
        rotateRight() {
            const tmp = this.left;
            this.left = tmp.right;
            tmp.right = this;
            this.updateHeight();
            tmp.updateHeight();
            return tmp;
        }
        updateHeight() {
            this.height = 1 + Math.max(this.heightLeft, this.heightRight);
        }
        balanceFactor() {
            return this.heightRight - this.heightLeft;
        }
        get heightLeft() {
            return this.left?.height ?? 0;
        }
        get heightRight() {
            return this.right?.height ?? 0;
        }
    }
    var Dir;
    (function (Dir) {
        Dir[Dir["Left"] = -1] = "Left";
        Dir[Dir["Mid"] = 0] = "Mid";
        Dir[Dir["Right"] = 1] = "Right";
    })(Dir || (Dir = {}));
    class $Li {
        static forUris(ignorePathCasing = () => false, ignoreQueryAndFragment = () => false) {
            return new $Li(new $Ki(ignorePathCasing, ignoreQueryAndFragment));
        }
        static forPaths(ignorePathCasing = false) {
            return new $Li(new $Ji(undefined, !ignorePathCasing));
        }
        static forStrings() {
            return new $Li(new $Hi());
        }
        static forConfigKeys() {
            return new $Li(new $Ii());
        }
        constructor(segments) {
            this.b = segments;
        }
        clear() {
            this.c = undefined;
        }
        fill(values, keys) {
            if (keys) {
                const arr = keys.slice(0);
                (0, arrays_1.$Vb)(arr);
                for (const k of arr) {
                    this.set(k, values);
                }
            }
            else {
                const arr = values.slice(0);
                (0, arrays_1.$Vb)(arr);
                for (const entry of arr) {
                    this.set(entry[0], entry[1]);
                }
            }
        }
        set(key, element) {
            const iter = this.b.reset(key);
            let node;
            if (!this.c) {
                this.c = new TernarySearchTreeNode();
                this.c.segment = iter.value();
            }
            const stack = [];
            // find insert_node
            node = this.c;
            while (true) {
                const val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    if (!node.left) {
                        node.left = new TernarySearchTreeNode();
                        node.left.segment = iter.value();
                    }
                    stack.push([Dir.Left, node]);
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    if (!node.right) {
                        node.right = new TernarySearchTreeNode();
                        node.right.segment = iter.value();
                    }
                    stack.push([Dir.Right, node]);
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    if (!node.mid) {
                        node.mid = new TernarySearchTreeNode();
                        node.mid.segment = iter.value();
                    }
                    stack.push([Dir.Mid, node]);
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            // set value
            const oldElement = node.value;
            node.value = element;
            node.key = key;
            // balance
            for (let i = stack.length - 1; i >= 0; i--) {
                const node = stack[i][1];
                node.updateHeight();
                const bf = node.balanceFactor();
                if (bf < -1 || bf > 1) {
                    // needs rotate
                    const d1 = stack[i][0];
                    const d2 = stack[i + 1][0];
                    if (d1 === Dir.Right && d2 === Dir.Right) {
                        //right, right -> rotate left
                        stack[i][1] = node.rotateLeft();
                    }
                    else if (d1 === Dir.Left && d2 === Dir.Left) {
                        // left, left -> rotate right
                        stack[i][1] = node.rotateRight();
                    }
                    else if (d1 === Dir.Right && d2 === Dir.Left) {
                        // right, left -> double rotate right, left
                        node.right = stack[i + 1][1] = stack[i + 1][1].rotateRight();
                        stack[i][1] = node.rotateLeft();
                    }
                    else if (d1 === Dir.Left && d2 === Dir.Right) {
                        // left, right -> double rotate left, right
                        node.left = stack[i + 1][1] = stack[i + 1][1].rotateLeft();
                        stack[i][1] = node.rotateRight();
                    }
                    else {
                        throw new Error();
                    }
                    // patch path to parent
                    if (i > 0) {
                        switch (stack[i - 1][0]) {
                            case Dir.Left:
                                stack[i - 1][1].left = stack[i][1];
                                break;
                            case Dir.Right:
                                stack[i - 1][1].right = stack[i][1];
                                break;
                            case Dir.Mid:
                                stack[i - 1][1].mid = stack[i][1];
                                break;
                        }
                    }
                    else {
                        this.c = stack[0][1];
                    }
                }
            }
            return oldElement;
        }
        get(key) {
            return this.d(key)?.value;
        }
        d(key) {
            const iter = this.b.reset(key);
            let node = this.c;
            while (node) {
                const val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node;
        }
        has(key) {
            const node = this.d(key);
            return !(node?.value === undefined && node?.mid === undefined);
        }
        delete(key) {
            return this.e(key, false);
        }
        deleteSuperstr(key) {
            return this.e(key, true);
        }
        e(key, superStr) {
            const iter = this.b.reset(key);
            const stack = [];
            let node = this.c;
            // find node
            while (node) {
                const val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    stack.push([Dir.Left, node]);
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    stack.push([Dir.Right, node]);
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    stack.push([Dir.Mid, node]);
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            if (!node) {
                // node not found
                return;
            }
            if (superStr) {
                // removing children, reset height
                node.left = undefined;
                node.mid = undefined;
                node.right = undefined;
                node.height = 1;
            }
            else {
                // removing element
                node.key = undefined;
                node.value = undefined;
            }
            // BST node removal
            if (!node.mid && !node.value) {
                if (node.left && node.right) {
                    // full node
                    // replace deleted-node with the min-node of the right branch.
                    // If there is no true min-node leave things as they are
                    const min = this.f(node.right);
                    if (min.key) {
                        const { key, value, segment } = min;
                        this.e(min.key, false);
                        node.key = key;
                        node.value = value;
                        node.segment = segment;
                    }
                }
                else {
                    // empty or half empty
                    const newChild = node.left ?? node.right;
                    if (stack.length > 0) {
                        const [dir, parent] = stack[stack.length - 1];
                        switch (dir) {
                            case Dir.Left:
                                parent.left = newChild;
                                break;
                            case Dir.Mid:
                                parent.mid = newChild;
                                break;
                            case Dir.Right:
                                parent.right = newChild;
                                break;
                        }
                    }
                    else {
                        this.c = newChild;
                    }
                }
            }
            // AVL balance
            for (let i = stack.length - 1; i >= 0; i--) {
                const node = stack[i][1];
                node.updateHeight();
                const bf = node.balanceFactor();
                if (bf > 1) {
                    // right heavy
                    if (node.right.balanceFactor() >= 0) {
                        // right, right -> rotate left
                        stack[i][1] = node.rotateLeft();
                    }
                    else {
                        // right, left -> double rotate
                        node.right = node.right.rotateRight();
                        stack[i][1] = node.rotateLeft();
                    }
                }
                else if (bf < -1) {
                    // left heavy
                    if (node.left.balanceFactor() <= 0) {
                        // left, left -> rotate right
                        stack[i][1] = node.rotateRight();
                    }
                    else {
                        // left, right -> double rotate
                        node.left = node.left.rotateLeft();
                        stack[i][1] = node.rotateRight();
                    }
                }
                // patch path to parent
                if (i > 0) {
                    switch (stack[i - 1][0]) {
                        case Dir.Left:
                            stack[i - 1][1].left = stack[i][1];
                            break;
                        case Dir.Right:
                            stack[i - 1][1].right = stack[i][1];
                            break;
                        case Dir.Mid:
                            stack[i - 1][1].mid = stack[i][1];
                            break;
                    }
                }
                else {
                    this.c = stack[0][1];
                }
            }
        }
        f(node) {
            while (node.left) {
                node = node.left;
            }
            return node;
        }
        findSubstr(key) {
            const iter = this.b.reset(key);
            let node = this.c;
            let candidate = undefined;
            while (node) {
                const val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    candidate = node.value || candidate;
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node && node.value || candidate;
        }
        findSuperstr(key) {
            return this.g(key, false);
        }
        g(key, allowValue) {
            const iter = this.b.reset(key);
            let node = this.c;
            while (node) {
                const val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    // collect
                    if (!node.mid) {
                        if (allowValue) {
                            return node.value;
                        }
                        else {
                            return undefined;
                        }
                    }
                    else {
                        return this.h(node.mid);
                    }
                }
            }
            return undefined;
        }
        hasElementOrSubtree(key) {
            return this.g(key, true) !== undefined;
        }
        forEach(callback) {
            for (const [key, value] of this) {
                callback(value, key);
            }
        }
        *[Symbol.iterator]() {
            yield* this.h(this.c);
        }
        h(node) {
            const result = [];
            this.j(node, result);
            return result[Symbol.iterator]();
        }
        j(node, bucket) {
            // DFS
            if (!node) {
                return;
            }
            if (node.left) {
                this.j(node.left, bucket);
            }
            if (node.value) {
                bucket.push([node.key, node.value]);
            }
            if (node.mid) {
                this.j(node.mid, bucket);
            }
            if (node.right) {
                this.j(node.right, bucket);
            }
        }
        // for debug/testing
        _isBalanced() {
            const nodeIsBalanced = (node) => {
                if (!node) {
                    return true;
                }
                const bf = node.balanceFactor();
                if (bf < -1 || bf > 1) {
                    return false;
                }
                return nodeIsBalanced(node.left) && nodeIsBalanced(node.right);
            };
            return nodeIsBalanced(this.c);
        }
    }
    exports.$Li = $Li;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[36/*vs/base/common/marshalling*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,2/*vs/base/common/uri*/,37/*vs/base/common/marshallingIds*/]), function (require, exports, buffer_1, uri_1, marshallingIds_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ai = $ai;
    exports.$bi = $bi;
    exports.$ci = $ci;
    function $ai(obj) {
        return JSON.stringify(obj, replacer);
    }
    function $bi(text) {
        let data = JSON.parse(text);
        data = $ci(data);
        return data;
    }
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: marshallingIds_1.MarshalledId.Regexp,
                source: value.source,
                flags: value.flags,
            };
        }
        return value;
    }
    function $ci(obj, depth = 0) {
        if (!obj || depth > 200) {
            return obj;
        }
        if (typeof obj === 'object') {
            switch (obj.$mid) {
                case marshallingIds_1.MarshalledId.Uri: return uri_1.URI.revive(obj);
                case marshallingIds_1.MarshalledId.Regexp: return new RegExp(obj.source, obj.flags);
                case marshallingIds_1.MarshalledId.Date: return new Date(obj.source);
            }
            if (obj instanceof buffer_1.$Ne
                || obj instanceof Uint8Array) {
                return obj;
            }
            if (Array.isArray(obj)) {
                for (let i = 0; i < obj.length; ++i) {
                    obj[i] = $ci(obj[i], depth + 1);
                }
            }
            else {
                // walk object
                for (const key in obj) {
                    if (Object.hasOwnProperty.call(obj, key)) {
                        obj[key] = $ci(obj[key], depth + 1);
                    }
                }
            }
        }
        return obj;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[15/*vs/base/common/network*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,20/*vs/base/common/platform*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/,19/*vs/base/common/path*/]), function (require, exports, errors, platform, strings_1, uri_1, paths) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.COI = exports.$Zg = exports.$Yg = exports.$Xg = exports.$Wg = exports.$Vg = exports.$Ug = exports.$Sg = exports.$Rg = exports.$Qg = exports.Schemas = void 0;
    exports.$Og = $Og;
    exports.$Pg = $Pg;
    exports.$Tg = $Tg;
    errors = __importStar(errors);
    platform = __importStar(platform);
    paths = __importStar(paths);
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        /**
         * A walk-through document.
         */
        Schemas.walkThrough = 'walkThrough';
        /**
         * An embedded code snippet.
         */
        Schemas.walkThroughSnippet = 'walkThroughSnippet';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
        Schemas.mailto = 'mailto';
        Schemas.untitled = 'untitled';
        Schemas.data = 'data';
        Schemas.command = 'command';
        Schemas.vscodeRemote = 'vscode-remote';
        Schemas.vscodeRemoteResource = 'vscode-remote-resource';
        Schemas.vscodeManagedRemoteResource = 'vscode-managed-remote-resource';
        Schemas.vscodeUserData = 'vscode-userdata';
        Schemas.vscodeCustomEditor = 'vscode-custom-editor';
        Schemas.vscodeNotebookCell = 'vscode-notebook-cell';
        Schemas.vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';
        Schemas.vscodeNotebookCellOutput = 'vscode-notebook-cell-output';
        Schemas.vscodeInteractiveInput = 'vscode-interactive-input';
        Schemas.vscodeSettings = 'vscode-settings';
        Schemas.vscodeWorkspaceTrust = 'vscode-workspace-trust';
        Schemas.vscodeTerminal = 'vscode-terminal';
        /** Scheme used for code blocks in chat. */
        Schemas.vscodeChatCodeBlock = 'vscode-chat-code-block';
        /**
         * Scheme used for backing documents created by copilot for chat.
         */
        Schemas.vscodeCopilotBackingChatCodeBlock = 'vscode-copilot-chat-code-block';
        /** Scheme used for LHS of code compare (aka diff) blocks in chat. */
        Schemas.vscodeChatCodeCompareBlock = 'vscode-chat-code-compare-block';
        /** Scheme used for the chat input editor. */
        Schemas.vscodeChatSesssion = 'vscode-chat-editor';
        /**
         * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)
         */
        Schemas.webviewPanel = 'webview-panel';
        /**
         * Scheme used for loading the wrapper html and script in webviews.
         */
        Schemas.vscodeWebview = 'vscode-webview';
        /**
         * Scheme used for extension pages
         */
        Schemas.extension = 'extension';
        /**
         * Scheme used as a replacement of `file` scheme to load
         * files with our custom protocol handler (desktop only).
         */
        Schemas.vscodeFileResource = 'vscode-file';
        /**
         * Scheme used for temporary resources
         */
        Schemas.tmp = 'tmp';
        /**
         * Scheme used vs live share
         */
        Schemas.vsls = 'vsls';
        /**
         * Scheme used for the Source Control commit input's text document
         */
        Schemas.vscodeSourceControl = 'vscode-scm';
        /**
         * Scheme used for input box for creating comments.
         */
        Schemas.commentsInput = 'comment';
        /**
         * Scheme used for special rendering of settings in the release notes
         */
        Schemas.codeSetting = 'code-setting';
    })(Schemas || (exports.Schemas = Schemas = {}));
    function $Og(target, scheme) {
        if (uri_1.URI.isUri(target)) {
            return (0, strings_1.$Ff)(target.scheme, scheme);
        }
        else {
            return (0, strings_1.$Gf)(target, scheme + ':');
        }
    }
    function $Pg(target, ...schemes) {
        return schemes.some(scheme => $Og(target, scheme));
    }
    exports.$Qg = 'vscode-tkn';
    exports.$Rg = 'tkn';
    class RemoteAuthoritiesImpl {
        constructor() {
            this.a = Object.create(null);
            this.b = Object.create(null);
            this.c = Object.create(null);
            this.d = 'http';
            this.e = null;
            this.f = '/';
        }
        setPreferredWebSchema(schema) {
            this.d = schema;
        }
        setDelegate(delegate) {
            this.e = delegate;
        }
        setServerRootPath(product, serverBasePath) {
            this.f = $Tg(product, serverBasePath);
        }
        getServerRootPath() {
            return this.f;
        }
        get g() {
            return paths.$gc.join(this.f, Schemas.vscodeRemoteResource);
        }
        set(authority, host, port) {
            this.a[authority] = host;
            this.b[authority] = port;
        }
        setConnectionToken(authority, connectionToken) {
            this.c[authority] = connectionToken;
        }
        getPreferredWebSchema() {
            return this.d;
        }
        rewrite(uri) {
            if (this.e) {
                try {
                    return this.e(uri);
                }
                catch (err) {
                    errors.$Y(err);
                    return uri;
                }
            }
            const authority = uri.authority;
            let host = this.a[authority];
            if (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {
                host = `[${host}]`;
            }
            const port = this.b[authority];
            const connectionToken = this.c[authority];
            let query = `path=${encodeURIComponent(uri.path)}`;
            if (typeof connectionToken === 'string') {
                query += `&${exports.$Rg}=${encodeURIComponent(connectionToken)}`;
            }
            return uri_1.URI.from({
                scheme: platform.$p ? this.d : Schemas.vscodeRemoteResource,
                authority: `${host}:${port}`,
                path: this.g,
                query
            });
        }
    }
    exports.$Sg = new RemoteAuthoritiesImpl();
    function $Tg(product, basePath) {
        return paths.$gc.join(basePath ?? '/', `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`);
    }
    exports.$Ug = 'vs/../../extensions';
    exports.$Vg = 'vs/../../node_modules';
    exports.$Wg = 'vs/../../node_modules.asar';
    exports.$Xg = 'vs/../../node_modules.asar.unpacked';
    exports.$Yg = 'vscode-app';
    class FileAccessImpl {
        static { this.a = exports.$Yg; }
        /**
         * Returns a URI to use in contexts where the browser is responsible
         * for loading (e.g. fetch()) or when used within the DOM.
         *
         * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
         */
        asBrowserUri(resourcePath) {
            const uri = this.b(resourcePath, require);
            return this.uriToBrowserUri(uri);
        }
        /**
         * Returns a URI to use in contexts where the browser is responsible
         * for loading (e.g. fetch()) or when used within the DOM.
         *
         * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
         */
        uriToBrowserUri(uri) {
            // Handle remote URIs via `RemoteAuthorities`
            if (uri.scheme === Schemas.vscodeRemote) {
                return exports.$Sg.rewrite(uri);
            }
            // Convert to `vscode-file` resource..
            if (
            // ...only ever for `file` resources
            uri.scheme === Schemas.file &&
                (
                // ...and we run in native environments
                platform.$n ||
                    // ...or web worker extensions on desktop
                    (platform.$r === `${Schemas.vscodeFileResource}://${FileAccessImpl.a}`))) {
                return uri.with({
                    scheme: Schemas.vscodeFileResource,
                    // We need to provide an authority here so that it can serve
                    // as origin for network and loading matters in chromium.
                    // If the URI is not coming with an authority already, we
                    // add our own
                    authority: uri.authority || FileAccessImpl.a,
                    query: null,
                    fragment: null
                });
            }
            return uri;
        }
        /**
         * Returns the `file` URI to use in contexts where node.js
         * is responsible for loading.
         */
        asFileUri(resourcePath) {
            const uri = this.b(resourcePath, require);
            return this.uriToFileUri(uri);
        }
        /**
         * Returns the `file` URI to use in contexts where node.js
         * is responsible for loading.
         */
        uriToFileUri(uri) {
            // Only convert the URI if it is `vscode-file:` scheme
            if (uri.scheme === Schemas.vscodeFileResource) {
                return uri.with({
                    scheme: Schemas.file,
                    // Only preserve the `authority` if it is different from
                    // our fallback authority. This ensures we properly preserve
                    // Windows UNC paths that come with their own authority.
                    authority: uri.authority !== FileAccessImpl.a ? uri.authority : null,
                    query: null,
                    fragment: null
                });
            }
            return uri;
        }
        b(uriOrModule, moduleIdToUrl) {
            if (uri_1.URI.isUri(uriOrModule)) {
                return uriOrModule;
            }
            return uri_1.URI.parse(moduleIdToUrl.toUrl(uriOrModule));
        }
    }
    exports.$Zg = new FileAccessImpl();
    var COI;
    (function (COI) {
        const coiHeaders = new Map([
            ['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],
            ['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],
            ['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],
        ]);
        COI.CoopAndCoep = Object.freeze(coiHeaders.get('3'));
        const coiSearchParamName = 'vscode-coi';
        /**
         * Extract desired headers from `vscode-coi` invocation
         */
        function getHeadersFromQuery(url) {
            let params;
            if (typeof url === 'string') {
                params = new URL(url).searchParams;
            }
            else if (url instanceof URL) {
                params = url.searchParams;
            }
            else if (uri_1.URI.isUri(url)) {
                params = new URL(url.toString(true)).searchParams;
            }
            const value = params?.get(coiSearchParamName);
            if (!value) {
                return undefined;
            }
            return coiHeaders.get(value);
        }
        COI.getHeadersFromQuery = getHeadersFromQuery;
        /**
         * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`
         * isn't enabled the current context
         */
        function addSearchParam(urlOrSearch, coop, coep) {
            if (!globalThis.crossOriginIsolated) {
                // depends on the current context being COI
                return;
            }
            const value = coop && coep ? '3' : coep ? '2' : '1';
            if (urlOrSearch instanceof URLSearchParams) {
                urlOrSearch.set(coiSearchParamName, value);
            }
            else {
                urlOrSearch[coiSearchParamName] = value;
            }
        }
        COI.addSearchParam = addSearchParam;
    })(COI || (exports.COI = COI = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[23/*vs/base/common/resources*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,51/*vs/base/common/extpath*/,15/*vs/base/common/network*/,19/*vs/base/common/path*/,20/*vs/base/common/platform*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/]), function (require, exports, charCode_1, extpath, network_1, paths, platform_1, strings_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataUri = exports.$oh = exports.$nh = exports.$mh = exports.$lh = exports.$kh = exports.$jh = exports.$ih = exports.$hh = exports.$gh = exports.$fh = exports.$eh = exports.$dh = exports.$ch = exports.$bh = exports.$ah = exports.$_g = exports.$$g = exports.$0g = exports.$9g = exports.$8g = void 0;
    exports.$7g = $7g;
    exports.$ph = $ph;
    exports.$qh = $qh;
    extpath = __importStar(extpath);
    paths = __importStar(paths);
    function $7g(uri) {
        return (0, uri_1.$wc)(uri, true);
    }
    class $8g {
        constructor(a) {
            this.a = a;
        }
        compare(uri1, uri2, ignoreFragment = false) {
            if (uri1 === uri2) {
                return 0;
            }
            return (0, strings_1.$yf)(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));
        }
        isEqual(uri1, uri2, ignoreFragment = false) {
            if (uri1 === uri2) {
                return true;
            }
            if (!uri1 || !uri2) {
                return false;
            }
            return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);
        }
        getComparisonKey(uri, ignoreFragment = false) {
            return uri.with({
                path: this.a(uri) ? uri.path.toLowerCase() : undefined,
                fragment: ignoreFragment ? null : undefined
            }).toString();
        }
        ignorePathCasing(uri) {
            return this.a(uri);
        }
        isEqualOrParent(base, parentCandidate, ignoreFragment = false) {
            if (base.scheme === parentCandidate.scheme) {
                if (base.scheme === network_1.Schemas.file) {
                    return extpath.$Eg($7g(base), $7g(parentCandidate), this.a(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
                }
                if ((0, exports.$lh)(base.authority, parentCandidate.authority)) {
                    return extpath.$Eg(base.path, parentCandidate.path, this.a(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);
                }
            }
            return false;
        }
        // --- path math
        joinPath(resource, ...pathFragment) {
            return uri_1.URI.joinPath(resource, ...pathFragment);
        }
        basenameOrAuthority(resource) {
            return (0, exports.$dh)(resource) || resource.authority;
        }
        basename(resource) {
            return paths.$gc.basename(resource.path);
        }
        extname(resource) {
            return paths.$gc.extname(resource.path);
        }
        dirname(resource) {
            if (resource.path.length === 0) {
                return resource;
            }
            let dirname;
            if (resource.scheme === network_1.Schemas.file) {
                dirname = uri_1.URI.file(paths.$mc($7g(resource))).path;
            }
            else {
                dirname = paths.$gc.dirname(resource.path);
                if (resource.authority && dirname.length && dirname.charCodeAt(0) !== charCode_1.CharCode.Slash) {
                    console.error(`dirname("${resource.toString})) resulted in a relative path`);
                    dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash ("/") character
                }
            }
            return resource.with({
                path: dirname
            });
        }
        normalizePath(resource) {
            if (!resource.path.length) {
                return resource;
            }
            let normalizedPath;
            if (resource.scheme === network_1.Schemas.file) {
                normalizedPath = uri_1.URI.file(paths.$hc($7g(resource))).path;
            }
            else {
                normalizedPath = paths.$gc.normalize(resource.path);
            }
            return resource.with({
                path: normalizedPath
            });
        }
        relativePath(from, to) {
            if (from.scheme !== to.scheme || !(0, exports.$lh)(from.authority, to.authority)) {
                return undefined;
            }
            if (from.scheme === network_1.Schemas.file) {
                const relativePath = paths.$lc($7g(from), $7g(to));
                return platform_1.$j ? extpath.$yg(relativePath) : relativePath;
            }
            let fromPath = from.path || '/';
            const toPath = to.path || '/';
            if (this.a(from)) {
                // make casing of fromPath match toPath
                let i = 0;
                for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {
                    if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {
                        if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {
                            break;
                        }
                    }
                }
                fromPath = toPath.substr(0, i) + fromPath.substr(i);
            }
            return paths.$gc.relative(fromPath, toPath);
        }
        resolvePath(base, path) {
            if (base.scheme === network_1.Schemas.file) {
                const newURI = uri_1.URI.file(paths.$kc($7g(base), path));
                return base.with({
                    authority: newURI.authority,
                    path: newURI.path
                });
            }
            path = extpath.$zg(path); // we allow path to be a windows path
            return base.with({
                path: paths.$gc.resolve(base.path, path)
            });
        }
        // --- misc
        isAbsolutePath(resource) {
            return !!resource.path && resource.path[0] === '/';
        }
        isEqualAuthority(a1, a2) {
            return a1 === a2 || (a1 !== undefined && a2 !== undefined && (0, strings_1.$Ff)(a1, a2));
        }
        hasTrailingPathSeparator(resource, sep = paths.sep) {
            if (resource.scheme === network_1.Schemas.file) {
                const fsp = $7g(resource);
                return fsp.length > extpath.$Ag(fsp).length && fsp[fsp.length - 1] === sep;
            }
            else {
                const p = resource.path;
                return (p.length > 1 && p.charCodeAt(p.length - 1) === charCode_1.CharCode.Slash) && !(/^[a-zA-Z]:(\/$|\\$)/.test(resource.fsPath)); // ignore the slash at offset 0
            }
        }
        removeTrailingPathSeparator(resource, sep = paths.sep) {
            // Make sure that the path isn't a drive letter. A trailing separator there is not removable.
            if ((0, exports.$mh)(resource, sep)) {
                return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });
            }
            return resource;
        }
        addTrailingPathSeparator(resource, sep = paths.sep) {
            let isRootSep = false;
            if (resource.scheme === network_1.Schemas.file) {
                const fsp = $7g(resource);
                isRootSep = ((fsp !== undefined) && (fsp.length === extpath.$Ag(fsp).length) && (fsp[fsp.length - 1] === sep));
            }
            else {
                sep = '/';
                const p = resource.path;
                isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === charCode_1.CharCode.Slash;
            }
            if (!isRootSep && !(0, exports.$mh)(resource, sep)) {
                return resource.with({ path: resource.path + '/' });
            }
            return resource;
        }
    }
    exports.$8g = $8g;
    /**
     * Unbiased utility that takes uris "as they are". This means it can be interchanged with
     * uri#toString() usages. The following is true
     * ```
     * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))
     * ```
     */
    exports.$9g = new $8g(() => false);
    /**
     * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you
     * understand what you are doing.
     *
     * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.
     *
     * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient
     * because those uris come from a "trustworthy source". When creating unknown uris it's always
     * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path
     * casing matters.
     */
    exports.$0g = new $8g(uri => {
        // A file scheme resource is in the same platform as code, so ignore case for non linux platforms
        // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider
        return uri.scheme === network_1.Schemas.file ? !platform_1.$l : true;
    });
    /**
     * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you
     * understand what you are doing.
     *
     * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.
     *
     * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient
     * because those uris come from a "trustworthy source". When creating unknown uris it's always
     * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path
     * casing matters.
     */
    exports.$$g = new $8g(_ => true);
    exports.$_g = exports.$9g.isEqual.bind(exports.$9g);
    exports.$ah = exports.$9g.isEqualOrParent.bind(exports.$9g);
    exports.$bh = exports.$9g.getComparisonKey.bind(exports.$9g);
    exports.$ch = exports.$9g.basenameOrAuthority.bind(exports.$9g);
    exports.$dh = exports.$9g.basename.bind(exports.$9g);
    exports.$eh = exports.$9g.extname.bind(exports.$9g);
    exports.$fh = exports.$9g.dirname.bind(exports.$9g);
    exports.$gh = exports.$9g.joinPath.bind(exports.$9g);
    exports.$hh = exports.$9g.normalizePath.bind(exports.$9g);
    exports.$ih = exports.$9g.relativePath.bind(exports.$9g);
    exports.$jh = exports.$9g.resolvePath.bind(exports.$9g);
    exports.$kh = exports.$9g.isAbsolutePath.bind(exports.$9g);
    exports.$lh = exports.$9g.isEqualAuthority.bind(exports.$9g);
    exports.$mh = exports.$9g.hasTrailingPathSeparator.bind(exports.$9g);
    exports.$nh = exports.$9g.removeTrailingPathSeparator.bind(exports.$9g);
    exports.$oh = exports.$9g.addTrailingPathSeparator.bind(exports.$9g);
    //#endregion
    function $ph(items, resourceAccessor) {
        const distinctParents = [];
        for (let i = 0; i < items.length; i++) {
            const candidateResource = resourceAccessor(items[i]);
            if (items.some((otherItem, index) => {
                if (index === i) {
                    return false;
                }
                return (0, exports.$ah)(candidateResource, resourceAccessor(otherItem));
            })) {
                continue;
            }
            distinctParents.push(items[i]);
        }
        return distinctParents;
    }
    /**
     * Data URI related helpers.
     */
    var DataUri;
    (function (DataUri) {
        DataUri.META_DATA_LABEL = 'label';
        DataUri.META_DATA_DESCRIPTION = 'description';
        DataUri.META_DATA_SIZE = 'size';
        DataUri.META_DATA_MIME = 'mime';
        function parseMetaData(dataUri) {
            const metadata = new Map();
            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
            // the metadata is: size:2313;label:SomeLabel;description:SomeDescription
            const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));
            meta.split(';').forEach(property => {
                const [key, value] = property.split(':');
                if (key && value) {
                    metadata.set(key, value);
                }
            });
            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
            // the mime is: image/png
            const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));
            if (mime) {
                metadata.set(DataUri.META_DATA_MIME, mime);
            }
            return metadata;
        }
        DataUri.parseMetaData = parseMetaData;
    })(DataUri || (exports.DataUri = DataUri = {}));
    function $qh(resource, authority, localScheme) {
        if (authority) {
            let path = resource.path;
            if (path && path[0] !== paths.$gc.sep) {
                path = paths.$gc.sep + path;
            }
            return resource.with({ scheme: localScheme, authority, path });
        }
        return resource.with({ scheme: localScheme });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[10/*vs/base/common/async*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/cancellation*/,13/*vs/base/common/errors*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,23/*vs/base/common/resources*/,20/*vs/base/common/platform*/,148/*vs/base/common/symbols*/,48/*vs/base/common/lazy*/]), function (require, exports, cancellation_1, errors_1, event_1, lifecycle_1, resources_1, platform_1, symbols_1, lazy_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$9h = exports.$7h = exports.$6h = exports.$5h = exports.$4h = exports.Promises = exports.$3h = exports.$2h = exports.$1h = exports.$Yh = exports.$Xh = exports.$Wh = exports.$Vh = exports.$Uh = exports.$Th = exports.$Sh = exports.$Rh = exports.$Qh = exports.$Ph = exports.$Oh = exports.$Nh = exports.$Mh = exports.$Lh = exports.$Fh = exports.$Eh = exports.$Dh = exports.$Ch = exports.$Bh = exports.$Ah = exports.$zh = void 0;
    exports.$rh = $rh;
    exports.$sh = $sh;
    exports.$th = $th;
    exports.$uh = $uh;
    exports.$vh = $vh;
    exports.$wh = $wh;
    exports.$xh = $xh;
    exports.$yh = $yh;
    exports.$Gh = $Gh;
    exports.$Hh = $Hh;
    exports.$Ih = $Ih;
    exports.$Jh = $Jh;
    exports.$Kh = $Kh;
    exports.$Zh = $Zh;
    exports.$8h = $8h;
    function $rh(obj) {
        return !!obj && typeof obj.then === 'function';
    }
    function $sh(callback) {
        const source = new cancellation_1.$we();
        const thenable = callback(source.token);
        const promise = new Promise((resolve, reject) => {
            const subscription = source.token.onCancellationRequested(() => {
                subscription.dispose();
                reject(new errors_1.$4());
            });
            Promise.resolve(thenable).then(value => {
                subscription.dispose();
                source.dispose();
                resolve(value);
            }, err => {
                subscription.dispose();
                source.dispose();
                reject(err);
            });
        });
        return new class {
            cancel() {
                source.cancel();
                source.dispose();
            }
            then(resolve, reject) {
                return promise.then(resolve, reject);
            }
            catch(reject) {
                return this.then(undefined, reject);
            }
            finally(onfinally) {
                return promise.finally(onfinally);
            }
        };
    }
    function $th(promise, token, defaultValue) {
        return new Promise((resolve, reject) => {
            const ref = token.onCancellationRequested(() => {
                ref.dispose();
                resolve(defaultValue);
            });
            promise.then(resolve, reject).finally(() => ref.dispose());
        });
    }
    /**
     * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.
     * @see {@link $th}
     */
    function $uh(promise, token) {
        return new Promise((resolve, reject) => {
            const ref = token.onCancellationRequested(() => {
                ref.dispose();
                reject(new errors_1.$4());
            });
            promise.then(resolve, reject).finally(() => ref.dispose());
        });
    }
    /**
     * Returns as soon as one of the promises resolves or rejects and cancels remaining promises
     */
    async function $vh(cancellablePromises) {
        let resolvedPromiseIndex = -1;
        const promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));
        try {
            const result = await Promise.race(promises);
            return result;
        }
        finally {
            cancellablePromises.forEach((cancellablePromise, index) => {
                if (index !== resolvedPromiseIndex) {
                    cancellablePromise.cancel();
                }
            });
        }
    }
    function $wh(promise, timeout, onTimeout) {
        let promiseResolve = undefined;
        const timer = setTimeout(() => {
            promiseResolve?.(undefined);
            onTimeout?.();
        }, timeout);
        return Promise.race([
            promise.finally(() => clearTimeout(timer)),
            new Promise(resolve => promiseResolve = resolve)
        ]);
    }
    function $xh(callback) {
        return new Promise((resolve, reject) => {
            const item = callback();
            if ($rh(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        });
    }
    /**
     * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.
     *
     * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported
     */
    function $yh() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        return { promise, resolve: resolve, reject: reject };
    }
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		const throttler = new Throttler();
     * 		const letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    class $zh {
        constructor() {
            this.f = false;
            this.a = null;
            this.b = null;
            this.d = null;
        }
        queue(promiseFactory) {
            if (this.f) {
                return Promise.reject(new Error('Throttler is disposed'));
            }
            if (this.a) {
                this.d = promiseFactory;
                if (!this.b) {
                    const onComplete = () => {
                        this.b = null;
                        if (this.f) {
                            return;
                        }
                        const result = this.queue(this.d);
                        this.d = null;
                        return result;
                    };
                    this.b = new Promise(resolve => {
                        this.a.then(onComplete, onComplete).then(resolve);
                    });
                }
                return new Promise((resolve, reject) => {
                    this.b.then(resolve, reject);
                });
            }
            this.a = promiseFactory();
            return new Promise((resolve, reject) => {
                this.a.then((result) => {
                    this.a = null;
                    resolve(result);
                }, (err) => {
                    this.a = null;
                    reject(err);
                });
            });
        }
        dispose() {
            this.f = true;
        }
    }
    exports.$zh = $zh;
    class $Ah {
        constructor() {
            this.a = Promise.resolve(null);
        }
        queue(promiseTask) {
            return this.a = this.a.then(() => promiseTask(), () => promiseTask());
        }
    }
    exports.$Ah = $Ah;
    class $Bh {
        constructor() {
            this.a = new Map();
        }
        queue(key, promiseTask) {
            const runningPromise = this.a.get(key) ?? Promise.resolve();
            const newPromise = runningPromise
                .catch(() => { })
                .then(promiseTask)
                .finally(() => {
                if (this.a.get(key) === newPromise) {
                    this.a.delete(key);
                }
            });
            this.a.set(key, newPromise);
            return newPromise;
        }
    }
    exports.$Bh = $Bh;
    const timeoutDeferred = (timeout, fn) => {
        let scheduled = true;
        const handle = setTimeout(() => {
            scheduled = false;
            fn();
        }, timeout);
        return {
            isTriggered: () => scheduled,
            dispose: () => {
                clearTimeout(handle);
                scheduled = false;
            },
        };
    };
    const microtaskDeferred = (fn) => {
        let scheduled = true;
        queueMicrotask(() => {
            if (scheduled) {
                scheduled = false;
                fn();
            }
        });
        return {
            isTriggered: () => scheduled,
            dispose: () => { scheduled = false; },
        };
    };
    /**
     * A helper to delay (debounce) execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		const delayer = new Delayer(WAITING_PERIOD);
     * 		const letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    class $Ch {
        constructor(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.a = null;
            this.b = null;
            this.d = null;
            this.f = null;
            this.g = null;
        }
        trigger(task, delay = this.defaultDelay) {
            this.g = task;
            this.h();
            if (!this.b) {
                this.b = new Promise((resolve, reject) => {
                    this.d = resolve;
                    this.f = reject;
                }).then(() => {
                    this.b = null;
                    this.d = null;
                    if (this.g) {
                        const task = this.g;
                        this.g = null;
                        return task();
                    }
                    return undefined;
                });
            }
            const fn = () => {
                this.a = null;
                this.d?.(null);
            };
            this.a = delay === symbols_1.$ge ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);
            return this.b;
        }
        isTriggered() {
            return !!this.a?.isTriggered();
        }
        cancel() {
            this.h();
            if (this.b) {
                this.f?.(new errors_1.$4());
                this.b = null;
            }
        }
        h() {
            this.a?.dispose();
            this.a = null;
        }
        dispose() {
            this.cancel();
        }
    }
    exports.$Ch = $Ch;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * The mail man is clever and waits for a certain amount of time, before going
     * out to deliver letters. While the mail man is going out, more letters arrive
     * and can only be delivered once he is back. Once he is back the mail man will
     * do one more trip to deliver the letters that have accumulated while he was out.
     */
    class $Dh {
        constructor(defaultDelay) {
            this.a = new $Ch(defaultDelay);
            this.b = new $zh();
        }
        trigger(promiseFactory, delay) {
            return this.a.trigger(() => this.b.queue(promiseFactory), delay);
        }
        isTriggered() {
            return this.a.isTriggered();
        }
        cancel() {
            this.a.cancel();
        }
        dispose() {
            this.a.dispose();
            this.b.dispose();
        }
    }
    exports.$Dh = $Dh;
    /**
     * A barrier that is initially closed and then becomes opened permanently.
     */
    class $Eh {
        constructor() {
            this.a = false;
            this.b = new Promise((c, e) => {
                this.d = c;
            });
        }
        isOpen() {
            return this.a;
        }
        open() {
            this.a = true;
            this.d(true);
        }
        wait() {
            return this.b;
        }
    }
    exports.$Eh = $Eh;
    /**
     * A barrier that is initially closed and then becomes opened permanently after a certain period of
     * time or when open is called explicitly
     */
    class $Fh extends $Eh {
        constructor(autoOpenTimeMs) {
            super();
            this.f = setTimeout(() => this.open(), autoOpenTimeMs);
        }
        open() {
            clearTimeout(this.f);
            super.open();
        }
    }
    exports.$Fh = $Fh;
    function $Gh(millis, token) {
        if (!token) {
            return $sh(token => $Gh(millis, token));
        }
        return new Promise((resolve, reject) => {
            const handle = setTimeout(() => {
                disposable.dispose();
                resolve();
            }, millis);
            const disposable = token.onCancellationRequested(() => {
                clearTimeout(handle);
                disposable.dispose();
                reject(new errors_1.$4());
            });
        });
    }
    /**
     * Creates a timeout that can be disposed using its returned value.
     * @param handler The timeout handler.
     * @param timeout An optional timeout in milliseconds.
     * @param store An optional {@link $Tc} that will have the timeout disposable managed automatically.
     *
     * @example
     * const store = new DisposableStore;
     * // Call the timeout after 1000ms at which point it will be automatically
     * // evicted from the store.
     * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);
     *
     * if (foo) {
     *   // Cancel the timeout and evict it from store.
     *   timeoutDisposable.dispose();
     * }
     */
    function $Hh(handler, timeout = 0, store) {
        const timer = setTimeout(() => {
            handler();
            if (store) {
                disposable.dispose();
            }
        }, timeout);
        const disposable = (0, lifecycle_1.$Sc)(() => {
            clearTimeout(timer);
            store?.deleteAndLeak(disposable);
        });
        store?.add(disposable);
        return disposable;
    }
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function $Ih(promiseFactories) {
        const results = [];
        let index = 0;
        const len = promiseFactories.length;
        function next() {
            return index < len ? promiseFactories[index++]() : null;
        }
        function thenHandler(result) {
            if (result !== undefined && result !== null) {
                results.push(result);
            }
            const n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return Promise.resolve(results);
        }
        return Promise.resolve(null).then(thenHandler);
    }
    function $Jh(promiseFactories, shouldStop = t => !!t, defaultValue = null) {
        let index = 0;
        const len = promiseFactories.length;
        const loop = () => {
            if (index >= len) {
                return Promise.resolve(defaultValue);
            }
            const factory = promiseFactories[index++];
            const promise = Promise.resolve(factory());
            return promise.then(result => {
                if (shouldStop(result)) {
                    return Promise.resolve(result);
                }
                return loop();
            });
        };
        return loop();
    }
    function $Kh(promiseList, shouldStop = t => !!t, defaultValue = null) {
        if (promiseList.length === 0) {
            return Promise.resolve(defaultValue);
        }
        let todo = promiseList.length;
        const finish = () => {
            todo = -1;
            for (const promise of promiseList) {
                promise.cancel?.();
            }
        };
        return new Promise((resolve, reject) => {
            for (const promise of promiseList) {
                promise.then(result => {
                    if (--todo >= 0 && shouldStop(result)) {
                        finish();
                        resolve(result);
                    }
                    else if (todo === 0) {
                        resolve(defaultValue);
                    }
                })
                    .catch(err => {
                    if (--todo >= 0) {
                        finish();
                        reject(err);
                    }
                });
            }
        });
    }
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    class $Lh {
        constructor(maxDegreeOfParalellism) {
            this.a = 0;
            this.b = false;
            this.f = maxDegreeOfParalellism;
            this.g = [];
            this.d = 0;
            this.h = new event_1.$le();
        }
        /**
         *
         * @returns A promise that resolved when all work is done (onDrained) or when
         * there is nothing to do
         */
        whenIdle() {
            return this.size > 0
                ? event_1.Event.toPromise(this.onDrained)
                : Promise.resolve();
        }
        get onDrained() {
            return this.h.event;
        }
        get size() {
            return this.a;
        }
        queue(factory) {
            if (this.b) {
                throw new Error('Object has been disposed');
            }
            this.a++;
            return new Promise((c, e) => {
                this.g.push({ factory, c, e });
                this.j();
            });
        }
        j() {
            while (this.g.length && this.d < this.f) {
                const iLimitedTask = this.g.shift();
                this.d++;
                const promise = iLimitedTask.factory();
                promise.then(iLimitedTask.c, iLimitedTask.e);
                promise.then(() => this.k(), () => this.k());
            }
        }
        k() {
            if (this.b) {
                return;
            }
            this.d--;
            if (--this.a === 0) {
                this.h.fire();
            }
            if (this.g.length > 0) {
                this.j();
            }
        }
        clear() {
            if (this.b) {
                throw new Error('Object has been disposed');
            }
            this.g.length = 0;
            this.a = this.d;
        }
        dispose() {
            this.b = true;
            this.g.length = 0; // stop further processing
            this.a = 0;
            this.h.dispose();
        }
    }
    exports.$Lh = $Lh;
    /**
     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
     */
    class $Mh extends $Lh {
        constructor() {
            super(1);
        }
    }
    exports.$Mh = $Mh;
    /**
     * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that
     * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will
     * replace the currently queued task until it executes.
     *
     * As such, the returned promise may not be from the factory that is passed in but from the next factory that
     * is running after having called `queue`.
     */
    class $Nh {
        constructor() {
            this.a = new $1h();
            this.b = 0;
        }
        queue(factory) {
            if (!this.a.isRunning()) {
                return this.a.run(this.b++, factory());
            }
            return this.a.queue(() => {
                return this.a.run(this.b++, factory());
            });
        }
    }
    exports.$Nh = $Nh;
    /**
     * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
     * by disposing them once the queue is empty.
     */
    class $Oh {
        constructor() {
            this.a = new Map();
            this.b = new Set();
            this.d = undefined;
            this.f = 0;
        }
        async whenDrained() {
            if (this.g()) {
                return;
            }
            const promise = new $3h();
            this.b.add(promise);
            return promise.p;
        }
        g() {
            for (const [, queue] of this.a) {
                if (queue.size > 0) {
                    return false;
                }
            }
            return true;
        }
        queueSize(resource, extUri = resources_1.$9g) {
            const key = extUri.getComparisonKey(resource);
            return this.a.get(key)?.size ?? 0;
        }
        queueFor(resource, factory, extUri = resources_1.$9g) {
            const key = extUri.getComparisonKey(resource);
            let queue = this.a.get(key);
            if (!queue) {
                queue = new $Mh();
                const drainListenerId = this.f++;
                const drainListener = event_1.Event.once(queue.onDrained)(() => {
                    queue?.dispose();
                    this.a.delete(key);
                    this.h();
                    this.d?.deleteAndDispose(drainListenerId);
                    if (this.d?.size === 0) {
                        this.d.dispose();
                        this.d = undefined;
                    }
                });
                if (!this.d) {
                    this.d = new lifecycle_1.$4c();
                }
                this.d.set(drainListenerId, drainListener);
                this.a.set(key, queue);
            }
            return queue.queue(factory);
        }
        h() {
            if (!this.g()) {
                return; // not done yet
            }
            this.j();
        }
        j() {
            for (const drainer of this.b) {
                drainer.complete();
            }
            this.b.clear();
        }
        dispose() {
            for (const [, queue] of this.a) {
                queue.dispose();
            }
            this.a.clear();
            // Even though we might still have pending
            // tasks queued, after the queues have been
            // disposed, we can no longer track them, so
            // we release drainers to prevent hanging
            // promises when the resource queue is being
            // disposed.
            this.j();
            this.d?.dispose();
        }
    }
    exports.$Oh = $Oh;
    class $Ph {
        constructor(runner, timeout) {
            this.b = false;
            this.a = -1;
            if (typeof runner === 'function' && typeof timeout === 'number') {
                this.setIfNotSet(runner, timeout);
            }
        }
        dispose() {
            this.cancel();
            this.b = true;
        }
        cancel() {
            if (this.a !== -1) {
                clearTimeout(this.a);
                this.a = -1;
            }
        }
        cancelAndSet(runner, timeout) {
            if (this.b) {
                throw new errors_1.$bb(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);
            }
            this.cancel();
            this.a = setTimeout(() => {
                this.a = -1;
                runner();
            }, timeout);
        }
        setIfNotSet(runner, timeout) {
            if (this.b) {
                throw new errors_1.$bb(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);
            }
            if (this.a !== -1) {
                // timer is already set
                return;
            }
            this.a = setTimeout(() => {
                this.a = -1;
                runner();
            }, timeout);
        }
    }
    exports.$Ph = $Ph;
    class $Qh {
        constructor() {
            this.d = undefined;
            this.f = false;
        }
        cancel() {
            this.d?.dispose();
            this.d = undefined;
        }
        cancelAndSet(runner, interval, context = globalThis) {
            if (this.f) {
                throw new errors_1.$bb(`Calling 'cancelAndSet' on a disposed IntervalTimer`);
            }
            this.cancel();
            const handle = context.setInterval(() => {
                runner();
            }, interval);
            this.d = (0, lifecycle_1.$Sc)(() => {
                context.clearInterval(handle);
                this.d = undefined;
            });
        }
        dispose() {
            this.cancel();
            this.f = true;
        }
    }
    exports.$Qh = $Qh;
    class $Rh {
        constructor(runner, delay) {
            this.b = -1;
            this.a = runner;
            this.d = delay;
            this.f = this.g.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        dispose() {
            this.cancel();
            this.a = null;
        }
        /**
         * Cancel current scheduled runner (if any).
         */
        cancel() {
            if (this.isScheduled()) {
                clearTimeout(this.b);
                this.b = -1;
            }
        }
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        schedule(delay = this.d) {
            this.cancel();
            this.b = setTimeout(this.f, delay);
        }
        get delay() {
            return this.d;
        }
        set delay(value) {
            this.d = value;
        }
        /**
         * Returns true if scheduled.
         */
        isScheduled() {
            return this.b !== -1;
        }
        flush() {
            if (this.isScheduled()) {
                this.cancel();
                this.h();
            }
        }
        g() {
            this.b = -1;
            if (this.a) {
                this.h();
            }
        }
        h() {
            this.a?.();
        }
    }
    exports.$Rh = $Rh;
    /**
     * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.
     * > **NOTE**: Only offers 1s resolution.
     *
     * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep
     * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But
     * this scheduler will execute 3hrs **after waking the computer from sleep**.
     */
    class $Sh {
        constructor(runner, delay) {
            if (delay % 1000 !== 0) {
                console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
            }
            this.a = runner;
            this.b = delay;
            this.d = 0;
            this.f = -1;
            this.g = this.h.bind(this);
        }
        dispose() {
            this.cancel();
            this.a = null;
        }
        cancel() {
            if (this.isScheduled()) {
                clearInterval(this.f);
                this.f = -1;
            }
        }
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        schedule(delay = this.b) {
            if (delay % 1000 !== 0) {
                console.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);
            }
            this.cancel();
            this.d = Math.ceil(delay / 1000);
            this.f = setInterval(this.g, 1000);
        }
        /**
         * Returns true if scheduled.
         */
        isScheduled() {
            return this.f !== -1;
        }
        h() {
            this.d--;
            if (this.d > 0) {
                // still need to wait
                return;
            }
            // time elapsed
            clearInterval(this.f);
            this.f = -1;
            this.a?.();
        }
    }
    exports.$Sh = $Sh;
    class $Th extends $Rh {
        constructor(runner, timeout) {
            super(runner, timeout);
            this.j = [];
        }
        work(unit) {
            this.j.push(unit);
            if (!this.isScheduled()) {
                this.schedule();
            }
        }
        h() {
            const units = this.j;
            this.j = [];
            this.a?.(units);
        }
        dispose() {
            this.j = [];
            super.dispose();
        }
    }
    exports.$Th = $Th;
    /**
     * The `ThrottledWorker` will accept units of work `T`
     * to handle. The contract is:
     * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)
     * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)
     * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)
     */
    class $Uh extends lifecycle_1.$Uc {
        constructor(g, h) {
            super();
            this.g = g;
            this.h = h;
            this.a = [];
            this.b = this.B(new lifecycle_1.$Vc());
            this.f = false;
        }
        /**
         * The number of work units that are pending to be processed.
         */
        get pending() { return this.a.length; }
        /**
         * Add units to be worked on. Use `pending` to figure out
         * how many units are not yet processed after this method
         * was called.
         *
         * @returns whether the work was accepted or not. If the
         * worker is disposed, it will not accept any more work.
         * If the number of pending units would become larger
         * than `maxPendingWork`, more work will also not be accepted.
         */
        work(units) {
            if (this.f) {
                return false; // work not accepted: disposed
            }
            // Check for reaching maximum of pending work
            if (typeof this.g.maxBufferedWork === 'number') {
                // Throttled: simple check if pending + units exceeds max pending
                if (this.b.value) {
                    if (this.pending + units.length > this.g.maxBufferedWork) {
                        return false; // work not accepted: too much pending work
                    }
                }
                // Unthrottled: same as throttled, but account for max chunk getting
                // worked on directly without being pending
                else {
                    if (this.pending + units.length - this.g.maxWorkChunkSize > this.g.maxBufferedWork) {
                        return false; // work not accepted: too much pending work
                    }
                }
            }
            // Add to pending units first
            for (const unit of units) {
                this.a.push(unit);
            }
            // If not throttled, start working directly
            // Otherwise, when the throttle delay has
            // past, pending work will be worked again.
            if (!this.b.value) {
                this.j();
            }
            return true; // work accepted
        }
        j() {
            // Extract chunk to handle and handle it
            this.h(this.a.splice(0, this.g.maxWorkChunkSize));
            // If we have remaining work, schedule it after a delay
            if (this.a.length > 0) {
                this.b.value = new $Rh(() => {
                    this.b.clear();
                    this.j();
                }, this.g.throttleDelay);
                this.b.value.schedule();
            }
        }
        dispose() {
            super.dispose();
            this.f = true;
        }
    }
    exports.$Uh = $Uh;
    (function () {
        if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {
            exports.$Wh = (_targetWindow, runner) => {
                (0, platform_1.$C)(() => {
                    if (disposed) {
                        return;
                    }
                    const end = Date.now() + 15; // one frame at 64fps
                    const deadline = {
                        didTimeout: true,
                        timeRemaining() {
                            return Math.max(0, end - Date.now());
                        }
                    };
                    runner(Object.freeze(deadline));
                });
                let disposed = false;
                return {
                    dispose() {
                        if (disposed) {
                            return;
                        }
                        disposed = true;
                    }
                };
            };
        }
        else {
            exports.$Wh = (targetWindow, runner, timeout) => {
                const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);
                let disposed = false;
                return {
                    dispose() {
                        if (disposed) {
                            return;
                        }
                        disposed = true;
                        targetWindow.cancelIdleCallback(handle);
                    }
                };
            };
        }
        exports.$Vh = (runner) => (0, exports.$Wh)(globalThis, runner);
    })();
    class $Xh {
        constructor(targetWindow, executor) {
            this.g = false;
            this.d = () => {
                try {
                    this.j = executor();
                }
                catch (err) {
                    this.l = err;
                }
                finally {
                    this.g = true;
                }
            };
            this.f = (0, exports.$Wh)(targetWindow, () => this.d());
        }
        dispose() {
            this.f.dispose();
        }
        get value() {
            if (!this.g) {
                this.f.dispose();
                this.d();
            }
            if (this.l) {
                throw this.l;
            }
            return this.j;
        }
        get isInitialized() {
            return this.g;
        }
    }
    exports.$Xh = $Xh;
    /**
     * An `IdleValue` that always uses the current window (which might be throttled or inactive)
     *
     * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser
     * context
     */
    class $Yh extends $Xh {
        constructor(executor) {
            super(globalThis, executor);
        }
    }
    exports.$Yh = $Yh;
    //#endregion
    async function $Zh(task, delay, retries) {
        let lastError;
        for (let i = 0; i < retries; i++) {
            try {
                return await task();
            }
            catch (error) {
                lastError = error;
                await $Gh(delay);
            }
        }
        throw lastError;
    }
    /**
     * @deprecated use `LimitedQueue` instead for an easier to use API
     */
    class $1h {
        isRunning(taskId) {
            if (typeof taskId === 'number') {
                return this.a?.taskId === taskId;
            }
            return !!this.a;
        }
        get running() {
            return this.a?.promise;
        }
        cancelRunning() {
            this.a?.cancel();
        }
        run(taskId, promise, onCancel) {
            this.a = { taskId, cancel: () => onCancel?.(), promise };
            promise.then(() => this.d(taskId), () => this.d(taskId));
            return promise;
        }
        d(taskId) {
            if (this.a && taskId === this.a.taskId) {
                // only set running to done if the promise finished that is associated with that taskId
                this.a = undefined;
                // schedule the queued task now that we are free if we have any
                this.f();
            }
        }
        f() {
            if (this.b) {
                const queued = this.b;
                this.b = undefined;
                // Run queued task and complete on the associated promise
                queued.run().then(queued.promiseResolve, queued.promiseReject);
            }
        }
        /**
         * Note: the promise to schedule as next run MUST itself call `run`.
         *       Otherwise, this sequentializer will report `false` for `isRunning`
         *       even when this task is running. Missing this detail means that
         *       suddenly multiple tasks will run in parallel.
         */
        queue(run) {
            // this is our first queued task, so we create associated promise with it
            // so that we can return a promise that completes when the task has
            // completed.
            if (!this.b) {
                const { promise, resolve: promiseResolve, reject: promiseReject } = $yh();
                this.b = {
                    run,
                    promise,
                    promiseResolve: promiseResolve,
                    promiseReject: promiseReject
                };
            }
            // we have a previous queued task, just overwrite it
            else {
                this.b.run = run;
            }
            return this.b.promise;
        }
        hasQueued() {
            return !!this.b;
        }
        async join() {
            return this.b?.promise ?? this.a?.promise;
        }
    }
    exports.$1h = $1h;
    //#endregion
    //#region
    /**
     * The `IntervalCounter` allows to count the number
     * of calls to `increment()` over a duration of
     * `interval`. This utility can be used to conditionally
     * throttle a frequent task when a certain threshold
     * is reached.
     */
    class $2h {
        constructor(d, f = () => Date.now()) {
            this.d = d;
            this.f = f;
            this.a = 0;
            this.b = 0;
        }
        increment() {
            const now = this.f();
            // We are outside of the range of `interval` and as such
            // start counting from 0 and remember the time
            if (now - this.a > this.d) {
                this.a = now;
                this.b = 0;
            }
            this.b++;
            return this.b;
        }
    }
    exports.$2h = $2h;
    var DeferredOutcome;
    (function (DeferredOutcome) {
        DeferredOutcome[DeferredOutcome["Resolved"] = 0] = "Resolved";
        DeferredOutcome[DeferredOutcome["Rejected"] = 1] = "Rejected";
    })(DeferredOutcome || (DeferredOutcome = {}));
    /**
     * Creates a promise whose resolution or rejection can be controlled imperatively.
     */
    class $3h {
        get isRejected() {
            return this.d?.outcome === DeferredOutcome.Rejected;
        }
        get isResolved() {
            return this.d?.outcome === DeferredOutcome.Resolved;
        }
        get isSettled() {
            return !!this.d;
        }
        get value() {
            return this.d?.outcome === DeferredOutcome.Resolved ? this.d?.value : undefined;
        }
        constructor() {
            this.p = new Promise((c, e) => {
                this.a = c;
                this.b = e;
            });
        }
        complete(value) {
            return new Promise(resolve => {
                this.a(value);
                this.d = { outcome: DeferredOutcome.Resolved, value };
                resolve();
            });
        }
        error(err) {
            return new Promise(resolve => {
                this.b(err);
                this.d = { outcome: DeferredOutcome.Rejected, value: err };
                resolve();
            });
        }
        cancel() {
            return this.error(new errors_1.$4());
        }
    }
    exports.$3h = $3h;
    //#endregion
    //#region Promises
    var Promises;
    (function (Promises) {
        /**
         * A drop-in replacement for `Promise.all` with the only difference
         * that the method awaits every promise to either fulfill or reject.
         *
         * Similar to `Promise.all`, only the first error will be returned
         * if any.
         */
        async function settled(promises) {
            let firstError = undefined;
            const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {
                if (!firstError) {
                    firstError = error;
                }
                return undefined; // do not rethrow so that other promises can settle
            })));
            if (typeof firstError !== 'undefined') {
                throw firstError;
            }
            return result; // cast is needed and protected by the `throw` above
        }
        Promises.settled = settled;
        /**
         * A helper to create a new `Promise<T>` with a body that is a promise
         * itself. By default, an error that raises from the async body will
         * end up as a unhandled rejection, so this utility properly awaits the
         * body and rejects the promise as a normal promise does without async
         * body.
         *
         * This method should only be used in rare cases where otherwise `async`
         * cannot be used (e.g. when callbacks are involved that require this).
         */
        function withAsyncBody(bodyFn) {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise(async (resolve, reject) => {
                try {
                    await bodyFn(resolve, reject);
                }
                catch (error) {
                    reject(error);
                }
            });
        }
        Promises.withAsyncBody = withAsyncBody;
    })(Promises || (exports.Promises = Promises = {}));
    class $4h {
        get value() { return this.a; }
        get error() { return this.b; }
        get isResolved() { return this.d; }
        constructor(promise) {
            this.a = undefined;
            this.b = undefined;
            this.d = false;
            this.promise = promise.then(value => {
                this.a = value;
                this.d = true;
                return value;
            }, error => {
                this.b = error;
                this.d = true;
                throw error;
            });
        }
        /**
         * Returns the resolved value.
         * Throws if the promise is not resolved yet.
         */
        requireValue() {
            if (!this.d) {
                throw new errors_1.$bb('Promise is not resolved yet');
            }
            if (this.b) {
                throw this.b;
            }
            return this.a;
        }
    }
    exports.$4h = $4h;
    class $5h {
        constructor(b) {
            this.b = b;
            this.a = new lazy_1.$T(() => new $4h(this.b()));
        }
        /**
         * Returns the resolved value.
         * Throws if the promise is not resolved yet.
         */
        requireValue() {
            return this.a.value.requireValue();
        }
        /**
         * Returns the promise (and triggers a computation of the promise if not yet done so).
         */
        getPromise() {
            return this.a.value.promise;
        }
        /**
         * Reads the current value without triggering a computation of the promise.
         */
        get currentValue() {
            return this.a.rawValue?.value;
        }
    }
    exports.$5h = $5h;
    //#endregion
    //#region
    var AsyncIterableSourceState;
    (function (AsyncIterableSourceState) {
        AsyncIterableSourceState[AsyncIterableSourceState["Initial"] = 0] = "Initial";
        AsyncIterableSourceState[AsyncIterableSourceState["DoneOK"] = 1] = "DoneOK";
        AsyncIterableSourceState[AsyncIterableSourceState["DoneError"] = 2] = "DoneError";
    })(AsyncIterableSourceState || (AsyncIterableSourceState = {}));
    /**
     * A rich implementation for an `AsyncIterable<T>`.
     */
    class $6h {
        static fromArray(items) {
            return new $6h((writer) => {
                writer.emitMany(items);
            });
        }
        static fromPromise(promise) {
            return new $6h(async (emitter) => {
                emitter.emitMany(await promise);
            });
        }
        static fromPromises(promises) {
            return new $6h(async (emitter) => {
                await Promise.all(promises.map(async (p) => emitter.emitOne(await p)));
            });
        }
        static merge(iterables) {
            return new $6h(async (emitter) => {
                await Promise.all(iterables.map(async (iterable) => {
                    for await (const item of iterable) {
                        emitter.emitOne(item);
                    }
                }));
            });
        }
        static { this.EMPTY = $6h.fromArray([]); }
        constructor(executor, onReturn) {
            this.a = AsyncIterableSourceState.Initial;
            this.b = [];
            this.d = null;
            this.f = onReturn;
            this.g = new event_1.$le();
            queueMicrotask(async () => {
                const writer = {
                    emitOne: (item) => this.h(item),
                    emitMany: (items) => this.j(items),
                    reject: (error) => this.l(error)
                };
                try {
                    await Promise.resolve(executor(writer));
                    this.k();
                }
                catch (err) {
                    this.l(err);
                }
                finally {
                    writer.emitOne = undefined;
                    writer.emitMany = undefined;
                    writer.reject = undefined;
                }
            });
        }
        [Symbol.asyncIterator]() {
            let i = 0;
            return {
                next: async () => {
                    do {
                        if (this.a === AsyncIterableSourceState.DoneError) {
                            throw this.d;
                        }
                        if (i < this.b.length) {
                            return { done: false, value: this.b[i++] };
                        }
                        if (this.a === AsyncIterableSourceState.DoneOK) {
                            return { done: true, value: undefined };
                        }
                        await event_1.Event.toPromise(this.g.event);
                    } while (true);
                },
                return: async () => {
                    this.f?.();
                    return { done: true, value: undefined };
                }
            };
        }
        static map(iterable, mapFn) {
            return new $6h(async (emitter) => {
                for await (const item of iterable) {
                    emitter.emitOne(mapFn(item));
                }
            });
        }
        map(mapFn) {
            return $6h.map(this, mapFn);
        }
        static filter(iterable, filterFn) {
            return new $6h(async (emitter) => {
                for await (const item of iterable) {
                    if (filterFn(item)) {
                        emitter.emitOne(item);
                    }
                }
            });
        }
        filter(filterFn) {
            return $6h.filter(this, filterFn);
        }
        static coalesce(iterable) {
            return $6h.filter(iterable, item => !!item);
        }
        coalesce() {
            return $6h.coalesce(this);
        }
        static async toPromise(iterable) {
            const result = [];
            for await (const item of iterable) {
                result.push(item);
            }
            return result;
        }
        toPromise() {
            return $6h.toPromise(this);
        }
        /**
         * The value will be appended at the end.
         *
         * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
         */
        h(value) {
            if (this.a !== AsyncIterableSourceState.Initial) {
                return;
            }
            // it is important to add new values at the end,
            // as we may have iterators already running on the array
            this.b.push(value);
            this.g.fire();
        }
        /**
         * The values will be appended at the end.
         *
         * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
         */
        j(values) {
            if (this.a !== AsyncIterableSourceState.Initial) {
                return;
            }
            // it is important to add new values at the end,
            // as we may have iterators already running on the array
            this.b = this.b.concat(values);
            this.g.fire();
        }
        /**
         * Calling `resolve()` will mark the result array as complete.
         *
         * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
         * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
         */
        k() {
            if (this.a !== AsyncIterableSourceState.Initial) {
                return;
            }
            this.a = AsyncIterableSourceState.DoneOK;
            this.g.fire();
        }
        /**
         * Writing an error will permanently invalidate this iterable.
         * The current users will receive an error thrown, as will all future users.
         *
         * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
         */
        l(error) {
            if (this.a !== AsyncIterableSourceState.Initial) {
                return;
            }
            this.a = AsyncIterableSourceState.DoneError;
            this.d = error;
            this.g.fire();
        }
    }
    exports.$6h = $6h;
    class $7h extends $6h {
        constructor(m, executor) {
            super(executor);
            this.m = m;
        }
        cancel() {
            this.m.cancel();
        }
    }
    exports.$7h = $7h;
    function $8h(callback) {
        const source = new cancellation_1.$we();
        const innerIterable = callback(source.token);
        return new $7h(source, async (emitter) => {
            const subscription = source.token.onCancellationRequested(() => {
                subscription.dispose();
                source.dispose();
                emitter.reject(new errors_1.$4());
            });
            try {
                for await (const item of innerIterable) {
                    if (source.token.isCancellationRequested) {
                        // canceled in the meantime
                        return;
                    }
                    emitter.emitOne(item);
                }
                subscription.dispose();
                source.dispose();
            }
            catch (err) {
                subscription.dispose();
                source.dispose();
                emitter.reject(err);
            }
        });
    }
    class $9h {
        /**
         *
         * @param onReturn A function that will be called when consuming the async iterable
         * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.
         * This is NOT called when resolving this source by its owner.
         */
        constructor(onReturn) {
            this.a = new $3h();
            this.b = new $6h(emitter => {
                if (earlyError) {
                    emitter.reject(earlyError);
                    return;
                }
                if (earlyItems) {
                    emitter.emitMany(earlyItems);
                }
                this.d = (error) => emitter.reject(error);
                this.f = (item) => emitter.emitOne(item);
                return this.a.p;
            }, onReturn);
            let earlyError;
            let earlyItems;
            this.f = (item) => {
                if (!earlyItems) {
                    earlyItems = [];
                }
                earlyItems.push(item);
            };
            this.d = (error) => {
                if (!earlyError) {
                    earlyError = error;
                }
            };
        }
        get asyncIterable() {
            return this.b;
        }
        resolve() {
            this.a.complete();
        }
        reject(error) {
            this.d(error);
            this.a.complete();
        }
        emitOne(item) {
            this.f(item);
        }
    }
    exports.$9h = $9h;
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[41/*vs/base/common/glob*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,10/*vs/base/common/async*/,27/*vs/base/common/charCode*/,51/*vs/base/common/extpath*/,28/*vs/base/common/map*/,19/*vs/base/common/path*/,20/*vs/base/common/platform*/,12/*vs/base/common/strings*/]), function (require, exports, arrays_1, async_1, charCode_1, extpath_1, map_1, path_1, platform_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$xk = exports.$wk = void 0;
    exports.$vk = $vk;
    exports.$yk = $yk;
    exports.$zk = $zk;
    exports.$Ak = $Ak;
    exports.$Bk = $Bk;
    exports.$Ck = $Ck;
    exports.$Dk = $Dk;
    exports.$Ek = $Ek;
    function $vk() {
        return Object.create(null);
    }
    exports.$wk = '**';
    exports.$xk = '/';
    const PATH_REGEX = '[/\\\\]'; // any slash or backslash
    const NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    const ALL_FORWARD_SLASHES = /\//g;
    function starsToRegExp(starCount, isLastPattern) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern
                //           in which case also matches (Path Sep followed by Path Val)
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;
        }
    }
    function $yk(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        const segments = [];
        let inBraces = false;
        let inBrackets = false;
        let curVal = '';
        for (const char of pattern) {
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        let regEx = '';
        // Split up into segments for each slash found
        const segments = $yk(pattern, exports.$xk);
        // Special case where we only have globstars
        if (segments.every(segment => segment === exports.$wk)) {
            regEx = '.*';
        }
        // Build regex over segments
        else {
            let previousSegmentWasGlobStar = false;
            segments.forEach((segment, index) => {
                // Treat globstar specially
                if (segment === exports.$wk) {
                    // if we have more than one globstar after another, just ignore it
                    if (previousSegmentWasGlobStar) {
                        return;
                    }
                    regEx += starsToRegExp(2, index === segments.length - 1);
                }
                // Anything else, not globstar
                else {
                    // States
                    let inBraces = false;
                    let braceVal = '';
                    let inBrackets = false;
                    let bracketVal = '';
                    for (const char of segment) {
                        // Support brace expansion
                        if (char !== '}' && inBraces) {
                            braceVal += char;
                            continue;
                        }
                        // Support brackets
                        if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                            let res;
                            // range operator
                            if (char === '-') {
                                res = char;
                            }
                            // negation operator (only valid on first index in bracket)
                            else if ((char === '^' || char === '!') && !bracketVal) {
                                res = '^';
                            }
                            // glob split matching is not allowed within character ranges
                            // see http://man7.org/linux/man-pages/man7/glob.7.html
                            else if (char === exports.$xk) {
                                res = '';
                            }
                            // anything else gets escaped
                            else {
                                res = (0, strings_1.$hf)(char);
                            }
                            bracketVal += res;
                            continue;
                        }
                        switch (char) {
                            case '{':
                                inBraces = true;
                                continue;
                            case '[':
                                inBrackets = true;
                                continue;
                            case '}': {
                                const choices = $yk(braceVal, ',');
                                // Converts {foo,bar} => [foo|bar]
                                const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;
                                regEx += braceRegExp;
                                inBraces = false;
                                braceVal = '';
                                break;
                            }
                            case ']': {
                                regEx += ('[' + bracketVal + ']');
                                inBrackets = false;
                                bracketVal = '';
                                break;
                            }
                            case '?':
                                regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                                continue;
                            case '*':
                                regEx += starsToRegExp(1);
                                continue;
                            default:
                                regEx += (0, strings_1.$hf)(char);
                        }
                    }
                    // Tail: Add the slash we had split on if there is more to
                    // come and the remaining pattern is not a globstar
                    // For example if pattern: some/**/*.js we want the "/" after
                    // some to be included in the RegEx to prevent a folder called
                    // "something" to match as well.
                    if (index < segments.length - 1 && // more segments to come after this
                        (segments[index + 1] !== exports.$wk || // next segment is not **, or...
                            index + 2 < segments.length // ...next segment is ** but there is more segments after that
                        )) {
                        regEx += PATH_REGEX;
                    }
                }
                // update globstar state
                previousSegmentWasGlobStar = (segment === exports.$wk);
            });
        }
        return regEx;
    }
    // regexes to check for trivial glob patterns that just check for String#endsWith
    const T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    const T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
    const T3 = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
    const T3_2 = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
    const T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
    const T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
    const CACHE = new map_1.$Dc(10000); // bounded to 10000 elements
    const FALSE = function () {
        return false;
    };
    const NULL = function () {
        return null;
    };
    function parsePattern(arg1, options) {
        if (!arg1) {
            return NULL;
        }
        // Handle relative patterns
        let pattern;
        if (typeof arg1 !== 'string') {
            pattern = arg1.pattern;
        }
        else {
            pattern = arg1;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        const patternKey = `${pattern}_${!!options.trimForExclusions}`;
        let parsedPattern = CACHE.get(patternKey);
        if (parsedPattern) {
            return wrapRelativePattern(parsedPattern, arg1);
        }
        // Check for Trivials
        let match;
        if (T1.test(pattern)) {
            parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check
        }
        else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
            parsedPattern = trivia2(match[1], pattern);
        }
        else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
            parsedPattern = trivia3(pattern, options);
        }
        else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
            parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
        }
        else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
            parsedPattern = trivia4and5(match[1], pattern, false);
        }
        // Otherwise convert to pattern
        else {
            parsedPattern = toRegExp(pattern);
        }
        // Cache
        CACHE.set(patternKey, parsedPattern);
        return wrapRelativePattern(parsedPattern, arg1);
    }
    function wrapRelativePattern(parsedPattern, arg2) {
        if (typeof arg2 === 'string') {
            return parsedPattern;
        }
        const wrappedPattern = function (path, basename) {
            if (!(0, extpath_1.$Eg)(path, arg2.base, !platform_1.$l)) {
                // skip glob matching if `base` is not a parent of `path`
                return null;
            }
            // Given we have checked `base` being a parent of `path`,
            // we can now remove the `base` portion of the `path`
            // and only match on the remaining path components
            // For that we try to extract the portion of the `path`
            // that comes after the `base` portion. We have to account
            // for the fact that `base` might end in a path separator
            // (https://github.com/microsoft/vscode/issues/162498)
            return parsedPattern((0, strings_1.$mf)(path.substr(arg2.base.length), path_1.sep), basename);
        };
        // Make sure to preserve associated metadata
        wrappedPattern.allBasenames = parsedPattern.allBasenames;
        wrappedPattern.allPaths = parsedPattern.allPaths;
        wrappedPattern.basenames = parsedPattern.basenames;
        wrappedPattern.patterns = parsedPattern.patterns;
        return wrappedPattern;
    }
    function trimForExclusions(pattern, options) {
        return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
    }
    // common pattern: **/*.txt just need endsWith check
    function trivia1(base, pattern) {
        return function (path, basename) {
            return typeof path === 'string' && path.endsWith(base) ? pattern : null;
        };
    }
    // common pattern: **/some.txt just need basename check
    function trivia2(base, pattern) {
        const slashBase = `/${base}`;
        const backslashBase = `\\${base}`;
        const parsedPattern = function (path, basename) {
            if (typeof path !== 'string') {
                return null;
            }
            if (basename) {
                return basename === base ? pattern : null;
            }
            return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;
        };
        const basenames = [base];
        parsedPattern.basenames = basenames;
        parsedPattern.patterns = [pattern];
        parsedPattern.allBasenames = basenames;
        return parsedPattern;
    }
    // repetition of common patterns (see above) {**/*.txt,**/*.png}
    function trivia3(pattern, options) {
        const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)
            .split(',')
            .map(pattern => parsePattern(pattern, options))
            .filter(pattern => pattern !== NULL), pattern);
        const patternsLength = parsedPatterns.length;
        if (!patternsLength) {
            return NULL;
        }
        if (patternsLength === 1) {
            return parsedPatterns[0];
        }
        const parsedPattern = function (path, basename) {
            for (let i = 0, n = parsedPatterns.length; i < n; i++) {
                if (parsedPatterns[i](path, basename)) {
                    return pattern;
                }
            }
            return null;
        };
        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
        if (withBasenames) {
            parsedPattern.allBasenames = withBasenames.allBasenames;
        }
        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
        if (allPaths.length) {
            parsedPattern.allPaths = allPaths;
        }
        return parsedPattern;
    }
    // common patterns: **/something/else just need endsWith check, something/else just needs and equals check
    function trivia4and5(targetPath, pattern, matchPathEnds) {
        const usingPosixSep = path_1.sep === path_1.$gc.sep;
        const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, path_1.sep);
        const nativePathEnd = path_1.sep + nativePath;
        const targetPathEnd = path_1.$gc.sep + targetPath;
        let parsedPattern;
        if (matchPathEnds) {
            parsedPattern = function (path, basename) {
                return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;
            };
        }
        else {
            parsedPattern = function (path, basename) {
                return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;
            };
        }
        parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];
        return parsedPattern;
    }
    function toRegExp(pattern) {
        try {
            const regExp = new RegExp(`^${parseRegExp(pattern)}$`);
            return function (path) {
                regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!
                return typeof path === 'string' && regExp.test(path) ? pattern : null;
            };
        }
        catch (error) {
            return NULL;
        }
    }
    function $zk(arg1, path, hasSibling) {
        if (!arg1 || typeof path !== 'string') {
            return false;
        }
        return $Ak(arg1)(path, undefined, hasSibling);
    }
    function $Ak(arg1, options = {}) {
        if (!arg1) {
            return FALSE;
        }
        // Glob with String
        if (typeof arg1 === 'string' || $Bk(arg1)) {
            const parsedPattern = parsePattern(arg1, options);
            if (parsedPattern === NULL) {
                return FALSE;
            }
            const resultPattern = function (path, basename) {
                return !!parsedPattern(path, basename);
            };
            if (parsedPattern.allBasenames) {
                resultPattern.allBasenames = parsedPattern.allBasenames;
            }
            if (parsedPattern.allPaths) {
                resultPattern.allPaths = parsedPattern.allPaths;
            }
            return resultPattern;
        }
        // Glob with Expression
        return parsedExpression(arg1, options);
    }
    function $Bk(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return typeof rp.base === 'string' && typeof rp.pattern === 'string';
    }
    function $Ck(patternOrExpression) {
        return patternOrExpression.allBasenames || [];
    }
    function $Dk(patternOrExpression) {
        return patternOrExpression.allPaths || [];
    }
    function parsedExpression(expression, options) {
        const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
            .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))
            .filter(pattern => pattern !== NULL));
        const patternsLength = parsedPatterns.length;
        if (!patternsLength) {
            return NULL;
        }
        if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {
            if (patternsLength === 1) {
                return parsedPatterns[0];
            }
            const resultExpression = function (path, basename) {
                let resultPromises = undefined;
                for (let i = 0, n = parsedPatterns.length; i < n; i++) {
                    const result = parsedPatterns[i](path, basename);
                    if (typeof result === 'string') {
                        return result; // immediately return as soon as the first expression matches
                    }
                    // If the result is a promise, we have to keep it for
                    // later processing and await the result properly.
                    if ((0, async_1.$rh)(result)) {
                        if (!resultPromises) {
                            resultPromises = [];
                        }
                        resultPromises.push(result);
                    }
                }
                // With result promises, we have to loop over each and
                // await the result before we can return any result.
                if (resultPromises) {
                    return (async () => {
                        for (const resultPromise of resultPromises) {
                            const result = await resultPromise;
                            if (typeof result === 'string') {
                                return result;
                            }
                        }
                        return null;
                    })();
                }
                return null;
            };
            const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
            if (withBasenames) {
                resultExpression.allBasenames = withBasenames.allBasenames;
            }
            const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
            if (allPaths.length) {
                resultExpression.allPaths = allPaths;
            }
            return resultExpression;
        }
        const resultExpression = function (path, base, hasSibling) {
            let name = undefined;
            let resultPromises = undefined;
            for (let i = 0, n = parsedPatterns.length; i < n; i++) {
                // Pattern matches path
                const parsedPattern = parsedPatterns[i];
                if (parsedPattern.requiresSiblings && hasSibling) {
                    if (!base) {
                        base = (0, path_1.$nc)(path);
                    }
                    if (!name) {
                        name = base.substr(0, base.length - (0, path_1.$oc)(path).length);
                    }
                }
                const result = parsedPattern(path, base, name, hasSibling);
                if (typeof result === 'string') {
                    return result; // immediately return as soon as the first expression matches
                }
                // If the result is a promise, we have to keep it for
                // later processing and await the result properly.
                if ((0, async_1.$rh)(result)) {
                    if (!resultPromises) {
                        resultPromises = [];
                    }
                    resultPromises.push(result);
                }
            }
            // With result promises, we have to loop over each and
            // await the result before we can return any result.
            if (resultPromises) {
                return (async () => {
                    for (const resultPromise of resultPromises) {
                        const result = await resultPromise;
                        if (typeof result === 'string') {
                            return result;
                        }
                    }
                    return null;
                })();
            }
            return null;
        };
        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    function parseExpressionPattern(pattern, value, options) {
        if (value === false) {
            return NULL; // pattern is disabled
        }
        const parsedPattern = parsePattern(pattern, options);
        if (parsedPattern === NULL) {
            return NULL;
        }
        // Expression Pattern is <boolean>
        if (typeof value === 'boolean') {
            return parsedPattern;
        }
        // Expression Pattern is <SiblingClause>
        if (value) {
            const when = value.when;
            if (typeof when === 'string') {
                const result = (path, basename, name, hasSibling) => {
                    if (!hasSibling || !parsedPattern(path, basename)) {
                        return null;
                    }
                    const clausePattern = when.replace('$(basename)', () => name);
                    const matched = hasSibling(clausePattern);
                    return (0, async_1.$rh)(matched) ?
                        matched.then(match => match ? pattern : null) :
                        matched ? pattern : null;
                };
                result.requiresSiblings = true;
                return result;
            }
        }
        // Expression is anything
        return parsedPattern;
    }
    function aggregateBasenameMatches(parsedPatterns, result) {
        const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);
        if (basenamePatterns.length < 2) {
            return parsedPatterns;
        }
        const basenames = basenamePatterns.reduce((all, current) => {
            const basenames = current.basenames;
            return basenames ? all.concat(basenames) : all;
        }, []);
        let patterns;
        if (result) {
            patterns = [];
            for (let i = 0, n = basenames.length; i < n; i++) {
                patterns.push(result);
            }
        }
        else {
            patterns = basenamePatterns.reduce((all, current) => {
                const patterns = current.patterns;
                return patterns ? all.concat(patterns) : all;
            }, []);
        }
        const aggregate = function (path, basename) {
            if (typeof path !== 'string') {
                return null;
            }
            if (!basename) {
                let i;
                for (i = path.length; i > 0; i--) {
                    const ch = path.charCodeAt(i - 1);
                    if (ch === charCode_1.CharCode.Slash || ch === charCode_1.CharCode.Backslash) {
                        break;
                    }
                }
                basename = path.substr(i);
            }
            const index = basenames.indexOf(basename);
            return index !== -1 ? patterns[index] : null;
        };
        aggregate.basenames = basenames;
        aggregate.patterns = patterns;
        aggregate.allBasenames = basenames;
        const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);
        aggregatedPatterns.push(aggregate);
        return aggregatedPatterns;
    }
    function $Ek(patternsA, patternsB) {
        return (0, arrays_1.$tb)(patternsA, patternsB, (a, b) => {
            if (typeof a === 'string' && typeof b === 'string') {
                return a === b;
            }
            if (typeof a !== 'string' && typeof b !== 'string') {
                return a.base === b.base && a.pattern === b.pattern;
            }
            return false;
        });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[59/*vs/base/common/htmlContent*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,98/*vs/base/common/iconLabels*/,23/*vs/base/common/resources*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/]), function (require, exports, errors_1, iconLabels_1, resources_1, strings_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$4k = exports.MarkdownStringTextNewlineStyle = void 0;
    exports.$5k = $5k;
    exports.$6k = $6k;
    exports.$7k = $7k;
    exports.$8k = $8k;
    exports.$9k = $9k;
    exports.$0k = $0k;
    exports.$$k = $$k;
    exports.$_k = $_k;
    var MarkdownStringTextNewlineStyle;
    (function (MarkdownStringTextNewlineStyle) {
        MarkdownStringTextNewlineStyle[MarkdownStringTextNewlineStyle["Paragraph"] = 0] = "Paragraph";
        MarkdownStringTextNewlineStyle[MarkdownStringTextNewlineStyle["Break"] = 1] = "Break";
    })(MarkdownStringTextNewlineStyle || (exports.MarkdownStringTextNewlineStyle = MarkdownStringTextNewlineStyle = {}));
    class $4k {
        constructor(value = '', isTrustedOrOptions = false) {
            this.value = value;
            if (typeof this.value !== 'string') {
                throw (0, errors_1.$6)('value');
            }
            if (typeof isTrustedOrOptions === 'boolean') {
                this.isTrusted = isTrustedOrOptions;
                this.supportThemeIcons = false;
                this.supportHtml = false;
            }
            else {
                this.isTrusted = isTrustedOrOptions.isTrusted ?? undefined;
                this.supportThemeIcons = isTrustedOrOptions.supportThemeIcons ?? false;
                this.supportHtml = isTrustedOrOptions.supportHtml ?? false;
            }
        }
        appendText(value, newlineStyle = MarkdownStringTextNewlineStyle.Paragraph) {
            this.value += $8k(this.supportThemeIcons ? (0, iconLabels_1.$Xk)(value) : value) // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.
                .replace(/([ \t]+)/g, (_match, g1) => '&nbsp;'.repeat(g1.length)) // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.
                .replace(/\>/gm, '\\>') // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.
                .replace(/\n/g, newlineStyle === MarkdownStringTextNewlineStyle.Break ? '\\\n' : '\n\n'); // CodeQL [SM02383] The Markdown is fully sanitized after being rendered.
            return this;
        }
        appendMarkdown(value) {
            this.value += value;
            return this;
        }
        appendCodeblock(langId, code) {
            this.value += `\n${$9k(code, langId)}\n`;
            return this;
        }
        appendLink(target, label, title) {
            this.value += '[';
            this.value += this.c(label, ']');
            this.value += '](';
            this.value += this.c(String(target), ')');
            if (title) {
                this.value += ` "${this.c(this.c(title, '"'), ')')}"`;
            }
            this.value += ')';
            return this;
        }
        c(value, ch) {
            const r = new RegExp((0, strings_1.$hf)(ch), 'g');
            return value.replace(r, (match, offset) => {
                if (value.charAt(offset - 1) !== '\\') {
                    return `\\${match}`;
                }
                else {
                    return match;
                }
            });
        }
    }
    exports.$4k = $4k;
    function $5k(oneOrMany) {
        if ($6k(oneOrMany)) {
            return !oneOrMany.value;
        }
        else if (Array.isArray(oneOrMany)) {
            return oneOrMany.every($5k);
        }
        else {
            return true;
        }
    }
    function $6k(thing) {
        if (thing instanceof $4k) {
            return true;
        }
        else if (thing && typeof thing === 'object') {
            return typeof thing.value === 'string'
                && (typeof thing.isTrusted === 'boolean' || typeof thing.isTrusted === 'object' || thing.isTrusted === undefined)
                && (typeof thing.supportThemeIcons === 'boolean' || thing.supportThemeIcons === undefined);
        }
        return false;
    }
    function $7k(a, b) {
        if (a === b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else {
            return a.value === b.value
                && a.isTrusted === b.isTrusted
                && a.supportThemeIcons === b.supportThemeIcons
                && a.supportHtml === b.supportHtml
                && (a.baseUri === b.baseUri || !!a.baseUri && !!b.baseUri && (0, resources_1.$_g)(uri_1.URI.from(a.baseUri), uri_1.URI.from(b.baseUri)));
        }
    }
    function $8k(text) {
        // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
        return text.replace(/[\\`*_{}[\]()#+\-!~]/g, '\\$&'); // CodeQL [SM02383] Backslash is escaped in the character class
    }
    /**
     * @see https://github.com/microsoft/vscode/issues/193746
     */
    function $9k(code, langId) {
        const longestFenceLength = code.match(/^`+/gm)?.reduce((a, b) => (a.length > b.length ? a : b)).length ??
            0;
        const desiredFenceLength = longestFenceLength >= 3 ? longestFenceLength + 1 : 3;
        // the markdown result
        return [
            `${'`'.repeat(desiredFenceLength)}${langId}`,
            code,
            `${'`'.repeat(desiredFenceLength)}`,
        ].join('\n');
    }
    function $0k(input) {
        return input.replace(/"/g, '&quot;');
    }
    function $$k(text) {
        if (!text) {
            return text;
        }
        return text.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, '$1');
    }
    function $_k(href) {
        const dimensions = [];
        const splitted = href.split('|').map(s => s.trim());
        href = splitted[0];
        const parameters = splitted[1];
        if (parameters) {
            const heightFromParams = /height=(\d+)/.exec(parameters);
            const widthFromParams = /width=(\d+)/.exec(parameters);
            const height = heightFromParams ? heightFromParams[1] : '';
            const width = widthFromParams ? widthFromParams[1] : '';
            const widthIsFinite = isFinite(parseInt(width));
            const heightIsFinite = isFinite(parseInt(height));
            if (widthIsFinite) {
                dimensions.push(`width="${width}"`);
            }
            if (heightIsFinite) {
                dimensions.push(`height="${height}"`);
            }
        }
        return { href, dimensions };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[99/*vs/base/common/labels*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,51/*vs/base/common/extpath*/,19/*vs/base/common/path*/,20/*vs/base/common/platform*/,23/*vs/base/common/resources*/,12/*vs/base/common/strings*/]), function (require, exports, arrays_1, extpath_1, path_1, platform_1, resources_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Zw = $Zw;
    exports.$1w = $1w;
    exports.$2w = $2w;
    exports.$3w = $3w;
    exports.$4w = $4w;
    exports.$5w = $5w;
    exports.$6w = $6w;
    exports.$7w = $7w;
    exports.$8w = $8w;
    exports.$9w = $9w;
    function $Zw(resource, formatting) {
        const { os, tildify: tildifier, relative: relatifier } = formatting;
        // return early with a relative path if we can resolve one
        if (relatifier) {
            const relativePath = getRelativePathLabel(resource, relatifier, os);
            if (typeof relativePath === 'string') {
                return relativePath;
            }
        }
        // otherwise try to resolve a absolute path label and
        // apply target OS standard path separators if target
        // OS differs from actual OS we are running in
        let absolutePath = resource.fsPath;
        if (os === platform_1.OperatingSystem.Windows && !platform_1.$j) {
            absolutePath = absolutePath.replace(/\//g, '\\');
        }
        else if (os !== platform_1.OperatingSystem.Windows && platform_1.$j) {
            absolutePath = absolutePath.replace(/\\/g, '/');
        }
        // macOS/Linux: tildify with provided user home directory
        if (os !== platform_1.OperatingSystem.Windows && tildifier?.userHome) {
            const userHome = tildifier.userHome.fsPath;
            // This is a bit of a hack, but in order to figure out if the
            // resource is in the user home, we need to make sure to convert it
            // to a user home resource. We cannot assume that the resource is
            // already a user home resource.
            let userHomeCandidate;
            if (resource.scheme !== tildifier.userHome.scheme && resource.path[0] === path_1.$gc.sep && resource.path[1] !== path_1.$gc.sep) {
                userHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;
            }
            else {
                userHomeCandidate = absolutePath;
            }
            absolutePath = $2w(userHomeCandidate, userHome, os);
        }
        // normalize
        const pathLib = os === platform_1.OperatingSystem.Windows ? path_1.$fc : path_1.$gc;
        return pathLib.normalize($1w(absolutePath, os === platform_1.OperatingSystem.Windows));
    }
    function getRelativePathLabel(resource, relativePathProvider, os) {
        const pathLib = os === platform_1.OperatingSystem.Windows ? path_1.$fc : path_1.$gc;
        const extUriLib = os === platform_1.OperatingSystem.Linux ? resources_1.$9g : resources_1.$$g;
        const workspace = relativePathProvider.getWorkspace();
        const firstFolder = (0, arrays_1.$Nb)(workspace.folders);
        if (!firstFolder) {
            return undefined;
        }
        // This is a bit of a hack, but in order to figure out the folder
        // the resource belongs to, we need to make sure to convert it
        // to a workspace resource. We cannot assume that the resource is
        // already matching the workspace.
        if (resource.scheme !== firstFolder.uri.scheme && resource.path[0] === path_1.$gc.sep && resource.path[1] !== path_1.$gc.sep) {
            resource = firstFolder.uri.with({ path: resource.path });
        }
        const folder = relativePathProvider.getWorkspaceFolder(resource);
        if (!folder) {
            return undefined;
        }
        let relativePathLabel = undefined;
        if (extUriLib.isEqual(folder.uri, resource)) {
            relativePathLabel = ''; // no label if paths are identical
        }
        else {
            relativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';
        }
        // normalize
        if (relativePathLabel) {
            relativePathLabel = pathLib.normalize(relativePathLabel);
        }
        // always show root basename if there are multiple folders
        if (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {
            const rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);
            relativePathLabel = relativePathLabel ? `${rootName} • ${relativePathLabel}` : rootName;
        }
        return relativePathLabel;
    }
    function $1w(path, isWindowsOS = platform_1.$j) {
        if ((0, extpath_1.$Jg)(path, isWindowsOS)) {
            return path.charAt(0).toUpperCase() + path.slice(1);
        }
        return path;
    }
    let normalizedUserHomeCached = Object.create(null);
    function $2w(path, userHome, os = platform_1.OS) {
        if (os === platform_1.OperatingSystem.Windows || !path || !userHome) {
            return path; // unsupported on Windows
        }
        let normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;
        if (!normalizedUserHome) {
            normalizedUserHome = userHome;
            if (platform_1.$j) {
                normalizedUserHome = (0, extpath_1.$yg)(normalizedUserHome); // make sure that the path is POSIX normalized on Windows
            }
            normalizedUserHome = `${(0, strings_1.$nf)(normalizedUserHome, path_1.$gc.sep)}${path_1.$gc.sep}`;
            normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
        }
        let normalizedPath = path;
        if (platform_1.$j) {
            normalizedPath = (0, extpath_1.$yg)(normalizedPath); // make sure that the path is POSIX normalized on Windows
        }
        // Linux: case sensitive, macOS: case insensitive
        if (os === platform_1.OperatingSystem.Linux ? normalizedPath.startsWith(normalizedUserHome) : (0, strings_1.$Gf)(normalizedPath, normalizedUserHome)) {
            return `~/${normalizedPath.substr(normalizedUserHome.length)}`;
        }
        return path;
    }
    function $3w(path, userHome) {
        return path.replace(/^~($|\/|\\)/, `${userHome}$1`);
    }
    /**
     * Shortens the paths but keeps them easy to distinguish.
     * Replaces not important parts with ellipsis.
     * Every shorten path matches only one original path and vice versa.
     *
     * Algorithm for shortening paths is as follows:
     * 1. For every path in list, find unique substring of that path.
     * 2. Unique substring along with ellipsis is shortened path of that path.
     * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
     *    and if present segment is not substring to any other paths then present segment is unique path,
     *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
     *    if it is true take present segment as unique path.
     * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
     *
     * Example 1
     * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
     * 2. find unique path of first path,
     * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
     * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
     * 	c. 'd\\c' is suffix of path2.
     *  d. 'b\\c' is not suffix of present path.
     *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
     * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
     *
     * Example 2
     * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
     * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
     * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
     */
    const ellipsis = '\u2026';
    const unc = '\\\\';
    const home = '~';
    function $4w(paths, pathSeparator = path_1.sep) {
        const shortenedPaths = new Array(paths.length);
        // for every path
        let match = false;
        for (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            const originalPath = paths[pathIndex];
            if (originalPath === '') {
                shortenedPaths[pathIndex] = `.${pathSeparator}`;
                continue;
            }
            if (!originalPath) {
                shortenedPaths[pathIndex] = originalPath;
                continue;
            }
            match = true;
            // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
            let prefix = '';
            let trimmedPath = originalPath;
            if (trimmedPath.indexOf(unc) === 0) {
                prefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);
                trimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);
            }
            else if (trimmedPath.indexOf(pathSeparator) === 0) {
                prefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
                trimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);
            }
            else if (trimmedPath.indexOf(home) === 0) {
                prefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);
                trimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);
            }
            // pick the first shortest subpath found
            const segments = trimmedPath.split(pathSeparator);
            for (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
                for (let start = segments.length - subpathLength; match && start >= 0; start--) {
                    match = false;
                    let subpath = segments.slice(start, start + subpathLength).join(pathSeparator);
                    // that is unique to any other path
                    for (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                        // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                        if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
                            const isSubpathEnding = (start + subpathLength === segments.length);
                            // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
                            // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
                            const subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;
                            const isOtherPathEnding = paths[otherPathIndex].endsWith(subpathWithSep);
                            match = !isSubpathEnding || isOtherPathEnding;
                        }
                    }
                    // found unique subpath
                    if (!match) {
                        let result = '';
                        // preserve disk drive or root prefix
                        if (segments[0].endsWith(':') || prefix !== '') {
                            if (start === 1) {
                                // extend subpath to include disk drive prefix
                                start = 0;
                                subpathLength++;
                                subpath = segments[0] + pathSeparator + subpath;
                            }
                            if (start > 0) {
                                result = segments[0] + pathSeparator;
                            }
                            result = prefix + result;
                        }
                        // add ellipsis at the beginning if needed
                        if (start > 0) {
                            result = result + ellipsis + pathSeparator;
                        }
                        result = result + subpath;
                        // add ellipsis at the end if needed
                        if (start + subpathLength < segments.length) {
                            result = result + pathSeparator + ellipsis;
                        }
                        shortenedPaths[pathIndex] = result;
                    }
                }
            }
            if (match) {
                shortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found
            }
        }
        return shortenedPaths;
    }
    var Type;
    (function (Type) {
        Type[Type["TEXT"] = 0] = "TEXT";
        Type[Type["VARIABLE"] = 1] = "VARIABLE";
        Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
    })(Type || (Type = {}));
    /**
     * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
     * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
     * @param value string to which template is applied
     * @param values the values of the templates to use
     */
    function $5w(template, values = Object.create(null)) {
        const segments = [];
        let inVariable = false;
        let curVal = '';
        for (const char of template) {
            // Beginning of variable
            if (char === '$' || (inVariable && char === '{')) {
                if (curVal) {
                    segments.push({ value: curVal, type: Type.TEXT });
                }
                curVal = '';
                inVariable = true;
            }
            // End of variable
            else if (char === '}' && inVariable) {
                const resolved = values[curVal];
                // Variable
                if (typeof resolved === 'string') {
                    if (resolved.length) {
                        segments.push({ value: resolved, type: Type.VARIABLE });
                    }
                }
                // Separator
                else if (resolved) {
                    const prevSegment = segments[segments.length - 1];
                    if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
                        segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
                    }
                }
                curVal = '';
                inVariable = false;
            }
            // Text or Variable Name
            else {
                curVal += char;
            }
        }
        // Tail
        if (curVal && !inVariable) {
            segments.push({ value: curVal, type: Type.TEXT });
        }
        return segments.filter((segment, index) => {
            // Only keep separator if we have values to the left and right
            if (segment.type === Type.SEPARATOR) {
                const left = segments[index - 1];
                const right = segments[index + 1];
                return [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);
            }
            // accept any TEXT and VARIABLE
            return true;
        }).map(segment => segment.value).join('');
    }
    /**
     * Handles mnemonics for menu items. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via & character (replace && with &)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function $6w(label, forceDisableMnemonics) {
        if (platform_1.$k || forceDisableMnemonics) {
            return label.replace(/\(&&\w\)|&&/g, '').replace(/&/g, platform_1.$k ? '&' : '&&');
        }
        return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
    }
    /**
     * Handles mnemonics for buttons. Depending on OS:
     * - Windows: Supported via & character (replace && with & and & with && for escaping)
     * -   Linux: Supported via _ character (replace && with _)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function $7w(label, forceDisableMnemonics) {
        if (platform_1.$k || forceDisableMnemonics) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        if (platform_1.$j) {
            return label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');
        }
        return label.replace(/&&/g, '_');
    }
    function $8w(label) {
        return label.replace(/&/g, '&&');
    }
    /**
     * Splits a recent label in name and parent path, supporting both '/' and '\' and workspace suffixes.
     * If the location is remote, the remote name is included in the name part.
     */
    function $9w(recentLabel) {
        if (recentLabel.endsWith(']')) {
            // label with workspace suffix
            const lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);
            if (lastIndexOfSquareBracket !== -1) {
                const split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));
                const remoteNameWithSpace = recentLabel.substring(lastIndexOfSquareBracket);
                return { name: split.name + remoteNameWithSpace, parentPath: split.parentPath };
            }
        }
        return splitName(recentLabel);
    }
    function splitName(fullPath) {
        const p = fullPath.indexOf('/') !== -1 ? path_1.$gc : path_1.$fc;
        const name = p.basename(fullPath);
        const parentPath = p.dirname(fullPath);
        if (name.length) {
            return { name, parentPath };
        }
        // only the root segment
        return { name: parentPath, parentPath: '' };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[150/*vs/base/common/uriIpc*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,37/*vs/base/common/marshallingIds*/,2/*vs/base/common/uri*/]), function (require, exports, buffer_1, marshallingIds_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Nn = exports.$Mn = void 0;
    exports.$On = $On;
    exports.$Pn = $Pn;
    exports.$Qn = $Qn;
    function toJSON(uri) {
        return uri.toJSON();
    }
    class $Mn {
        constructor(uriTransformer) {
            this.a = uriTransformer;
        }
        transformIncoming(uri) {
            const result = this.a.transformIncoming(uri);
            return (result === uri ? uri : toJSON(uri_1.URI.from(result)));
        }
        transformOutgoing(uri) {
            const result = this.a.transformOutgoing(uri);
            return (result === uri ? uri : toJSON(uri_1.URI.from(result)));
        }
        transformOutgoingURI(uri) {
            const result = this.a.transformOutgoing(uri);
            return (result === uri ? uri : uri_1.URI.from(result));
        }
        transformOutgoingScheme(scheme) {
            return this.a.transformOutgoingScheme(scheme);
        }
    }
    exports.$Mn = $Mn;
    exports.$Nn = new class {
        transformIncoming(uri) {
            return uri;
        }
        transformOutgoing(uri) {
            return uri;
        }
        transformOutgoingURI(uri) {
            return uri;
        }
        transformOutgoingScheme(scheme) {
            return scheme;
        }
    };
    function _transformOutgoingURIs(obj, transformer, depth) {
        if (!obj || depth > 200) {
            return null;
        }
        if (typeof obj === 'object') {
            if (obj instanceof uri_1.URI) {
                return transformer.transformOutgoing(obj);
            }
            // walk object (or array)
            for (const key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    const r = _transformOutgoingURIs(obj[key], transformer, depth + 1);
                    if (r !== null) {
                        obj[key] = r;
                    }
                }
            }
        }
        return null;
    }
    function $On(obj, transformer) {
        const result = _transformOutgoingURIs(obj, transformer, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
    function _transformIncomingURIs(obj, transformer, revive, depth) {
        if (!obj || depth > 200) {
            return null;
        }
        if (typeof obj === 'object') {
            if (obj.$mid === marshallingIds_1.MarshalledId.Uri) {
                return revive ? uri_1.URI.revive(transformer.transformIncoming(obj)) : transformer.transformIncoming(obj);
            }
            if (obj instanceof buffer_1.$Ne) {
                return null;
            }
            // walk object (or array)
            for (const key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    const r = _transformIncomingURIs(obj[key], transformer, revive, depth + 1);
                    if (r !== null) {
                        obj[key] = r;
                    }
                }
            }
        }
        return null;
    }
    function $Pn(obj, transformer) {
        const result = _transformIncomingURIs(obj, transformer, false, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
    function $Qn(obj, transformer) {
        const result = _transformIncomingURIs(obj, transformer, true, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[38/*vs/base/common/uuid*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$2g = void 0;
    exports.$1g = $1g;
    const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function $1g(value) {
        return _UUIDPattern.test(value);
    }
    exports.$2g = (function () {
        // use `randomUUID` if possible
        if (typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {
            return crypto.randomUUID.bind(crypto);
        }
        // use `randomValues` if possible
        let getRandomValues;
        if (typeof crypto === 'object' && typeof crypto.getRandomValues === 'function') {
            getRandomValues = crypto.getRandomValues.bind(crypto);
        }
        else {
            getRandomValues = function (bucket) {
                for (let i = 0; i < bucket.length; i++) {
                    bucket[i] = Math.floor(Math.random() * 256);
                }
                return bucket;
            };
        }
        // prep-work
        const _data = new Uint8Array(16);
        const _hex = [];
        for (let i = 0; i < 256; i++) {
            _hex.push(i.toString(16).padStart(2, '0'));
        }
        return function generateUuid() {
            // get data
            getRandomValues(_data);
            // set version bits
            _data[6] = (_data[6] & 0x0f) | 0x40;
            _data[8] = (_data[8] & 0x3f) | 0x80;
            // print as string
            let i = 0;
            let result = '';
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += '-';
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += '-';
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += '-';
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += '-';
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            result += _hex[_data[i++]];
            return result;
        };
    })();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[151/*vs/base/common/dataTransfer*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,40/*vs/base/common/iterator*/,38/*vs/base/common/uuid*/]), function (require, exports, arrays_1, iterator_1, uuid_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$tu = exports.$ru = void 0;
    exports.$pu = $pu;
    exports.$qu = $qu;
    exports.$su = $su;
    function $pu(stringOrPromise) {
        return {
            asString: async () => stringOrPromise,
            asFile: () => undefined,
            value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,
        };
    }
    function $qu(fileName, uri, data) {
        const file = { id: (0, uuid_1.$2g)(), name: fileName, uri, data };
        return {
            asString: async () => '',
            asFile: () => file,
            value: undefined,
        };
    }
    class $ru {
        constructor() {
            this.a = new Map();
        }
        get size() {
            let size = 0;
            for (const _ of this.a) {
                size++;
            }
            return size;
        }
        has(mimeType) {
            return this.a.has(this.b(mimeType));
        }
        matches(pattern) {
            const mimes = [...this.a.keys()];
            if (iterator_1.Iterable.some(this, ([_, item]) => item.asFile())) {
                mimes.push('files');
            }
            return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);
        }
        get(mimeType) {
            return this.a.get(this.b(mimeType))?.[0];
        }
        /**
         * Add a new entry to this data transfer.
         *
         * This does not replace existing entries for `mimeType`.
         */
        append(mimeType, value) {
            const existing = this.a.get(mimeType);
            if (existing) {
                existing.push(value);
            }
            else {
                this.a.set(this.b(mimeType), [value]);
            }
        }
        /**
         * Set the entry for a given mime type.
         *
         * This replaces all existing entries for `mimeType`.
         */
        replace(mimeType, value) {
            this.a.set(this.b(mimeType), [value]);
        }
        /**
         * Remove all entries for `mimeType`.
         */
        delete(mimeType) {
            this.a.delete(this.b(mimeType));
        }
        /**
         * Iterate over all `[mime, item]` pairs in this data transfer.
         *
         * There may be multiple entries for each mime type.
         */
        *[Symbol.iterator]() {
            for (const [mine, items] of this.a) {
                for (const item of items) {
                    yield [mine, item];
                }
            }
        }
        b(mimeType) {
            return normalizeMimeType(mimeType);
        }
    }
    exports.$ru = $ru;
    function normalizeMimeType(mimeType) {
        return mimeType.toLowerCase();
    }
    function $su(pattern, mimeTypes) {
        return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));
    }
    function matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {
        // Anything wildcard
        if (normalizedPattern === '*/*') {
            return normalizedMimeTypes.length > 0;
        }
        // Exact match
        if (normalizedMimeTypes.includes(normalizedPattern)) {
            return true;
        }
        // Wildcard, such as `image/*`
        const wildcard = normalizedPattern.match(/^([a-z]+)\/([a-z]+|\*)$/i);
        if (!wildcard) {
            return false;
        }
        const [_, type, subtype] = wildcard;
        if (subtype === '*') {
            return normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));
        }
        return false;
    }
    exports.$tu = Object.freeze({
        // http://amundsen.com/hypermedia/urilist/
        create: (entries) => {
            return (0, arrays_1.$Lb)(entries.map(x => x.toString())).join('\r\n');
        },
        split: (str) => {
            return str.split('\r\n');
        },
        parse: (str) => {
            return exports.$tu.split(str).filter(value => !value.startsWith('#'));
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[152/*vs/base/parts/storage/common/storage*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,36/*vs/base/common/marshalling*/,14/*vs/base/common/types*/]), function (require, exports, async_1, event_1, lifecycle_1, marshalling_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$fq = exports.$eq = exports.StorageState = exports.StorageHint = void 0;
    exports.$dq = $dq;
    var StorageHint;
    (function (StorageHint) {
        // A hint to the storage that the storage
        // does not exist on disk yet. This allows
        // the storage library to improve startup
        // time by not checking the storage for data.
        StorageHint[StorageHint["STORAGE_DOES_NOT_EXIST"] = 0] = "STORAGE_DOES_NOT_EXIST";
        // A hint to the storage that the storage
        // is backed by an in-memory storage.
        StorageHint[StorageHint["STORAGE_IN_MEMORY"] = 1] = "STORAGE_IN_MEMORY";
    })(StorageHint || (exports.StorageHint = StorageHint = {}));
    function $dq(thing) {
        const candidate = thing;
        return candidate?.changed instanceof Map || candidate?.deleted instanceof Set;
    }
    var StorageState;
    (function (StorageState) {
        StorageState[StorageState["None"] = 0] = "None";
        StorageState[StorageState["Initialized"] = 1] = "Initialized";
        StorageState[StorageState["Closed"] = 2] = "Closed";
    })(StorageState || (exports.StorageState = StorageState = {}));
    class $eq extends lifecycle_1.$Uc {
        static { this.a = 100; }
        constructor(r, s = Object.create(null)) {
            super();
            this.r = r;
            this.s = s;
            this.b = this.B(new event_1.$oe());
            this.onDidChangeStorage = this.b.event;
            this.c = StorageState.None;
            this.f = new Map();
            this.g = this.B(new async_1.$Dh($eq.a));
            this.h = new Set();
            this.j = new Map();
            this.m = undefined;
            this.n = [];
            this.t();
        }
        t() {
            this.B(this.r.onDidChangeItemsExternal(e => this.u(e)));
        }
        u(e) {
            this.b.pause();
            try {
                // items that change external require us to update our
                // caches with the values. we just accept the value and
                // emit an event if there is a change.
                e.changed?.forEach((value, key) => this.w(key, value));
                e.deleted?.forEach(key => this.w(key, undefined));
            }
            finally {
                this.b.resume();
            }
        }
        w(key, value) {
            if (this.c === StorageState.Closed) {
                return; // Return early if we are already closed
            }
            let changed = false;
            // Item got removed, check for deletion
            if ((0, types_1.$ng)(value)) {
                changed = this.f.delete(key);
            }
            // Item got updated, check for change
            else {
                const currentValue = this.f.get(key);
                if (currentValue !== value) {
                    this.f.set(key, value);
                    changed = true;
                }
            }
            // Signal to outside listeners
            if (changed) {
                this.b.fire({ key, external: true });
            }
        }
        get items() {
            return this.f;
        }
        get size() {
            return this.f.size;
        }
        async init() {
            if (this.c !== StorageState.None) {
                return; // either closed or already initialized
            }
            this.c = StorageState.Initialized;
            if (this.s.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {
                // return early if we know the storage file does not exist. this is a performance
                // optimization to not load all items of the underlying storage if we know that
                // there can be no items because the storage does not exist.
                return;
            }
            this.f = await this.r.getItems();
        }
        get(key, fallbackValue) {
            const value = this.f.get(key);
            if ((0, types_1.$ng)(value)) {
                return fallbackValue;
            }
            return value;
        }
        getBoolean(key, fallbackValue) {
            const value = this.get(key);
            if ((0, types_1.$ng)(value)) {
                return fallbackValue;
            }
            return value === 'true';
        }
        getNumber(key, fallbackValue) {
            const value = this.get(key);
            if ((0, types_1.$ng)(value)) {
                return fallbackValue;
            }
            return parseInt(value, 10);
        }
        getObject(key, fallbackValue) {
            const value = this.get(key);
            if ((0, types_1.$ng)(value)) {
                return fallbackValue;
            }
            return (0, marshalling_1.$bi)(value);
        }
        async set(key, value, external = false) {
            if (this.c === StorageState.Closed) {
                return; // Return early if we are already closed
            }
            // We remove the key for undefined/null values
            if ((0, types_1.$ng)(value)) {
                return this.delete(key, external);
            }
            // Otherwise, convert to String and store
            const valueStr = (0, types_1.$gg)(value) || Array.isArray(value) ? (0, marshalling_1.$ai)(value) : String(value);
            // Return early if value already set
            const currentValue = this.f.get(key);
            if (currentValue === valueStr) {
                return;
            }
            // Update in cache and pending
            this.f.set(key, valueStr);
            this.j.set(key, valueStr);
            this.h.delete(key);
            // Event
            this.b.fire({ key, external });
            // Accumulate work by scheduling after timeout
            return this.D();
        }
        async delete(key, external = false) {
            if (this.c === StorageState.Closed) {
                return; // Return early if we are already closed
            }
            // Remove from cache and add to pending
            const wasDeleted = this.f.delete(key);
            if (!wasDeleted) {
                return; // Return early if value already deleted
            }
            if (!this.h.has(key)) {
                this.h.add(key);
            }
            this.j.delete(key);
            // Event
            this.b.fire({ key, external });
            // Accumulate work by scheduling after timeout
            return this.D();
        }
        async optimize() {
            if (this.c === StorageState.Closed) {
                return; // Return early if we are already closed
            }
            // Await pending data to be flushed to the DB
            // before attempting to optimize the DB
            await this.flush(0);
            return this.r.optimize();
        }
        async close() {
            if (!this.m) {
                this.m = this.y();
            }
            return this.m;
        }
        async y() {
            // Update state
            this.c = StorageState.Closed;
            // Trigger new flush to ensure data is persisted and then close
            // even if there is an error flushing. We must always ensure
            // the DB is closed to avoid corruption.
            //
            // Recovery: we pass our cache over as recovery option in case
            // the DB is not healthy.
            try {
                await this.D(0 /* as soon as possible */);
            }
            catch (error) {
                // Ignore
            }
            await this.r.close(() => this.f);
        }
        get z() {
            return this.j.size > 0 || this.h.size > 0;
        }
        async C() {
            if (!this.z) {
                return; // return early if nothing to do
            }
            // Get pending data
            const updateRequest = { insert: this.j, delete: this.h };
            // Reset pending data for next run
            this.h = new Set();
            this.j = new Map();
            // Update in storage and release any
            // waiters we have once done
            return this.r.updateItems(updateRequest).finally(() => {
                if (!this.z) {
                    while (this.n.length) {
                        this.n.pop()?.();
                    }
                }
            });
        }
        async flush(delay) {
            if (this.c === StorageState.Closed || // Return early if we are already closed
                this.m // return early if nothing to do
            ) {
                return;
            }
            return this.D(delay);
        }
        async D(delay) {
            if (this.s.hint === StorageHint.STORAGE_IN_MEMORY) {
                return this.C(); // return early if in-memory
            }
            return this.g.trigger(() => this.C(), delay);
        }
        async whenFlushed() {
            if (!this.z) {
                return; // return early if nothing to do
            }
            return new Promise(resolve => this.n.push(resolve));
        }
        isInMemory() {
            return this.s.hint === StorageHint.STORAGE_IN_MEMORY;
        }
    }
    exports.$eq = $eq;
    class $fq {
        constructor() {
            this.onDidChangeItemsExternal = event_1.Event.None;
            this.a = new Map();
        }
        async getItems() {
            return this.a;
        }
        async updateItems(request) {
            request.insert?.forEach((value, key) => this.a.set(key, value));
            request.delete?.forEach(key => this.a.delete(key));
        }
        async optimize() { }
        async close() { }
    }
    exports.$fq = $fq;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[153/*vs/editor/common/core/eolCounter*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/]), function (require, exports, charCode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringEOL = void 0;
    exports.$zu = $zu;
    var StringEOL;
    (function (StringEOL) {
        StringEOL[StringEOL["Unknown"] = 0] = "Unknown";
        StringEOL[StringEOL["Invalid"] = 3] = "Invalid";
        StringEOL[StringEOL["LF"] = 1] = "LF";
        StringEOL[StringEOL["CRLF"] = 2] = "CRLF";
    })(StringEOL || (exports.StringEOL = StringEOL = {}));
    function $zu(text) {
        let eolCount = 0;
        let firstLineLength = 0;
        let lastLineStart = 0;
        let eol = StringEOL.Unknown;
        for (let i = 0, len = text.length; i < len; i++) {
            const chr = text.charCodeAt(i);
            if (chr === charCode_1.CharCode.CarriageReturn) {
                if (eolCount === 0) {
                    firstLineLength = i;
                }
                eolCount++;
                if (i + 1 < len && text.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {
                    // \r\n... case
                    eol |= StringEOL.CRLF;
                    i++; // skip \n
                }
                else {
                    // \r... case
                    eol |= StringEOL.Invalid;
                }
                lastLineStart = i + 1;
            }
            else if (chr === charCode_1.CharCode.LineFeed) {
                // \n... case
                eol |= StringEOL.LF;
                if (eolCount === 0) {
                    firstLineLength = i;
                }
                eolCount++;
                lastLineStart = i + 1;
            }
        }
        if (eolCount === 0) {
            firstLineLength = text.length;
        }
        return [eolCount, firstLineLength, text.length - lastLineStart, eol];
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[154/*vs/editor/common/core/stringBuilder*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/strings*/,20/*vs/base/common/platform*/,22/*vs/base/common/buffer*/]), function (require, exports, strings, platform, buffer) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$eu = void 0;
    exports.$cu = $cu;
    exports.$du = $du;
    strings = __importStar(strings);
    platform = __importStar(platform);
    buffer = __importStar(buffer);
    let _utf16LE_TextDecoder;
    function getUTF16LE_TextDecoder() {
        if (!_utf16LE_TextDecoder) {
            _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');
        }
        return _utf16LE_TextDecoder;
    }
    let _utf16BE_TextDecoder;
    function getUTF16BE_TextDecoder() {
        if (!_utf16BE_TextDecoder) {
            _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');
        }
        return _utf16BE_TextDecoder;
    }
    let _platformTextDecoder;
    function $cu() {
        if (!_platformTextDecoder) {
            _platformTextDecoder = platform.$E() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();
        }
        return _platformTextDecoder;
    }
    function $du(source, offset, len) {
        const view = new Uint16Array(source.buffer, offset, len);
        if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {
            // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark
            // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)
            // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained
            // So we use the manual decoder
            return compatDecodeUTF16LE(source, offset, len);
        }
        return getUTF16LE_TextDecoder().decode(view);
    }
    function compatDecodeUTF16LE(source, offset, len) {
        const result = [];
        let resultLen = 0;
        for (let i = 0; i < len; i++) {
            const charCode = buffer.$Pe(source, offset);
            offset += 2;
            result[resultLen++] = String.fromCharCode(charCode);
        }
        return result.join('');
    }
    class $eu {
        constructor(capacity) {
            this.a = capacity | 0;
            this.b = new Uint16Array(this.a);
            this.c = null;
            this.d = 0;
        }
        reset() {
            this.c = null;
            this.d = 0;
        }
        build() {
            if (this.c !== null) {
                this.f();
                return this.c.join('');
            }
            return this.e();
        }
        e() {
            if (this.d === 0) {
                return '';
            }
            const view = new Uint16Array(this.b.buffer, 0, this.d);
            return $cu().decode(view);
        }
        f() {
            const bufferString = this.e();
            this.d = 0;
            if (this.c === null) {
                this.c = [bufferString];
            }
            else {
                this.c[this.c.length] = bufferString;
            }
        }
        /**
         * Append a char code (<2^16)
         */
        appendCharCode(charCode) {
            const remainingSpace = this.a - this.d;
            if (remainingSpace <= 1) {
                if (remainingSpace === 0 || strings.$Jf(charCode)) {
                    this.f();
                }
            }
            this.b[this.d++] = charCode;
        }
        /**
         * Append an ASCII char code (<2^8)
         */
        appendASCIICharCode(charCode) {
            if (this.d === this.a) {
                // buffer is full
                this.f();
            }
            this.b[this.d++] = charCode;
        }
        appendString(str) {
            const strLen = str.length;
            if (this.d + strLen >= this.a) {
                // This string does not fit in the remaining buffer space
                this.f();
                this.c[this.c.length] = str;
                return;
            }
            for (let i = 0; i < strLen; i++) {
                this.b[this.d++] = str.charCodeAt(i);
            }
        }
    }
    exports.$eu = $eu;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[155/*vs/editor/common/core/textChange*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,154/*vs/editor/common/core/stringBuilder*/]), function (require, exports, buffer, stringBuilder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$fu = void 0;
    exports.$gu = $gu;
    buffer = __importStar(buffer);
    function escapeNewLine(str) {
        return (str
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r'));
    }
    class $fu {
        get oldLength() {
            return this.oldText.length;
        }
        get oldEnd() {
            return this.oldPosition + this.oldText.length;
        }
        get newLength() {
            return this.newText.length;
        }
        get newEnd() {
            return this.newPosition + this.newText.length;
        }
        constructor(oldPosition, oldText, newPosition, newText) {
            this.oldPosition = oldPosition;
            this.oldText = oldText;
            this.newPosition = newPosition;
            this.newText = newText;
        }
        toString() {
            if (this.oldText.length === 0) {
                return `(insert@${this.oldPosition} "${escapeNewLine(this.newText)}")`;
            }
            if (this.newText.length === 0) {
                return `(delete@${this.oldPosition} "${escapeNewLine(this.oldText)}")`;
            }
            return `(replace@${this.oldPosition} "${escapeNewLine(this.oldText)}" with "${escapeNewLine(this.newText)}")`;
        }
        static a(str) {
            return (4 + 2 * str.length);
        }
        static c(b, str, offset) {
            const len = str.length;
            buffer.$Se(b, len, offset);
            offset += 4;
            for (let i = 0; i < len; i++) {
                buffer.$Qe(b, str.charCodeAt(i), offset);
                offset += 2;
            }
            return offset;
        }
        static d(b, offset) {
            const len = buffer.$Re(b, offset);
            offset += 4;
            return (0, stringBuilder_1.$du)(b, offset, len);
        }
        writeSize() {
            return (+4 // oldPosition
                + 4 // newPosition
                + $fu.a(this.oldText)
                + $fu.a(this.newText));
        }
        write(b, offset) {
            buffer.$Se(b, this.oldPosition, offset);
            offset += 4;
            buffer.$Se(b, this.newPosition, offset);
            offset += 4;
            offset = $fu.c(b, this.oldText, offset);
            offset = $fu.c(b, this.newText, offset);
            return offset;
        }
        static read(b, offset, dest) {
            const oldPosition = buffer.$Re(b, offset);
            offset += 4;
            const newPosition = buffer.$Re(b, offset);
            offset += 4;
            const oldText = $fu.d(b, offset);
            offset += $fu.a(oldText);
            const newText = $fu.d(b, offset);
            offset += $fu.a(newText);
            dest.push(new $fu(oldPosition, oldText, newPosition, newText));
            return offset;
        }
    }
    exports.$fu = $fu;
    function $gu(prevEdits, currEdits) {
        if (prevEdits === null || prevEdits.length === 0) {
            return currEdits;
        }
        const compressor = new TextChangeCompressor(prevEdits, currEdits);
        return compressor.compress();
    }
    class TextChangeCompressor {
        constructor(prevEdits, currEdits) {
            this.a = prevEdits;
            this.c = currEdits;
            this.d = [];
            this.e = 0;
            this.f = this.a.length;
            this.g = 0;
            this.h = this.c.length;
            this.j = 0;
        }
        compress() {
            let prevIndex = 0;
            let currIndex = 0;
            let prevEdit = this.n(prevIndex);
            let currEdit = this.l(currIndex);
            while (prevIndex < this.f || currIndex < this.h) {
                if (prevEdit === null) {
                    this.k(currEdit);
                    currEdit = this.l(++currIndex);
                    continue;
                }
                if (currEdit === null) {
                    this.m(prevEdit);
                    prevEdit = this.n(++prevIndex);
                    continue;
                }
                if (currEdit.oldEnd <= prevEdit.newPosition) {
                    this.k(currEdit);
                    currEdit = this.l(++currIndex);
                    continue;
                }
                if (prevEdit.newEnd <= currEdit.oldPosition) {
                    this.m(prevEdit);
                    prevEdit = this.n(++prevIndex);
                    continue;
                }
                if (currEdit.oldPosition < prevEdit.newPosition) {
                    const [e1, e2] = TextChangeCompressor.r(currEdit, prevEdit.newPosition - currEdit.oldPosition);
                    this.k(e1);
                    currEdit = e2;
                    continue;
                }
                if (prevEdit.newPosition < currEdit.oldPosition) {
                    const [e1, e2] = TextChangeCompressor.q(prevEdit, currEdit.oldPosition - prevEdit.newPosition);
                    this.m(e1);
                    prevEdit = e2;
                    continue;
                }
                // At this point, currEdit.oldPosition === prevEdit.newPosition
                let mergePrev;
                let mergeCurr;
                if (currEdit.oldEnd === prevEdit.newEnd) {
                    mergePrev = prevEdit;
                    mergeCurr = currEdit;
                    prevEdit = this.n(++prevIndex);
                    currEdit = this.l(++currIndex);
                }
                else if (currEdit.oldEnd < prevEdit.newEnd) {
                    const [e1, e2] = TextChangeCompressor.q(prevEdit, currEdit.oldLength);
                    mergePrev = e1;
                    mergeCurr = currEdit;
                    prevEdit = e2;
                    currEdit = this.l(++currIndex);
                }
                else {
                    const [e1, e2] = TextChangeCompressor.r(currEdit, prevEdit.newLength);
                    mergePrev = prevEdit;
                    mergeCurr = e1;
                    prevEdit = this.n(++prevIndex);
                    currEdit = e2;
                }
                this.d[this.e++] = new $fu(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);
                this.g += mergePrev.newLength - mergePrev.oldLength;
                this.j += mergeCurr.newLength - mergeCurr.oldLength;
            }
            const merged = TextChangeCompressor.s(this.d);
            const cleaned = TextChangeCompressor.t(merged);
            return cleaned;
        }
        k(currEdit) {
            this.d[this.e++] = TextChangeCompressor.o(this.g, currEdit);
            this.j += currEdit.newLength - currEdit.oldLength;
        }
        l(currIndex) {
            return (currIndex < this.h ? this.c[currIndex] : null);
        }
        m(prevEdit) {
            this.d[this.e++] = TextChangeCompressor.p(this.j, prevEdit);
            this.g += prevEdit.newLength - prevEdit.oldLength;
        }
        n(prevIndex) {
            return (prevIndex < this.f ? this.a[prevIndex] : null);
        }
        static o(prevDeltaOffset, currEdit) {
            return new $fu(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);
        }
        static p(currDeltaOffset, prevEdit) {
            return new $fu(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);
        }
        static q(edit, offset) {
            const preText = edit.newText.substr(0, offset);
            const postText = edit.newText.substr(offset);
            return [
                new $fu(edit.oldPosition, edit.oldText, edit.newPosition, preText),
                new $fu(edit.oldEnd, '', edit.newPosition + offset, postText)
            ];
        }
        static r(edit, offset) {
            const preText = edit.oldText.substr(0, offset);
            const postText = edit.oldText.substr(offset);
            return [
                new $fu(edit.oldPosition, preText, edit.newPosition, edit.newText),
                new $fu(edit.oldPosition + offset, postText, edit.newEnd, '')
            ];
        }
        static s(edits) {
            if (edits.length === 0) {
                return edits;
            }
            const result = [];
            let resultLen = 0;
            let prev = edits[0];
            for (let i = 1; i < edits.length; i++) {
                const curr = edits[i];
                if (prev.oldEnd === curr.oldPosition) {
                    // Merge into `prev`
                    prev = new $fu(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);
                }
                else {
                    result[resultLen++] = prev;
                    prev = curr;
                }
            }
            result[resultLen++] = prev;
            return result;
        }
        static t(edits) {
            if (edits.length === 0) {
                return edits;
            }
            const result = [];
            let resultLen = 0;
            for (let i = 0; i < edits.length; i++) {
                const edit = edits[i];
                if (edit.oldText === edit.newText) {
                    continue;
                }
                result[resultLen++] = edit;
            }
            return result;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[156/*vs/editor/common/core/textModelDefaults*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$lt = void 0;
    exports.$lt = {
        tabSize: 4,
        indentSize: 4,
        insertSpaces: true,
        detectIndentation: true,
        trimAutoWhitespace: true,
        largeFileOptimizations: true,
        bracketPairColorizationOptions: {
            enabled: true,
            independentColorPoolPerBracketType: false,
        },
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[157/*vs/editor/common/languageSelector*/], __M([1/*require*/,0/*exports*/,41/*vs/base/common/glob*/,19/*vs/base/common/path*/]), function (require, exports, glob_1, path_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$wu = $wu;
    exports.$xu = $xu;
    function $wu(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {
        if (Array.isArray(selector)) {
            // array -> take max individual value
            let ret = 0;
            for (const filter of selector) {
                const value = $wu(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);
                if (value === 10) {
                    return value; // already at the highest
                }
                if (value > ret) {
                    ret = value;
                }
            }
            return ret;
        }
        else if (typeof selector === 'string') {
            if (!candidateIsSynchronized) {
                return 0;
            }
            // short-hand notion, desugars to
            // 'fooLang' -> { language: 'fooLang'}
            // '*' -> { language: '*' }
            if (selector === '*') {
                return 5;
            }
            else if (selector === candidateLanguage) {
                return 10;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            // filter -> select accordingly, use defaults for scheme
            const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768
            if (!candidateIsSynchronized && !hasAccessToAllModels) {
                return 0;
            }
            // selector targets a notebook -> use the notebook uri instead
            // of the "normal" document uri.
            if (notebookType && candidateNotebookUri) {
                candidateUri = candidateNotebookUri;
            }
            let ret = 0;
            if (scheme) {
                if (scheme === candidateUri.scheme) {
                    ret = 10;
                }
                else if (scheme === '*') {
                    ret = 5;
                }
                else {
                    return 0;
                }
            }
            if (language) {
                if (language === candidateLanguage) {
                    ret = 10;
                }
                else if (language === '*') {
                    ret = Math.max(ret, 5);
                }
                else {
                    return 0;
                }
            }
            if (notebookType) {
                if (notebookType === candidateNotebookType) {
                    ret = 10;
                }
                else if (notebookType === '*' && candidateNotebookType !== undefined) {
                    ret = Math.max(ret, 5);
                }
                else {
                    return 0;
                }
            }
            if (pattern) {
                let normalizedPattern;
                if (typeof pattern === 'string') {
                    normalizedPattern = pattern;
                }
                else {
                    // Since this pattern has a `base` property, we need
                    // to normalize this path first before passing it on
                    // because we will compare it against `Uri.fsPath`
                    // which uses platform specific separators.
                    // Refs: https://github.com/microsoft/vscode/issues/99938
                    normalizedPattern = { ...pattern, base: (0, path_1.$hc)(pattern.base) };
                }
                if (normalizedPattern === candidateUri.fsPath || (0, glob_1.$zk)(normalizedPattern, candidateUri.fsPath)) {
                    ret = 10;
                }
                else {
                    return 0;
                }
            }
            return ret;
        }
        else {
            return 0;
        }
    }
    function $xu(selector) {
        if (typeof selector === 'string') {
            return false;
        }
        else if (Array.isArray(selector)) {
            return selector.some($xu);
        }
        else {
            return !!selector.notebookType;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[158/*vs/editor/common/languages/languageConfiguration*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,159/*vs/editor/common/encodedTokenAttributes*/]), function (require, exports, charCode_1, encodedTokenAttributes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Xu = exports.$Wu = exports.IndentAction = void 0;
    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    var IndentAction;
    (function (IndentAction) {
        /**
         * Insert new line and copy the previous line's indentation.
         */
        IndentAction[IndentAction["None"] = 0] = "None";
        /**
         * Insert new line and indent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        /**
         * Insert new line and outdent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(IndentAction || (exports.IndentAction = IndentAction = {}));
    /**
     * @internal
     */
    class $Wu {
        constructor(source) {
            this.e = null;
            this.f = false;
            this.open = source.open;
            this.close = source.close;
            // initially allowed in all tokens
            this.b = true;
            this.c = true;
            this.d = true;
            if (Array.isArray(source.notIn)) {
                for (let i = 0, len = source.notIn.length; i < len; i++) {
                    const notIn = source.notIn[i];
                    switch (notIn) {
                        case 'string':
                            this.b = false;
                            break;
                        case 'comment':
                            this.c = false;
                            break;
                        case 'regex':
                            this.d = false;
                            break;
                    }
                }
            }
        }
        isOK(standardToken) {
            switch (standardToken) {
                case encodedTokenAttributes_1.StandardTokenType.Other:
                    return true;
                case encodedTokenAttributes_1.StandardTokenType.Comment:
                    return this.c;
                case encodedTokenAttributes_1.StandardTokenType.String:
                    return this.b;
                case encodedTokenAttributes_1.StandardTokenType.RegEx:
                    return this.d;
            }
        }
        shouldAutoClose(context, column) {
            // Always complete on empty line
            if (context.getTokenCount() === 0) {
                return true;
            }
            const tokenIndex = context.findTokenIndexAtOffset(column - 2);
            const standardTokenType = context.getStandardTokenType(tokenIndex);
            return this.isOK(standardTokenType);
        }
        g(fromCharCode, toCharCode) {
            for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {
                const character = String.fromCharCode(charCode);
                if (!this.open.includes(character) && !this.close.includes(character)) {
                    return character;
                }
            }
            return null;
        }
        /**
         * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
         */
        findNeutralCharacter() {
            if (!this.f) {
                this.f = true;
                if (!this.e) {
                    this.e = this.g(charCode_1.CharCode.Digit0, charCode_1.CharCode.Digit9);
                }
                if (!this.e) {
                    this.e = this.g(charCode_1.CharCode.a, charCode_1.CharCode.z);
                }
                if (!this.e) {
                    this.e = this.g(charCode_1.CharCode.A, charCode_1.CharCode.Z);
                }
            }
            return this.e;
        }
    }
    exports.$Wu = $Wu;
    /**
     * @internal
     */
    class $Xu {
        constructor(autoClosingPairs) {
            this.autoClosingPairsOpenByStart = new Map();
            this.autoClosingPairsOpenByEnd = new Map();
            this.autoClosingPairsCloseByStart = new Map();
            this.autoClosingPairsCloseByEnd = new Map();
            this.autoClosingPairsCloseSingleChar = new Map();
            for (const pair of autoClosingPairs) {
                appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);
                appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);
                appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);
                appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);
                if (pair.close.length === 1 && pair.open.length === 1) {
                    appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
                }
            }
        }
    }
    exports.$Xu = $Xu;
    function appendEntry(target, key, value) {
        if (target.has(key)) {
            target.get(key).push(value);
        }
        else {
            target.set(key, [value]);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[160/*vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$bD = exports.NodeColor = exports.$aD = void 0;
    exports.$cD = $cD;
    exports.$dD = $dD;
    exports.$eD = $eD;
    exports.$fD = $fD;
    exports.$gD = $gD;
    exports.$hD = $hD;
    exports.$iD = $iD;
    exports.$jD = $jD;
    class $aD {
        constructor(piece, color) {
            this.piece = piece;
            this.color = color;
            this.size_left = 0;
            this.lf_left = 0;
            this.parent = this;
            this.left = this;
            this.right = this;
        }
        next() {
            if (this.right !== exports.$bD) {
                return $cD(this.right);
            }
            let node = this;
            while (node.parent !== exports.$bD) {
                if (node.parent.left === node) {
                    break;
                }
                node = node.parent;
            }
            if (node.parent === exports.$bD) {
                return exports.$bD;
            }
            else {
                return node.parent;
            }
        }
        prev() {
            if (this.left !== exports.$bD) {
                return $dD(this.left);
            }
            let node = this;
            while (node.parent !== exports.$bD) {
                if (node.parent.right === node) {
                    break;
                }
                node = node.parent;
            }
            if (node.parent === exports.$bD) {
                return exports.$bD;
            }
            else {
                return node.parent;
            }
        }
        detach() {
            this.parent = null;
            this.left = null;
            this.right = null;
        }
    }
    exports.$aD = $aD;
    var NodeColor;
    (function (NodeColor) {
        NodeColor[NodeColor["Black"] = 0] = "Black";
        NodeColor[NodeColor["Red"] = 1] = "Red";
    })(NodeColor || (exports.NodeColor = NodeColor = {}));
    exports.$bD = new $aD(null, NodeColor.Black);
    exports.$bD.parent = exports.$bD;
    exports.$bD.left = exports.$bD;
    exports.$bD.right = exports.$bD;
    exports.$bD.color = NodeColor.Black;
    function $cD(node) {
        while (node.left !== exports.$bD) {
            node = node.left;
        }
        return node;
    }
    function $dD(node) {
        while (node.right !== exports.$bD) {
            node = node.right;
        }
        return node;
    }
    function calculateSize(node) {
        if (node === exports.$bD) {
            return 0;
        }
        return node.size_left + node.piece.length + calculateSize(node.right);
    }
    function calculateLF(node) {
        if (node === exports.$bD) {
            return 0;
        }
        return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);
    }
    function resetSentinel() {
        exports.$bD.parent = exports.$bD;
    }
    function $eD(tree, x) {
        const y = x.right;
        // fix size_left
        y.size_left += x.size_left + (x.piece ? x.piece.length : 0);
        y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
        x.right = y.left;
        if (y.left !== exports.$bD) {
            y.left.parent = x;
        }
        y.parent = x.parent;
        if (x.parent === exports.$bD) {
            tree.root = y;
        }
        else if (x.parent.left === x) {
            x.parent.left = y;
        }
        else {
            x.parent.right = y;
        }
        y.left = x;
        x.parent = y;
    }
    function $fD(tree, y) {
        const x = y.left;
        y.left = x.right;
        if (x.right !== exports.$bD) {
            x.right.parent = y;
        }
        x.parent = y.parent;
        // fix size_left
        y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);
        y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);
        if (y.parent === exports.$bD) {
            tree.root = x;
        }
        else if (y === y.parent.right) {
            y.parent.right = x;
        }
        else {
            y.parent.left = x;
        }
        x.right = y;
        y.parent = x;
    }
    function $gD(tree, z) {
        let x;
        let y;
        if (z.left === exports.$bD) {
            y = z;
            x = y.right;
        }
        else if (z.right === exports.$bD) {
            y = z;
            x = y.left;
        }
        else {
            y = $cD(z.right);
            x = y.right;
        }
        if (y === tree.root) {
            tree.root = x;
            // if x is null, we are removing the only node
            x.color = NodeColor.Black;
            z.detach();
            resetSentinel();
            tree.root.parent = exports.$bD;
            return;
        }
        const yWasRed = (y.color === NodeColor.Red);
        if (y === y.parent.left) {
            y.parent.left = x;
        }
        else {
            y.parent.right = x;
        }
        if (y === z) {
            x.parent = y.parent;
            $jD(tree, x);
        }
        else {
            if (y.parent === z) {
                x.parent = y;
            }
            else {
                x.parent = y.parent;
            }
            // as we make changes to x's hierarchy, update size_left of subtree first
            $jD(tree, x);
            y.left = z.left;
            y.right = z.right;
            y.parent = z.parent;
            y.color = z.color;
            if (z === tree.root) {
                tree.root = y;
            }
            else {
                if (z === z.parent.left) {
                    z.parent.left = y;
                }
                else {
                    z.parent.right = y;
                }
            }
            if (y.left !== exports.$bD) {
                y.left.parent = y;
            }
            if (y.right !== exports.$bD) {
                y.right.parent = y;
            }
            // update metadata
            // we replace z with y, so in this sub tree, the length change is z.item.length
            y.size_left = z.size_left;
            y.lf_left = z.lf_left;
            $jD(tree, y);
        }
        z.detach();
        if (x.parent.left === x) {
            const newSizeLeft = calculateSize(x);
            const newLFLeft = calculateLF(x);
            if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {
                const delta = newSizeLeft - x.parent.size_left;
                const lf_delta = newLFLeft - x.parent.lf_left;
                x.parent.size_left = newSizeLeft;
                x.parent.lf_left = newLFLeft;
                $iD(tree, x.parent, delta, lf_delta);
            }
        }
        $jD(tree, x.parent);
        if (yWasRed) {
            resetSentinel();
            return;
        }
        // RB-DELETE-FIXUP
        let w;
        while (x !== tree.root && x.color === NodeColor.Black) {
            if (x === x.parent.left) {
                w = x.parent.right;
                if (w.color === NodeColor.Red) {
                    w.color = NodeColor.Black;
                    x.parent.color = NodeColor.Red;
                    $eD(tree, x.parent);
                    w = x.parent.right;
                }
                if (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {
                    w.color = NodeColor.Red;
                    x = x.parent;
                }
                else {
                    if (w.right.color === NodeColor.Black) {
                        w.left.color = NodeColor.Black;
                        w.color = NodeColor.Red;
                        $fD(tree, w);
                        w = x.parent.right;
                    }
                    w.color = x.parent.color;
                    x.parent.color = NodeColor.Black;
                    w.right.color = NodeColor.Black;
                    $eD(tree, x.parent);
                    x = tree.root;
                }
            }
            else {
                w = x.parent.left;
                if (w.color === NodeColor.Red) {
                    w.color = NodeColor.Black;
                    x.parent.color = NodeColor.Red;
                    $fD(tree, x.parent);
                    w = x.parent.left;
                }
                if (w.left.color === NodeColor.Black && w.right.color === NodeColor.Black) {
                    w.color = NodeColor.Red;
                    x = x.parent;
                }
                else {
                    if (w.left.color === NodeColor.Black) {
                        w.right.color = NodeColor.Black;
                        w.color = NodeColor.Red;
                        $eD(tree, w);
                        w = x.parent.left;
                    }
                    w.color = x.parent.color;
                    x.parent.color = NodeColor.Black;
                    w.left.color = NodeColor.Black;
                    $fD(tree, x.parent);
                    x = tree.root;
                }
            }
        }
        x.color = NodeColor.Black;
        resetSentinel();
    }
    function $hD(tree, x) {
        $jD(tree, x);
        while (x !== tree.root && x.parent.color === NodeColor.Red) {
            if (x.parent === x.parent.parent.left) {
                const y = x.parent.parent.right;
                if (y.color === NodeColor.Red) {
                    x.parent.color = NodeColor.Black;
                    y.color = NodeColor.Black;
                    x.parent.parent.color = NodeColor.Red;
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.right) {
                        x = x.parent;
                        $eD(tree, x);
                    }
                    x.parent.color = NodeColor.Black;
                    x.parent.parent.color = NodeColor.Red;
                    $fD(tree, x.parent.parent);
                }
            }
            else {
                const y = x.parent.parent.left;
                if (y.color === NodeColor.Red) {
                    x.parent.color = NodeColor.Black;
                    y.color = NodeColor.Black;
                    x.parent.parent.color = NodeColor.Red;
                    x = x.parent.parent;
                }
                else {
                    if (x === x.parent.left) {
                        x = x.parent;
                        $fD(tree, x);
                    }
                    x.parent.color = NodeColor.Black;
                    x.parent.parent.color = NodeColor.Red;
                    $eD(tree, x.parent.parent);
                }
            }
        }
        tree.root.color = NodeColor.Black;
    }
    function $iD(tree, x, delta, lineFeedCntDelta) {
        // node length change or line feed count change
        while (x !== tree.root && x !== exports.$bD) {
            if (x.parent.left === x) {
                x.parent.size_left += delta;
                x.parent.lf_left += lineFeedCntDelta;
            }
            x = x.parent;
        }
    }
    function $jD(tree, x) {
        let delta = 0;
        let lf_delta = 0;
        if (x === tree.root) {
            return;
        }
        // go upwards till the node whose left subtree is changed.
        while (x !== tree.root && x === x.parent.right) {
            x = x.parent;
        }
        if (x === tree.root) {
            // well, it means we add a node to the end (inorder)
            return;
        }
        // x is the node whose right subtree is changed.
        x = x.parent;
        delta = calculateSize(x.left) - x.size_left;
        lf_delta = calculateLF(x.left) - x.lf_left;
        x.size_left += delta;
        x.lf_left += lf_delta;
        // go upwards till root. O(logN)
        while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {
            if (x.parent.left === x) {
                x.parent.size_left += delta;
                x.parent.lf_left += lf_delta;
            }
            x = x.parent;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[100/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,101/*vs/editor/common/core/position*/,32/*vs/editor/common/core/range*/,52/*vs/editor/common/model*/,160/*vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase*/,102/*vs/editor/common/model/textModelSearch*/]), function (require, exports, charCode_1, position_1, range_1, model_1, rbTreeBase_1, textModelSearch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$uD = exports.$tD = exports.$sD = void 0;
    exports.$qD = $qD;
    exports.$rD = $rD;
    // const lfRegex = new RegExp(/\r\n|\r|\n/g);
    const AverageBufferSize = 65535;
    function createUintArray(arr) {
        let r;
        if (arr[arr.length - 1] < 65536) {
            r = new Uint16Array(arr.length);
        }
        else {
            r = new Uint32Array(arr.length);
        }
        r.set(arr, 0);
        return r;
    }
    class LineStarts {
        constructor(lineStarts, cr, lf, crlf, isBasicASCII) {
            this.lineStarts = lineStarts;
            this.cr = cr;
            this.lf = lf;
            this.crlf = crlf;
            this.isBasicASCII = isBasicASCII;
        }
    }
    function $qD(str, readonly = true) {
        const r = [0];
        let rLength = 1;
        for (let i = 0, len = str.length; i < len; i++) {
            const chr = str.charCodeAt(i);
            if (chr === charCode_1.CharCode.CarriageReturn) {
                if (i + 1 < len && str.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {
                    // \r\n... case
                    r[rLength++] = i + 2;
                    i++; // skip \n
                }
                else {
                    // \r... case
                    r[rLength++] = i + 1;
                }
            }
            else if (chr === charCode_1.CharCode.LineFeed) {
                r[rLength++] = i + 1;
            }
        }
        if (readonly) {
            return createUintArray(r);
        }
        else {
            return r;
        }
    }
    function $rD(r, str) {
        r.length = 0;
        r[0] = 0;
        let rLength = 1;
        let cr = 0, lf = 0, crlf = 0;
        let isBasicASCII = true;
        for (let i = 0, len = str.length; i < len; i++) {
            const chr = str.charCodeAt(i);
            if (chr === charCode_1.CharCode.CarriageReturn) {
                if (i + 1 < len && str.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {
                    // \r\n... case
                    crlf++;
                    r[rLength++] = i + 2;
                    i++; // skip \n
                }
                else {
                    cr++;
                    // \r... case
                    r[rLength++] = i + 1;
                }
            }
            else if (chr === charCode_1.CharCode.LineFeed) {
                lf++;
                r[rLength++] = i + 1;
            }
            else {
                if (isBasicASCII) {
                    if (chr !== charCode_1.CharCode.Tab && (chr < 32 || chr > 126)) {
                        isBasicASCII = false;
                    }
                }
            }
        }
        const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);
        r.length = 0;
        return result;
    }
    class $sD {
        constructor(bufferIndex, start, end, lineFeedCnt, length) {
            this.bufferIndex = bufferIndex;
            this.start = start;
            this.end = end;
            this.lineFeedCnt = lineFeedCnt;
            this.length = length;
        }
    }
    exports.$sD = $sD;
    class $tD {
        constructor(buffer, lineStarts) {
            this.buffer = buffer;
            this.lineStarts = lineStarts;
        }
    }
    exports.$tD = $tD;
    /**
     * Readonly snapshot for piece tree.
     * In a real multiple thread environment, to make snapshot reading always work correctly, we need to
     * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.
     * 2. TreeNode/Buffers normalization should not happen during snapshot reading.
     */
    class PieceTreeSnapshot {
        constructor(tree, BOM) {
            this.a = [];
            this.c = tree;
            this.d = BOM;
            this.b = 0;
            if (tree.root !== rbTreeBase_1.$bD) {
                tree.iterate(tree.root, node => {
                    if (node !== rbTreeBase_1.$bD) {
                        this.a.push(node.piece);
                    }
                    return true;
                });
            }
        }
        read() {
            if (this.a.length === 0) {
                if (this.b === 0) {
                    this.b++;
                    return this.d;
                }
                else {
                    return null;
                }
            }
            if (this.b > this.a.length - 1) {
                return null;
            }
            if (this.b === 0) {
                return this.d + this.c.getPieceContent(this.a[this.b++]);
            }
            return this.c.getPieceContent(this.a[this.b++]);
        }
    }
    class PieceTreeSearchCache {
        constructor(limit) {
            this.a = limit;
            this.b = [];
        }
        get(offset) {
            for (let i = this.b.length - 1; i >= 0; i--) {
                const nodePos = this.b[i];
                if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {
                    return nodePos;
                }
            }
            return null;
        }
        get2(lineNumber) {
            for (let i = this.b.length - 1; i >= 0; i--) {
                const nodePos = this.b[i];
                if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {
                    return nodePos;
                }
            }
            return null;
        }
        set(nodePosition) {
            if (this.b.length >= this.a) {
                this.b.shift();
            }
            this.b.push(nodePosition);
        }
        validate(offset) {
            let hasInvalidVal = false;
            const tmp = this.b;
            for (let i = 0; i < tmp.length; i++) {
                const nodePos = tmp[i];
                if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {
                    tmp[i] = null;
                    hasInvalidVal = true;
                    continue;
                }
            }
            if (hasInvalidVal) {
                const newArr = [];
                for (const entry of tmp) {
                    if (entry !== null) {
                        newArr.push(entry);
                    }
                }
                this.b = newArr;
            }
        }
    }
    class $uD {
        constructor(chunks, eol, eolNormalized) {
            this.create(chunks, eol, eolNormalized);
        }
        create(chunks, eol, eolNormalized) {
            this.a = [
                new $tD('', [0])
            ];
            this.g = { line: 0, column: 0 };
            this.root = rbTreeBase_1.$bD;
            this.b = 1;
            this.c = 0;
            this.d = eol;
            this.e = eol.length;
            this.f = eolNormalized;
            let lastNode = null;
            for (let i = 0, len = chunks.length; i < len; i++) {
                if (chunks[i].buffer.length > 0) {
                    if (!chunks[i].lineStarts) {
                        chunks[i].lineStarts = $qD(chunks[i].buffer);
                    }
                    const piece = new $sD(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);
                    this.a.push(chunks[i]);
                    lastNode = this.S(lastNode, piece);
                }
            }
            this.h = new PieceTreeSearchCache(1);
            this.j = { lineNumber: 0, value: '' };
            this.y();
        }
        normalizeEOL(eol) {
            const averageBufferSize = AverageBufferSize;
            const min = averageBufferSize - Math.floor(averageBufferSize / 3);
            const max = min * 2;
            let tempChunk = '';
            let tempChunkLen = 0;
            const chunks = [];
            this.iterate(this.root, node => {
                const str = this.R(node);
                const len = str.length;
                if (tempChunkLen <= min || tempChunkLen + len < max) {
                    tempChunk += str;
                    tempChunkLen += len;
                    return true;
                }
                // flush anyways
                const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
                chunks.push(new $tD(text, $qD(text)));
                tempChunk = str;
                tempChunkLen = len;
                return true;
            });
            if (tempChunkLen > 0) {
                const text = tempChunk.replace(/\r\n|\r|\n/g, eol);
                chunks.push(new $tD(text, $qD(text)));
            }
            this.create(chunks, eol, true);
        }
        // #region Buffer API
        getEOL() {
            return this.d;
        }
        setEOL(newEOL) {
            this.d = newEOL;
            this.e = this.d.length;
            this.normalizeEOL(newEOL);
        }
        createSnapshot(BOM) {
            return new PieceTreeSnapshot(this, BOM);
        }
        equal(other) {
            if (this.getLength() !== other.getLength()) {
                return false;
            }
            if (this.getLineCount() !== other.getLineCount()) {
                return false;
            }
            let offset = 0;
            const ret = this.iterate(this.root, node => {
                if (node === rbTreeBase_1.$bD) {
                    return true;
                }
                const str = this.R(node);
                const len = str.length;
                const startPosition = other.G(offset);
                const endPosition = other.G(offset + len);
                const val = other.getValueInRange2(startPosition, endPosition);
                offset += len;
                return str === val;
            });
            return ret;
        }
        getOffsetAt(lineNumber, column) {
            let leftLen = 0; // inorder
            let x = this.root;
            while (x !== rbTreeBase_1.$bD) {
                if (x.left !== rbTreeBase_1.$bD && x.lf_left + 1 >= lineNumber) {
                    x = x.left;
                }
                else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {
                    leftLen += x.size_left;
                    // lineNumber >= 2
                    const accumualtedValInCurrentIndex = this.B(x, lineNumber - x.lf_left - 2);
                    return leftLen += accumualtedValInCurrentIndex + column - 1;
                }
                else {
                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                    leftLen += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
            return leftLen;
        }
        getPositionAt(offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            let x = this.root;
            let lfCnt = 0;
            const originalOffset = offset;
            while (x !== rbTreeBase_1.$bD) {
                if (x.size_left !== 0 && x.size_left >= offset) {
                    x = x.left;
                }
                else if (x.size_left + x.piece.length >= offset) {
                    const out = this.A(x, offset - x.size_left);
                    lfCnt += x.lf_left + out.index;
                    if (out.index === 0) {
                        const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                        const column = originalOffset - lineStartOffset;
                        return new position_1.$Nt(lfCnt + 1, column + 1);
                    }
                    return new position_1.$Nt(lfCnt + 1, out.remainder + 1);
                }
                else {
                    offset -= x.size_left + x.piece.length;
                    lfCnt += x.lf_left + x.piece.lineFeedCnt;
                    if (x.right === rbTreeBase_1.$bD) {
                        // last node
                        const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);
                        const column = originalOffset - offset - lineStartOffset;
                        return new position_1.$Nt(lfCnt + 1, column + 1);
                    }
                    else {
                        x = x.right;
                    }
                }
            }
            return new position_1.$Nt(1, 1);
        }
        getValueInRange(range, eol) {
            if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {
                return '';
            }
            const startPosition = this.H(range.startLineNumber, range.startColumn);
            const endPosition = this.H(range.endLineNumber, range.endColumn);
            const value = this.getValueInRange2(startPosition, endPosition);
            if (eol) {
                if (eol !== this.d || !this.f) {
                    return value.replace(/\r\n|\r|\n/g, eol);
                }
                if (eol === this.getEOL() && this.f) {
                    if (eol === '\r\n') {
                    }
                    return value;
                }
                return value.replace(/\r\n|\r|\n/g, eol);
            }
            return value;
        }
        getValueInRange2(startPosition, endPosition) {
            if (startPosition.node === endPosition.node) {
                const node = startPosition.node;
                const buffer = this.a[node.piece.bufferIndex].buffer;
                const startOffset = this.u(node.piece.bufferIndex, node.piece.start);
                return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);
            }
            let x = startPosition.node;
            const buffer = this.a[x.piece.bufferIndex].buffer;
            const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
            let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);
            x = x.next();
            while (x !== rbTreeBase_1.$bD) {
                const buffer = this.a[x.piece.bufferIndex].buffer;
                const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
                if (x === endPosition.node) {
                    ret += buffer.substring(startOffset, startOffset + endPosition.remainder);
                    break;
                }
                else {
                    ret += buffer.substr(startOffset, x.piece.length);
                }
                x = x.next();
            }
            return ret;
        }
        getLinesContent() {
            const lines = [];
            let linesLength = 0;
            let currentLine = '';
            let danglingCR = false;
            this.iterate(this.root, node => {
                if (node === rbTreeBase_1.$bD) {
                    return true;
                }
                const piece = node.piece;
                let pieceLength = piece.length;
                if (pieceLength === 0) {
                    return true;
                }
                const buffer = this.a[piece.bufferIndex].buffer;
                const lineStarts = this.a[piece.bufferIndex].lineStarts;
                const pieceStartLine = piece.start.line;
                const pieceEndLine = piece.end.line;
                let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;
                if (danglingCR) {
                    if (buffer.charCodeAt(pieceStartOffset) === charCode_1.CharCode.LineFeed) {
                        // pretend the \n was in the previous piece..
                        pieceStartOffset++;
                        pieceLength--;
                    }
                    lines[linesLength++] = currentLine;
                    currentLine = '';
                    danglingCR = false;
                    if (pieceLength === 0) {
                        return true;
                    }
                }
                if (pieceStartLine === pieceEndLine) {
                    // this piece has no new lines
                    if (!this.f && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === charCode_1.CharCode.CarriageReturn) {
                        danglingCR = true;
                        currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);
                    }
                    else {
                        currentLine += buffer.substr(pieceStartOffset, pieceLength);
                    }
                    return true;
                }
                // add the text before the first line start in this piece
                currentLine += (this.f
                    ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this.e))
                    : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\r\n|\r|\n)$/, ''));
                lines[linesLength++] = currentLine;
                for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {
                    currentLine = (this.f
                        ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this.e)
                        : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\r\n|\r|\n)$/, ''));
                    lines[linesLength++] = currentLine;
                }
                if (!this.f && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === charCode_1.CharCode.CarriageReturn) {
                    danglingCR = true;
                    if (piece.end.column === 0) {
                        // The last line ended with a \r, let's undo the push, it will be pushed by next iteration
                        linesLength--;
                    }
                    else {
                        currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);
                    }
                }
                else {
                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);
                }
                return true;
            });
            if (danglingCR) {
                lines[linesLength++] = currentLine;
                currentLine = '';
            }
            lines[linesLength++] = currentLine;
            return lines;
        }
        getLength() {
            return this.c;
        }
        getLineCount() {
            return this.b;
        }
        getLineContent(lineNumber) {
            if (this.j.lineNumber === lineNumber) {
                return this.j.value;
            }
            this.j.lineNumber = lineNumber;
            if (lineNumber === this.b) {
                this.j.value = this.getLineRawContent(lineNumber);
            }
            else if (this.f) {
                this.j.value = this.getLineRawContent(lineNumber, this.e);
            }
            else {
                this.j.value = this.getLineRawContent(lineNumber).replace(/(\r\n|\r|\n)$/, '');
            }
            return this.j.value;
        }
        l(nodePos) {
            if (nodePos.remainder === nodePos.node.piece.length) {
                // the char we want to fetch is at the head of next node.
                const matchingNode = nodePos.node.next();
                if (!matchingNode) {
                    return 0;
                }
                const buffer = this.a[matchingNode.piece.bufferIndex];
                const startOffset = this.u(matchingNode.piece.bufferIndex, matchingNode.piece.start);
                return buffer.buffer.charCodeAt(startOffset);
            }
            else {
                const buffer = this.a[nodePos.node.piece.bufferIndex];
                const startOffset = this.u(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
                const targetOffset = startOffset + nodePos.remainder;
                return buffer.buffer.charCodeAt(targetOffset);
            }
        }
        getLineCharCode(lineNumber, index) {
            const nodePos = this.H(lineNumber, index + 1);
            return this.l(nodePos);
        }
        getLineLength(lineNumber) {
            if (lineNumber === this.getLineCount()) {
                const startOffset = this.getOffsetAt(lineNumber, 1);
                return this.getLength() - startOffset;
            }
            return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this.e;
        }
        getCharCode(offset) {
            const nodePos = this.G(offset);
            return this.l(nodePos);
        }
        getNearestChunk(offset) {
            const nodePos = this.G(offset);
            if (nodePos.remainder === nodePos.node.piece.length) {
                // the offset is at the head of next node.
                const matchingNode = nodePos.node.next();
                if (!matchingNode || matchingNode === rbTreeBase_1.$bD) {
                    return '';
                }
                const buffer = this.a[matchingNode.piece.bufferIndex];
                const startOffset = this.u(matchingNode.piece.bufferIndex, matchingNode.piece.start);
                return buffer.buffer.substring(startOffset, startOffset + matchingNode.piece.length);
            }
            else {
                const buffer = this.a[nodePos.node.piece.bufferIndex];
                const startOffset = this.u(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);
                const targetOffset = startOffset + nodePos.remainder;
                const targetEnd = startOffset + nodePos.node.piece.length;
                return buffer.buffer.substring(targetOffset, targetEnd);
            }
        }
        findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {
            const buffer = this.a[node.piece.bufferIndex];
            const startOffsetInBuffer = this.u(node.piece.bufferIndex, node.piece.start);
            const start = this.u(node.piece.bufferIndex, startCursor);
            const end = this.u(node.piece.bufferIndex, endCursor);
            let m;
            // Reset regex to search from the beginning
            const ret = { line: 0, column: 0 };
            let searchText;
            let offsetInBuffer;
            if (searcher._wordSeparators) {
                searchText = buffer.buffer.substring(start, end);
                offsetInBuffer = (offset) => offset + start;
                searcher.reset(0);
            }
            else {
                searchText = buffer.buffer;
                offsetInBuffer = (offset) => offset;
                searcher.reset(start);
            }
            do {
                m = searcher.next(searchText);
                if (m) {
                    if (offsetInBuffer(m.index) >= end) {
                        return resultLen;
                    }
                    this.s(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);
                    const lineFeedCnt = this.t(node.piece.bufferIndex, startCursor, ret);
                    const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;
                    const retEndColumn = retStartColumn + m[0].length;
                    result[resultLen++] = (0, textModelSearch_1.$mD)(new range_1.$Ot(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);
                    if (offsetInBuffer(m.index) + m[0].length >= end) {
                        return resultLen;
                    }
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            } while (m);
            return resultLen;
        }
        findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
            const result = [];
            let resultLen = 0;
            const searcher = new textModelSearch_1.$pD(searchData.wordSeparators, searchData.regex);
            let startPosition = this.H(searchRange.startLineNumber, searchRange.startColumn);
            if (startPosition === null) {
                return [];
            }
            const endPosition = this.H(searchRange.endLineNumber, searchRange.endColumn);
            if (endPosition === null) {
                return [];
            }
            let start = this.s(startPosition.node, startPosition.remainder);
            const end = this.s(endPosition.node, endPosition.remainder);
            if (startPosition.node === endPosition.node) {
                this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
                return result;
            }
            let startLineNumber = searchRange.startLineNumber;
            let currentNode = startPosition.node;
            while (currentNode !== endPosition.node) {
                const lineBreakCnt = this.t(currentNode.piece.bufferIndex, start, currentNode.piece.end);
                if (lineBreakCnt >= 1) {
                    // last line break position
                    const lineStarts = this.a[currentNode.piece.bufferIndex].lineStarts;
                    const startOffsetInBuffer = this.u(currentNode.piece.bufferIndex, currentNode.piece.start);
                    const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];
                    const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
                    resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.s(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);
                    if (resultLen >= limitResultCount) {
                        return result;
                    }
                    startLineNumber += lineBreakCnt;
                }
                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
                // search for the remaining content
                if (startLineNumber === searchRange.endLineNumber) {
                    const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);
                    resultLen = this.n(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);
                    return result;
                }
                resultLen = this.n(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);
                if (resultLen >= limitResultCount) {
                    return result;
                }
                startLineNumber++;
                startPosition = this.H(startLineNumber, 1);
                currentNode = startPosition.node;
                start = this.s(startPosition.node, startPosition.remainder);
            }
            if (startLineNumber === searchRange.endLineNumber) {
                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;
                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);
                resultLen = this.n(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);
                return result;
            }
            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;
            resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);
            return result;
        }
        n(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {
            const wordSeparators = searchData.wordSeparators;
            if (!captureMatches && searchData.simpleSearch) {
                const searchString = searchData.simpleSearch;
                const searchStringLen = searchString.length;
                const textLength = text.length;
                let lastMatchIndex = -searchStringLen;
                while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {
                    if (!wordSeparators || (0, textModelSearch_1.$oD)(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {
                        result[resultLen++] = new model_1.$ew(new range_1.$Ot(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);
                        if (resultLen >= limitResultCount) {
                            return resultLen;
                        }
                    }
                }
                return resultLen;
            }
            let m;
            // Reset regex to search from the beginning
            searcher.reset(0);
            do {
                m = searcher.next(text);
                if (m) {
                    result[resultLen++] = (0, textModelSearch_1.$mD)(new range_1.$Ot(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);
                    if (resultLen >= limitResultCount) {
                        return resultLen;
                    }
                }
            } while (m);
            return resultLen;
        }
        // #endregion
        // #region Piece Table
        insert(offset, value, eolNormalized = false) {
            this.f = this.f && eolNormalized;
            this.j.lineNumber = 0;
            this.j.value = '';
            if (this.root !== rbTreeBase_1.$bD) {
                const { node, remainder, nodeStartOffset } = this.G(offset);
                const piece = node.piece;
                const bufferIndex = piece.bufferIndex;
                const insertPosInBuffer = this.s(node, remainder);
                if (node.piece.bufferIndex === 0 &&
                    piece.end.line === this.g.line &&
                    piece.end.column === this.g.column &&
                    (nodeStartOffset + piece.length === offset) &&
                    value.length < AverageBufferSize) {
                    // changed buffer
                    this.F(node, value);
                    this.y();
                    return;
                }
                if (nodeStartOffset === offset) {
                    this.o(value, node);
                    this.h.validate(offset);
                }
                else if (nodeStartOffset + node.piece.length > offset) {
                    // we are inserting into the middle of a node.
                    const nodesToDel = [];
                    let newRightPiece = new $sD(piece.bufferIndex, insertPosInBuffer, piece.end, this.t(piece.bufferIndex, insertPosInBuffer, piece.end), this.u(bufferIndex, piece.end) - this.u(bufferIndex, insertPosInBuffer));
                    if (this.K() && this.M(value)) {
                        const headOfRight = this.I(node, remainder);
                        if (headOfRight === 10 /** \n */) {
                            const newStart = { line: newRightPiece.start.line + 1, column: 0 };
                            newRightPiece = new $sD(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.t(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);
                            value += '\n';
                        }
                    }
                    // reuse node for content before insertion point.
                    if (this.K() && this.L(value)) {
                        const tailOfLeft = this.I(node, remainder - 1);
                        if (tailOfLeft === 13 /** \r */) {
                            const previousPos = this.s(node, remainder - 1);
                            this.C(node, previousPos);
                            value = '\r' + value;
                            if (node.piece.length === 0) {
                                nodesToDel.push(node);
                            }
                        }
                        else {
                            this.C(node, insertPosInBuffer);
                        }
                    }
                    else {
                        this.C(node, insertPosInBuffer);
                    }
                    const newPieces = this.w(value);
                    if (newRightPiece.length > 0) {
                        this.S(node, newRightPiece);
                    }
                    let tmpNode = node;
                    for (let k = 0; k < newPieces.length; k++) {
                        tmpNode = this.S(tmpNode, newPieces[k]);
                    }
                    this.v(nodesToDel);
                }
                else {
                    this.q(value, node);
                }
            }
            else {
                // insert new node
                const pieces = this.w(value);
                let node = this.T(null, pieces[0]);
                for (let k = 1; k < pieces.length; k++) {
                    node = this.S(node, pieces[k]);
                }
            }
            // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.
            this.y();
        }
        delete(offset, cnt) {
            this.j.lineNumber = 0;
            this.j.value = '';
            if (cnt <= 0 || this.root === rbTreeBase_1.$bD) {
                return;
            }
            const startPosition = this.G(offset);
            const endPosition = this.G(offset + cnt);
            const startNode = startPosition.node;
            const endNode = endPosition.node;
            if (startNode === endNode) {
                const startSplitPosInBuffer = this.s(startNode, startPosition.remainder);
                const endSplitPosInBuffer = this.s(startNode, endPosition.remainder);
                if (startPosition.nodeStartOffset === offset) {
                    if (cnt === startNode.piece.length) { // delete node
                        const next = startNode.next();
                        (0, rbTreeBase_1.$gD)(this, startNode);
                        this.N(next);
                        this.y();
                        return;
                    }
                    this.D(startNode, endSplitPosInBuffer);
                    this.h.validate(offset);
                    this.N(startNode);
                    this.y();
                    return;
                }
                if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {
                    this.C(startNode, startSplitPosInBuffer);
                    this.O(startNode);
                    this.y();
                    return;
                }
                // delete content in the middle, this node will be splitted to nodes
                this.E(startNode, startSplitPosInBuffer, endSplitPosInBuffer);
                this.y();
                return;
            }
            const nodesToDel = [];
            const startSplitPosInBuffer = this.s(startNode, startPosition.remainder);
            this.C(startNode, startSplitPosInBuffer);
            this.h.validate(offset);
            if (startNode.piece.length === 0) {
                nodesToDel.push(startNode);
            }
            // update last touched node
            const endSplitPosInBuffer = this.s(endNode, endPosition.remainder);
            this.D(endNode, endSplitPosInBuffer);
            if (endNode.piece.length === 0) {
                nodesToDel.push(endNode);
            }
            // delete nodes in between
            const secondNode = startNode.next();
            for (let node = secondNode; node !== rbTreeBase_1.$bD && node !== endNode; node = node.next()) {
                nodesToDel.push(node);
            }
            const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;
            this.v(nodesToDel);
            this.O(prev);
            this.y();
        }
        o(value, node) {
            // we are inserting content to the beginning of node
            const nodesToDel = [];
            if (this.K() && this.M(value) && this.L(node)) {
                // move `\n` to new node.
                const piece = node.piece;
                const newStart = { line: piece.start.line + 1, column: 0 };
                const nPiece = new $sD(piece.bufferIndex, newStart, piece.end, this.t(piece.bufferIndex, newStart, piece.end), piece.length - 1);
                node.piece = nPiece;
                value += '\n';
                (0, rbTreeBase_1.$iD)(this, node, -1, -1);
                if (node.piece.length === 0) {
                    nodesToDel.push(node);
                }
            }
            const newPieces = this.w(value);
            let newNode = this.T(node, newPieces[newPieces.length - 1]);
            for (let k = newPieces.length - 2; k >= 0; k--) {
                newNode = this.T(newNode, newPieces[k]);
            }
            this.N(newNode);
            this.v(nodesToDel);
        }
        q(value, node) {
            // we are inserting to the right of this node.
            if (this.Q(value, node)) {
                // move \n to the new node.
                value += '\n';
            }
            const newPieces = this.w(value);
            const newNode = this.S(node, newPieces[0]);
            let tmpNode = newNode;
            for (let k = 1; k < newPieces.length; k++) {
                tmpNode = this.S(tmpNode, newPieces[k]);
            }
            this.N(newNode);
        }
        s(node, remainder, ret) {
            const piece = node.piece;
            const bufferIndex = node.piece.bufferIndex;
            const lineStarts = this.a[bufferIndex].lineStarts;
            const startOffset = lineStarts[piece.start.line] + piece.start.column;
            const offset = startOffset + remainder;
            // binary search offset between startOffset and endOffset
            let low = piece.start.line;
            let high = piece.end.line;
            let mid = 0;
            let midStop = 0;
            let midStart = 0;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStart = lineStarts[mid];
                if (mid === high) {
                    break;
                }
                midStop = lineStarts[mid + 1];
                if (offset < midStart) {
                    high = mid - 1;
                }
                else if (offset >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            if (ret) {
                ret.line = mid;
                ret.column = offset - midStart;
                return null;
            }
            return {
                line: mid,
                column: offset - midStart
            };
        }
        t(bufferIndex, start, end) {
            // we don't need to worry about start: abc\r|\n, or abc|\r, or abc|\n, or abc|\r\n doesn't change the fact that, there is one line break after start.
            // now let's take care of end: abc\r|\n, if end is in between \r and \n, we need to add line feed count by 1
            if (end.column === 0) {
                return end.line - start.line;
            }
            const lineStarts = this.a[bufferIndex].lineStarts;
            if (end.line === lineStarts.length - 1) { // it means, there is no \n after end, otherwise, there will be one more lineStart.
                return end.line - start.line;
            }
            const nextLineStartOffset = lineStarts[end.line + 1];
            const endOffset = lineStarts[end.line] + end.column;
            if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \n
                return end.line - start.line;
            }
            // endOffset + 1 === nextLineStartOffset
            // character at endOffset is \n, so we check the character before first
            // if character at endOffset is \r, end.column is 0 and we can't get here.
            const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.
            const buffer = this.a[bufferIndex].buffer;
            if (buffer.charCodeAt(previousCharOffset) === 13) {
                return end.line - start.line + 1;
            }
            else {
                return end.line - start.line;
            }
        }
        u(bufferIndex, cursor) {
            const lineStarts = this.a[bufferIndex].lineStarts;
            return lineStarts[cursor.line] + cursor.column;
        }
        v(nodes) {
            for (let i = 0; i < nodes.length; i++) {
                (0, rbTreeBase_1.$gD)(this, nodes[i]);
            }
        }
        w(text) {
            if (text.length > AverageBufferSize) {
                // the content is large, operations like substring, charCode becomes slow
                // so here we split it into smaller chunks, just like what we did for CR/LF normalization
                const newPieces = [];
                while (text.length > AverageBufferSize) {
                    const lastChar = text.charCodeAt(AverageBufferSize - 1);
                    let splitText;
                    if (lastChar === charCode_1.CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {
                        // last character is \r or a high surrogate => keep it back
                        splitText = text.substring(0, AverageBufferSize - 1);
                        text = text.substring(AverageBufferSize - 1);
                    }
                    else {
                        splitText = text.substring(0, AverageBufferSize);
                        text = text.substring(AverageBufferSize);
                    }
                    const lineStarts = $qD(splitText);
                    newPieces.push(new $sD(this.a.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));
                    this.a.push(new $tD(splitText, lineStarts));
                }
                const lineStarts = $qD(text);
                newPieces.push(new $sD(this.a.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));
                this.a.push(new $tD(text, lineStarts));
                return newPieces;
            }
            let startOffset = this.a[0].buffer.length;
            const lineStarts = $qD(text, false);
            let start = this.g;
            if (this.a[0].lineStarts[this.a[0].lineStarts.length - 1] === startOffset
                && startOffset !== 0
                && this.L(text)
                && this.M(this.a[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one
            ) {
                this.g = { line: this.g.line, column: this.g.column + 1 };
                start = this.g;
                for (let i = 0; i < lineStarts.length; i++) {
                    lineStarts[i] += startOffset + 1;
                }
                this.a[0].lineStarts = this.a[0].lineStarts.concat(lineStarts.slice(1));
                this.a[0].buffer += '_' + text;
                startOffset += 1;
            }
            else {
                if (startOffset !== 0) {
                    for (let i = 0; i < lineStarts.length; i++) {
                        lineStarts[i] += startOffset;
                    }
                }
                this.a[0].lineStarts = this.a[0].lineStarts.concat(lineStarts.slice(1));
                this.a[0].buffer += text;
            }
            const endOffset = this.a[0].buffer.length;
            const endIndex = this.a[0].lineStarts.length - 1;
            const endColumn = endOffset - this.a[0].lineStarts[endIndex];
            const endPos = { line: endIndex, column: endColumn };
            const newPiece = new $sD(0, /** todo@peng */ start, endPos, this.t(0, start, endPos), endOffset - startOffset);
            this.g = endPos;
            return [newPiece];
        }
        getLinesRawContent() {
            return this.U(this.root);
        }
        getLineRawContent(lineNumber, endOffset = 0) {
            let x = this.root;
            let ret = '';
            const cache = this.h.get2(lineNumber);
            if (cache) {
                x = cache.node;
                const prevAccumulatedValue = this.B(x, lineNumber - cache.nodeStartLineNumber - 1);
                const buffer = this.a[x.piece.bufferIndex].buffer;
                const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
                if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {
                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
                }
                else {
                    const accumulatedValue = this.B(x, lineNumber - cache.nodeStartLineNumber);
                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
                }
            }
            else {
                let nodeStartOffset = 0;
                const originalLineNumber = lineNumber;
                while (x !== rbTreeBase_1.$bD) {
                    if (x.left !== rbTreeBase_1.$bD && x.lf_left >= lineNumber - 1) {
                        x = x.left;
                    }
                    else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                        const prevAccumulatedValue = this.B(x, lineNumber - x.lf_left - 2);
                        const accumulatedValue = this.B(x, lineNumber - x.lf_left - 1);
                        const buffer = this.a[x.piece.bufferIndex].buffer;
                        const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
                        nodeStartOffset += x.size_left;
                        this.h.set({
                            node: x,
                            nodeStartOffset,
                            nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)
                        });
                        return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);
                    }
                    else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                        const prevAccumulatedValue = this.B(x, lineNumber - x.lf_left - 2);
                        const buffer = this.a[x.piece.bufferIndex].buffer;
                        const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
                        ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);
                        break;
                    }
                    else {
                        lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                        nodeStartOffset += x.size_left + x.piece.length;
                        x = x.right;
                    }
                }
            }
            // search in order, to find the node contains end column
            x = x.next();
            while (x !== rbTreeBase_1.$bD) {
                const buffer = this.a[x.piece.bufferIndex].buffer;
                if (x.piece.lineFeedCnt > 0) {
                    const accumulatedValue = this.B(x, 0);
                    const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
                    ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);
                    return ret;
                }
                else {
                    const startOffset = this.u(x.piece.bufferIndex, x.piece.start);
                    ret += buffer.substr(startOffset, x.piece.length);
                }
                x = x.next();
            }
            return ret;
        }
        y() {
            let x = this.root;
            let lfCnt = 1;
            let len = 0;
            while (x !== rbTreeBase_1.$bD) {
                lfCnt += x.lf_left + x.piece.lineFeedCnt;
                len += x.size_left + x.piece.length;
                x = x.right;
            }
            this.b = lfCnt;
            this.c = len;
            this.h.validate(this.c);
        }
        // #region node operations
        A(node, accumulatedValue) {
            const piece = node.piece;
            const pos = this.s(node, accumulatedValue);
            const lineCnt = pos.line - piece.start.line;
            if (this.u(piece.bufferIndex, piece.end) - this.u(piece.bufferIndex, piece.start) === accumulatedValue) {
                // we are checking the end of this node, so a CRLF check is necessary.
                const realLineCnt = this.t(node.piece.bufferIndex, piece.start, pos);
                if (realLineCnt !== lineCnt) {
                    // aha yes, CRLF
                    return { index: realLineCnt, remainder: 0 };
                }
            }
            return { index: lineCnt, remainder: pos.column };
        }
        B(node, index) {
            if (index < 0) {
                return 0;
            }
            const piece = node.piece;
            const lineStarts = this.a[piece.bufferIndex].lineStarts;
            const expectedLineStartIndex = piece.start.line + index + 1;
            if (expectedLineStartIndex > piece.end.line) {
                return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;
            }
            else {
                return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;
            }
        }
        C(node, pos) {
            const piece = node.piece;
            const originalLFCnt = piece.lineFeedCnt;
            const originalEndOffset = this.u(piece.bufferIndex, piece.end);
            const newEnd = pos;
            const newEndOffset = this.u(piece.bufferIndex, newEnd);
            const newLineFeedCnt = this.t(piece.bufferIndex, piece.start, newEnd);
            const lf_delta = newLineFeedCnt - originalLFCnt;
            const size_delta = newEndOffset - originalEndOffset;
            const newLength = piece.length + size_delta;
            node.piece = new $sD(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
            (0, rbTreeBase_1.$iD)(this, node, size_delta, lf_delta);
        }
        D(node, pos) {
            const piece = node.piece;
            const originalLFCnt = piece.lineFeedCnt;
            const originalStartOffset = this.u(piece.bufferIndex, piece.start);
            const newStart = pos;
            const newLineFeedCnt = this.t(piece.bufferIndex, newStart, piece.end);
            const newStartOffset = this.u(piece.bufferIndex, newStart);
            const lf_delta = newLineFeedCnt - originalLFCnt;
            const size_delta = originalStartOffset - newStartOffset;
            const newLength = piece.length + size_delta;
            node.piece = new $sD(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
            (0, rbTreeBase_1.$iD)(this, node, size_delta, lf_delta);
        }
        E(node, start, end) {
            const piece = node.piece;
            const originalStartPos = piece.start;
            const originalEndPos = piece.end;
            // old piece, originalStartPos, start
            const oldLength = piece.length;
            const oldLFCnt = piece.lineFeedCnt;
            const newEnd = start;
            const newLineFeedCnt = this.t(piece.bufferIndex, piece.start, newEnd);
            const newLength = this.u(piece.bufferIndex, start) - this.u(piece.bufferIndex, originalStartPos);
            node.piece = new $sD(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);
            (0, rbTreeBase_1.$iD)(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);
            // new right piece, end, originalEndPos
            const newPiece = new $sD(piece.bufferIndex, end, originalEndPos, this.t(piece.bufferIndex, end, originalEndPos), this.u(piece.bufferIndex, originalEndPos) - this.u(piece.bufferIndex, end));
            const newNode = this.S(node, newPiece);
            this.N(newNode);
        }
        F(node, value) {
            if (this.Q(value, node)) {
                value += '\n';
            }
            const hitCRLF = this.K() && this.L(value) && this.M(node);
            const startOffset = this.a[0].buffer.length;
            this.a[0].buffer += value;
            const lineStarts = $qD(value, false);
            for (let i = 0; i < lineStarts.length; i++) {
                lineStarts[i] += startOffset;
            }
            if (hitCRLF) {
                const prevStartOffset = this.a[0].lineStarts[this.a[0].lineStarts.length - 2];
                this.a[0].lineStarts.pop();
                // _lastChangeBufferPos is already wrong
                this.g = { line: this.g.line - 1, column: startOffset - prevStartOffset };
            }
            this.a[0].lineStarts = this.a[0].lineStarts.concat(lineStarts.slice(1));
            const endIndex = this.a[0].lineStarts.length - 1;
            const endColumn = this.a[0].buffer.length - this.a[0].lineStarts[endIndex];
            const newEnd = { line: endIndex, column: endColumn };
            const newLength = node.piece.length + value.length;
            const oldLineFeedCnt = node.piece.lineFeedCnt;
            const newLineFeedCnt = this.t(0, node.piece.start, newEnd);
            const lf_delta = newLineFeedCnt - oldLineFeedCnt;
            node.piece = new $sD(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);
            this.g = newEnd;
            (0, rbTreeBase_1.$iD)(this, node, value.length, lf_delta);
        }
        G(offset) {
            let x = this.root;
            const cache = this.h.get(offset);
            if (cache) {
                return {
                    node: cache.node,
                    nodeStartOffset: cache.nodeStartOffset,
                    remainder: offset - cache.nodeStartOffset
                };
            }
            let nodeStartOffset = 0;
            while (x !== rbTreeBase_1.$bD) {
                if (x.size_left > offset) {
                    x = x.left;
                }
                else if (x.size_left + x.piece.length >= offset) {
                    nodeStartOffset += x.size_left;
                    const ret = {
                        node: x,
                        remainder: offset - x.size_left,
                        nodeStartOffset
                    };
                    this.h.set(ret);
                    return ret;
                }
                else {
                    offset -= x.size_left + x.piece.length;
                    nodeStartOffset += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
            return null;
        }
        H(lineNumber, column) {
            let x = this.root;
            let nodeStartOffset = 0;
            while (x !== rbTreeBase_1.$bD) {
                if (x.left !== rbTreeBase_1.$bD && x.lf_left >= lineNumber - 1) {
                    x = x.left;
                }
                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {
                    const prevAccumualtedValue = this.B(x, lineNumber - x.lf_left - 2);
                    const accumulatedValue = this.B(x, lineNumber - x.lf_left - 1);
                    nodeStartOffset += x.size_left;
                    return {
                        node: x,
                        remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),
                        nodeStartOffset
                    };
                }
                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {
                    const prevAccumualtedValue = this.B(x, lineNumber - x.lf_left - 2);
                    if (prevAccumualtedValue + column - 1 <= x.piece.length) {
                        return {
                            node: x,
                            remainder: prevAccumualtedValue + column - 1,
                            nodeStartOffset
                        };
                    }
                    else {
                        column -= x.piece.length - prevAccumualtedValue;
                        break;
                    }
                }
                else {
                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;
                    nodeStartOffset += x.size_left + x.piece.length;
                    x = x.right;
                }
            }
            // search in order, to find the node contains position.column
            x = x.next();
            while (x !== rbTreeBase_1.$bD) {
                if (x.piece.lineFeedCnt > 0) {
                    const accumulatedValue = this.B(x, 0);
                    const nodeStartOffset = this.J(x);
                    return {
                        node: x,
                        remainder: Math.min(column - 1, accumulatedValue),
                        nodeStartOffset
                    };
                }
                else {
                    if (x.piece.length >= column - 1) {
                        const nodeStartOffset = this.J(x);
                        return {
                            node: x,
                            remainder: column - 1,
                            nodeStartOffset
                        };
                    }
                    else {
                        column -= x.piece.length;
                    }
                }
                x = x.next();
            }
            return null;
        }
        I(node, offset) {
            if (node.piece.lineFeedCnt < 1) {
                return -1;
            }
            const buffer = this.a[node.piece.bufferIndex];
            const newOffset = this.u(node.piece.bufferIndex, node.piece.start) + offset;
            return buffer.buffer.charCodeAt(newOffset);
        }
        J(node) {
            if (!node) {
                return 0;
            }
            let pos = node.size_left;
            while (node !== this.root) {
                if (node.parent.right === node) {
                    pos += node.parent.size_left + node.parent.piece.length;
                }
                node = node.parent;
            }
            return pos;
        }
        // #endregion
        // #region CRLF
        K() {
            return !(this.f && this.d === '\n');
        }
        L(val) {
            if (typeof val === 'string') {
                return val.charCodeAt(0) === 10;
            }
            if (val === rbTreeBase_1.$bD || val.piece.lineFeedCnt === 0) {
                return false;
            }
            const piece = val.piece;
            const lineStarts = this.a[piece.bufferIndex].lineStarts;
            const line = piece.start.line;
            const startOffset = lineStarts[line] + piece.start.column;
            if (line === lineStarts.length - 1) {
                // last line, so there is no line feed at the end of this line
                return false;
            }
            const nextLineOffset = lineStarts[line + 1];
            if (nextLineOffset > startOffset + 1) {
                return false;
            }
            return this.a[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;
        }
        M(val) {
            if (typeof val === 'string') {
                return val.charCodeAt(val.length - 1) === 13;
            }
            if (val === rbTreeBase_1.$bD || val.piece.lineFeedCnt === 0) {
                return false;
            }
            return this.I(val, val.piece.length - 1) === 13;
        }
        N(nextNode) {
            if (this.K() && this.L(nextNode)) {
                const node = nextNode.prev();
                if (this.M(node)) {
                    this.P(node, nextNode);
                }
            }
        }
        O(node) {
            if (this.K() && this.M(node)) {
                const nextNode = node.next();
                if (this.L(nextNode)) {
                    this.P(node, nextNode);
                }
            }
        }
        P(prev, next) {
            const nodesToDel = [];
            // update node
            const lineStarts = this.a[prev.piece.bufferIndex].lineStarts;
            let newEnd;
            if (prev.piece.end.column === 0) {
                // it means, last line ends with \r, not \r\n
                newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };
            }
            else {
                // \r\n
                newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };
            }
            const prevNewLength = prev.piece.length - 1;
            const prevNewLFCnt = prev.piece.lineFeedCnt - 1;
            prev.piece = new $sD(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);
            (0, rbTreeBase_1.$iD)(this, prev, -1, -1);
            if (prev.piece.length === 0) {
                nodesToDel.push(prev);
            }
            // update nextNode
            const newStart = { line: next.piece.start.line + 1, column: 0 };
            const newLength = next.piece.length - 1;
            const newLineFeedCnt = this.t(next.piece.bufferIndex, newStart, next.piece.end);
            next.piece = new $sD(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);
            (0, rbTreeBase_1.$iD)(this, next, -1, -1);
            if (next.piece.length === 0) {
                nodesToDel.push(next);
            }
            // create new piece which contains \r\n
            const pieces = this.w('\r\n');
            this.S(prev, pieces[0]);
            // delete empty nodes
            for (let i = 0; i < nodesToDel.length; i++) {
                (0, rbTreeBase_1.$gD)(this, nodesToDel[i]);
            }
        }
        Q(value, node) {
            if (this.K() && this.M(value)) {
                const nextNode = node.next();
                if (this.L(nextNode)) {
                    // move `\n` forward
                    value += '\n';
                    if (nextNode.piece.length === 1) {
                        (0, rbTreeBase_1.$gD)(this, nextNode);
                    }
                    else {
                        const piece = nextNode.piece;
                        const newStart = { line: piece.start.line + 1, column: 0 };
                        const newLength = piece.length - 1;
                        const newLineFeedCnt = this.t(piece.bufferIndex, newStart, piece.end);
                        nextNode.piece = new $sD(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);
                        (0, rbTreeBase_1.$iD)(this, nextNode, -1, -1);
                    }
                    return true;
                }
            }
            return false;
        }
        // #endregion
        // #endregion
        // #region Tree operations
        iterate(node, callback) {
            if (node === rbTreeBase_1.$bD) {
                return callback(rbTreeBase_1.$bD);
            }
            const leftRet = this.iterate(node.left, callback);
            if (!leftRet) {
                return leftRet;
            }
            return callback(node) && this.iterate(node.right, callback);
        }
        R(node) {
            if (node === rbTreeBase_1.$bD) {
                return '';
            }
            const buffer = this.a[node.piece.bufferIndex];
            const piece = node.piece;
            const startOffset = this.u(piece.bufferIndex, piece.start);
            const endOffset = this.u(piece.bufferIndex, piece.end);
            const currentContent = buffer.buffer.substring(startOffset, endOffset);
            return currentContent;
        }
        getPieceContent(piece) {
            const buffer = this.a[piece.bufferIndex];
            const startOffset = this.u(piece.bufferIndex, piece.start);
            const endOffset = this.u(piece.bufferIndex, piece.end);
            const currentContent = buffer.buffer.substring(startOffset, endOffset);
            return currentContent;
        }
        /**
         *      node              node
         *     /  \              /  \
         *    a   b    <----   a    b
         *                         /
         *                        z
         */
        S(node, p) {
            const z = new rbTreeBase_1.$aD(p, rbTreeBase_1.NodeColor.Red);
            z.left = rbTreeBase_1.$bD;
            z.right = rbTreeBase_1.$bD;
            z.parent = rbTreeBase_1.$bD;
            z.size_left = 0;
            z.lf_left = 0;
            const x = this.root;
            if (x === rbTreeBase_1.$bD) {
                this.root = z;
                z.color = rbTreeBase_1.NodeColor.Black;
            }
            else if (node.right === rbTreeBase_1.$bD) {
                node.right = z;
                z.parent = node;
            }
            else {
                const nextNode = (0, rbTreeBase_1.$cD)(node.right);
                nextNode.left = z;
                z.parent = nextNode;
            }
            (0, rbTreeBase_1.$hD)(this, z);
            return z;
        }
        /**
         *      node              node
         *     /  \              /  \
         *    a   b     ---->   a    b
         *                       \
         *                        z
         */
        T(node, p) {
            const z = new rbTreeBase_1.$aD(p, rbTreeBase_1.NodeColor.Red);
            z.left = rbTreeBase_1.$bD;
            z.right = rbTreeBase_1.$bD;
            z.parent = rbTreeBase_1.$bD;
            z.size_left = 0;
            z.lf_left = 0;
            if (this.root === rbTreeBase_1.$bD) {
                this.root = z;
                z.color = rbTreeBase_1.NodeColor.Black;
            }
            else if (node.left === rbTreeBase_1.$bD) {
                node.left = z;
                z.parent = node;
            }
            else {
                const prevNode = (0, rbTreeBase_1.$dD)(node.left); // a
                prevNode.right = z;
                z.parent = prevNode;
            }
            (0, rbTreeBase_1.$hD)(this, z);
            return z;
        }
        U(node) {
            let str = '';
            this.iterate(node, node => {
                str += this.R(node);
                return true;
            });
            return str;
        }
    }
    exports.$uD = $uD;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[161/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,12/*vs/base/common/strings*/,32/*vs/editor/common/core/range*/,52/*vs/editor/common/model*/,100/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase*/,153/*vs/editor/common/core/eolCounter*/,155/*vs/editor/common/core/textChange*/,4/*vs/base/common/lifecycle*/]), function (require, exports, event_1, strings, range_1, model_1, pieceTreeBase_1, eolCounter_1, textChange_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vD = void 0;
    strings = __importStar(strings);
    class $vD extends lifecycle_1.$Uc {
        constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {
            super();
            this.m = this.B(new event_1.$le());
            this.onDidChangeContent = this.m.event;
            this.f = BOM;
            this.j = !isBasicASCII;
            this.g = containsRTL;
            this.h = containsUnusualLineTerminators;
            this.c = new pieceTreeBase_1.$uD(chunks, eol, eolNormalized);
        }
        // #region TextBuffer
        equals(other) {
            if (!(other instanceof $vD)) {
                return false;
            }
            if (this.f !== other.f) {
                return false;
            }
            if (this.getEOL() !== other.getEOL()) {
                return false;
            }
            return this.c.equal(other.c);
        }
        mightContainRTL() {
            return this.g;
        }
        mightContainUnusualLineTerminators() {
            return this.h;
        }
        resetMightContainUnusualLineTerminators() {
            this.h = false;
        }
        mightContainNonBasicASCII() {
            return this.j;
        }
        getBOM() {
            return this.f;
        }
        getEOL() {
            return this.c.getEOL();
        }
        createSnapshot(preserveBOM) {
            return this.c.createSnapshot(preserveBOM ? this.f : '');
        }
        getOffsetAt(lineNumber, column) {
            return this.c.getOffsetAt(lineNumber, column);
        }
        getPositionAt(offset) {
            return this.c.getPositionAt(offset);
        }
        getRangeAt(start, length) {
            const end = start + length;
            const startPosition = this.getPositionAt(start);
            const endPosition = this.getPositionAt(end);
            return new range_1.$Ot(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        }
        getValueInRange(range, eol = model_1.EndOfLinePreference.TextDefined) {
            if (range.isEmpty()) {
                return '';
            }
            const lineEnding = this.n(eol);
            return this.c.getValueInRange(range, lineEnding);
        }
        getValueLengthInRange(range, eol = model_1.EndOfLinePreference.TextDefined) {
            if (range.isEmpty()) {
                return 0;
            }
            if (range.startLineNumber === range.endLineNumber) {
                return (range.endColumn - range.startColumn);
            }
            const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);
            const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);
            // offsets use the text EOL, so we need to compensate for length differences
            // if the requested EOL doesn't match the text EOL
            let eolOffsetCompensation = 0;
            const desiredEOL = this.n(eol);
            const actualEOL = this.getEOL();
            if (desiredEOL.length !== actualEOL.length) {
                const delta = desiredEOL.length - actualEOL.length;
                const eolCount = range.endLineNumber - range.startLineNumber;
                eolOffsetCompensation = delta * eolCount;
            }
            return endOffset - startOffset + eolOffsetCompensation;
        }
        getCharacterCountInRange(range, eol = model_1.EndOfLinePreference.TextDefined) {
            if (this.j) {
                // we must count by iterating
                let result = 0;
                const fromLineNumber = range.startLineNumber;
                const toLineNumber = range.endLineNumber;
                for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                    const lineContent = this.getLineContent(lineNumber);
                    const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);
                    const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);
                    for (let offset = fromOffset; offset < toOffset; offset++) {
                        if (strings.$Jf(lineContent.charCodeAt(offset))) {
                            result = result + 1;
                            offset = offset + 1;
                        }
                        else {
                            result = result + 1;
                        }
                    }
                }
                result += this.n(eol).length * (toLineNumber - fromLineNumber);
                return result;
            }
            return this.getValueLengthInRange(range, eol);
        }
        getNearestChunk(offset) {
            return this.c.getNearestChunk(offset);
        }
        getLength() {
            return this.c.getLength();
        }
        getLineCount() {
            return this.c.getLineCount();
        }
        getLinesContent() {
            return this.c.getLinesContent();
        }
        getLineContent(lineNumber) {
            return this.c.getLineContent(lineNumber);
        }
        getLineCharCode(lineNumber, index) {
            return this.c.getLineCharCode(lineNumber, index);
        }
        getCharCode(offset) {
            return this.c.getCharCode(offset);
        }
        getLineLength(lineNumber) {
            return this.c.getLineLength(lineNumber);
        }
        getLineMinColumn(lineNumber) {
            return 1;
        }
        getLineMaxColumn(lineNumber) {
            return this.getLineLength(lineNumber) + 1;
        }
        getLineFirstNonWhitespaceColumn(lineNumber) {
            const result = strings.$uf(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 1;
        }
        getLineLastNonWhitespaceColumn(lineNumber) {
            const result = strings.$wf(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 2;
        }
        n(eol) {
            switch (eol) {
                case model_1.EndOfLinePreference.LF:
                    return '\n';
                case model_1.EndOfLinePreference.CRLF:
                    return '\r\n';
                case model_1.EndOfLinePreference.TextDefined:
                    return this.getEOL();
                default:
                    throw new Error('Unknown EOL preference');
            }
        }
        setEOL(newEOL) {
            this.c.setEOL(newEOL);
        }
        applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {
            let mightContainRTL = this.g;
            let mightContainUnusualLineTerminators = this.h;
            let mightContainNonBasicASCII = this.j;
            let canReduceOperations = true;
            let operations = [];
            for (let i = 0; i < rawOperations.length; i++) {
                const op = rawOperations[i];
                if (canReduceOperations && op._isTracked) {
                    canReduceOperations = false;
                }
                const validatedRange = op.range;
                if (op.text) {
                    let textMightContainNonBasicASCII = true;
                    if (!mightContainNonBasicASCII) {
                        textMightContainNonBasicASCII = !strings.$Uf(op.text);
                        mightContainNonBasicASCII = textMightContainNonBasicASCII;
                    }
                    if (!mightContainRTL && textMightContainNonBasicASCII) {
                        // check if the new inserted text contains RTL
                        mightContainRTL = strings.$Tf(op.text);
                    }
                    if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {
                        // check if the new inserted text contains unusual line terminators
                        mightContainUnusualLineTerminators = strings.$Wf(op.text);
                    }
                }
                let validText = '';
                let eolCount = 0;
                let firstLineLength = 0;
                let lastLineLength = 0;
                if (op.text) {
                    let strEOL;
                    [eolCount, firstLineLength, lastLineLength, strEOL] = (0, eolCounter_1.$zu)(op.text);
                    const bufferEOL = this.getEOL();
                    const expectedStrEOL = (bufferEOL === '\r\n' ? eolCounter_1.StringEOL.CRLF : eolCounter_1.StringEOL.LF);
                    if (strEOL === eolCounter_1.StringEOL.Unknown || strEOL === expectedStrEOL) {
                        validText = op.text;
                    }
                    else {
                        validText = op.text.replace(/\r\n|\r|\n/g, bufferEOL);
                    }
                }
                operations[i] = {
                    sortIndex: i,
                    identifier: op.identifier || null,
                    range: validatedRange,
                    rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),
                    rangeLength: this.getValueLengthInRange(validatedRange),
                    text: validText,
                    eolCount: eolCount,
                    firstLineLength: firstLineLength,
                    lastLineLength: lastLineLength,
                    forceMoveMarkers: Boolean(op.forceMoveMarkers),
                    isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
                };
            }
            // Sort operations ascending
            operations.sort($vD.u);
            let hasTouchingRanges = false;
            for (let i = 0, count = operations.length - 1; i < count; i++) {
                const rangeEnd = operations[i].range.getEndPosition();
                const nextRangeStart = operations[i + 1].range.getStartPosition();
                if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {
                    if (nextRangeStart.isBefore(rangeEnd)) {
                        // overlapping ranges
                        throw new Error('Overlapping ranges are not allowed!');
                    }
                    hasTouchingRanges = true;
                }
            }
            if (canReduceOperations) {
                operations = this.s(operations);
            }
            // Delta encode operations
            const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? $vD._getInverseEditRanges(operations) : []);
            const newTrimAutoWhitespaceCandidates = [];
            if (recordTrimAutoWhitespace) {
                for (let i = 0; i < operations.length; i++) {
                    const op = operations[i];
                    const reverseRange = reverseRanges[i];
                    if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {
                        // Record already the future line numbers that might be auto whitespace removal candidates on next edit
                        for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                            let currentLineContent = '';
                            if (lineNumber === reverseRange.startLineNumber) {
                                currentLineContent = this.getLineContent(op.range.startLineNumber);
                                if (strings.$uf(currentLineContent) !== -1) {
                                    continue;
                                }
                            }
                            newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });
                        }
                    }
                }
            }
            let reverseOperations = null;
            if (computeUndoEdits) {
                let reverseRangeDeltaOffset = 0;
                reverseOperations = [];
                for (let i = 0; i < operations.length; i++) {
                    const op = operations[i];
                    const reverseRange = reverseRanges[i];
                    const bufferText = this.getValueInRange(op.range);
                    const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;
                    reverseRangeDeltaOffset += (op.text.length - bufferText.length);
                    reverseOperations[i] = {
                        sortIndex: op.sortIndex,
                        identifier: op.identifier,
                        range: reverseRange,
                        text: bufferText,
                        textChange: new textChange_1.$fu(op.rangeOffset, bufferText, reverseRangeOffset, op.text)
                    };
                }
                // Can only sort reverse operations when the order is not significant
                if (!hasTouchingRanges) {
                    reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);
                }
            }
            this.g = mightContainRTL;
            this.h = mightContainUnusualLineTerminators;
            this.j = mightContainNonBasicASCII;
            const contentChanges = this.t(operations);
            let trimAutoWhitespaceLineNumbers = null;
            if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
                // sort line numbers auto whitespace removal candidates for next edit descending
                newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);
                trimAutoWhitespaceLineNumbers = [];
                for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
                    const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
                    if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
                        // Do not have the same line number twice
                        continue;
                    }
                    const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
                    const lineContent = this.getLineContent(lineNumber);
                    if (lineContent.length === 0 || lineContent === prevContent || strings.$uf(lineContent) !== -1) {
                        continue;
                    }
                    trimAutoWhitespaceLineNumbers.push(lineNumber);
                }
            }
            this.m.fire();
            return new model_1.$iw(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);
        }
        /**
         * Transform operations such that they represent the same logic edit,
         * but that they also do not cause OOM crashes.
         */
        s(operations) {
            if (operations.length < 1000) {
                // We know from empirical testing that a thousand edits work fine regardless of their shape.
                return operations;
            }
            // At one point, due to how events are emitted and how each operation is handled,
            // some operations can trigger a high amount of temporary string allocations,
            // that will immediately get edited again.
            // e.g. a formatter inserting ridiculous ammounts of \n on a model with a single line
            // Therefore, the strategy is to collapse all the operations into a huge single edit operation
            return [this._toSingleEditOperation(operations)];
        }
        _toSingleEditOperation(operations) {
            let forceMoveMarkers = false;
            const firstEditRange = operations[0].range;
            const lastEditRange = operations[operations.length - 1].range;
            const entireEditRange = new range_1.$Ot(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);
            let lastEndLineNumber = firstEditRange.startLineNumber;
            let lastEndColumn = firstEditRange.startColumn;
            const result = [];
            for (let i = 0, len = operations.length; i < len; i++) {
                const operation = operations[i];
                const range = operation.range;
                forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
                // (1) -- Push old text
                result.push(this.getValueInRange(new range_1.$Ot(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));
                // (2) -- Push new text
                if (operation.text.length > 0) {
                    result.push(operation.text);
                }
                lastEndLineNumber = range.endLineNumber;
                lastEndColumn = range.endColumn;
            }
            const text = result.join('');
            const [eolCount, firstLineLength, lastLineLength] = (0, eolCounter_1.$zu)(text);
            return {
                sortIndex: 0,
                identifier: operations[0].identifier,
                range: entireEditRange,
                rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),
                rangeLength: this.getValueLengthInRange(entireEditRange, model_1.EndOfLinePreference.TextDefined),
                text: text,
                eolCount: eolCount,
                firstLineLength: firstLineLength,
                lastLineLength: lastLineLength,
                forceMoveMarkers: forceMoveMarkers,
                isAutoWhitespaceEdit: false
            };
        }
        t(operations) {
            operations.sort($vD.w);
            const contentChanges = [];
            // operations are from bottom to top
            for (let i = 0; i < operations.length; i++) {
                const op = operations[i];
                const startLineNumber = op.range.startLineNumber;
                const startColumn = op.range.startColumn;
                const endLineNumber = op.range.endLineNumber;
                const endColumn = op.range.endColumn;
                if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {
                    // no-op
                    continue;
                }
                if (op.text) {
                    // replacement
                    this.c.delete(op.rangeOffset, op.rangeLength);
                    this.c.insert(op.rangeOffset, op.text, true);
                }
                else {
                    // deletion
                    this.c.delete(op.rangeOffset, op.rangeLength);
                }
                const contentChangeRange = new range_1.$Ot(startLineNumber, startColumn, endLineNumber, endColumn);
                contentChanges.push({
                    range: contentChangeRange,
                    rangeLength: op.rangeLength,
                    text: op.text,
                    rangeOffset: op.rangeOffset,
                    forceMoveMarkers: op.forceMoveMarkers
                });
            }
            return contentChanges;
        }
        findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {
            return this.c.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);
        }
        // #endregion
        // #region helper
        // testing purpose.
        getPieceTree() {
            return this.c;
        }
        static _getInverseEditRange(range, text) {
            const startLineNumber = range.startLineNumber;
            const startColumn = range.startColumn;
            const [eolCount, firstLineLength, lastLineLength] = (0, eolCounter_1.$zu)(text);
            let resultRange;
            if (text.length > 0) {
                // the operation inserts something
                const lineCount = eolCount + 1;
                if (lineCount === 1) {
                    // single line insert
                    resultRange = new range_1.$Ot(startLineNumber, startColumn, startLineNumber, startColumn + firstLineLength);
                }
                else {
                    // multi line insert
                    resultRange = new range_1.$Ot(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLineLength + 1);
                }
            }
            else {
                // There is nothing to insert
                resultRange = new range_1.$Ot(startLineNumber, startColumn, startLineNumber, startColumn);
            }
            return resultRange;
        }
        /**
         * Assumes `operations` are validated and sorted ascending
         */
        static _getInverseEditRanges(operations) {
            const result = [];
            let prevOpEndLineNumber = 0;
            let prevOpEndColumn = 0;
            let prevOp = null;
            for (let i = 0, len = operations.length; i < len; i++) {
                const op = operations[i];
                let startLineNumber;
                let startColumn;
                if (prevOp) {
                    if (prevOp.range.endLineNumber === op.range.startLineNumber) {
                        startLineNumber = prevOpEndLineNumber;
                        startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
                    }
                    else {
                        startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
                        startColumn = op.range.startColumn;
                    }
                }
                else {
                    startLineNumber = op.range.startLineNumber;
                    startColumn = op.range.startColumn;
                }
                let resultRange;
                if (op.text.length > 0) {
                    // the operation inserts something
                    const lineCount = op.eolCount + 1;
                    if (lineCount === 1) {
                        // single line insert
                        resultRange = new range_1.$Ot(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);
                    }
                    else {
                        // multi line insert
                        resultRange = new range_1.$Ot(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);
                    }
                }
                else {
                    // There is nothing to insert
                    resultRange = new range_1.$Ot(startLineNumber, startColumn, startLineNumber, startColumn);
                }
                prevOpEndLineNumber = resultRange.endLineNumber;
                prevOpEndColumn = resultRange.endColumn;
                result.push(resultRange);
                prevOp = op;
            }
            return result;
        }
        static u(a, b) {
            const r = range_1.$Ot.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return a.sortIndex - b.sortIndex;
            }
            return r;
        }
        static w(a, b) {
            const r = range_1.$Ot.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return b.sortIndex - a.sortIndex;
            }
            return -r;
        }
    }
    exports.$vD = $vD;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[162/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,12/*vs/base/common/strings*/,52/*vs/editor/common/model*/,100/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase*/,161/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer*/]), function (require, exports, charCode_1, strings, model_1, pieceTreeBase_1, pieceTreeTextBuffer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$wD = void 0;
    strings = __importStar(strings);
    class PieceTreeTextBufferFactory {
        constructor(a, b, c, d, e, f, g, h, j) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.e = e;
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
        }
        k(defaultEOL) {
            const totalEOLCount = this.c + this.d + this.e;
            const totalCRCount = this.c + this.e;
            if (totalEOLCount === 0) {
                // This is an empty file or a file with precisely one line
                return (defaultEOL === model_1.DefaultEndOfLine.LF ? '\n' : '\r\n');
            }
            if (totalCRCount > totalEOLCount / 2) {
                // More than half of the file contains \r\n ending lines
                return '\r\n';
            }
            // At least one line more ends in \n
            return '\n';
        }
        create(defaultEOL) {
            const eol = this.k(defaultEOL);
            const chunks = this.a;
            if (this.j &&
                ((eol === '\r\n' && (this.c > 0 || this.d > 0))
                    || (eol === '\n' && (this.c > 0 || this.e > 0)))) {
                // Normalize pieces
                for (let i = 0, len = chunks.length; i < len; i++) {
                    const str = chunks[i].buffer.replace(/\r\n|\r|\n/g, eol);
                    const newLineStart = (0, pieceTreeBase_1.$qD)(str);
                    chunks[i] = new pieceTreeBase_1.$tD(str, newLineStart);
                }
            }
            const textBuffer = new pieceTreeTextBuffer_1.$vD(chunks, this.b, eol, this.f, this.g, this.h, this.j);
            return { textBuffer: textBuffer, disposable: textBuffer };
        }
        getFirstLineText(lengthLimit) {
            return this.a[0].buffer.substr(0, lengthLimit).split(/\r\n|\r|\n/)[0];
        }
    }
    class $wD {
        constructor() {
            this.a = [];
            this.b = '';
            this.c = false;
            this.d = 0;
            this.e = [];
            this.f = 0;
            this.g = 0;
            this.h = 0;
            this.j = false;
            this.k = false;
            this.l = true;
        }
        acceptChunk(chunk) {
            if (chunk.length === 0) {
                return;
            }
            if (this.a.length === 0) {
                if (strings.$5f(chunk)) {
                    this.b = strings.$4f;
                    chunk = chunk.substr(1);
                }
            }
            const lastChar = chunk.charCodeAt(chunk.length - 1);
            if (lastChar === charCode_1.CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {
                // last character is \r or a high surrogate => keep it back
                this.m(chunk.substr(0, chunk.length - 1), false);
                this.c = true;
                this.d = lastChar;
            }
            else {
                this.m(chunk, false);
                this.c = false;
                this.d = lastChar;
            }
        }
        m(chunk, allowEmptyStrings) {
            if (!allowEmptyStrings && chunk.length === 0) {
                // Nothing to do
                return;
            }
            if (this.c) {
                this.n(String.fromCharCode(this.d) + chunk);
            }
            else {
                this.n(chunk);
            }
        }
        n(chunk) {
            const lineStarts = (0, pieceTreeBase_1.$rD)(this.e, chunk);
            this.a.push(new pieceTreeBase_1.$tD(chunk, lineStarts.lineStarts));
            this.f += lineStarts.cr;
            this.g += lineStarts.lf;
            this.h += lineStarts.crlf;
            if (!lineStarts.isBasicASCII) {
                // this chunk contains non basic ASCII characters
                this.l = false;
                if (!this.j) {
                    this.j = strings.$Tf(chunk);
                }
                if (!this.k) {
                    this.k = strings.$Wf(chunk);
                }
            }
        }
        finish(normalizeEOL = true) {
            this.o();
            return new PieceTreeTextBufferFactory(this.a, this.b, this.f, this.g, this.h, this.j, this.k, this.l, normalizeEOL);
        }
        o() {
            if (this.a.length === 0) {
                this.m('', true);
            }
            if (this.c) {
                this.c = false;
                // recreate last chunk
                const lastChunk = this.a[this.a.length - 1];
                lastChunk.buffer += String.fromCharCode(this.d);
                const newLineStarts = (0, pieceTreeBase_1.$qD)(lastChunk.buffer);
                lastChunk.lineStarts = newLineStarts;
                if (this.d === charCode_1.CharCode.CarriageReturn) {
                    this.f++;
                }
            }
        }
    }
    exports.$wD = $wD;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[103/*vs/editor/common/services/semanticTokensDto*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,20/*vs/base/common/platform*/]), function (require, exports, buffer_1, platform) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Adb = $Adb;
    exports.$Bdb = $Bdb;
    platform = __importStar(platform);
    var EncodedSemanticTokensType;
    (function (EncodedSemanticTokensType) {
        EncodedSemanticTokensType[EncodedSemanticTokensType["Full"] = 1] = "Full";
        EncodedSemanticTokensType[EncodedSemanticTokensType["Delta"] = 2] = "Delta";
    })(EncodedSemanticTokensType || (EncodedSemanticTokensType = {}));
    function reverseEndianness(arr) {
        for (let i = 0, len = arr.length; i < len; i += 4) {
            // flip bytes 0<->3 and 1<->2
            const b0 = arr[i + 0];
            const b1 = arr[i + 1];
            const b2 = arr[i + 2];
            const b3 = arr[i + 3];
            arr[i + 0] = b3;
            arr[i + 1] = b2;
            arr[i + 2] = b1;
            arr[i + 3] = b0;
        }
    }
    function toLittleEndianBuffer(arr) {
        const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);
        if (!platform.$E()) {
            // the byte order must be changed
            reverseEndianness(uint8Arr);
        }
        return buffer_1.$Ne.wrap(uint8Arr);
    }
    function fromLittleEndianBuffer(buff) {
        const uint8Arr = buff.buffer;
        if (!platform.$E()) {
            // the byte order must be changed
            reverseEndianness(uint8Arr);
        }
        if (uint8Arr.byteOffset % 4 === 0) {
            return new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4);
        }
        else {
            // unaligned memory access doesn't work on all platforms
            const data = new Uint8Array(uint8Arr.byteLength);
            data.set(uint8Arr);
            return new Uint32Array(data.buffer, data.byteOffset, data.length / 4);
        }
    }
    function $Adb(semanticTokens) {
        const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));
        let offset = 0;
        dest[offset++] = semanticTokens.id;
        if (semanticTokens.type === 'full') {
            dest[offset++] = EncodedSemanticTokensType.Full;
            dest[offset++] = semanticTokens.data.length;
            dest.set(semanticTokens.data, offset);
            offset += semanticTokens.data.length;
        }
        else {
            dest[offset++] = EncodedSemanticTokensType.Delta;
            dest[offset++] = semanticTokens.deltas.length;
            for (const delta of semanticTokens.deltas) {
                dest[offset++] = delta.start;
                dest[offset++] = delta.deleteCount;
                if (delta.data) {
                    dest[offset++] = delta.data.length;
                    dest.set(delta.data, offset);
                    offset += delta.data.length;
                }
                else {
                    dest[offset++] = 0;
                }
            }
        }
        return toLittleEndianBuffer(dest);
    }
    function encodeSemanticTokensDtoSize(semanticTokens) {
        let result = 0;
        result += (+1 // id
            + 1 // type
        );
        if (semanticTokens.type === 'full') {
            result += (+1 // data length
                + semanticTokens.data.length);
        }
        else {
            result += (+1 // delta count
            );
            result += (+1 // start
                + 1 // deleteCount
                + 1 // data length
            ) * semanticTokens.deltas.length;
            for (const delta of semanticTokens.deltas) {
                if (delta.data) {
                    result += delta.data.length;
                }
            }
        }
        return result;
    }
    function $Bdb(_buff) {
        const src = fromLittleEndianBuffer(_buff);
        let offset = 0;
        const id = src[offset++];
        const type = src[offset++];
        if (type === EncodedSemanticTokensType.Full) {
            const length = src[offset++];
            const data = src.subarray(offset, offset + length);
            offset += length;
            return {
                id: id,
                type: 'full',
                data: data
            };
        }
        const deltaCount = src[offset++];
        const deltas = [];
        for (let i = 0; i < deltaCount; i++) {
            const start = src[offset++];
            const deleteCount = src[offset++];
            const length = src[offset++];
            let data;
            if (length > 0) {
                data = src.subarray(offset, offset + length);
                offset += length;
            }
            deltas[i] = { start, deleteCount, data };
        }
        return {
            id: id,
            type: 'delta',
            deltas: deltas
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[163/*vs/editor/common/services/treeViewsDnd*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$s_ = exports.$r_ = void 0;
    class $r_ {
        constructor() {
            this.a = new Map();
        }
        removeDragOperationTransfer(uuid) {
            if ((uuid && this.a.has(uuid))) {
                const operation = this.a.get(uuid);
                this.a.delete(uuid);
                return operation;
            }
            return undefined;
        }
        addDragOperationTransfer(uuid, transferPromise) {
            this.a.set(uuid, transferPromise);
        }
    }
    exports.$r_ = $r_;
    class $s_ {
        constructor(identifier) {
            this.identifier = identifier;
        }
    }
    exports.$s_ = $s_;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[164/*vs/base/common/actions*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,9/*vs/nls*/]), function (require, exports, event_1, lifecycle_1, nls) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oj = exports.$nj = exports.$mj = exports.$lj = exports.$kj = void 0;
    exports.$pj = $pj;
    nls = __importStar(nls);
    class $kj extends lifecycle_1.$Uc {
        constructor(id, label = '', cssClass = '', enabled = true, actionCallback) {
            super();
            this.j = this.B(new event_1.$le());
            this.onDidChange = this.j.event;
            this.z = true;
            this.m = id;
            this.n = label;
            this.w = cssClass;
            this.z = enabled;
            this.D = actionCallback;
        }
        get id() {
            return this.m;
        }
        get label() {
            return this.n;
        }
        set label(value) {
            this.F(value);
        }
        F(value) {
            if (this.n !== value) {
                this.n = value;
                this.j.fire({ label: value });
            }
        }
        get tooltip() {
            return this.u || '';
        }
        set tooltip(value) {
            this.G(value);
        }
        G(value) {
            if (this.u !== value) {
                this.u = value;
                this.j.fire({ tooltip: value });
            }
        }
        get class() {
            return this.w;
        }
        set class(value) {
            this.H(value);
        }
        H(value) {
            if (this.w !== value) {
                this.w = value;
                this.j.fire({ class: value });
            }
        }
        get enabled() {
            return this.z;
        }
        set enabled(value) {
            this.I(value);
        }
        I(value) {
            if (this.z !== value) {
                this.z = value;
                this.j.fire({ enabled: value });
            }
        }
        get checked() {
            return this.C;
        }
        set checked(value) {
            this.J(value);
        }
        J(value) {
            if (this.C !== value) {
                this.C = value;
                this.j.fire({ checked: value });
            }
        }
        async run(event, data) {
            if (this.D) {
                await this.D(event);
            }
        }
    }
    exports.$kj = $kj;
    class $lj extends lifecycle_1.$Uc {
        constructor() {
            super(...arguments);
            this.f = this.B(new event_1.$le());
            this.onWillRun = this.f.event;
            this.m = this.B(new event_1.$le());
            this.onDidRun = this.m.event;
        }
        async run(action, context) {
            if (!action.enabled) {
                return;
            }
            this.f.fire({ action });
            let error = undefined;
            try {
                await this.u(action, context);
            }
            catch (e) {
                error = e;
            }
            this.m.fire({ action, error });
        }
        async u(action, context) {
            await action.run(context);
        }
    }
    exports.$lj = $lj;
    class $mj {
        constructor() {
            this.id = $mj.ID;
            this.label = '';
            this.tooltip = '';
            this.class = 'separator';
            this.enabled = false;
            this.checked = false;
        }
        /**
         * Joins all non-empty lists of actions with separators.
         */
        static join(...actionLists) {
            let out = [];
            for (const list of actionLists) {
                if (!list.length) {
                    // skip
                }
                else if (out.length) {
                    out = [...out, new $mj(), ...list];
                }
                else {
                    out = list;
                }
            }
            return out;
        }
        static { this.ID = 'vs.actions.separator'; }
        async run() { }
    }
    exports.$mj = $mj;
    class $nj {
        get actions() { return this.a; }
        constructor(id, label, actions, cssClass) {
            this.tooltip = '';
            this.enabled = true;
            this.checked = undefined;
            this.id = id;
            this.label = label;
            this.class = cssClass;
            this.a = actions;
        }
        async run() { }
    }
    exports.$nj = $nj;
    class $oj extends $kj {
        static { this.ID = 'vs.actions.empty'; }
        constructor() {
            super($oj.ID, nls.localize(13030, null), undefined, false);
        }
    }
    exports.$oj = $oj;
    function $pj(props) {
        return {
            id: props.id,
            label: props.label,
            tooltip: props.tooltip ?? props.label,
            class: props.class,
            enabled: props.enabled ?? true,
            checked: props.checked,
            run: async (...args) => props.run(...args),
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[165/*vs/base/common/date*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/]), function (require, exports, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$2m = $2m;
    exports.$3m = $3m;
    exports.$4m = $4m;
    const minute = 60;
    const hour = minute * 60;
    const day = hour * 24;
    const week = day * 7;
    const month = day * 30;
    const year = day * 365;
    /**
     * Create a localized difference of the time between now and the specified date.
     * @param date The date to generate the difference from.
     * @param appendAgoLabel Whether to append the " ago" to the end.
     * @param useFullTimeWords Whether to use full words (eg. seconds) instead of
     * shortened (eg. secs).
     * @param disallowNow Whether to disallow the string "now" when the difference
     * is less than 30 seconds.
     */
    function $2m(date, appendAgoLabel, useFullTimeWords, disallowNow) {
        if (typeof date !== 'number') {
            date = date.getTime();
        }
        const seconds = Math.round((new Date().getTime() - date) / 1000);
        if (seconds < -30) {
            return (0, nls_1.localize)(12967, null, $2m(new Date().getTime() + seconds * 1000, false));
        }
        if (!disallowNow && seconds < 30) {
            return (0, nls_1.localize)(12968, null);
        }
        let value;
        if (seconds < minute) {
            value = seconds;
            if (appendAgoLabel) {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12969, null, value)
                        : (0, nls_1.localize)(12970, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12971, null, value)
                        : (0, nls_1.localize)(12972, null, value);
                }
            }
            else {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12973, null, value)
                        : (0, nls_1.localize)(12974, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12975, null, value)
                        : (0, nls_1.localize)(12976, null, value);
                }
            }
        }
        if (seconds < hour) {
            value = Math.floor(seconds / minute);
            if (appendAgoLabel) {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12977, null, value)
                        : (0, nls_1.localize)(12978, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12979, null, value)
                        : (0, nls_1.localize)(12980, null, value);
                }
            }
            else {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12981, null, value)
                        : (0, nls_1.localize)(12982, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12983, null, value)
                        : (0, nls_1.localize)(12984, null, value);
                }
            }
        }
        if (seconds < day) {
            value = Math.floor(seconds / hour);
            if (appendAgoLabel) {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12985, null, value)
                        : (0, nls_1.localize)(12986, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12987, null, value)
                        : (0, nls_1.localize)(12988, null, value);
                }
            }
            else {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12989, null, value)
                        : (0, nls_1.localize)(12990, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12991, null, value)
                        : (0, nls_1.localize)(12992, null, value);
                }
            }
        }
        if (seconds < week) {
            value = Math.floor(seconds / day);
            if (appendAgoLabel) {
                return value === 1
                    ? (0, nls_1.localize)(12993, null, value)
                    : (0, nls_1.localize)(12994, null, value);
            }
            else {
                return value === 1
                    ? (0, nls_1.localize)(12995, null, value)
                    : (0, nls_1.localize)(12996, null, value);
            }
        }
        if (seconds < month) {
            value = Math.floor(seconds / week);
            if (appendAgoLabel) {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12997, null, value)
                        : (0, nls_1.localize)(12998, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(12999, null, value)
                        : (0, nls_1.localize)(13000, null, value);
                }
            }
            else {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(13001, null, value)
                        : (0, nls_1.localize)(13002, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(13003, null, value)
                        : (0, nls_1.localize)(13004, null, value);
                }
            }
        }
        if (seconds < year) {
            value = Math.floor(seconds / month);
            if (appendAgoLabel) {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(13005, null, value)
                        : (0, nls_1.localize)(13006, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(13007, null, value)
                        : (0, nls_1.localize)(13008, null, value);
                }
            }
            else {
                if (value === 1) {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(13009, null, value)
                        : (0, nls_1.localize)(13010, null, value);
                }
                else {
                    return useFullTimeWords
                        ? (0, nls_1.localize)(13011, null, value)
                        : (0, nls_1.localize)(13012, null, value);
                }
            }
        }
        value = Math.floor(seconds / year);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? (0, nls_1.localize)(13013, null, value)
                    : (0, nls_1.localize)(13014, null, value);
            }
            else {
                return useFullTimeWords
                    ? (0, nls_1.localize)(13015, null, value)
                    : (0, nls_1.localize)(13016, null, value);
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? (0, nls_1.localize)(13017, null, value)
                    : (0, nls_1.localize)(13018, null, value);
            }
            else {
                return useFullTimeWords
                    ? (0, nls_1.localize)(13019, null, value)
                    : (0, nls_1.localize)(13020, null, value);
            }
        }
    }
    /**
     * Gets a readable duration with intelligent/lossy precision. For example "40ms" or "3.040s")
     * @param ms The duration to get in milliseconds.
     * @param useFullTimeWords Whether to use full words (eg. seconds) instead of
     * shortened (eg. secs).
     */
    function $3m(ms, useFullTimeWords) {
        const seconds = Math.abs(ms / 1000);
        if (seconds < 1) {
            return useFullTimeWords
                ? (0, nls_1.localize)(13021, null, ms)
                : (0, nls_1.localize)(13022, null, ms);
        }
        if (seconds < minute) {
            return useFullTimeWords
                ? (0, nls_1.localize)(13023, null, Math.round(ms) / 1000)
                : (0, nls_1.localize)(13024, null, Math.round(ms) / 1000);
        }
        if (seconds < hour) {
            return useFullTimeWords
                ? (0, nls_1.localize)(13025, null, Math.round(ms / (1000 * minute)))
                : (0, nls_1.localize)(13026, null, Math.round(ms / (1000 * minute)));
        }
        if (seconds < day) {
            return useFullTimeWords
                ? (0, nls_1.localize)(13027, null, Math.round(ms / (1000 * hour)))
                : (0, nls_1.localize)(13028, null, Math.round(ms / (1000 * hour)));
        }
        return (0, nls_1.localize)(13029, null, Math.round(ms / (1000 * day)));
    }
    function $4m(date) {
        return date.getFullYear() +
            '-' + String(date.getMonth() + 1).padStart(2, '0') +
            '-' + String(date.getDate()).padStart(2, '0') +
            'T' + String(date.getHours()).padStart(2, '0') +
            ':' + String(date.getMinutes()).padStart(2, '0') +
            ':' + String(date.getSeconds()).padStart(2, '0') +
            '.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5) +
            'Z';
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[42/*vs/base/common/errorMessage*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,14/*vs/base/common/types*/,9/*vs/nls*/]), function (require, exports, arrays, types, nls) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$qj = $qj;
    exports.$rj = $rj;
    exports.$sj = $sj;
    arrays = __importStar(arrays);
    types = __importStar(types);
    nls = __importStar(nls);
    function exceptionToErrorMessage(exception, verbose) {
        if (verbose && (exception.stack || exception.stacktrace)) {
            return nls.localize(12961, null, detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
        }
        return detectSystemErrorMessage(exception);
    }
    function stackToString(stack) {
        if (Array.isArray(stack)) {
            return stack.join('\n');
        }
        return stack;
    }
    function detectSystemErrorMessage(exception) {
        // Custom node.js error from us
        if (exception.code === 'ERR_UNC_HOST_NOT_ALLOWED') {
            return `${exception.message}. Please update the 'security.allowedUNCHosts' setting if you want to allow this host.`;
        }
        // See https://nodejs.org/api/errors.html#errors_class_system_error
        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
            return nls.localize(12962, null, exception.message);
        }
        return exception.message || nls.localize(12963, null);
    }
    /**
     * Tries to generate a human readable error message out of the error. If the verbose parameter
     * is set to true, the error message will include stacktrace details if provided.
     *
     * @returns A string containing the error message.
     */
    function $qj(error = null, verbose = false) {
        if (!error) {
            return nls.localize(12964, null);
        }
        if (Array.isArray(error)) {
            const errors = arrays.$Gb(error);
            const msg = $qj(errors[0], verbose);
            if (errors.length > 1) {
                return nls.localize(12965, null, msg, errors.length);
            }
            return msg;
        }
        if (types.$eg(error)) {
            return error;
        }
        if (error.detail) {
            const detail = error.detail;
            if (detail.error) {
                return exceptionToErrorMessage(detail.error, verbose);
            }
            if (detail.exception) {
                return exceptionToErrorMessage(detail.exception, verbose);
            }
        }
        if (error.stack) {
            return exceptionToErrorMessage(error, verbose);
        }
        if (error.message) {
            return error.message;
        }
        return nls.localize(12966, null);
    }
    function $rj(obj) {
        const candidate = obj;
        return candidate instanceof Error && Array.isArray(candidate.actions);
    }
    function $sj(messageOrError, actions) {
        let error;
        if (typeof messageOrError === 'string') {
            error = new Error(messageOrError);
        }
        else {
            error = messageOrError;
        }
        error.actions = actions;
        return error;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[166/*vs/platform/contextkey/common/scanner*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,13/*vs/base/common/errors*/,9/*vs/nls*/]), function (require, exports, charCode_1, errors_1, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Aj = exports.TokenType = void 0;
    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["LParen"] = 0] = "LParen";
        TokenType[TokenType["RParen"] = 1] = "RParen";
        TokenType[TokenType["Neg"] = 2] = "Neg";
        TokenType[TokenType["Eq"] = 3] = "Eq";
        TokenType[TokenType["NotEq"] = 4] = "NotEq";
        TokenType[TokenType["Lt"] = 5] = "Lt";
        TokenType[TokenType["LtEq"] = 6] = "LtEq";
        TokenType[TokenType["Gt"] = 7] = "Gt";
        TokenType[TokenType["GtEq"] = 8] = "GtEq";
        TokenType[TokenType["RegexOp"] = 9] = "RegexOp";
        TokenType[TokenType["RegexStr"] = 10] = "RegexStr";
        TokenType[TokenType["True"] = 11] = "True";
        TokenType[TokenType["False"] = 12] = "False";
        TokenType[TokenType["In"] = 13] = "In";
        TokenType[TokenType["Not"] = 14] = "Not";
        TokenType[TokenType["And"] = 15] = "And";
        TokenType[TokenType["Or"] = 16] = "Or";
        TokenType[TokenType["Str"] = 17] = "Str";
        TokenType[TokenType["QuotedStr"] = 18] = "QuotedStr";
        TokenType[TokenType["Error"] = 19] = "Error";
        TokenType[TokenType["EOF"] = 20] = "EOF";
    })(TokenType || (exports.TokenType = TokenType = {}));
    function hintDidYouMean(...meant) {
        switch (meant.length) {
            case 1:
                return (0, nls_1.localize)(11055, null, meant[0]);
            case 2:
                return (0, nls_1.localize)(11056, null, meant[0], meant[1]);
            case 3:
                return (0, nls_1.localize)(11057, null, meant[0], meant[1], meant[2]);
            default: // we just don't expect that many
                return undefined;
        }
    }
    const hintDidYouForgetToOpenOrCloseQuote = (0, nls_1.localize)(11058, null);
    const hintDidYouForgetToEscapeSlash = (0, nls_1.localize)(11059, null);
    /**
     * A simple scanner for context keys.
     *
     * Example:
     *
     * ```ts
     * const scanner = new Scanner().reset('resourceFileName =~ /docker/ && !config.docker.enabled');
     * const tokens = [...scanner];
     * if (scanner.errorTokens.length > 0) {
     *     scanner.errorTokens.forEach(err => console.error(`Unexpected token at ${err.offset}: ${err.lexeme}\nHint: ${err.additional}`));
     * } else {
     *     // process tokens
     * }
     * ```
     */
    class $Aj {
        constructor() {
            this.c = '';
            this.d = 0;
            this.e = 0;
            this.f = [];
            this.g = [];
            // u - unicode, y - sticky // TODO@ulugbekna: we accept double quotes as part of the string rather than as a delimiter (to preserve old parser's behavior)
            this.m = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
        }
        static getLexeme(token) {
            switch (token.type) {
                case TokenType.LParen:
                    return '(';
                case TokenType.RParen:
                    return ')';
                case TokenType.Neg:
                    return '!';
                case TokenType.Eq:
                    return token.isTripleEq ? '===' : '==';
                case TokenType.NotEq:
                    return token.isTripleEq ? '!==' : '!=';
                case TokenType.Lt:
                    return '<';
                case TokenType.LtEq:
                    return '<=';
                case TokenType.Gt:
                    return '>=';
                case TokenType.GtEq:
                    return '>=';
                case TokenType.RegexOp:
                    return '=~';
                case TokenType.RegexStr:
                    return token.lexeme;
                case TokenType.True:
                    return 'true';
                case TokenType.False:
                    return 'false';
                case TokenType.In:
                    return 'in';
                case TokenType.Not:
                    return 'not';
                case TokenType.And:
                    return '&&';
                case TokenType.Or:
                    return '||';
                case TokenType.Str:
                    return token.lexeme;
                case TokenType.QuotedStr:
                    return token.lexeme;
                case TokenType.Error:
                    return token.lexeme;
                case TokenType.EOF:
                    return 'EOF';
                default:
                    throw (0, errors_1.$7)(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
            }
        }
        static { this.a = new Set(['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0))); }
        static { this.b = new Map([
            ['not', TokenType.Not],
            ['in', TokenType.In],
            ['false', TokenType.False],
            ['true', TokenType.True],
        ]); }
        get errors() {
            return this.g;
        }
        reset(value) {
            this.c = value;
            this.d = 0;
            this.e = 0;
            this.f = [];
            this.g = [];
            return this;
        }
        scan() {
            while (!this.r()) {
                this.d = this.e;
                const ch = this.i();
                switch (ch) {
                    case charCode_1.CharCode.OpenParen:
                        this.k(TokenType.LParen);
                        break;
                    case charCode_1.CharCode.CloseParen:
                        this.k(TokenType.RParen);
                        break;
                    case charCode_1.CharCode.ExclamationMark:
                        if (this.h(charCode_1.CharCode.Equals)) {
                            const isTripleEq = this.h(charCode_1.CharCode.Equals); // eat last `=` if `!==`
                            this.f.push({ type: TokenType.NotEq, offset: this.d, isTripleEq });
                        }
                        else {
                            this.k(TokenType.Neg);
                        }
                        break;
                    case charCode_1.CharCode.SingleQuote:
                        this.o();
                        break;
                    case charCode_1.CharCode.Slash:
                        this.q();
                        break;
                    case charCode_1.CharCode.Equals:
                        if (this.h(charCode_1.CharCode.Equals)) { // support `==`
                            const isTripleEq = this.h(charCode_1.CharCode.Equals); // eat last `=` if `===`
                            this.f.push({ type: TokenType.Eq, offset: this.d, isTripleEq });
                        }
                        else if (this.h(charCode_1.CharCode.Tilde)) {
                            this.k(TokenType.RegexOp);
                        }
                        else {
                            this.l(hintDidYouMean('==', '=~'));
                        }
                        break;
                    case charCode_1.CharCode.LessThan:
                        this.k(this.h(charCode_1.CharCode.Equals) ? TokenType.LtEq : TokenType.Lt);
                        break;
                    case charCode_1.CharCode.GreaterThan:
                        this.k(this.h(charCode_1.CharCode.Equals) ? TokenType.GtEq : TokenType.Gt);
                        break;
                    case charCode_1.CharCode.Ampersand:
                        if (this.h(charCode_1.CharCode.Ampersand)) {
                            this.k(TokenType.And);
                        }
                        else {
                            this.l(hintDidYouMean('&&'));
                        }
                        break;
                    case charCode_1.CharCode.Pipe:
                        if (this.h(charCode_1.CharCode.Pipe)) {
                            this.k(TokenType.Or);
                        }
                        else {
                            this.l(hintDidYouMean('||'));
                        }
                        break;
                    // TODO@ulugbekna: 1) rewrite using a regex 2) reconsider what characters are considered whitespace, including unicode, nbsp, etc.
                    case charCode_1.CharCode.Space:
                    case charCode_1.CharCode.CarriageReturn:
                    case charCode_1.CharCode.Tab:
                    case charCode_1.CharCode.LineFeed:
                    case charCode_1.CharCode.NoBreakSpace: // &nbsp
                        break;
                    default:
                        this.n();
                }
            }
            this.d = this.e;
            this.k(TokenType.EOF);
            return Array.from(this.f);
        }
        h(expected) {
            if (this.r()) {
                return false;
            }
            if (this.c.charCodeAt(this.e) !== expected) {
                return false;
            }
            this.e++;
            return true;
        }
        i() {
            return this.c.charCodeAt(this.e++);
        }
        j() {
            return this.r() ? charCode_1.CharCode.Null : this.c.charCodeAt(this.e);
        }
        k(type) {
            this.f.push({ type, offset: this.d });
        }
        l(additional) {
            const offset = this.d;
            const lexeme = this.c.substring(this.d, this.e);
            const errToken = { type: TokenType.Error, offset: this.d, lexeme };
            this.g.push({ offset, lexeme, additionalInfo: additional });
            this.f.push(errToken);
        }
        n() {
            this.m.lastIndex = this.d;
            const match = this.m.exec(this.c);
            if (match) {
                this.e = this.d + match[0].length;
                const lexeme = this.c.substring(this.d, this.e);
                const keyword = $Aj.b.get(lexeme);
                if (keyword) {
                    this.k(keyword);
                }
                else {
                    this.f.push({ type: TokenType.Str, lexeme, offset: this.d });
                }
            }
        }
        // captures the lexeme without the leading and trailing '
        o() {
            while (this.j() !== charCode_1.CharCode.SingleQuote && !this.r()) { // TODO@ulugbekna: add support for escaping ' ?
                this.i();
            }
            if (this.r()) {
                this.l(hintDidYouForgetToOpenOrCloseQuote);
                return;
            }
            // consume the closing '
            this.i();
            this.f.push({ type: TokenType.QuotedStr, lexeme: this.c.substring(this.d + 1, this.e - 1), offset: this.d + 1 });
        }
        /*
         * Lexing a regex expression: /.../[igsmyu]*
         * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
         *
         * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
         */
        q() {
            let p = this.e;
            let inEscape = false;
            let inCharacterClass = false;
            while (true) {
                if (p >= this.c.length) {
                    this.e = p;
                    this.l(hintDidYouForgetToEscapeSlash);
                    return;
                }
                const ch = this.c.charCodeAt(p);
                if (inEscape) { // parsing an escape character
                    inEscape = false;
                }
                else if (ch === charCode_1.CharCode.Slash && !inCharacterClass) { // end of regex
                    p++;
                    break;
                }
                else if (ch === charCode_1.CharCode.OpenSquareBracket) {
                    inCharacterClass = true;
                }
                else if (ch === charCode_1.CharCode.Backslash) {
                    inEscape = true;
                }
                else if (ch === charCode_1.CharCode.CloseSquareBracket) {
                    inCharacterClass = false;
                }
                p++;
            }
            // Consume flags // TODO@ulugbekna: use regex instead
            while (p < this.c.length && $Aj.a.has(this.c.charCodeAt(p))) {
                p++;
            }
            this.e = p;
            const lexeme = this.c.substring(this.d, this.e);
            this.f.push({ type: TokenType.RegexStr, lexeme, offset: this.d });
        }
        r() {
            return this.e >= this.c.length;
        }
    }
    exports.$Aj = $Aj;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[104/*vs/platform/extensions/common/extensionsApiProposals*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.allApiProposals = void 0;
    // THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.
    const _allApiProposals = {
        activeComment: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.activeComment.d.ts',
        },
        aiRelatedInformation: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiRelatedInformation.d.ts',
        },
        aiTextSearchProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProvider.d.ts',
        },
        aiTextSearchProviderNew: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.aiTextSearchProviderNew.d.ts',
        },
        attributableCoverage: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.attributableCoverage.d.ts',
        },
        authGetSessions: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authGetSessions.d.ts',
        },
        authLearnMore: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authLearnMore.d.ts',
        },
        authSession: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.authSession.d.ts',
        },
        canonicalUriProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.canonicalUriProvider.d.ts',
        },
        chatParticipantAdditions: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantAdditions.d.ts',
        },
        chatParticipantPrivate: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatParticipantPrivate.d.ts',
            version: 2
        },
        chatProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatProvider.d.ts',
        },
        chatTab: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatTab.d.ts',
        },
        chatVariableResolver: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.chatVariableResolver.d.ts',
        },
        codeActionAI: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionAI.d.ts',
        },
        codeActionRanges: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codeActionRanges.d.ts',
        },
        codiconDecoration: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.codiconDecoration.d.ts',
        },
        commentReactor: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReactor.d.ts',
        },
        commentReveal: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentReveal.d.ts',
        },
        commentThreadApplicability: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentThreadApplicability.d.ts',
        },
        commentingRangeHint: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentingRangeHint.d.ts',
        },
        commentsDraftState: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.commentsDraftState.d.ts',
        },
        contribAccessibilityHelpContent: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribAccessibilityHelpContent.d.ts',
        },
        contribCommentEditorActionsMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentEditorActionsMenu.d.ts',
        },
        contribCommentPeekContext: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentPeekContext.d.ts',
        },
        contribCommentThreadAdditionalMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentThreadAdditionalMenu.d.ts',
        },
        contribCommentsViewThreadMenus: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribCommentsViewThreadMenus.d.ts',
        },
        contribDiffEditorGutterToolBarMenus: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribDiffEditorGutterToolBarMenus.d.ts',
        },
        contribEditSessions: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditSessions.d.ts',
        },
        contribEditorContentMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribEditorContentMenu.d.ts',
        },
        contribIssueReporter: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribIssueReporter.d.ts',
        },
        contribLabelFormatterWorkspaceTooltip: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribLabelFormatterWorkspaceTooltip.d.ts',
        },
        contribMenuBarHome: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMenuBarHome.d.ts',
        },
        contribMergeEditorMenus: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMergeEditorMenus.d.ts',
        },
        contribMultiDiffEditorMenus: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribMultiDiffEditorMenus.d.ts',
        },
        contribNotebookStaticPreloads: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribNotebookStaticPreloads.d.ts',
        },
        contribRemoteHelp: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribRemoteHelp.d.ts',
        },
        contribShareMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribShareMenu.d.ts',
        },
        contribSourceControlHistoryItemChangesMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemChangesMenu.d.ts',
        },
        contribSourceControlHistoryItemGroupMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemGroupMenu.d.ts',
        },
        contribSourceControlHistoryItemMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlHistoryItemMenu.d.ts',
        },
        contribSourceControlInputBoxMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlInputBoxMenu.d.ts',
        },
        contribSourceControlTitleMenu: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribSourceControlTitleMenu.d.ts',
        },
        contribStatusBarItems: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribStatusBarItems.d.ts',
        },
        contribViewsRemote: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsRemote.d.ts',
        },
        contribViewsWelcome: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.contribViewsWelcome.d.ts',
        },
        createFileSystemWatcher: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.createFileSystemWatcher.d.ts',
        },
        customEditorMove: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.customEditorMove.d.ts',
        },
        debugVisualization: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.debugVisualization.d.ts',
        },
        defaultChatParticipant: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.defaultChatParticipant.d.ts',
        },
        diffCommand: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffCommand.d.ts',
        },
        diffContentOptions: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.diffContentOptions.d.ts',
        },
        documentFiltersExclusive: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentFiltersExclusive.d.ts',
        },
        documentPaste: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.documentPaste.d.ts',
        },
        editSessionIdentityProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editSessionIdentityProvider.d.ts',
        },
        editorHoverVerbosityLevel: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorHoverVerbosityLevel.d.ts',
        },
        editorInsets: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.editorInsets.d.ts',
        },
        embeddings: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.embeddings.d.ts',
        },
        extensionRuntime: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionRuntime.d.ts',
        },
        extensionsAny: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.extensionsAny.d.ts',
        },
        externalUriOpener: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.externalUriOpener.d.ts',
        },
        fileComments: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileComments.d.ts',
        },
        fileSearchProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProvider.d.ts',
        },
        fileSearchProviderNew: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fileSearchProviderNew.d.ts',
        },
        findFiles2: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2.d.ts',
        },
        findFiles2New: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findFiles2New.d.ts',
        },
        findTextInFiles: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFiles.d.ts',
        },
        findTextInFilesNew: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.findTextInFilesNew.d.ts',
        },
        fsChunks: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.fsChunks.d.ts',
        },
        idToken: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.idToken.d.ts',
        },
        inlineCompletionsAdditions: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineCompletionsAdditions.d.ts',
        },
        inlineEdit: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.inlineEdit.d.ts',
        },
        interactive: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactive.d.ts',
        },
        interactiveWindow: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.interactiveWindow.d.ts',
        },
        ipc: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.ipc.d.ts',
        },
        languageModelSystem: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageModelSystem.d.ts',
        },
        languageStatusText: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.languageStatusText.d.ts',
        },
        lmTools: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.lmTools.d.ts',
            version: 2
        },
        mappedEditsProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.mappedEditsProvider.d.ts',
        },
        multiDocumentHighlightProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.multiDocumentHighlightProvider.d.ts',
        },
        newSymbolNamesProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.newSymbolNamesProvider.d.ts',
        },
        notebookCellExecution: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecution.d.ts',
        },
        notebookCellExecutionState: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookCellExecutionState.d.ts',
        },
        notebookControllerAffinityHidden: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookControllerAffinityHidden.d.ts',
        },
        notebookDeprecated: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookDeprecated.d.ts',
        },
        notebookExecution: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookExecution.d.ts',
        },
        notebookKernelSource: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookKernelSource.d.ts',
        },
        notebookLiveShare: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookLiveShare.d.ts',
        },
        notebookMessaging: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMessaging.d.ts',
        },
        notebookMime: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookMime.d.ts',
        },
        notebookVariableProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.notebookVariableProvider.d.ts',
        },
        portsAttributes: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.portsAttributes.d.ts',
        },
        profileContentHandlers: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.profileContentHandlers.d.ts',
        },
        quickDiffProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickDiffProvider.d.ts',
        },
        quickInputButtonLocation: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickInputButtonLocation.d.ts',
        },
        quickPickItemTooltip: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickItemTooltip.d.ts',
        },
        quickPickSortByLabel: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.quickPickSortByLabel.d.ts',
        },
        resolvers: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.resolvers.d.ts',
        },
        scmActionButton: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmActionButton.d.ts',
        },
        scmHistoryProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmHistoryProvider.d.ts',
        },
        scmMultiDiffEditor: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmMultiDiffEditor.d.ts',
        },
        scmSelectedProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmSelectedProvider.d.ts',
        },
        scmTextDocument: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmTextDocument.d.ts',
        },
        scmValidation: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.scmValidation.d.ts',
        },
        shareProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.shareProvider.d.ts',
        },
        showLocal: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.showLocal.d.ts',
        },
        speech: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.speech.d.ts',
        },
        tabInputMultiDiff: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputMultiDiff.d.ts',
        },
        tabInputTextMerge: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tabInputTextMerge.d.ts',
        },
        taskPresentationGroup: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.taskPresentationGroup.d.ts',
        },
        telemetry: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.telemetry.d.ts',
        },
        terminalDataWriteEvent: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDataWriteEvent.d.ts',
        },
        terminalDimensions: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalDimensions.d.ts',
        },
        terminalExecuteCommandEvent: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalExecuteCommandEvent.d.ts',
        },
        terminalQuickFixProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalQuickFixProvider.d.ts',
        },
        terminalSelection: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalSelection.d.ts',
        },
        terminalShellIntegration: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.terminalShellIntegration.d.ts',
        },
        testMessageStackTrace: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testMessageStackTrace.d.ts',
        },
        testObserver: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testObserver.d.ts',
        },
        testRelatedCode: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.testRelatedCode.d.ts',
        },
        textSearchCompleteNew: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchCompleteNew.d.ts',
        },
        textSearchProvider: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProvider.d.ts',
        },
        textSearchProviderNew: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.textSearchProviderNew.d.ts',
        },
        timeline: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.timeline.d.ts',
        },
        tokenInformation: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tokenInformation.d.ts',
        },
        treeViewActiveItem: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewActiveItem.d.ts',
        },
        treeViewMarkdownMessage: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewMarkdownMessage.d.ts',
        },
        treeViewReveal: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.treeViewReveal.d.ts',
        },
        tunnelFactory: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnelFactory.d.ts',
        },
        tunnels: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.tunnels.d.ts',
        },
        workspaceTrust: {
            proposal: 'https://raw.githubusercontent.com/microsoft/vscode/main/src/vscode-dts/vscode.proposed.workspaceTrust.d.ts',
        }
    };
    exports.allApiProposals = Object.freeze(_allApiProposals);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[73/*vs/platform/instantiation/common/descriptors*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ci = void 0;
    class $Ci {
        constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
            this.ctor = ctor;
            this.staticArguments = staticArguments;
            this.supportsDelayedInstantiation = supportsDelayedInstantiation;
        }
    }
    exports.$Ci = $Ci;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[60/*vs/platform/instantiation/common/extensions*/], __M([1/*require*/,0/*exports*/,73/*vs/platform/instantiation/common/descriptors*/]), function (require, exports, descriptors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstantiationType = void 0;
    exports.$Rs = $Rs;
    exports.$Ss = $Ss;
    const _registry = [];
    var InstantiationType;
    (function (InstantiationType) {
        /**
         * Instantiate this service as soon as a consumer depends on it. _Note_ that this
         * is more costly as some upfront work is done that is likely not needed
         */
        InstantiationType[InstantiationType["Eager"] = 0] = "Eager";
        /**
         * Instantiate this service as soon as a consumer uses it. This is the _better_
         * way of registering a service.
         */
        InstantiationType[InstantiationType["Delayed"] = 1] = "Delayed";
    })(InstantiationType || (exports.InstantiationType = InstantiationType = {}));
    function $Rs(id, ctorOrDescriptor, supportsDelayedInstantiation) {
        if (!(ctorOrDescriptor instanceof descriptors_1.$Ci)) {
            ctorOrDescriptor = new descriptors_1.$Ci(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));
        }
        _registry.push([id, ctorOrDescriptor]);
    }
    function $Ss() {
        return _registry;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[167/*vs/platform/instantiation/common/graph*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vr = exports.$ur = void 0;
    class $ur {
        constructor(key, data) {
            this.key = key;
            this.data = data;
            this.incoming = new Map();
            this.outgoing = new Map();
        }
    }
    exports.$ur = $ur;
    class $vr {
        constructor(b) {
            this.b = b;
            this.a = new Map();
            // empty
        }
        roots() {
            const ret = [];
            for (const node of this.a.values()) {
                if (node.outgoing.size === 0) {
                    ret.push(node);
                }
            }
            return ret;
        }
        insertEdge(from, to) {
            const fromNode = this.lookupOrInsertNode(from);
            const toNode = this.lookupOrInsertNode(to);
            fromNode.outgoing.set(toNode.key, toNode);
            toNode.incoming.set(fromNode.key, fromNode);
        }
        removeNode(data) {
            const key = this.b(data);
            this.a.delete(key);
            for (const node of this.a.values()) {
                node.outgoing.delete(key);
                node.incoming.delete(key);
            }
        }
        lookupOrInsertNode(data) {
            const key = this.b(data);
            let node = this.a.get(key);
            if (!node) {
                node = new $ur(key, data);
                this.a.set(key, node);
            }
            return node;
        }
        lookup(data) {
            return this.a.get(this.b(data));
        }
        isEmpty() {
            return this.a.size === 0;
        }
        toString() {
            const data = [];
            for (const [key, value] of this.a) {
                data.push(`${key}\n\t(-> incoming)[${[...value.incoming.keys()].join(', ')}]\n\t(outgoing ->)[${[...value.outgoing.keys()].join(',')}]\n`);
            }
            return data.join('\n');
        }
        /**
         * This is brute force and slow and **only** be used
         * to trouble shoot.
         */
        findCycleSlow() {
            for (const [id, node] of this.a) {
                const seen = new Set([id]);
                const res = this.c(node, seen);
                if (res) {
                    return res;
                }
            }
            return undefined;
        }
        c(node, seen) {
            for (const [id, outgoing] of node.outgoing) {
                if (seen.has(id)) {
                    return [...seen, id].join(' -> ');
                }
                seen.add(id);
                const value = this.c(outgoing, seen);
                if (value) {
                    return value;
                }
                seen.delete(id);
            }
            return undefined;
        }
    }
    exports.$vr = $vr;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[3/*vs/platform/instantiation/common/instantiation*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ei = exports._util = void 0;
    exports.$Fi = $Fi;
    exports.$Gi = $Gi;
    // ------ internal util
    var _util;
    (function (_util) {
        _util.serviceIds = new Map();
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util || (exports._util = _util = {}));
    exports.$Ei = $Fi('instantiationService');
    function storeServiceDependency(id, target, index) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id, index });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id, index }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * The *only* valid way to create a {{ServiceIdentifier}}.
     */
    function $Fi(serviceId) {
        if (_util.serviceIds.has(serviceId)) {
            return _util.serviceIds.get(serviceId);
        }
        const id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index);
        };
        id.toString = () => serviceId;
        _util.serviceIds.set(serviceId, id);
        return id;
    }
    function $Gi(serviceIdentifier) {
        return serviceIdentifier;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[43/*vs/platform/configuration/common/configuration*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, types, uri_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationTarget = exports.$_i = void 0;
    exports.$aj = $aj;
    exports.$bj = $bj;
    exports.$cj = $cj;
    exports.$dj = $dj;
    exports.$ej = $ej;
    exports.$fj = $fj;
    exports.$gj = $gj;
    exports.$hj = $hj;
    exports.$ij = $ij;
    exports.$jj = $jj;
    types = __importStar(types);
    exports.$_i = (0, instantiation_1.$Fi)('configurationService');
    function $aj(thing) {
        return thing
            && typeof thing === 'object'
            && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
            && (!thing.resource || thing.resource instanceof uri_1.URI);
    }
    function $bj(thing) {
        return thing
            && typeof thing === 'object'
            && (!thing.overrideIdentifiers || Array.isArray(thing.overrideIdentifiers))
            && !thing.overrideIdentifier
            && (!thing.resource || thing.resource instanceof uri_1.URI);
    }
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["APPLICATION"] = 1] = "APPLICATION";
        ConfigurationTarget[ConfigurationTarget["USER"] = 2] = "USER";
        ConfigurationTarget[ConfigurationTarget["USER_LOCAL"] = 3] = "USER_LOCAL";
        ConfigurationTarget[ConfigurationTarget["USER_REMOTE"] = 4] = "USER_REMOTE";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE"] = 5] = "WORKSPACE";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE_FOLDER"] = 6] = "WORKSPACE_FOLDER";
        ConfigurationTarget[ConfigurationTarget["DEFAULT"] = 7] = "DEFAULT";
        ConfigurationTarget[ConfigurationTarget["MEMORY"] = 8] = "MEMORY";
    })(ConfigurationTarget || (exports.ConfigurationTarget = ConfigurationTarget = {}));
    function $cj(configurationTarget) {
        switch (configurationTarget) {
            case ConfigurationTarget.APPLICATION: return 'APPLICATION';
            case ConfigurationTarget.USER: return 'USER';
            case ConfigurationTarget.USER_LOCAL: return 'USER_LOCAL';
            case ConfigurationTarget.USER_REMOTE: return 'USER_REMOTE';
            case ConfigurationTarget.WORKSPACE: return 'WORKSPACE';
            case ConfigurationTarget.WORKSPACE_FOLDER: return 'WORKSPACE_FOLDER';
            case ConfigurationTarget.DEFAULT: return 'DEFAULT';
            case ConfigurationTarget.MEMORY: return 'MEMORY';
        }
    }
    function $dj(configValue) {
        return configValue.applicationValue !== undefined ||
            configValue.userValue !== undefined ||
            configValue.userLocalValue !== undefined ||
            configValue.userRemoteValue !== undefined ||
            configValue.workspaceValue !== undefined ||
            configValue.workspaceFolderValue !== undefined;
    }
    function $ej(properties, conflictReporter) {
        const root = Object.create(null);
        for (const key in properties) {
            $fj(root, key, properties[key], conflictReporter);
        }
        return root;
    }
    function $fj(settingsTreeRoot, key, value, conflictReporter) {
        const segments = key.split('.');
        const last = segments.pop();
        let curr = settingsTreeRoot;
        for (let i = 0; i < segments.length; i++) {
            const s = segments[i];
            let obj = curr[s];
            switch (typeof obj) {
                case 'undefined':
                    obj = curr[s] = Object.create(null);
                    break;
                case 'object':
                    if (obj === null) {
                        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is null`);
                        return;
                    }
                    break;
                default:
                    conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);
                    return;
            }
            curr = obj;
        }
        if (typeof curr === 'object' && curr !== null) {
            try {
                curr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606
            }
            catch (e) {
                conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
            }
        }
        else {
            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
        }
    }
    function $gj(valueTree, key) {
        const segments = key.split('.');
        doRemoveFromValueTree(valueTree, segments);
    }
    function doRemoveFromValueTree(valueTree, segments) {
        const first = segments.shift();
        if (segments.length === 0) {
            // Reached last segment
            delete valueTree[first];
            return;
        }
        if (Object.keys(valueTree).indexOf(first) !== -1) {
            const value = valueTree[first];
            if (typeof value === 'object' && !Array.isArray(value)) {
                doRemoveFromValueTree(value, segments);
                if (Object.keys(value).length === 0) {
                    delete valueTree[first];
                }
            }
        }
    }
    /**
     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
     */
    function $hj(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            let current = config;
            for (const component of path) {
                if (typeof current !== 'object' || current === null) {
                    return undefined;
                }
                current = current[component];
            }
            return current;
        }
        const path = settingPath.split('.');
        const result = accessSetting(config, path);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    function $ij(base, add, overwrite) {
        Object.keys(add).forEach(key => {
            if (key !== '__proto__') {
                if (key in base) {
                    if (types.$gg(base[key]) && types.$gg(add[key])) {
                        $ij(base[key], add[key], overwrite);
                    }
                    else if (overwrite) {
                        base[key] = add[key];
                    }
                }
                else {
                    base[key] = add[key];
                }
            }
        });
    }
    function $jj(settingKey) {
        return settingKey.replace(/[\[\]]/g, '');
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[31/*vs/platform/contextkey/common/contextkey*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,20/*vs/base/common/platform*/,12/*vs/base/common/strings*/,166/*vs/platform/contextkey/common/scanner*/,3/*vs/platform/instantiation/common/instantiation*/,9/*vs/nls*/,13/*vs/base/common/errors*/]), function (require, exports, charCode_1, platform_1, strings_1, scanner_1, instantiation_1, nls_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Xj = exports.$Wj = exports.$Vj = exports.$Uj = exports.$Tj = exports.$Sj = exports.$Rj = exports.$Qj = exports.$Pj = exports.$Oj = exports.$Nj = exports.$Mj = exports.$Lj = exports.$Kj = exports.$Jj = exports.$Ij = exports.$Hj = exports.$Gj = exports.$Dj = exports.$Cj = exports.ContextKeyExprType = void 0;
    exports.$Bj = $Bj;
    exports.$Ej = $Ej;
    exports.$Fj = $Fj;
    exports.$Yj = $Yj;
    const CONSTANT_VALUES = new Map();
    CONSTANT_VALUES.set('false', false);
    CONSTANT_VALUES.set('true', true);
    CONSTANT_VALUES.set('isMac', platform_1.$k);
    CONSTANT_VALUES.set('isLinux', platform_1.$l);
    CONSTANT_VALUES.set('isWindows', platform_1.$j);
    CONSTANT_VALUES.set('isWeb', platform_1.$p);
    CONSTANT_VALUES.set('isMacNative', platform_1.$k && !platform_1.$p);
    CONSTANT_VALUES.set('isEdge', platform_1.$I);
    CONSTANT_VALUES.set('isFirefox', platform_1.$G);
    CONSTANT_VALUES.set('isChrome', platform_1.$F);
    CONSTANT_VALUES.set('isSafari', platform_1.$H);
    /** allow register constant context keys that are known only after startup; requires running `substituteConstants` on the context key - https://github.com/microsoft/vscode/issues/174218#issuecomment-1437972127 */
    function $Bj(key, value) {
        if (CONSTANT_VALUES.get(key) !== undefined) {
            throw (0, errors_1.$6)('contextkey.setConstant(k, v) invoked with already set constant `k`');
        }
        CONSTANT_VALUES.set(key, value);
    }
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    var ContextKeyExprType;
    (function (ContextKeyExprType) {
        ContextKeyExprType[ContextKeyExprType["False"] = 0] = "False";
        ContextKeyExprType[ContextKeyExprType["True"] = 1] = "True";
        ContextKeyExprType[ContextKeyExprType["Defined"] = 2] = "Defined";
        ContextKeyExprType[ContextKeyExprType["Not"] = 3] = "Not";
        ContextKeyExprType[ContextKeyExprType["Equals"] = 4] = "Equals";
        ContextKeyExprType[ContextKeyExprType["NotEquals"] = 5] = "NotEquals";
        ContextKeyExprType[ContextKeyExprType["And"] = 6] = "And";
        ContextKeyExprType[ContextKeyExprType["Regex"] = 7] = "Regex";
        ContextKeyExprType[ContextKeyExprType["NotRegex"] = 8] = "NotRegex";
        ContextKeyExprType[ContextKeyExprType["Or"] = 9] = "Or";
        ContextKeyExprType[ContextKeyExprType["In"] = 10] = "In";
        ContextKeyExprType[ContextKeyExprType["NotIn"] = 11] = "NotIn";
        ContextKeyExprType[ContextKeyExprType["Greater"] = 12] = "Greater";
        ContextKeyExprType[ContextKeyExprType["GreaterEquals"] = 13] = "GreaterEquals";
        ContextKeyExprType[ContextKeyExprType["Smaller"] = 14] = "Smaller";
        ContextKeyExprType[ContextKeyExprType["SmallerEquals"] = 15] = "SmallerEquals";
    })(ContextKeyExprType || (exports.ContextKeyExprType = ContextKeyExprType = {}));
    const defaultConfig = {
        regexParsingWithErrorRecovery: true
    };
    const errorEmptyString = (0, nls_1.localize)(11069, null);
    const hintEmptyString = (0, nls_1.localize)(11070, null);
    const errorNoInAfterNot = (0, nls_1.localize)(11071, null);
    const errorClosingParenthesis = (0, nls_1.localize)(11072, null);
    const errorUnexpectedToken = (0, nls_1.localize)(11073, null);
    const hintUnexpectedToken = (0, nls_1.localize)(11074, null);
    const errorUnexpectedEOF = (0, nls_1.localize)(11075, null);
    const hintUnexpectedEOF = (0, nls_1.localize)(11076, null);
    /**
     * A parser for context key expressions.
     *
     * Example:
     * ```ts
     * const parser = new Parser();
     * const expr = parser.parse('foo == "bar" && baz == true');
     *
     * if (expr === undefined) {
     * 	// there were lexing or parsing errors
     * 	// process lexing errors with `parser.lexingErrors`
     *  // process parsing errors with `parser.parsingErrors`
     * } else {
     * 	// expr is a valid expression
     * }
     * ```
     */
    class $Cj {
        // Note: this doesn't produce an exact syntax tree but a normalized one
        // ContextKeyExpression's that we use as AST nodes do not expose constructors that do not normalize
        static { this.c = new Error(); }
        get lexingErrors() {
            return this.d.errors;
        }
        get parsingErrors() {
            return this.h;
        }
        constructor(k = defaultConfig) {
            this.k = k;
            // lifetime note: `_scanner` lives as long as the parser does, i.e., is not reset between calls to `parse`
            this.d = new scanner_1.$Aj();
            // lifetime note: `_tokens`, `_current`, and `_parsingErrors` must be reset between calls to `parse`
            this.f = [];
            this.g = 0; // invariant: 0 <= this._current < this._tokens.length ; any incrementation of this value must first call `_isAtEnd`
            this.h = [];
            this.v = /g|y/g;
        }
        /**
         * Parse a context key expression.
         *
         * @param input the expression to parse
         * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
         */
        parse(input) {
            if (input === '') {
                this.h.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });
                return undefined;
            }
            this.f = this.d.reset(input).scan();
            // @ulugbekna: we do not stop parsing if there are lexing errors to be able to reconstruct regexes with unescaped slashes; TODO@ulugbekna: make this respect config option for recovery
            this.g = 0;
            this.h = [];
            try {
                const expr = this.l();
                if (!this.E()) {
                    const peek = this.D();
                    const additionalInfo = peek.type === scanner_1.TokenType.Str ? hintUnexpectedToken : undefined;
                    this.h.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: scanner_1.$Aj.getLexeme(peek), additionalInfo });
                    throw $Cj.c;
                }
                return expr;
            }
            catch (e) {
                if (!(e === $Cj.c)) {
                    throw e;
                }
                return undefined;
            }
        }
        l() {
            return this.m();
        }
        m() {
            const expr = [this.o()];
            while (this.y(scanner_1.TokenType.Or)) {
                const right = this.o();
                expr.push(right);
            }
            return expr.length === 1 ? expr[0] : $Dj.or(...expr);
        }
        o() {
            const expr = [this.s()];
            while (this.y(scanner_1.TokenType.And)) {
                const right = this.s();
                expr.push(right);
            }
            return expr.length === 1 ? expr[0] : $Dj.and(...expr);
        }
        s() {
            if (this.y(scanner_1.TokenType.Neg)) {
                const peek = this.D();
                switch (peek.type) {
                    case scanner_1.TokenType.True:
                        this.z();
                        return $Gj.INSTANCE;
                    case scanner_1.TokenType.False:
                        this.z();
                        return $Hj.INSTANCE;
                    case scanner_1.TokenType.LParen: {
                        this.z();
                        const expr = this.l();
                        this.A(scanner_1.TokenType.RParen, errorClosingParenthesis);
                        return expr?.negate();
                    }
                    case scanner_1.TokenType.Str:
                        this.z();
                        return $Nj.create(peek.lexeme);
                    default:
                        throw this.B(`KEY | true | false | '(' expression ')'`, peek);
                }
            }
            return this.t();
        }
        t() {
            const peek = this.D();
            switch (peek.type) {
                case scanner_1.TokenType.True:
                    this.z();
                    return $Dj.true();
                case scanner_1.TokenType.False:
                    this.z();
                    return $Dj.false();
                case scanner_1.TokenType.LParen: {
                    this.z();
                    const expr = this.l();
                    this.A(scanner_1.TokenType.RParen, errorClosingParenthesis);
                    return expr;
                }
                case scanner_1.TokenType.Str: {
                    // KEY
                    const key = peek.lexeme;
                    this.z();
                    // =~ regex
                    if (this.y(scanner_1.TokenType.RegexOp)) {
                        // @ulugbekna: we need to reconstruct the regex from the tokens because some extensions use unescaped slashes in regexes
                        const expr = this.D();
                        if (!this.k.regexParsingWithErrorRecovery) {
                            this.z();
                            if (expr.type !== scanner_1.TokenType.RegexStr) {
                                throw this.B(`REGEX`, expr);
                            }
                            const regexLexeme = expr.lexeme;
                            const closingSlashIndex = regexLexeme.lastIndexOf('/');
                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this.w(regexLexeme.substring(closingSlashIndex + 1));
                            let regexp;
                            try {
                                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                            }
                            catch (e) {
                                throw this.B(`REGEX`, expr);
                            }
                            return $Sj.create(key, regexp);
                        }
                        switch (expr.type) {
                            case scanner_1.TokenType.RegexStr:
                            case scanner_1.TokenType.Error: { // also handle an ErrorToken in case of smth such as /(/file)/
                                const lexemeReconstruction = [expr.lexeme]; // /REGEX/ or /REGEX/FLAGS
                                this.z();
                                let followingToken = this.D();
                                let parenBalance = 0;
                                for (let i = 0; i < expr.lexeme.length; i++) {
                                    if (expr.lexeme.charCodeAt(i) === charCode_1.CharCode.OpenParen) {
                                        parenBalance++;
                                    }
                                    else if (expr.lexeme.charCodeAt(i) === charCode_1.CharCode.CloseParen) {
                                        parenBalance--;
                                    }
                                }
                                while (!this.E() && followingToken.type !== scanner_1.TokenType.And && followingToken.type !== scanner_1.TokenType.Or) {
                                    switch (followingToken.type) {
                                        case scanner_1.TokenType.LParen:
                                            parenBalance++;
                                            break;
                                        case scanner_1.TokenType.RParen:
                                            parenBalance--;
                                            break;
                                        case scanner_1.TokenType.RegexStr:
                                        case scanner_1.TokenType.QuotedStr:
                                            for (let i = 0; i < followingToken.lexeme.length; i++) {
                                                if (followingToken.lexeme.charCodeAt(i) === charCode_1.CharCode.OpenParen) {
                                                    parenBalance++;
                                                }
                                                else if (expr.lexeme.charCodeAt(i) === charCode_1.CharCode.CloseParen) {
                                                    parenBalance--;
                                                }
                                            }
                                    }
                                    if (parenBalance < 0) {
                                        break;
                                    }
                                    lexemeReconstruction.push(scanner_1.$Aj.getLexeme(followingToken));
                                    this.z();
                                    followingToken = this.D();
                                }
                                const regexLexeme = lexemeReconstruction.join('');
                                const closingSlashIndex = regexLexeme.lastIndexOf('/');
                                const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this.w(regexLexeme.substring(closingSlashIndex + 1));
                                let regexp;
                                try {
                                    regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);
                                }
                                catch (e) {
                                    throw this.B(`REGEX`, expr);
                                }
                                return $Dj.regex(key, regexp);
                            }
                            case scanner_1.TokenType.QuotedStr: {
                                const serializedValue = expr.lexeme;
                                this.z();
                                // replicate old regex parsing behavior
                                let regex = null;
                                if (!(0, strings_1.$cf)(serializedValue)) {
                                    const start = serializedValue.indexOf('/');
                                    const end = serializedValue.lastIndexOf('/');
                                    if (start !== end && start >= 0) {
                                        const value = serializedValue.slice(start + 1, end);
                                        const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
                                        try {
                                            regex = new RegExp(value, caseIgnoreFlag);
                                        }
                                        catch (_e) {
                                            throw this.B(`REGEX`, expr);
                                        }
                                    }
                                }
                                if (regex === null) {
                                    throw this.B('REGEX', expr);
                                }
                                return $Sj.create(key, regex);
                            }
                            default:
                                throw this.B('REGEX', this.D());
                        }
                    }
                    // [ 'not' 'in' value ]
                    if (this.y(scanner_1.TokenType.Not)) {
                        this.A(scanner_1.TokenType.In, errorNoInAfterNot);
                        const right = this.u();
                        return $Dj.notIn(key, right);
                    }
                    // [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in') value ]
                    const maybeOp = this.D().type;
                    switch (maybeOp) {
                        case scanner_1.TokenType.Eq: {
                            this.z();
                            const right = this.u();
                            if (this.x().type === scanner_1.TokenType.QuotedStr) { // to preserve old parser behavior: "foo == 'true'" is preserved as "foo == 'true'", but "foo == true" is optimized as "foo"
                                return $Dj.equals(key, right);
                            }
                            switch (right) {
                                case 'true':
                                    return $Dj.has(key);
                                case 'false':
                                    return $Dj.not(key);
                                default:
                                    return $Dj.equals(key, right);
                            }
                        }
                        case scanner_1.TokenType.NotEq: {
                            this.z();
                            const right = this.u();
                            if (this.x().type === scanner_1.TokenType.QuotedStr) { // same as above with "foo != 'true'"
                                return $Dj.notEquals(key, right);
                            }
                            switch (right) {
                                case 'true':
                                    return $Dj.not(key);
                                case 'false':
                                    return $Dj.has(key);
                                default:
                                    return $Dj.notEquals(key, right);
                            }
                        }
                        // TODO: ContextKeyExpr.smaller(key, right) accepts only `number` as `right` AND during eval of this node, we just eval to `false` if `right` is not a number
                        // consequently, package.json linter should _warn_ the user if they're passing undesired things to ops
                        case scanner_1.TokenType.Lt:
                            this.z();
                            return $Qj.create(key, this.u());
                        case scanner_1.TokenType.LtEq:
                            this.z();
                            return $Rj.create(key, this.u());
                        case scanner_1.TokenType.Gt:
                            this.z();
                            return $Oj.create(key, this.u());
                        case scanner_1.TokenType.GtEq:
                            this.z();
                            return $Pj.create(key, this.u());
                        case scanner_1.TokenType.In:
                            this.z();
                            return $Dj.in(key, this.u());
                        default:
                            return $Dj.has(key);
                    }
                }
                case scanner_1.TokenType.EOF:
                    this.h.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });
                    throw $Cj.c;
                default:
                    throw this.B(`true | false | KEY \n\t| KEY '=~' REGEX \n\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this.D());
            }
        }
        u() {
            const token = this.D();
            switch (token.type) {
                case scanner_1.TokenType.Str:
                case scanner_1.TokenType.QuotedStr:
                    this.z();
                    return token.lexeme;
                case scanner_1.TokenType.True:
                    this.z();
                    return 'true';
                case scanner_1.TokenType.False:
                    this.z();
                    return 'false';
                case scanner_1.TokenType.In: // we support `in` as a value, e.g., "when": "languageId == in" - exists in existing extensions
                    this.z();
                    return 'in';
                default:
                    // this allows "when": "foo == " which's used by existing extensions
                    // we do not call `_advance` on purpose - we don't want to eat unintended tokens
                    return '';
            }
        }
        w(flags) {
            return flags.replaceAll(this.v, '');
        }
        // careful: this can throw if current token is the initial one (ie index = 0)
        x() {
            return this.f[this.g - 1];
        }
        y(token) {
            if (this.C(token)) {
                this.z();
                return true;
            }
            return false;
        }
        z() {
            if (!this.E()) {
                this.g++;
            }
            return this.x();
        }
        A(type, message) {
            if (this.C(type)) {
                return this.z();
            }
            throw this.B(message, this.D());
        }
        B(expected, got, additionalInfo) {
            const message = (0, nls_1.localize)(11077, null, expected, scanner_1.$Aj.getLexeme(got));
            const offset = got.offset;
            const lexeme = scanner_1.$Aj.getLexeme(got);
            this.h.push({ message, offset, lexeme, additionalInfo });
            return $Cj.c;
        }
        C(type) {
            return this.D().type === type;
        }
        D() {
            return this.f[this.g];
        }
        E() {
            return this.D().type === scanner_1.TokenType.EOF;
        }
    }
    exports.$Cj = $Cj;
    class $Dj {
        static false() {
            return $Gj.INSTANCE;
        }
        static true() {
            return $Hj.INSTANCE;
        }
        static has(key) {
            return $Ij.create(key);
        }
        static equals(key, value) {
            return $Jj.create(key, value);
        }
        static notEquals(key, value) {
            return $Mj.create(key, value);
        }
        static regex(key, value) {
            return $Sj.create(key, value);
        }
        static in(key, value) {
            return $Kj.create(key, value);
        }
        static notIn(key, value) {
            return $Lj.create(key, value);
        }
        static not(key) {
            return $Nj.create(key);
        }
        static and(...expr) {
            return $Uj.create(expr, null, true);
        }
        static or(...expr) {
            return $Vj.create(expr, null, true);
        }
        static greater(key, value) {
            return $Oj.create(key, value);
        }
        static greaterEquals(key, value) {
            return $Pj.create(key, value);
        }
        static smaller(key, value) {
            return $Qj.create(key, value);
        }
        static smallerEquals(key, value) {
            return $Rj.create(key, value);
        }
        static { this.c = new $Cj({ regexParsingWithErrorRecovery: false }); }
        static deserialize(serialized) {
            if (serialized === undefined || serialized === null) { // an empty string needs to be handled by the parser to get a corresponding parsing error reported
                return undefined;
            }
            const expr = this.c.parse(serialized);
            return expr;
        }
    }
    exports.$Dj = $Dj;
    function $Ej(whenClauses) {
        const parser = new $Cj({ regexParsingWithErrorRecovery: false }); // we run with no recovery to guide users to use correct regexes
        return whenClauses.map(whenClause => {
            parser.parse(whenClause);
            if (parser.lexingErrors.length > 0) {
                return parser.lexingErrors.map((se) => ({
                    errorMessage: se.additionalInfo ?
                        (0, nls_1.localize)(11078, null, se.additionalInfo) :
                        (0, nls_1.localize)(11079, null),
                    offset: se.offset,
                    length: se.lexeme.length,
                }));
            }
            else if (parser.parsingErrors.length > 0) {
                return parser.parsingErrors.map((pe) => ({
                    errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,
                    offset: pe.offset,
                    length: pe.lexeme.length,
                }));
            }
            else {
                return [];
            }
        });
    }
    function $Fj(a, b) {
        const aExpr = a ? a.substituteConstants() : undefined;
        const bExpr = b ? b.substituteConstants() : undefined;
        if (!aExpr && !bExpr) {
            return true;
        }
        if (!aExpr || !bExpr) {
            return false;
        }
        return aExpr.equals(bExpr);
    }
    function cmp(a, b) {
        return a.cmp(b);
    }
    class $Gj {
        static { this.INSTANCE = new $Gj(); }
        constructor() {
            this.type = ContextKeyExprType.False;
        }
        cmp(other) {
            return this.type - other.type;
        }
        equals(other) {
            return (other.type === this.type);
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            return false;
        }
        serialize() {
            return 'false';
        }
        keys() {
            return [];
        }
        map(mapFnc) {
            return this;
        }
        negate() {
            return $Hj.INSTANCE;
        }
    }
    exports.$Gj = $Gj;
    class $Hj {
        static { this.INSTANCE = new $Hj(); }
        constructor() {
            this.type = ContextKeyExprType.True;
        }
        cmp(other) {
            return this.type - other.type;
        }
        equals(other) {
            return (other.type === this.type);
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            return true;
        }
        serialize() {
            return 'true';
        }
        keys() {
            return [];
        }
        map(mapFnc) {
            return this;
        }
        negate() {
            return $Gj.INSTANCE;
        }
    }
    exports.$Hj = $Hj;
    class $Ij {
        static create(key, negated = null) {
            const constantValue = CONSTANT_VALUES.get(key);
            if (typeof constantValue === 'boolean') {
                return constantValue ? $Hj.INSTANCE : $Gj.INSTANCE;
            }
            return new $Ij(key, negated);
        }
        constructor(key, c) {
            this.key = key;
            this.c = c;
            this.type = ContextKeyExprType.Defined;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp1(this.key, other.key);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.key === other.key);
            }
            return false;
        }
        substituteConstants() {
            const constantValue = CONSTANT_VALUES.get(this.key);
            if (typeof constantValue === 'boolean') {
                return constantValue ? $Hj.INSTANCE : $Gj.INSTANCE;
            }
            return this;
        }
        evaluate(context) {
            return (!!context.getValue(this.key));
        }
        serialize() {
            return this.key;
        }
        keys() {
            return [this.key];
        }
        map(mapFnc) {
            return mapFnc.mapDefined(this.key);
        }
        negate() {
            if (!this.c) {
                this.c = $Nj.create(this.key, this);
            }
            return this.c;
        }
    }
    exports.$Ij = $Ij;
    class $Jj {
        static create(key, value, negated = null) {
            if (typeof value === 'boolean') {
                return (value ? $Ij.create(key, negated) : $Nj.create(key, negated));
            }
            const constantValue = CONSTANT_VALUES.get(key);
            if (typeof constantValue === 'boolean') {
                const trueValue = constantValue ? 'true' : 'false';
                return (value === trueValue ? $Hj.INSTANCE : $Gj.INSTANCE);
            }
            return new $Jj(key, value, negated);
        }
        constructor(c, d, f) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.Equals;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.c, this.d, other.c, other.d);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c && this.d === other.d);
            }
            return false;
        }
        substituteConstants() {
            const constantValue = CONSTANT_VALUES.get(this.c);
            if (typeof constantValue === 'boolean') {
                const trueValue = constantValue ? 'true' : 'false';
                return (this.d === trueValue ? $Hj.INSTANCE : $Gj.INSTANCE);
            }
            return this;
        }
        evaluate(context) {
            // Intentional ==
            // eslint-disable-next-line eqeqeq
            return (context.getValue(this.c) == this.d);
        }
        serialize() {
            return `${this.c} == '${this.d}'`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapEquals(this.c, this.d);
        }
        negate() {
            if (!this.f) {
                this.f = $Mj.create(this.c, this.d, this);
            }
            return this.f;
        }
    }
    exports.$Jj = $Jj;
    class $Kj {
        static create(key, valueKey) {
            return new $Kj(key, valueKey);
        }
        constructor(d, f) {
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.In;
            this.c = null;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.d, this.f, other.d, other.f);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.d === other.d && this.f === other.f);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            const source = context.getValue(this.f);
            const item = context.getValue(this.d);
            if (Array.isArray(source)) {
                return source.includes(item);
            }
            if (typeof item === 'string' && typeof source === 'object' && source !== null) {
                return hasOwnProperty.call(source, item);
            }
            return false;
        }
        serialize() {
            return `${this.d} in '${this.f}'`;
        }
        keys() {
            return [this.d, this.f];
        }
        map(mapFnc) {
            return mapFnc.mapIn(this.d, this.f);
        }
        negate() {
            if (!this.c) {
                this.c = $Lj.create(this.d, this.f);
            }
            return this.c;
        }
    }
    exports.$Kj = $Kj;
    class $Lj {
        static create(key, valueKey) {
            return new $Lj(key, valueKey);
        }
        constructor(d, f) {
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.NotIn;
            this.c = $Kj.create(d, f);
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return this.c.cmp(other.c);
        }
        equals(other) {
            if (other.type === this.type) {
                return this.c.equals(other.c);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            return !this.c.evaluate(context);
        }
        serialize() {
            return `${this.d} not in '${this.f}'`;
        }
        keys() {
            return this.c.keys();
        }
        map(mapFnc) {
            return mapFnc.mapNotIn(this.d, this.f);
        }
        negate() {
            return this.c;
        }
    }
    exports.$Lj = $Lj;
    class $Mj {
        static create(key, value, negated = null) {
            if (typeof value === 'boolean') {
                if (value) {
                    return $Nj.create(key, negated);
                }
                return $Ij.create(key, negated);
            }
            const constantValue = CONSTANT_VALUES.get(key);
            if (typeof constantValue === 'boolean') {
                const falseValue = constantValue ? 'true' : 'false';
                return (value === falseValue ? $Gj.INSTANCE : $Hj.INSTANCE);
            }
            return new $Mj(key, value, negated);
        }
        constructor(c, d, f) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.NotEquals;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.c, this.d, other.c, other.d);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c && this.d === other.d);
            }
            return false;
        }
        substituteConstants() {
            const constantValue = CONSTANT_VALUES.get(this.c);
            if (typeof constantValue === 'boolean') {
                const falseValue = constantValue ? 'true' : 'false';
                return (this.d === falseValue ? $Gj.INSTANCE : $Hj.INSTANCE);
            }
            return this;
        }
        evaluate(context) {
            // Intentional !=
            // eslint-disable-next-line eqeqeq
            return (context.getValue(this.c) != this.d);
        }
        serialize() {
            return `${this.c} != '${this.d}'`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapNotEquals(this.c, this.d);
        }
        negate() {
            if (!this.f) {
                this.f = $Jj.create(this.c, this.d, this);
            }
            return this.f;
        }
    }
    exports.$Mj = $Mj;
    class $Nj {
        static create(key, negated = null) {
            const constantValue = CONSTANT_VALUES.get(key);
            if (typeof constantValue === 'boolean') {
                return (constantValue ? $Gj.INSTANCE : $Hj.INSTANCE);
            }
            return new $Nj(key, negated);
        }
        constructor(c, d) {
            this.c = c;
            this.d = d;
            this.type = ContextKeyExprType.Not;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp1(this.c, other.c);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c);
            }
            return false;
        }
        substituteConstants() {
            const constantValue = CONSTANT_VALUES.get(this.c);
            if (typeof constantValue === 'boolean') {
                return (constantValue ? $Gj.INSTANCE : $Hj.INSTANCE);
            }
            return this;
        }
        evaluate(context) {
            return (!context.getValue(this.c));
        }
        serialize() {
            return `!${this.c}`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapNot(this.c);
        }
        negate() {
            if (!this.d) {
                this.d = $Ij.create(this.c, this);
            }
            return this.d;
        }
    }
    exports.$Nj = $Nj;
    function withFloatOrStr(value, callback) {
        if (typeof value === 'string') {
            const n = parseFloat(value);
            if (!isNaN(n)) {
                value = n;
            }
        }
        if (typeof value === 'string' || typeof value === 'number') {
            return callback(value);
        }
        return $Gj.INSTANCE;
    }
    class $Oj {
        static create(key, _value, negated = null) {
            return withFloatOrStr(_value, (value) => new $Oj(key, value, negated));
        }
        constructor(c, d, f) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.Greater;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.c, this.d, other.c, other.d);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c && this.d === other.d);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            if (typeof this.d === 'string') {
                return false;
            }
            return (parseFloat(context.getValue(this.c)) > this.d);
        }
        serialize() {
            return `${this.c} > ${this.d}`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapGreater(this.c, this.d);
        }
        negate() {
            if (!this.f) {
                this.f = $Rj.create(this.c, this.d, this);
            }
            return this.f;
        }
    }
    exports.$Oj = $Oj;
    class $Pj {
        static create(key, _value, negated = null) {
            return withFloatOrStr(_value, (value) => new $Pj(key, value, negated));
        }
        constructor(c, d, f) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.GreaterEquals;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.c, this.d, other.c, other.d);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c && this.d === other.d);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            if (typeof this.d === 'string') {
                return false;
            }
            return (parseFloat(context.getValue(this.c)) >= this.d);
        }
        serialize() {
            return `${this.c} >= ${this.d}`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapGreaterEquals(this.c, this.d);
        }
        negate() {
            if (!this.f) {
                this.f = $Qj.create(this.c, this.d, this);
            }
            return this.f;
        }
    }
    exports.$Pj = $Pj;
    class $Qj {
        static create(key, _value, negated = null) {
            return withFloatOrStr(_value, (value) => new $Qj(key, value, negated));
        }
        constructor(c, d, f) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.Smaller;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.c, this.d, other.c, other.d);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c && this.d === other.d);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            if (typeof this.d === 'string') {
                return false;
            }
            return (parseFloat(context.getValue(this.c)) < this.d);
        }
        serialize() {
            return `${this.c} < ${this.d}`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapSmaller(this.c, this.d);
        }
        negate() {
            if (!this.f) {
                this.f = $Pj.create(this.c, this.d, this);
            }
            return this.f;
        }
    }
    exports.$Qj = $Qj;
    class $Rj {
        static create(key, _value, negated = null) {
            return withFloatOrStr(_value, (value) => new $Rj(key, value, negated));
        }
        constructor(c, d, f) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.SmallerEquals;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return cmp2(this.c, this.d, other.c, other.d);
        }
        equals(other) {
            if (other.type === this.type) {
                return (this.c === other.c && this.d === other.d);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            if (typeof this.d === 'string') {
                return false;
            }
            return (parseFloat(context.getValue(this.c)) <= this.d);
        }
        serialize() {
            return `${this.c} <= ${this.d}`;
        }
        keys() {
            return [this.c];
        }
        map(mapFnc) {
            return mapFnc.mapSmallerEquals(this.c, this.d);
        }
        negate() {
            if (!this.f) {
                this.f = $Oj.create(this.c, this.d, this);
            }
            return this.f;
        }
    }
    exports.$Rj = $Rj;
    class $Sj {
        static create(key, regexp) {
            return new $Sj(key, regexp);
        }
        constructor(d, f) {
            this.d = d;
            this.f = f;
            this.type = ContextKeyExprType.Regex;
            this.c = null;
            //
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            if (this.d < other.d) {
                return -1;
            }
            if (this.d > other.d) {
                return 1;
            }
            const thisSource = this.f ? this.f.source : '';
            const otherSource = other.f ? other.f.source : '';
            if (thisSource < otherSource) {
                return -1;
            }
            if (thisSource > otherSource) {
                return 1;
            }
            return 0;
        }
        equals(other) {
            if (other.type === this.type) {
                const thisSource = this.f ? this.f.source : '';
                const otherSource = other.f ? other.f.source : '';
                return (this.d === other.d && thisSource === otherSource);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            const value = context.getValue(this.d);
            return this.f ? this.f.test(value) : false;
        }
        serialize() {
            const value = this.f
                ? `/${this.f.source}/${this.f.flags}`
                : '/invalid/';
            return `${this.d} =~ ${value}`;
        }
        keys() {
            return [this.d];
        }
        map(mapFnc) {
            return mapFnc.mapRegex(this.d, this.f);
        }
        negate() {
            if (!this.c) {
                this.c = $Tj.create(this);
            }
            return this.c;
        }
    }
    exports.$Sj = $Sj;
    class $Tj {
        static create(actual) {
            return new $Tj(actual);
        }
        constructor(c) {
            this.c = c;
            this.type = ContextKeyExprType.NotRegex;
            //
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            return this.c.cmp(other.c);
        }
        equals(other) {
            if (other.type === this.type) {
                return this.c.equals(other.c);
            }
            return false;
        }
        substituteConstants() {
            return this;
        }
        evaluate(context) {
            return !this.c.evaluate(context);
        }
        serialize() {
            return `!(${this.c.serialize()})`;
        }
        keys() {
            return this.c.keys();
        }
        map(mapFnc) {
            return new $Tj(this.c.map(mapFnc));
        }
        negate() {
            return this.c;
        }
    }
    exports.$Tj = $Tj;
    /**
     * @returns the same instance if nothing changed.
     */
    function eliminateConstantsInArray(arr) {
        // Allocate array only if there is a difference
        let newArr = null;
        for (let i = 0, len = arr.length; i < len; i++) {
            const newExpr = arr[i].substituteConstants();
            if (arr[i] !== newExpr) {
                // something has changed!
                // allocate array on first difference
                if (newArr === null) {
                    newArr = [];
                    for (let j = 0; j < i; j++) {
                        newArr[j] = arr[j];
                    }
                }
            }
            if (newArr !== null) {
                newArr[i] = newExpr;
            }
        }
        if (newArr === null) {
            return arr;
        }
        return newArr;
    }
    class $Uj {
        static create(_expr, negated, extraRedundantCheck) {
            return $Uj.d(_expr, negated, extraRedundantCheck);
        }
        constructor(expr, c) {
            this.expr = expr;
            this.c = c;
            this.type = ContextKeyExprType.And;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            if (this.expr.length < other.expr.length) {
                return -1;
            }
            if (this.expr.length > other.expr.length) {
                return 1;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
                const r = cmp(this.expr[i], other.expr[i]);
                if (r !== 0) {
                    return r;
                }
            }
            return 0;
        }
        equals(other) {
            if (other.type === this.type) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (let i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
        substituteConstants() {
            const exprArr = eliminateConstantsInArray(this.expr);
            if (exprArr === this.expr) {
                // no change
                return this;
            }
            return $Uj.create(exprArr, this.c, false);
        }
        evaluate(context) {
            for (let i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        }
        static d(arr, negated, extraRedundantCheck) {
            const expr = [];
            let hasTrue = false;
            for (const e of arr) {
                if (!e) {
                    continue;
                }
                if (e.type === ContextKeyExprType.True) {
                    // anything && true ==> anything
                    hasTrue = true;
                    continue;
                }
                if (e.type === ContextKeyExprType.False) {
                    // anything && false ==> false
                    return $Gj.INSTANCE;
                }
                if (e.type === ContextKeyExprType.And) {
                    expr.push(...e.expr);
                    continue;
                }
                expr.push(e);
            }
            if (expr.length === 0 && hasTrue) {
                return $Hj.INSTANCE;
            }
            if (expr.length === 0) {
                return undefined;
            }
            if (expr.length === 1) {
                return expr[0];
            }
            expr.sort(cmp);
            // eliminate duplicate terms
            for (let i = 1; i < expr.length; i++) {
                if (expr[i - 1].equals(expr[i])) {
                    expr.splice(i, 1);
                    i--;
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
            // We must distribute any OR expression because we don't support parens
            // OR extensions will be at the end (due to sorting rules)
            while (expr.length > 1) {
                const lastElement = expr[expr.length - 1];
                if (lastElement.type !== ContextKeyExprType.Or) {
                    break;
                }
                // pop the last element
                expr.pop();
                // pop the second to last element
                const secondToLastElement = expr.pop();
                const isFinished = (expr.length === 0);
                // distribute `lastElement` over `secondToLastElement`
                const resultElement = $Vj.create(lastElement.expr.map(el => $Uj.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);
                if (resultElement) {
                    expr.push(resultElement);
                    expr.sort(cmp);
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
            // resolve false AND expressions
            if (extraRedundantCheck) {
                for (let i = 0; i < expr.length; i++) {
                    for (let j = i + 1; j < expr.length; j++) {
                        if (expr[i].negate().equals(expr[j])) {
                            // A && !A case
                            return $Gj.INSTANCE;
                        }
                    }
                }
                if (expr.length === 1) {
                    return expr[0];
                }
            }
            return new $Uj(expr, negated);
        }
        serialize() {
            return this.expr.map(e => e.serialize()).join(' && ');
        }
        keys() {
            const result = [];
            for (const expr of this.expr) {
                result.push(...expr.keys());
            }
            return result;
        }
        map(mapFnc) {
            return new $Uj(this.expr.map(expr => expr.map(mapFnc)), null);
        }
        negate() {
            if (!this.c) {
                const result = [];
                for (const expr of this.expr) {
                    result.push(expr.negate());
                }
                this.c = $Vj.create(result, this, true);
            }
            return this.c;
        }
    }
    exports.$Uj = $Uj;
    class $Vj {
        static create(_expr, negated, extraRedundantCheck) {
            return $Vj.d(_expr, negated, extraRedundantCheck);
        }
        constructor(expr, c) {
            this.expr = expr;
            this.c = c;
            this.type = ContextKeyExprType.Or;
        }
        cmp(other) {
            if (other.type !== this.type) {
                return this.type - other.type;
            }
            if (this.expr.length < other.expr.length) {
                return -1;
            }
            if (this.expr.length > other.expr.length) {
                return 1;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
                const r = cmp(this.expr[i], other.expr[i]);
                if (r !== 0) {
                    return r;
                }
            }
            return 0;
        }
        equals(other) {
            if (other.type === this.type) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (let i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
        substituteConstants() {
            const exprArr = eliminateConstantsInArray(this.expr);
            if (exprArr === this.expr) {
                // no change
                return this;
            }
            return $Vj.create(exprArr, this.c, false);
        }
        evaluate(context) {
            for (let i = 0, len = this.expr.length; i < len; i++) {
                if (this.expr[i].evaluate(context)) {
                    return true;
                }
            }
            return false;
        }
        static d(arr, negated, extraRedundantCheck) {
            let expr = [];
            let hasFalse = false;
            if (arr) {
                for (let i = 0, len = arr.length; i < len; i++) {
                    const e = arr[i];
                    if (!e) {
                        continue;
                    }
                    if (e.type === ContextKeyExprType.False) {
                        // anything || false ==> anything
                        hasFalse = true;
                        continue;
                    }
                    if (e.type === ContextKeyExprType.True) {
                        // anything || true ==> true
                        return $Hj.INSTANCE;
                    }
                    if (e.type === ContextKeyExprType.Or) {
                        expr = expr.concat(e.expr);
                        continue;
                    }
                    expr.push(e);
                }
                if (expr.length === 0 && hasFalse) {
                    return $Gj.INSTANCE;
                }
                expr.sort(cmp);
            }
            if (expr.length === 0) {
                return undefined;
            }
            if (expr.length === 1) {
                return expr[0];
            }
            // eliminate duplicate terms
            for (let i = 1; i < expr.length; i++) {
                if (expr[i - 1].equals(expr[i])) {
                    expr.splice(i, 1);
                    i--;
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
            // resolve true OR expressions
            if (extraRedundantCheck) {
                for (let i = 0; i < expr.length; i++) {
                    for (let j = i + 1; j < expr.length; j++) {
                        if (expr[i].negate().equals(expr[j])) {
                            // A || !A case
                            return $Hj.INSTANCE;
                        }
                    }
                }
                if (expr.length === 1) {
                    return expr[0];
                }
            }
            return new $Vj(expr, negated);
        }
        serialize() {
            return this.expr.map(e => e.serialize()).join(' || ');
        }
        keys() {
            const result = [];
            for (const expr of this.expr) {
                result.push(...expr.keys());
            }
            return result;
        }
        map(mapFnc) {
            return new $Vj(this.expr.map(expr => expr.map(mapFnc)), null);
        }
        negate() {
            if (!this.c) {
                const result = [];
                for (const expr of this.expr) {
                    result.push(expr.negate());
                }
                // We don't support parens, so here we distribute the AND over the OR terminals
                // We always take the first 2 AND pairs and distribute them
                while (result.length > 1) {
                    const LEFT = result.shift();
                    const RIGHT = result.shift();
                    const all = [];
                    for (const left of getTerminals(LEFT)) {
                        for (const right of getTerminals(RIGHT)) {
                            all.push($Uj.create([left, right], null, false));
                        }
                    }
                    result.unshift($Vj.create(all, null, false));
                }
                this.c = $Vj.create(result, this, true);
            }
            return this.c;
        }
    }
    exports.$Vj = $Vj;
    class $Wj extends $Ij {
        static { this.d = []; }
        static all() {
            return $Wj.d.values();
        }
        constructor(key, defaultValue, metaOrHide) {
            super(key, null);
            this.f = defaultValue;
            // collect all context keys into a central place
            if (typeof metaOrHide === 'object') {
                $Wj.d.push({ ...metaOrHide, key });
            }
            else if (metaOrHide !== true) {
                $Wj.d.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });
            }
        }
        bindTo(target) {
            return target.createKey(this.key, this.f);
        }
        getValue(target) {
            return target.getContextKeyValue(this.key);
        }
        toNegated() {
            return this.negate();
        }
        isEqualTo(value) {
            return $Jj.create(this.key, value);
        }
        notEqualsTo(value) {
            return $Mj.create(this.key, value);
        }
    }
    exports.$Wj = $Wj;
    exports.$Xj = (0, instantiation_1.$Fi)('contextKeyService');
    function cmp1(key1, key2) {
        if (key1 < key2) {
            return -1;
        }
        if (key1 > key2) {
            return 1;
        }
        return 0;
    }
    function cmp2(key1, value1, key2, value2) {
        if (key1 < key2) {
            return -1;
        }
        if (key1 > key2) {
            return 1;
        }
        if (value1 < value2) {
            return -1;
        }
        if (value1 > value2) {
            return 1;
        }
        return 0;
    }
    /**
     * Returns true if it is provable `p` implies `q`.
     */
    function $Yj(p, q) {
        if (p.type === ContextKeyExprType.False || q.type === ContextKeyExprType.True) {
            // false implies anything
            // anything implies true
            return true;
        }
        if (p.type === ContextKeyExprType.Or) {
            if (q.type === ContextKeyExprType.Or) {
                // `a || b || c` can only imply something like `a || b || c || d`
                return allElementsIncluded(p.expr, q.expr);
            }
            return false;
        }
        if (q.type === ContextKeyExprType.Or) {
            for (const element of q.expr) {
                if ($Yj(p, element)) {
                    return true;
                }
            }
            return false;
        }
        if (p.type === ContextKeyExprType.And) {
            if (q.type === ContextKeyExprType.And) {
                // `a && b && c` implies `a && c`
                return allElementsIncluded(q.expr, p.expr);
            }
            for (const element of p.expr) {
                if ($Yj(element, q)) {
                    return true;
                }
            }
            return false;
        }
        return p.equals(q);
    }
    /**
     * Returns true if all elements in `p` are also present in `q`.
     * The two arrays are assumed to be sorted
     */
    function allElementsIncluded(p, q) {
        let pIndex = 0;
        let qIndex = 0;
        while (pIndex < p.length && qIndex < q.length) {
            const cmp = p[pIndex].cmp(q[qIndex]);
            if (cmp < 0) {
                // an element from `p` is missing from `q`
                return false;
            }
            else if (cmp === 0) {
                pIndex++;
                qIndex++;
            }
            else {
                qIndex++;
            }
        }
        return (pIndex === p.length);
    }
    function getTerminals(node) {
        if (node.type === ContextKeyExprType.Or) {
            return node.expr;
        }
        return [node];
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[168/*vs/platform/accessibility/common/accessibility*/], __M([1/*require*/,0/*exports*/,31/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ut = exports.$st = exports.AccessibilitySupport = exports.$rt = void 0;
    exports.$tt = $tt;
    exports.$rt = (0, instantiation_1.$Fi)('accessibilityService');
    var AccessibilitySupport;
    (function (AccessibilitySupport) {
        /**
         * This should be the browser case where it is not known if a screen reader is attached or no.
         */
        AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
        AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
        AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
    })(AccessibilitySupport || (exports.AccessibilitySupport = AccessibilitySupport = {}));
    exports.$st = new contextkey_1.$Wj('accessibilityModeEnabled', false);
    function $tt(obj) {
        return obj && typeof obj === 'object'
            && typeof obj.label === 'string'
            && (typeof obj.role === 'undefined' || typeof obj.role === 'string');
    }
    exports.$ut = 'ACCESSIBLE_VIEW_SHOWN_';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[105/*vs/editor/common/config/editorOptions*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,25/*vs/base/common/objects*/,20/*vs/base/common/platform*/,146/*vs/base/common/scrollable*/,280/*vs/base/common/uint*/,156/*vs/editor/common/core/textModelDefaults*/,169/*vs/editor/common/core/wordHelper*/,9/*vs/nls*/,168/*vs/platform/accessibility/common/accessibility*/]), function (require, exports, arrays, objects, platform, scrollable_1, uint_1, textModelDefaults_1, wordHelper_1, nls, accessibility_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditorOptions = exports.EditorOption = exports.editorOptionsRegistry = exports.EDITOR_FONT_DEFAULTS = exports.WrappingIndent = exports.unicodeHighlightConfigKeys = exports.inUntrustedWorkspace = exports.RenderLineNumbersType = exports.ShowLightbulbIconMode = exports.EditorLayoutInfoComputer = exports.RenderMinimap = exports.EditorFontVariations = exports.EditorFontLigatures = exports.TextEditorCursorStyle = exports.TextEditorCursorBlinkingStyle = exports.ApplyUpdateResult = exports.ComputeOptionsMemory = exports.ConfigurationChangedEvent = exports.MINIMAP_GUTTER_WIDTH = exports.EditorAutoIndentStrategy = void 0;
    exports.boolean = boolean;
    exports.clampedInt = clampedInt;
    exports.clampedFloat = clampedFloat;
    exports.stringSet = stringSet;
    exports.cursorStyleToString = cursorStyleToString;
    exports.filterValidationDecorations = filterValidationDecorations;
    arrays = __importStar(arrays);
    objects = __importStar(objects);
    platform = __importStar(platform);
    nls = __importStar(nls);
    /**
     * Configuration options for auto indentation in the editor
     */
    var EditorAutoIndentStrategy;
    (function (EditorAutoIndentStrategy) {
        EditorAutoIndentStrategy[EditorAutoIndentStrategy["None"] = 0] = "None";
        EditorAutoIndentStrategy[EditorAutoIndentStrategy["Keep"] = 1] = "Keep";
        EditorAutoIndentStrategy[EditorAutoIndentStrategy["Brackets"] = 2] = "Brackets";
        EditorAutoIndentStrategy[EditorAutoIndentStrategy["Advanced"] = 3] = "Advanced";
        EditorAutoIndentStrategy[EditorAutoIndentStrategy["Full"] = 4] = "Full";
    })(EditorAutoIndentStrategy || (exports.EditorAutoIndentStrategy = EditorAutoIndentStrategy = {}));
    /**
     * @internal
     * The width of the minimap gutter, in pixels.
     */
    exports.MINIMAP_GUTTER_WIDTH = 8;
    //#endregion
    /**
     * An event describing that the configuration of the editor has changed.
     */
    class ConfigurationChangedEvent {
        /**
         * @internal
         */
        constructor(values) {
            this.c = values;
        }
        hasChanged(id) {
            return this.c[id];
        }
    }
    exports.ConfigurationChangedEvent = ConfigurationChangedEvent;
    /**
     * @internal
     */
    class ComputeOptionsMemory {
        constructor() {
            this.stableMinimapLayoutInput = null;
            this.stableFitMaxMinimapScale = 0;
            this.stableFitRemainingWidth = 0;
        }
    }
    exports.ComputeOptionsMemory = ComputeOptionsMemory;
    /**
     * @internal
     */
    class BaseEditorOption {
        constructor(id, name, defaultValue, schema) {
            this.id = id;
            this.name = name;
            this.defaultValue = defaultValue;
            this.schema = schema;
        }
        applyUpdate(value, update) {
            return applyUpdate(value, update);
        }
        compute(env, options, value) {
            return value;
        }
    }
    class ApplyUpdateResult {
        constructor(newValue, didChange) {
            this.newValue = newValue;
            this.didChange = didChange;
        }
    }
    exports.ApplyUpdateResult = ApplyUpdateResult;
    function applyUpdate(value, update) {
        if (typeof value !== 'object' || typeof update !== 'object' || !value || !update) {
            return new ApplyUpdateResult(update, value !== update);
        }
        if (Array.isArray(value) || Array.isArray(update)) {
            const arrayEquals = Array.isArray(value) && Array.isArray(update) && arrays.$tb(value, update);
            return new ApplyUpdateResult(update, !arrayEquals);
        }
        let didChange = false;
        for (const key in update) {
            if (update.hasOwnProperty(key)) {
                const result = applyUpdate(value[key], update[key]);
                if (result.didChange) {
                    value[key] = result.newValue;
                    didChange = true;
                }
            }
        }
        return new ApplyUpdateResult(value, didChange);
    }
    /**
     * @internal
     */
    class ComputedEditorOption {
        constructor(id) {
            this.schema = undefined;
            this.id = id;
            this.name = '_never_';
            this.defaultValue = undefined;
        }
        applyUpdate(value, update) {
            return applyUpdate(value, update);
        }
        validate(input) {
            return this.defaultValue;
        }
    }
    class SimpleEditorOption {
        constructor(id, name, defaultValue, schema) {
            this.id = id;
            this.name = name;
            this.defaultValue = defaultValue;
            this.schema = schema;
        }
        applyUpdate(value, update) {
            return applyUpdate(value, update);
        }
        validate(input) {
            if (typeof input === 'undefined') {
                return this.defaultValue;
            }
            return input;
        }
        compute(env, options, value) {
            return value;
        }
    }
    /**
     * @internal
     */
    function boolean(value, defaultValue) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        if (value === 'false') {
            // treat the string 'false' as false
            return false;
        }
        return Boolean(value);
    }
    class EditorBooleanOption extends SimpleEditorOption {
        constructor(id, name, defaultValue, schema = undefined) {
            if (typeof schema !== 'undefined') {
                schema.type = 'boolean';
                schema.default = defaultValue;
            }
            super(id, name, defaultValue, schema);
        }
        validate(input) {
            return boolean(input, this.defaultValue);
        }
    }
    /**
     * @internal
     */
    function clampedInt(value, defaultValue, minimum, maximum) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        let r = parseInt(value, 10);
        if (isNaN(r)) {
            return defaultValue;
        }
        r = Math.max(minimum, r);
        r = Math.min(maximum, r);
        return r | 0;
    }
    class EditorIntOption extends SimpleEditorOption {
        static clampedInt(value, defaultValue, minimum, maximum) {
            return clampedInt(value, defaultValue, minimum, maximum);
        }
        constructor(id, name, defaultValue, minimum, maximum, schema = undefined) {
            if (typeof schema !== 'undefined') {
                schema.type = 'integer';
                schema.default = defaultValue;
                schema.minimum = minimum;
                schema.maximum = maximum;
            }
            super(id, name, defaultValue, schema);
            this.minimum = minimum;
            this.maximum = maximum;
        }
        validate(input) {
            return EditorIntOption.clampedInt(input, this.defaultValue, this.minimum, this.maximum);
        }
    }
    /**
     * @internal
     */
    function clampedFloat(value, defaultValue, minimum, maximum) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        const r = EditorFloatOption.float(value, defaultValue);
        return EditorFloatOption.clamp(r, minimum, maximum);
    }
    class EditorFloatOption extends SimpleEditorOption {
        static clamp(n, min, max) {
            if (n < min) {
                return min;
            }
            if (n > max) {
                return max;
            }
            return n;
        }
        static float(value, defaultValue) {
            if (typeof value === 'number') {
                return value;
            }
            if (typeof value === 'undefined') {
                return defaultValue;
            }
            const r = parseFloat(value);
            return (isNaN(r) ? defaultValue : r);
        }
        constructor(id, name, defaultValue, validationFn, schema) {
            if (typeof schema !== 'undefined') {
                schema.type = 'number';
                schema.default = defaultValue;
            }
            super(id, name, defaultValue, schema);
            this.validationFn = validationFn;
        }
        validate(input) {
            return this.validationFn(EditorFloatOption.float(input, this.defaultValue));
        }
    }
    class EditorStringOption extends SimpleEditorOption {
        static string(value, defaultValue) {
            if (typeof value !== 'string') {
                return defaultValue;
            }
            return value;
        }
        constructor(id, name, defaultValue, schema = undefined) {
            if (typeof schema !== 'undefined') {
                schema.type = 'string';
                schema.default = defaultValue;
            }
            super(id, name, defaultValue, schema);
        }
        validate(input) {
            return EditorStringOption.string(input, this.defaultValue);
        }
    }
    /**
     * @internal
     */
    function stringSet(value, defaultValue, allowedValues, renamedValues) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        if (renamedValues && value in renamedValues) {
            return renamedValues[value];
        }
        if (allowedValues.indexOf(value) === -1) {
            return defaultValue;
        }
        return value;
    }
    class EditorStringEnumOption extends SimpleEditorOption {
        constructor(id, name, defaultValue, allowedValues, schema = undefined) {
            if (typeof schema !== 'undefined') {
                schema.type = 'string';
                schema.enum = allowedValues;
                schema.default = defaultValue;
            }
            super(id, name, defaultValue, schema);
            this.c = allowedValues;
        }
        validate(input) {
            return stringSet(input, this.defaultValue, this.c);
        }
    }
    class EditorEnumOption extends BaseEditorOption {
        constructor(id, name, defaultValue, defaultStringValue, allowedValues, convert, schema = undefined) {
            if (typeof schema !== 'undefined') {
                schema.type = 'string';
                schema.enum = allowedValues;
                schema.default = defaultStringValue;
            }
            super(id, name, defaultValue, schema);
            this.c = allowedValues;
            this.d = convert;
        }
        validate(input) {
            if (typeof input !== 'string') {
                return this.defaultValue;
            }
            if (this.c.indexOf(input) === -1) {
                return this.defaultValue;
            }
            return this.d(input);
        }
    }
    //#endregion
    //#region autoIndent
    function _autoIndentFromString(autoIndent) {
        switch (autoIndent) {
            case 'none': return EditorAutoIndentStrategy.None;
            case 'keep': return EditorAutoIndentStrategy.Keep;
            case 'brackets': return EditorAutoIndentStrategy.Brackets;
            case 'advanced': return EditorAutoIndentStrategy.Advanced;
            case 'full': return EditorAutoIndentStrategy.Full;
        }
    }
    //#endregion
    //#region accessibilitySupport
    class EditorAccessibilitySupport extends BaseEditorOption {
        constructor() {
            super(EditorOption.accessibilitySupport, 'accessibilitySupport', accessibility_1.AccessibilitySupport.Unknown, {
                type: 'string',
                enum: ['auto', 'on', 'off'],
                enumDescriptions: [
                    nls.localize(11775, null),
                    nls.localize(11776, null),
                    nls.localize(11777, null),
                ],
                default: 'auto',
                tags: ['accessibility'],
                description: nls.localize(11778, null)
            });
        }
        validate(input) {
            switch (input) {
                case 'auto': return accessibility_1.AccessibilitySupport.Unknown;
                case 'off': return accessibility_1.AccessibilitySupport.Disabled;
                case 'on': return accessibility_1.AccessibilitySupport.Enabled;
            }
            return this.defaultValue;
        }
        compute(env, options, value) {
            if (value === accessibility_1.AccessibilitySupport.Unknown) {
                // The editor reads the `accessibilitySupport` from the environment
                return env.accessibilitySupport;
            }
            return value;
        }
    }
    class EditorComments extends BaseEditorOption {
        constructor() {
            const defaults = {
                insertSpace: true,
                ignoreEmptyLines: true,
            };
            super(EditorOption.comments, 'comments', defaults, {
                'editor.comments.insertSpace': {
                    type: 'boolean',
                    default: defaults.insertSpace,
                    description: nls.localize(11779, null)
                },
                'editor.comments.ignoreEmptyLines': {
                    type: 'boolean',
                    default: defaults.ignoreEmptyLines,
                    description: nls.localize(11780, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                insertSpace: boolean(input.insertSpace, this.defaultValue.insertSpace),
                ignoreEmptyLines: boolean(input.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines),
            };
        }
    }
    //#endregion
    //#region cursorBlinking
    /**
     * The kind of animation in which the editor's cursor should be rendered.
     */
    var TextEditorCursorBlinkingStyle;
    (function (TextEditorCursorBlinkingStyle) {
        /**
         * Hidden
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
        /**
         * Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
        /**
         * Blinking with smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
        /**
         * Blinking with prolonged filled state and smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
        /**
         * Expand collapse animation on the y axis
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
        /**
         * No-Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
    })(TextEditorCursorBlinkingStyle || (exports.TextEditorCursorBlinkingStyle = TextEditorCursorBlinkingStyle = {}));
    function _cursorBlinkingStyleFromString(cursorBlinkingStyle) {
        switch (cursorBlinkingStyle) {
            case 'blink': return TextEditorCursorBlinkingStyle.Blink;
            case 'smooth': return TextEditorCursorBlinkingStyle.Smooth;
            case 'phase': return TextEditorCursorBlinkingStyle.Phase;
            case 'expand': return TextEditorCursorBlinkingStyle.Expand;
            case 'solid': return TextEditorCursorBlinkingStyle.Solid;
        }
    }
    //#endregion
    //#region cursorStyle
    /**
     * The style in which the editor's cursor should be rendered.
     */
    var TextEditorCursorStyle;
    (function (TextEditorCursorStyle) {
        /**
         * As a vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        /**
         * As a block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        /**
         * As a horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
        /**
         * As a thin vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
        /**
         * As an outlined block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
        /**
         * As a thin horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
    })(TextEditorCursorStyle || (exports.TextEditorCursorStyle = TextEditorCursorStyle = {}));
    /**
     * @internal
     */
    function cursorStyleToString(cursorStyle) {
        switch (cursorStyle) {
            case TextEditorCursorStyle.Line: return 'line';
            case TextEditorCursorStyle.Block: return 'block';
            case TextEditorCursorStyle.Underline: return 'underline';
            case TextEditorCursorStyle.LineThin: return 'line-thin';
            case TextEditorCursorStyle.BlockOutline: return 'block-outline';
            case TextEditorCursorStyle.UnderlineThin: return 'underline-thin';
        }
    }
    function _cursorStyleFromString(cursorStyle) {
        switch (cursorStyle) {
            case 'line': return TextEditorCursorStyle.Line;
            case 'block': return TextEditorCursorStyle.Block;
            case 'underline': return TextEditorCursorStyle.Underline;
            case 'line-thin': return TextEditorCursorStyle.LineThin;
            case 'block-outline': return TextEditorCursorStyle.BlockOutline;
            case 'underline-thin': return TextEditorCursorStyle.UnderlineThin;
        }
    }
    //#endregion
    //#region editorClassName
    class EditorClassName extends ComputedEditorOption {
        constructor() {
            super(EditorOption.editorClassName);
        }
        compute(env, options, _) {
            const classNames = ['monaco-editor'];
            if (options.get(EditorOption.extraEditorClassName)) {
                classNames.push(options.get(EditorOption.extraEditorClassName));
            }
            if (env.extraEditorClassName) {
                classNames.push(env.extraEditorClassName);
            }
            if (options.get(EditorOption.mouseStyle) === 'default') {
                classNames.push('mouse-default');
            }
            else if (options.get(EditorOption.mouseStyle) === 'copy') {
                classNames.push('mouse-copy');
            }
            if (options.get(EditorOption.showUnused)) {
                classNames.push('showUnused');
            }
            if (options.get(EditorOption.showDeprecated)) {
                classNames.push('showDeprecated');
            }
            return classNames.join(' ');
        }
    }
    //#endregion
    //#region emptySelectionClipboard
    class EditorEmptySelectionClipboard extends EditorBooleanOption {
        constructor() {
            super(EditorOption.emptySelectionClipboard, 'emptySelectionClipboard', true, { description: nls.localize(11781, null) });
        }
        compute(env, options, value) {
            return value && env.emptySelectionClipboard;
        }
    }
    class EditorFind extends BaseEditorOption {
        constructor() {
            const defaults = {
                cursorMoveOnType: true,
                seedSearchStringFromSelection: 'always',
                autoFindInSelection: 'never',
                globalFindClipboard: false,
                addExtraSpaceOnTop: true,
                loop: true
            };
            super(EditorOption.find, 'find', defaults, {
                'editor.find.cursorMoveOnType': {
                    type: 'boolean',
                    default: defaults.cursorMoveOnType,
                    description: nls.localize(11782, null)
                },
                'editor.find.seedSearchStringFromSelection': {
                    type: 'string',
                    enum: ['never', 'always', 'selection'],
                    default: defaults.seedSearchStringFromSelection,
                    enumDescriptions: [
                        nls.localize(11783, null),
                        nls.localize(11784, null),
                        nls.localize(11785, null)
                    ],
                    description: nls.localize(11786, null)
                },
                'editor.find.autoFindInSelection': {
                    type: 'string',
                    enum: ['never', 'always', 'multiline'],
                    default: defaults.autoFindInSelection,
                    enumDescriptions: [
                        nls.localize(11787, null),
                        nls.localize(11788, null),
                        nls.localize(11789, null)
                    ],
                    description: nls.localize(11790, null)
                },
                'editor.find.globalFindClipboard': {
                    type: 'boolean',
                    default: defaults.globalFindClipboard,
                    description: nls.localize(11791, null),
                    included: platform.$k
                },
                'editor.find.addExtraSpaceOnTop': {
                    type: 'boolean',
                    default: defaults.addExtraSpaceOnTop,
                    description: nls.localize(11792, null)
                },
                'editor.find.loop': {
                    type: 'boolean',
                    default: defaults.loop,
                    description: nls.localize(11793, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                cursorMoveOnType: boolean(input.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
                seedSearchStringFromSelection: typeof _input.seedSearchStringFromSelection === 'boolean'
                    ? (_input.seedSearchStringFromSelection ? 'always' : 'never')
                    : stringSet(input.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ['never', 'always', 'selection']),
                autoFindInSelection: typeof _input.autoFindInSelection === 'boolean'
                    ? (_input.autoFindInSelection ? 'always' : 'never')
                    : stringSet(input.autoFindInSelection, this.defaultValue.autoFindInSelection, ['never', 'always', 'multiline']),
                globalFindClipboard: boolean(input.globalFindClipboard, this.defaultValue.globalFindClipboard),
                addExtraSpaceOnTop: boolean(input.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
                loop: boolean(input.loop, this.defaultValue.loop),
            };
        }
    }
    //#endregion
    //#region fontLigatures
    /**
     * @internal
     */
    class EditorFontLigatures extends BaseEditorOption {
        static { this.OFF = '"liga" off, "calt" off'; }
        static { this.ON = '"liga" on, "calt" on'; }
        constructor() {
            super(EditorOption.fontLigatures, 'fontLigatures', EditorFontLigatures.OFF, {
                anyOf: [
                    {
                        type: 'boolean',
                        description: nls.localize(11794, null),
                    },
                    {
                        type: 'string',
                        description: nls.localize(11795, null)
                    }
                ],
                description: nls.localize(11796, null),
                default: false
            });
        }
        validate(input) {
            if (typeof input === 'undefined') {
                return this.defaultValue;
            }
            if (typeof input === 'string') {
                if (input === 'false' || input.length === 0) {
                    return EditorFontLigatures.OFF;
                }
                if (input === 'true') {
                    return EditorFontLigatures.ON;
                }
                return input;
            }
            if (Boolean(input)) {
                return EditorFontLigatures.ON;
            }
            return EditorFontLigatures.OFF;
        }
    }
    exports.EditorFontLigatures = EditorFontLigatures;
    //#endregion
    //#region fontVariations
    /**
     * @internal
     */
    class EditorFontVariations extends BaseEditorOption {
        // Text is laid out using default settings.
        static { this.OFF = 'normal'; }
        // Translate `fontWeight` config to the `font-variation-settings` CSS property.
        static { this.TRANSLATE = 'translate'; }
        constructor() {
            super(EditorOption.fontVariations, 'fontVariations', EditorFontVariations.OFF, {
                anyOf: [
                    {
                        type: 'boolean',
                        description: nls.localize(11797, null),
                    },
                    {
                        type: 'string',
                        description: nls.localize(11798, null)
                    }
                ],
                description: nls.localize(11799, null),
                default: false
            });
        }
        validate(input) {
            if (typeof input === 'undefined') {
                return this.defaultValue;
            }
            if (typeof input === 'string') {
                if (input === 'false') {
                    return EditorFontVariations.OFF;
                }
                if (input === 'true') {
                    return EditorFontVariations.TRANSLATE;
                }
                return input;
            }
            if (Boolean(input)) {
                return EditorFontVariations.TRANSLATE;
            }
            return EditorFontVariations.OFF;
        }
        compute(env, options, value) {
            // The value is computed from the fontWeight if it is true.
            // So take the result from env.fontInfo
            return env.fontInfo.fontVariationSettings;
        }
    }
    exports.EditorFontVariations = EditorFontVariations;
    //#endregion
    //#region fontInfo
    class EditorFontInfo extends ComputedEditorOption {
        constructor() {
            super(EditorOption.fontInfo);
        }
        compute(env, options, _) {
            return env.fontInfo;
        }
    }
    //#endregion
    //#region fontSize
    class EditorFontSize extends SimpleEditorOption {
        constructor() {
            super(EditorOption.fontSize, 'fontSize', exports.EDITOR_FONT_DEFAULTS.fontSize, {
                type: 'number',
                minimum: 6,
                maximum: 100,
                default: exports.EDITOR_FONT_DEFAULTS.fontSize,
                description: nls.localize(11800, null)
            });
        }
        validate(input) {
            const r = EditorFloatOption.float(input, this.defaultValue);
            if (r === 0) {
                return exports.EDITOR_FONT_DEFAULTS.fontSize;
            }
            return EditorFloatOption.clamp(r, 6, 100);
        }
        compute(env, options, value) {
            // The final fontSize respects the editor zoom level.
            // So take the result from env.fontInfo
            return env.fontInfo.fontSize;
        }
    }
    //#endregion
    //#region fontWeight
    class EditorFontWeight extends BaseEditorOption {
        static { this.c = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']; }
        static { this.d = 1; }
        static { this.e = 1000; }
        constructor() {
            super(EditorOption.fontWeight, 'fontWeight', exports.EDITOR_FONT_DEFAULTS.fontWeight, {
                anyOf: [
                    {
                        type: 'number',
                        minimum: EditorFontWeight.d,
                        maximum: EditorFontWeight.e,
                        errorMessage: nls.localize(11801, null)
                    },
                    {
                        type: 'string',
                        pattern: '^(normal|bold|1000|[1-9][0-9]{0,2})$'
                    },
                    {
                        enum: EditorFontWeight.c
                    }
                ],
                default: exports.EDITOR_FONT_DEFAULTS.fontWeight,
                description: nls.localize(11802, null)
            });
        }
        validate(input) {
            if (input === 'normal' || input === 'bold') {
                return input;
            }
            return String(EditorIntOption.clampedInt(input, exports.EDITOR_FONT_DEFAULTS.fontWeight, EditorFontWeight.d, EditorFontWeight.e));
        }
    }
    class EditorGoToLocation extends BaseEditorOption {
        constructor() {
            const defaults = {
                multiple: 'peek',
                multipleDefinitions: 'peek',
                multipleTypeDefinitions: 'peek',
                multipleDeclarations: 'peek',
                multipleImplementations: 'peek',
                multipleReferences: 'peek',
                multipleTests: 'peek',
                alternativeDefinitionCommand: 'editor.action.goToReferences',
                alternativeTypeDefinitionCommand: 'editor.action.goToReferences',
                alternativeDeclarationCommand: 'editor.action.goToReferences',
                alternativeImplementationCommand: '',
                alternativeReferenceCommand: '',
                alternativeTestsCommand: '',
            };
            const jsonSubset = {
                type: 'string',
                enum: ['peek', 'gotoAndPeek', 'goto'],
                default: defaults.multiple,
                enumDescriptions: [
                    nls.localize(11803, null),
                    nls.localize(11804, null),
                    nls.localize(11805, null)
                ]
            };
            const alternativeCommandOptions = ['', 'editor.action.referenceSearch.trigger', 'editor.action.goToReferences', 'editor.action.peekImplementation', 'editor.action.goToImplementation', 'editor.action.peekTypeDefinition', 'editor.action.goToTypeDefinition', 'editor.action.peekDeclaration', 'editor.action.revealDeclaration', 'editor.action.peekDefinition', 'editor.action.revealDefinitionAside', 'editor.action.revealDefinition'];
            super(EditorOption.gotoLocation, 'gotoLocation', defaults, {
                'editor.gotoLocation.multiple': {
                    deprecationMessage: nls.localize(11806, null),
                },
                'editor.gotoLocation.multipleDefinitions': {
                    description: nls.localize(11807, null),
                    ...jsonSubset,
                },
                'editor.gotoLocation.multipleTypeDefinitions': {
                    description: nls.localize(11808, null),
                    ...jsonSubset,
                },
                'editor.gotoLocation.multipleDeclarations': {
                    description: nls.localize(11809, null),
                    ...jsonSubset,
                },
                'editor.gotoLocation.multipleImplementations': {
                    description: nls.localize(11810, null),
                    ...jsonSubset,
                },
                'editor.gotoLocation.multipleReferences': {
                    description: nls.localize(11811, null),
                    ...jsonSubset,
                },
                'editor.gotoLocation.alternativeDefinitionCommand': {
                    type: 'string',
                    default: defaults.alternativeDefinitionCommand,
                    enum: alternativeCommandOptions,
                    description: nls.localize(11812, null)
                },
                'editor.gotoLocation.alternativeTypeDefinitionCommand': {
                    type: 'string',
                    default: defaults.alternativeTypeDefinitionCommand,
                    enum: alternativeCommandOptions,
                    description: nls.localize(11813, null)
                },
                'editor.gotoLocation.alternativeDeclarationCommand': {
                    type: 'string',
                    default: defaults.alternativeDeclarationCommand,
                    enum: alternativeCommandOptions,
                    description: nls.localize(11814, null)
                },
                'editor.gotoLocation.alternativeImplementationCommand': {
                    type: 'string',
                    default: defaults.alternativeImplementationCommand,
                    enum: alternativeCommandOptions,
                    description: nls.localize(11815, null)
                },
                'editor.gotoLocation.alternativeReferenceCommand': {
                    type: 'string',
                    default: defaults.alternativeReferenceCommand,
                    enum: alternativeCommandOptions,
                    description: nls.localize(11816, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                multiple: stringSet(input.multiple, this.defaultValue.multiple, ['peek', 'gotoAndPeek', 'goto']),
                multipleDefinitions: input.multipleDefinitions ?? stringSet(input.multipleDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),
                multipleTypeDefinitions: input.multipleTypeDefinitions ?? stringSet(input.multipleTypeDefinitions, 'peek', ['peek', 'gotoAndPeek', 'goto']),
                multipleDeclarations: input.multipleDeclarations ?? stringSet(input.multipleDeclarations, 'peek', ['peek', 'gotoAndPeek', 'goto']),
                multipleImplementations: input.multipleImplementations ?? stringSet(input.multipleImplementations, 'peek', ['peek', 'gotoAndPeek', 'goto']),
                multipleReferences: input.multipleReferences ?? stringSet(input.multipleReferences, 'peek', ['peek', 'gotoAndPeek', 'goto']),
                multipleTests: input.multipleTests ?? stringSet(input.multipleTests, 'peek', ['peek', 'gotoAndPeek', 'goto']),
                alternativeDefinitionCommand: EditorStringOption.string(input.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
                alternativeTypeDefinitionCommand: EditorStringOption.string(input.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
                alternativeDeclarationCommand: EditorStringOption.string(input.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
                alternativeImplementationCommand: EditorStringOption.string(input.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
                alternativeReferenceCommand: EditorStringOption.string(input.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
                alternativeTestsCommand: EditorStringOption.string(input.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand),
            };
        }
    }
    class EditorHover extends BaseEditorOption {
        constructor() {
            const defaults = {
                enabled: true,
                delay: 300,
                hidingDelay: 300,
                sticky: true,
                above: true,
            };
            super(EditorOption.hover, 'hover', defaults, {
                'editor.hover.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    description: nls.localize(11817, null)
                },
                'editor.hover.delay': {
                    type: 'number',
                    default: defaults.delay,
                    minimum: 0,
                    maximum: 10000,
                    description: nls.localize(11818, null)
                },
                'editor.hover.sticky': {
                    type: 'boolean',
                    default: defaults.sticky,
                    description: nls.localize(11819, null)
                },
                'editor.hover.hidingDelay': {
                    type: 'integer',
                    minimum: 0,
                    default: defaults.hidingDelay,
                    description: nls.localize(11820, null)
                },
                'editor.hover.above': {
                    type: 'boolean',
                    default: defaults.above,
                    description: nls.localize(11821, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                delay: EditorIntOption.clampedInt(input.delay, this.defaultValue.delay, 0, 10000),
                sticky: boolean(input.sticky, this.defaultValue.sticky),
                hidingDelay: EditorIntOption.clampedInt(input.hidingDelay, this.defaultValue.hidingDelay, 0, 600000),
                above: boolean(input.above, this.defaultValue.above),
            };
        }
    }
    var RenderMinimap;
    (function (RenderMinimap) {
        RenderMinimap[RenderMinimap["None"] = 0] = "None";
        RenderMinimap[RenderMinimap["Text"] = 1] = "Text";
        RenderMinimap[RenderMinimap["Blocks"] = 2] = "Blocks";
    })(RenderMinimap || (exports.RenderMinimap = RenderMinimap = {}));
    /**
     * @internal
     */
    class EditorLayoutInfoComputer extends ComputedEditorOption {
        constructor() {
            super(EditorOption.layoutInfo);
        }
        compute(env, options, _) {
            return EditorLayoutInfoComputer.computeLayout(options, {
                memory: env.memory,
                outerWidth: env.outerWidth,
                outerHeight: env.outerHeight,
                isDominatedByLongLines: env.isDominatedByLongLines,
                lineHeight: env.fontInfo.lineHeight,
                viewLineCount: env.viewLineCount,
                lineNumbersDigitCount: env.lineNumbersDigitCount,
                typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,
                maxDigitWidth: env.fontInfo.maxDigitWidth,
                pixelRatio: env.pixelRatio,
                glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount
            });
        }
        static computeContainedMinimapLineCount(input) {
            const typicalViewportLineCount = input.height / input.lineHeight;
            const extraLinesBeforeFirstLine = Math.floor(input.paddingTop / input.lineHeight);
            let extraLinesBeyondLastLine = Math.floor(input.paddingBottom / input.lineHeight);
            if (input.scrollBeyondLastLine) {
                extraLinesBeyondLastLine = Math.max(extraLinesBeyondLastLine, typicalViewportLineCount - 1);
            }
            const desiredRatio = (extraLinesBeforeFirstLine + input.viewLineCount + extraLinesBeyondLastLine) / (input.pixelRatio * input.height);
            const minimapLineCount = Math.floor(input.viewLineCount / desiredRatio);
            return { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount };
        }
        static c(input, memory) {
            const outerWidth = input.outerWidth;
            const outerHeight = input.outerHeight;
            const pixelRatio = input.pixelRatio;
            if (!input.minimap.enabled) {
                return {
                    renderMinimap: RenderMinimap.None,
                    minimapLeft: 0,
                    minimapWidth: 0,
                    minimapHeightIsEditorHeight: false,
                    minimapIsSampling: false,
                    minimapScale: 1,
                    minimapLineHeight: 1,
                    minimapCanvasInnerWidth: 0,
                    minimapCanvasInnerHeight: Math.floor(pixelRatio * outerHeight),
                    minimapCanvasOuterWidth: 0,
                    minimapCanvasOuterHeight: outerHeight,
                };
            }
            // Can use memory if only the `viewLineCount` and `remainingWidth` have changed
            const stableMinimapLayoutInput = memory.stableMinimapLayoutInput;
            const couldUseMemory = (stableMinimapLayoutInput
                // && input.outerWidth === lastMinimapLayoutInput.outerWidth !!! INTENTIONAL OMITTED
                && input.outerHeight === stableMinimapLayoutInput.outerHeight
                && input.lineHeight === stableMinimapLayoutInput.lineHeight
                && input.typicalHalfwidthCharacterWidth === stableMinimapLayoutInput.typicalHalfwidthCharacterWidth
                && input.pixelRatio === stableMinimapLayoutInput.pixelRatio
                && input.scrollBeyondLastLine === stableMinimapLayoutInput.scrollBeyondLastLine
                && input.paddingTop === stableMinimapLayoutInput.paddingTop
                && input.paddingBottom === stableMinimapLayoutInput.paddingBottom
                && input.minimap.enabled === stableMinimapLayoutInput.minimap.enabled
                && input.minimap.side === stableMinimapLayoutInput.minimap.side
                && input.minimap.size === stableMinimapLayoutInput.minimap.size
                && input.minimap.showSlider === stableMinimapLayoutInput.minimap.showSlider
                && input.minimap.renderCharacters === stableMinimapLayoutInput.minimap.renderCharacters
                && input.minimap.maxColumn === stableMinimapLayoutInput.minimap.maxColumn
                && input.minimap.scale === stableMinimapLayoutInput.minimap.scale
                && input.verticalScrollbarWidth === stableMinimapLayoutInput.verticalScrollbarWidth
                // && input.viewLineCount === lastMinimapLayoutInput.viewLineCount !!! INTENTIONAL OMITTED
                // && input.remainingWidth === lastMinimapLayoutInput.remainingWidth !!! INTENTIONAL OMITTED
                && input.isViewportWrapping === stableMinimapLayoutInput.isViewportWrapping);
            const lineHeight = input.lineHeight;
            const typicalHalfwidthCharacterWidth = input.typicalHalfwidthCharacterWidth;
            const scrollBeyondLastLine = input.scrollBeyondLastLine;
            const minimapRenderCharacters = input.minimap.renderCharacters;
            let minimapScale = (pixelRatio >= 2 ? Math.round(input.minimap.scale * 2) : input.minimap.scale);
            const minimapMaxColumn = input.minimap.maxColumn;
            const minimapSize = input.minimap.size;
            const minimapSide = input.minimap.side;
            const verticalScrollbarWidth = input.verticalScrollbarWidth;
            const viewLineCount = input.viewLineCount;
            const remainingWidth = input.remainingWidth;
            const isViewportWrapping = input.isViewportWrapping;
            const baseCharHeight = minimapRenderCharacters ? 2 : 3;
            let minimapCanvasInnerHeight = Math.floor(pixelRatio * outerHeight);
            const minimapCanvasOuterHeight = minimapCanvasInnerHeight / pixelRatio;
            let minimapHeightIsEditorHeight = false;
            let minimapIsSampling = false;
            let minimapLineHeight = baseCharHeight * minimapScale;
            let minimapCharWidth = minimapScale / pixelRatio;
            let minimapWidthMultiplier = 1;
            if (minimapSize === 'fill' || minimapSize === 'fit') {
                const { typicalViewportLineCount, extraLinesBeforeFirstLine, extraLinesBeyondLastLine, desiredRatio, minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({
                    viewLineCount: viewLineCount,
                    scrollBeyondLastLine: scrollBeyondLastLine,
                    paddingTop: input.paddingTop,
                    paddingBottom: input.paddingBottom,
                    height: outerHeight,
                    lineHeight: lineHeight,
                    pixelRatio: pixelRatio
                });
                // ratio is intentionally not part of the layout to avoid the layout changing all the time
                // when doing sampling
                const ratio = viewLineCount / minimapLineCount;
                if (ratio > 1) {
                    minimapHeightIsEditorHeight = true;
                    minimapIsSampling = true;
                    minimapScale = 1;
                    minimapLineHeight = 1;
                    minimapCharWidth = minimapScale / pixelRatio;
                }
                else {
                    let fitBecomesFill = false;
                    let maxMinimapScale = minimapScale + 1;
                    if (minimapSize === 'fit') {
                        const effectiveMinimapHeight = Math.ceil((extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine) * minimapLineHeight);
                        if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
                            // There is a loop when using `fit` and viewport wrapping:
                            // - view line count impacts minimap layout
                            // - minimap layout impacts viewport width
                            // - viewport width impacts view line count
                            // To break the loop, once we go to a smaller minimap scale, we try to stick with it.
                            fitBecomesFill = true;
                            maxMinimapScale = memory.stableFitMaxMinimapScale;
                        }
                        else {
                            fitBecomesFill = (effectiveMinimapHeight > minimapCanvasInnerHeight);
                        }
                    }
                    if (minimapSize === 'fill' || fitBecomesFill) {
                        minimapHeightIsEditorHeight = true;
                        const configuredMinimapScale = minimapScale;
                        minimapLineHeight = Math.min(lineHeight * pixelRatio, Math.max(1, Math.floor(1 / desiredRatio)));
                        if (isViewportWrapping && couldUseMemory && remainingWidth <= memory.stableFitRemainingWidth) {
                            // There is a loop when using `fill` and viewport wrapping:
                            // - view line count impacts minimap layout
                            // - minimap layout impacts viewport width
                            // - viewport width impacts view line count
                            // To break the loop, once we go to a smaller minimap scale, we try to stick with it.
                            maxMinimapScale = memory.stableFitMaxMinimapScale;
                        }
                        minimapScale = Math.min(maxMinimapScale, Math.max(1, Math.floor(minimapLineHeight / baseCharHeight)));
                        if (minimapScale > configuredMinimapScale) {
                            minimapWidthMultiplier = Math.min(2, minimapScale / configuredMinimapScale);
                        }
                        minimapCharWidth = minimapScale / pixelRatio / minimapWidthMultiplier;
                        minimapCanvasInnerHeight = Math.ceil((Math.max(typicalViewportLineCount, extraLinesBeforeFirstLine + viewLineCount + extraLinesBeyondLastLine)) * minimapLineHeight);
                        if (isViewportWrapping) {
                            // remember for next time
                            memory.stableMinimapLayoutInput = input;
                            memory.stableFitRemainingWidth = remainingWidth;
                            memory.stableFitMaxMinimapScale = minimapScale;
                        }
                        else {
                            memory.stableMinimapLayoutInput = null;
                            memory.stableFitRemainingWidth = 0;
                        }
                    }
                }
            }
            // Given:
            // (leaving 2px for the cursor to have space after the last character)
            // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth
            // minimapWidth = viewportColumn * minimapCharWidth
            // contentWidth = remainingWidth - minimapWidth
            // What are good values for contentWidth and minimapWidth ?
            // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth
            // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth
            // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth
            // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth
            // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)
            const minimapMaxWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
            const minimapWidth = Math.min(minimapMaxWidth, Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth))) + exports.MINIMAP_GUTTER_WIDTH);
            let minimapCanvasInnerWidth = Math.floor(pixelRatio * minimapWidth);
            const minimapCanvasOuterWidth = minimapCanvasInnerWidth / pixelRatio;
            minimapCanvasInnerWidth = Math.floor(minimapCanvasInnerWidth * minimapWidthMultiplier);
            const renderMinimap = (minimapRenderCharacters ? RenderMinimap.Text : RenderMinimap.Blocks);
            const minimapLeft = (minimapSide === 'left' ? 0 : (outerWidth - minimapWidth - verticalScrollbarWidth));
            return {
                renderMinimap,
                minimapLeft,
                minimapWidth,
                minimapHeightIsEditorHeight,
                minimapIsSampling,
                minimapScale,
                minimapLineHeight,
                minimapCanvasInnerWidth,
                minimapCanvasInnerHeight,
                minimapCanvasOuterWidth,
                minimapCanvasOuterHeight,
            };
        }
        static computeLayout(options, env) {
            const outerWidth = env.outerWidth | 0;
            const outerHeight = env.outerHeight | 0;
            const lineHeight = env.lineHeight | 0;
            const lineNumbersDigitCount = env.lineNumbersDigitCount | 0;
            const typicalHalfwidthCharacterWidth = env.typicalHalfwidthCharacterWidth;
            const maxDigitWidth = env.maxDigitWidth;
            const pixelRatio = env.pixelRatio;
            const viewLineCount = env.viewLineCount;
            const wordWrapOverride2 = options.get(EditorOption.wordWrapOverride2);
            const wordWrapOverride1 = (wordWrapOverride2 === 'inherit' ? options.get(EditorOption.wordWrapOverride1) : wordWrapOverride2);
            const wordWrap = (wordWrapOverride1 === 'inherit' ? options.get(EditorOption.wordWrap) : wordWrapOverride1);
            const wordWrapColumn = options.get(EditorOption.wordWrapColumn);
            const isDominatedByLongLines = env.isDominatedByLongLines;
            const showGlyphMargin = options.get(EditorOption.glyphMargin);
            const showLineNumbers = (options.get(EditorOption.lineNumbers).renderType !== RenderLineNumbersType.Off);
            const lineNumbersMinChars = options.get(EditorOption.lineNumbersMinChars);
            const scrollBeyondLastLine = options.get(EditorOption.scrollBeyondLastLine);
            const padding = options.get(EditorOption.padding);
            const minimap = options.get(EditorOption.minimap);
            const scrollbar = options.get(EditorOption.scrollbar);
            const verticalScrollbarWidth = scrollbar.verticalScrollbarSize;
            const verticalScrollbarHasArrows = scrollbar.verticalHasArrows;
            const scrollbarArrowSize = scrollbar.arrowSize;
            const horizontalScrollbarHeight = scrollbar.horizontalScrollbarSize;
            const folding = options.get(EditorOption.folding);
            const showFoldingDecoration = options.get(EditorOption.showFoldingControls) !== 'never';
            let lineDecorationsWidth = options.get(EditorOption.lineDecorationsWidth);
            if (folding && showFoldingDecoration) {
                lineDecorationsWidth += 16;
            }
            let lineNumbersWidth = 0;
            if (showLineNumbers) {
                const digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
                lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
            }
            let glyphMarginWidth = 0;
            if (showGlyphMargin) {
                glyphMarginWidth = lineHeight * env.glyphMarginDecorationLaneCount;
            }
            let glyphMarginLeft = 0;
            let lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
            let decorationsLeft = lineNumbersLeft + lineNumbersWidth;
            let contentLeft = decorationsLeft + lineDecorationsWidth;
            const remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
            let isWordWrapMinified = false;
            let isViewportWrapping = false;
            let wrappingColumn = -1;
            if (wordWrapOverride1 === 'inherit' && isDominatedByLongLines) {
                // Force viewport width wrapping if model is dominated by long lines
                isWordWrapMinified = true;
                isViewportWrapping = true;
            }
            else if (wordWrap === 'on' || wordWrap === 'bounded') {
                isViewportWrapping = true;
            }
            else if (wordWrap === 'wordWrapColumn') {
                wrappingColumn = wordWrapColumn;
            }
            const minimapLayout = EditorLayoutInfoComputer.c({
                outerWidth: outerWidth,
                outerHeight: outerHeight,
                lineHeight: lineHeight,
                typicalHalfwidthCharacterWidth: typicalHalfwidthCharacterWidth,
                pixelRatio: pixelRatio,
                scrollBeyondLastLine: scrollBeyondLastLine,
                paddingTop: padding.top,
                paddingBottom: padding.bottom,
                minimap: minimap,
                verticalScrollbarWidth: verticalScrollbarWidth,
                viewLineCount: viewLineCount,
                remainingWidth: remainingWidth,
                isViewportWrapping: isViewportWrapping,
            }, env.memory || new ComputeOptionsMemory());
            if (minimapLayout.renderMinimap !== RenderMinimap.None && minimapLayout.minimapLeft === 0) {
                // the minimap is rendered to the left, so move everything to the right
                glyphMarginLeft += minimapLayout.minimapWidth;
                lineNumbersLeft += minimapLayout.minimapWidth;
                decorationsLeft += minimapLayout.minimapWidth;
                contentLeft += minimapLayout.minimapWidth;
            }
            const contentWidth = remainingWidth - minimapLayout.minimapWidth;
            // (leaving 2px for the cursor to have space after the last character)
            const viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
            const verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
            if (isViewportWrapping) {
                // compute the actual wrappingColumn
                wrappingColumn = Math.max(1, viewportColumn);
                if (wordWrap === 'bounded') {
                    wrappingColumn = Math.min(wrappingColumn, wordWrapColumn);
                }
            }
            return {
                width: outerWidth,
                height: outerHeight,
                glyphMarginLeft: glyphMarginLeft,
                glyphMarginWidth: glyphMarginWidth,
                glyphMarginDecorationLaneCount: env.glyphMarginDecorationLaneCount,
                lineNumbersLeft: lineNumbersLeft,
                lineNumbersWidth: lineNumbersWidth,
                decorationsLeft: decorationsLeft,
                decorationsWidth: lineDecorationsWidth,
                contentLeft: contentLeft,
                contentWidth: contentWidth,
                minimap: minimapLayout,
                viewportColumn: viewportColumn,
                isWordWrapMinified: isWordWrapMinified,
                isViewportWrapping: isViewportWrapping,
                wrappingColumn: wrappingColumn,
                verticalScrollbarWidth: verticalScrollbarWidth,
                horizontalScrollbarHeight: horizontalScrollbarHeight,
                overviewRuler: {
                    top: verticalArrowSize,
                    width: verticalScrollbarWidth,
                    height: (outerHeight - 2 * verticalArrowSize),
                    right: 0
                }
            };
        }
    }
    exports.EditorLayoutInfoComputer = EditorLayoutInfoComputer;
    //#endregion
    //#region WrappingStrategy
    class WrappingStrategy extends BaseEditorOption {
        constructor() {
            super(EditorOption.wrappingStrategy, 'wrappingStrategy', 'simple', {
                'editor.wrappingStrategy': {
                    enumDescriptions: [
                        nls.localize(11822, null),
                        nls.localize(11823, null)
                    ],
                    type: 'string',
                    enum: ['simple', 'advanced'],
                    default: 'simple',
                    description: nls.localize(11824, null)
                }
            });
        }
        validate(input) {
            return stringSet(input, 'simple', ['simple', 'advanced']);
        }
        compute(env, options, value) {
            const accessibilitySupport = options.get(EditorOption.accessibilitySupport);
            if (accessibilitySupport === accessibility_1.AccessibilitySupport.Enabled) {
                // if we know for a fact that a screen reader is attached, we switch our strategy to advanced to
                // help that the editor's wrapping points match the textarea's wrapping points
                return 'advanced';
            }
            return value;
        }
    }
    //#endregion
    //#region lightbulb
    var ShowLightbulbIconMode;
    (function (ShowLightbulbIconMode) {
        ShowLightbulbIconMode["Off"] = "off";
        ShowLightbulbIconMode["OnCode"] = "onCode";
        ShowLightbulbIconMode["On"] = "on";
    })(ShowLightbulbIconMode || (exports.ShowLightbulbIconMode = ShowLightbulbIconMode = {}));
    class EditorLightbulb extends BaseEditorOption {
        constructor() {
            const defaults = { enabled: ShowLightbulbIconMode.On };
            super(EditorOption.lightbulb, 'lightbulb', defaults, {
                'editor.lightbulb.enabled': {
                    type: 'string',
                    tags: ['experimental'],
                    enum: [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On],
                    default: defaults.enabled,
                    enumDescriptions: [
                        nls.localize(11825, null),
                        nls.localize(11826, null),
                        nls.localize(11827, null),
                    ],
                    description: nls.localize(11828, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: stringSet(input.enabled, this.defaultValue.enabled, [ShowLightbulbIconMode.Off, ShowLightbulbIconMode.OnCode, ShowLightbulbIconMode.On])
            };
        }
    }
    class EditorStickyScroll extends BaseEditorOption {
        constructor() {
            const defaults = { enabled: true, maxLineCount: 5, defaultModel: 'outlineModel', scrollWithEditor: true };
            super(EditorOption.stickyScroll, 'stickyScroll', defaults, {
                'editor.stickyScroll.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    description: nls.localize(11829, null),
                    tags: ['experimental']
                },
                'editor.stickyScroll.maxLineCount': {
                    type: 'number',
                    default: defaults.maxLineCount,
                    minimum: 1,
                    maximum: 20,
                    description: nls.localize(11830, null)
                },
                'editor.stickyScroll.defaultModel': {
                    type: 'string',
                    enum: ['outlineModel', 'foldingProviderModel', 'indentationModel'],
                    default: defaults.defaultModel,
                    description: nls.localize(11831, null)
                },
                'editor.stickyScroll.scrollWithEditor': {
                    type: 'boolean',
                    default: defaults.scrollWithEditor,
                    description: nls.localize(11832, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                maxLineCount: EditorIntOption.clampedInt(input.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
                defaultModel: stringSet(input.defaultModel, this.defaultValue.defaultModel, ['outlineModel', 'foldingProviderModel', 'indentationModel']),
                scrollWithEditor: boolean(input.scrollWithEditor, this.defaultValue.scrollWithEditor)
            };
        }
    }
    class EditorInlayHints extends BaseEditorOption {
        constructor() {
            const defaults = { enabled: 'on', fontSize: 0, fontFamily: '', padding: false };
            super(EditorOption.inlayHints, 'inlayHints', defaults, {
                'editor.inlayHints.enabled': {
                    type: 'string',
                    default: defaults.enabled,
                    description: nls.localize(11833, null),
                    enum: ['on', 'onUnlessPressed', 'offUnlessPressed', 'off'],
                    markdownEnumDescriptions: [
                        nls.localize(11834, null),
                        nls.localize(11835, null, platform.$k ? `Ctrl+Option` : `Ctrl+Alt`),
                        nls.localize(11836, null, platform.$k ? `Ctrl+Option` : `Ctrl+Alt`),
                        nls.localize(11837, null),
                    ],
                },
                'editor.inlayHints.fontSize': {
                    type: 'number',
                    default: defaults.fontSize,
                    markdownDescription: nls.localize(11838, null, '`#editor.fontSize#`', '`5`')
                },
                'editor.inlayHints.fontFamily': {
                    type: 'string',
                    default: defaults.fontFamily,
                    markdownDescription: nls.localize(11839, null, '`#editor.fontFamily#`')
                },
                'editor.inlayHints.padding': {
                    type: 'boolean',
                    default: defaults.padding,
                    description: nls.localize(11840, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            if (typeof input.enabled === 'boolean') {
                input.enabled = input.enabled ? 'on' : 'off';
            }
            return {
                enabled: stringSet(input.enabled, this.defaultValue.enabled, ['on', 'off', 'offUnlessPressed', 'onUnlessPressed']),
                fontSize: EditorIntOption.clampedInt(input.fontSize, this.defaultValue.fontSize, 0, 100),
                fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
                padding: boolean(input.padding, this.defaultValue.padding)
            };
        }
    }
    //#endregion
    //#region lineDecorationsWidth
    class EditorLineDecorationsWidth extends BaseEditorOption {
        constructor() {
            super(EditorOption.lineDecorationsWidth, 'lineDecorationsWidth', 10);
        }
        validate(input) {
            if (typeof input === 'string' && /^\d+(\.\d+)?ch$/.test(input)) {
                const multiple = parseFloat(input.substring(0, input.length - 2));
                return -multiple; // negative numbers signal a multiple
            }
            else {
                return EditorIntOption.clampedInt(input, this.defaultValue, 0, 1000);
            }
        }
        compute(env, options, value) {
            if (value < 0) {
                // negative numbers signal a multiple
                return EditorIntOption.clampedInt(-value * env.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1000);
            }
            else {
                return value;
            }
        }
    }
    //#endregion
    //#region lineHeight
    class EditorLineHeight extends EditorFloatOption {
        constructor() {
            super(EditorOption.lineHeight, 'lineHeight', exports.EDITOR_FONT_DEFAULTS.lineHeight, x => EditorFloatOption.clamp(x, 0, 150), { markdownDescription: nls.localize(11841, null) });
        }
        compute(env, options, value) {
            // The lineHeight is computed from the fontSize if it is 0.
            // Moreover, the final lineHeight respects the editor zoom level.
            // So take the result from env.fontInfo
            return env.fontInfo.lineHeight;
        }
    }
    class EditorMinimap extends BaseEditorOption {
        constructor() {
            const defaults = {
                enabled: true,
                size: 'proportional',
                side: 'right',
                showSlider: 'mouseover',
                autohide: false,
                renderCharacters: true,
                maxColumn: 120,
                scale: 1,
                showRegionSectionHeaders: true,
                showMarkSectionHeaders: true,
                sectionHeaderFontSize: 9,
                sectionHeaderLetterSpacing: 1,
            };
            super(EditorOption.minimap, 'minimap', defaults, {
                'editor.minimap.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    description: nls.localize(11842, null)
                },
                'editor.minimap.autohide': {
                    type: 'boolean',
                    default: defaults.autohide,
                    description: nls.localize(11843, null)
                },
                'editor.minimap.size': {
                    type: 'string',
                    enum: ['proportional', 'fill', 'fit'],
                    enumDescriptions: [
                        nls.localize(11844, null),
                        nls.localize(11845, null),
                        nls.localize(11846, null),
                    ],
                    default: defaults.size,
                    description: nls.localize(11847, null)
                },
                'editor.minimap.side': {
                    type: 'string',
                    enum: ['left', 'right'],
                    default: defaults.side,
                    description: nls.localize(11848, null)
                },
                'editor.minimap.showSlider': {
                    type: 'string',
                    enum: ['always', 'mouseover'],
                    default: defaults.showSlider,
                    description: nls.localize(11849, null)
                },
                'editor.minimap.scale': {
                    type: 'number',
                    default: defaults.scale,
                    minimum: 1,
                    maximum: 3,
                    enum: [1, 2, 3],
                    description: nls.localize(11850, null)
                },
                'editor.minimap.renderCharacters': {
                    type: 'boolean',
                    default: defaults.renderCharacters,
                    description: nls.localize(11851, null)
                },
                'editor.minimap.maxColumn': {
                    type: 'number',
                    default: defaults.maxColumn,
                    description: nls.localize(11852, null)
                },
                'editor.minimap.showRegionSectionHeaders': {
                    type: 'boolean',
                    default: defaults.showRegionSectionHeaders,
                    description: nls.localize(11853, null)
                },
                'editor.minimap.showMarkSectionHeaders': {
                    type: 'boolean',
                    default: defaults.showMarkSectionHeaders,
                    description: nls.localize(11854, null)
                },
                'editor.minimap.sectionHeaderFontSize': {
                    type: 'number',
                    default: defaults.sectionHeaderFontSize,
                    description: nls.localize(11855, null)
                },
                'editor.minimap.sectionHeaderLetterSpacing': {
                    type: 'number',
                    default: defaults.sectionHeaderLetterSpacing,
                    description: nls.localize(11856, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                autohide: boolean(input.autohide, this.defaultValue.autohide),
                size: stringSet(input.size, this.defaultValue.size, ['proportional', 'fill', 'fit']),
                side: stringSet(input.side, this.defaultValue.side, ['right', 'left']),
                showSlider: stringSet(input.showSlider, this.defaultValue.showSlider, ['always', 'mouseover']),
                renderCharacters: boolean(input.renderCharacters, this.defaultValue.renderCharacters),
                scale: EditorIntOption.clampedInt(input.scale, 1, 1, 3),
                maxColumn: EditorIntOption.clampedInt(input.maxColumn, this.defaultValue.maxColumn, 1, 10000),
                showRegionSectionHeaders: boolean(input.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
                showMarkSectionHeaders: boolean(input.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
                sectionHeaderFontSize: EditorFloatOption.clamp(input.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),
                sectionHeaderLetterSpacing: EditorFloatOption.clamp(input.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5),
            };
        }
    }
    //#endregion
    //#region multiCursorModifier
    function _multiCursorModifierFromString(multiCursorModifier) {
        if (multiCursorModifier === 'ctrlCmd') {
            return (platform.$k ? 'metaKey' : 'ctrlKey');
        }
        return 'altKey';
    }
    class EditorPadding extends BaseEditorOption {
        constructor() {
            super(EditorOption.padding, 'padding', { top: 0, bottom: 0 }, {
                'editor.padding.top': {
                    type: 'number',
                    default: 0,
                    minimum: 0,
                    maximum: 1000,
                    description: nls.localize(11857, null)
                },
                'editor.padding.bottom': {
                    type: 'number',
                    default: 0,
                    minimum: 0,
                    maximum: 1000,
                    description: nls.localize(11858, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                top: EditorIntOption.clampedInt(input.top, 0, 0, 1000),
                bottom: EditorIntOption.clampedInt(input.bottom, 0, 0, 1000)
            };
        }
    }
    class EditorParameterHints extends BaseEditorOption {
        constructor() {
            const defaults = {
                enabled: true,
                cycle: true
            };
            super(EditorOption.parameterHints, 'parameterHints', defaults, {
                'editor.parameterHints.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    description: nls.localize(11859, null)
                },
                'editor.parameterHints.cycle': {
                    type: 'boolean',
                    default: defaults.cycle,
                    description: nls.localize(11860, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                cycle: boolean(input.cycle, this.defaultValue.cycle)
            };
        }
    }
    //#endregion
    //#region pixelRatio
    class EditorPixelRatio extends ComputedEditorOption {
        constructor() {
            super(EditorOption.pixelRatio);
        }
        compute(env, options, _) {
            return env.pixelRatio;
        }
    }
    //#endregion
    //#region
    class PlaceholderOption extends BaseEditorOption {
        constructor() {
            super(EditorOption.placeholder, 'placeholder', undefined);
        }
        validate(input) {
            if (typeof input === 'undefined') {
                return this.defaultValue;
            }
            if (typeof input === 'string') {
                return input;
            }
            return this.defaultValue;
        }
    }
    class EditorQuickSuggestions extends BaseEditorOption {
        constructor() {
            const defaults = {
                other: 'on',
                comments: 'off',
                strings: 'off'
            };
            const types = [
                { type: 'boolean' },
                {
                    type: 'string',
                    enum: ['on', 'inline', 'off'],
                    enumDescriptions: [nls.localize(11861, null), nls.localize(11862, null), nls.localize(11863, null)]
                }
            ];
            super(EditorOption.quickSuggestions, 'quickSuggestions', defaults, {
                type: 'object',
                additionalProperties: false,
                properties: {
                    strings: {
                        anyOf: types,
                        default: defaults.strings,
                        description: nls.localize(11864, null)
                    },
                    comments: {
                        anyOf: types,
                        default: defaults.comments,
                        description: nls.localize(11865, null)
                    },
                    other: {
                        anyOf: types,
                        default: defaults.other,
                        description: nls.localize(11866, null)
                    },
                },
                default: defaults,
                markdownDescription: nls.localize(11867, null, '`#editor.suggestOnTriggerCharacters#`')
            });
            this.defaultValue = defaults;
        }
        validate(input) {
            if (typeof input === 'boolean') {
                // boolean -> all on/off
                const value = input ? 'on' : 'off';
                return { comments: value, strings: value, other: value };
            }
            if (!input || typeof input !== 'object') {
                // invalid object
                return this.defaultValue;
            }
            const { other, comments, strings } = input;
            const allowedValues = ['on', 'inline', 'off'];
            let validatedOther;
            let validatedComments;
            let validatedStrings;
            if (typeof other === 'boolean') {
                validatedOther = other ? 'on' : 'off';
            }
            else {
                validatedOther = stringSet(other, this.defaultValue.other, allowedValues);
            }
            if (typeof comments === 'boolean') {
                validatedComments = comments ? 'on' : 'off';
            }
            else {
                validatedComments = stringSet(comments, this.defaultValue.comments, allowedValues);
            }
            if (typeof strings === 'boolean') {
                validatedStrings = strings ? 'on' : 'off';
            }
            else {
                validatedStrings = stringSet(strings, this.defaultValue.strings, allowedValues);
            }
            return {
                other: validatedOther,
                comments: validatedComments,
                strings: validatedStrings
            };
        }
    }
    var RenderLineNumbersType;
    (function (RenderLineNumbersType) {
        RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
        RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
        RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
        RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
        RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
    })(RenderLineNumbersType || (exports.RenderLineNumbersType = RenderLineNumbersType = {}));
    class EditorRenderLineNumbersOption extends BaseEditorOption {
        constructor() {
            super(EditorOption.lineNumbers, 'lineNumbers', { renderType: RenderLineNumbersType.On, renderFn: null }, {
                type: 'string',
                enum: ['off', 'on', 'relative', 'interval'],
                enumDescriptions: [
                    nls.localize(11868, null),
                    nls.localize(11869, null),
                    nls.localize(11870, null),
                    nls.localize(11871, null)
                ],
                default: 'on',
                description: nls.localize(11872, null)
            });
        }
        validate(lineNumbers) {
            let renderType = this.defaultValue.renderType;
            let renderFn = this.defaultValue.renderFn;
            if (typeof lineNumbers !== 'undefined') {
                if (typeof lineNumbers === 'function') {
                    renderType = RenderLineNumbersType.Custom;
                    renderFn = lineNumbers;
                }
                else if (lineNumbers === 'interval') {
                    renderType = RenderLineNumbersType.Interval;
                }
                else if (lineNumbers === 'relative') {
                    renderType = RenderLineNumbersType.Relative;
                }
                else if (lineNumbers === 'on') {
                    renderType = RenderLineNumbersType.On;
                }
                else {
                    renderType = RenderLineNumbersType.Off;
                }
            }
            return {
                renderType,
                renderFn
            };
        }
    }
    //#endregion
    //#region renderValidationDecorations
    /**
     * @internal
     */
    function filterValidationDecorations(options) {
        const renderValidationDecorations = options.get(EditorOption.renderValidationDecorations);
        if (renderValidationDecorations === 'editable') {
            return options.get(EditorOption.readOnly);
        }
        return renderValidationDecorations === 'on' ? false : true;
    }
    class EditorRulers extends BaseEditorOption {
        constructor() {
            const defaults = [];
            const columnSchema = { type: 'number', description: nls.localize(11873, null) };
            super(EditorOption.rulers, 'rulers', defaults, {
                type: 'array',
                items: {
                    anyOf: [
                        columnSchema,
                        {
                            type: [
                                'object'
                            ],
                            properties: {
                                column: columnSchema,
                                color: {
                                    type: 'string',
                                    description: nls.localize(11874, null),
                                    format: 'color-hex'
                                }
                            }
                        }
                    ]
                },
                default: defaults,
                description: nls.localize(11875, null)
            });
        }
        validate(input) {
            if (Array.isArray(input)) {
                const rulers = [];
                for (const _element of input) {
                    if (typeof _element === 'number') {
                        rulers.push({
                            column: EditorIntOption.clampedInt(_element, 0, 0, 10000),
                            color: null
                        });
                    }
                    else if (_element && typeof _element === 'object') {
                        const element = _element;
                        rulers.push({
                            column: EditorIntOption.clampedInt(element.column, 0, 0, 10000),
                            color: element.color
                        });
                    }
                }
                rulers.sort((a, b) => a.column - b.column);
                return rulers;
            }
            return this.defaultValue;
        }
    }
    //#endregion
    //#region readonly
    /**
     * Configuration options for readonly message
     */
    class ReadonlyMessage extends BaseEditorOption {
        constructor() {
            const defaults = undefined;
            super(EditorOption.readOnlyMessage, 'readOnlyMessage', defaults);
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            return _input;
        }
    }
    function _scrollbarVisibilityFromString(visibility, defaultValue) {
        if (typeof visibility !== 'string') {
            return defaultValue;
        }
        switch (visibility) {
            case 'hidden': return scrollable_1.ScrollbarVisibility.Hidden;
            case 'visible': return scrollable_1.ScrollbarVisibility.Visible;
            default: return scrollable_1.ScrollbarVisibility.Auto;
        }
    }
    class EditorScrollbar extends BaseEditorOption {
        constructor() {
            const defaults = {
                vertical: scrollable_1.ScrollbarVisibility.Auto,
                horizontal: scrollable_1.ScrollbarVisibility.Auto,
                arrowSize: 11,
                useShadows: true,
                verticalHasArrows: false,
                horizontalHasArrows: false,
                horizontalScrollbarSize: 12,
                horizontalSliderSize: 12,
                verticalScrollbarSize: 14,
                verticalSliderSize: 14,
                handleMouseWheel: true,
                alwaysConsumeMouseWheel: true,
                scrollByPage: false,
                ignoreHorizontalScrollbarInContentHeight: false,
            };
            super(EditorOption.scrollbar, 'scrollbar', defaults, {
                'editor.scrollbar.vertical': {
                    type: 'string',
                    enum: ['auto', 'visible', 'hidden'],
                    enumDescriptions: [
                        nls.localize(11876, null),
                        nls.localize(11877, null),
                        nls.localize(11878, null),
                    ],
                    default: 'auto',
                    description: nls.localize(11879, null)
                },
                'editor.scrollbar.horizontal': {
                    type: 'string',
                    enum: ['auto', 'visible', 'hidden'],
                    enumDescriptions: [
                        nls.localize(11880, null),
                        nls.localize(11881, null),
                        nls.localize(11882, null),
                    ],
                    default: 'auto',
                    description: nls.localize(11883, null)
                },
                'editor.scrollbar.verticalScrollbarSize': {
                    type: 'number',
                    default: defaults.verticalScrollbarSize,
                    description: nls.localize(11884, null)
                },
                'editor.scrollbar.horizontalScrollbarSize': {
                    type: 'number',
                    default: defaults.horizontalScrollbarSize,
                    description: nls.localize(11885, null)
                },
                'editor.scrollbar.scrollByPage': {
                    type: 'boolean',
                    default: defaults.scrollByPage,
                    description: nls.localize(11886, null)
                },
                'editor.scrollbar.ignoreHorizontalScrollbarInContentHeight': {
                    type: 'boolean',
                    default: defaults.ignoreHorizontalScrollbarInContentHeight,
                    description: nls.localize(11887, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            const horizontalScrollbarSize = EditorIntOption.clampedInt(input.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1000);
            const verticalScrollbarSize = EditorIntOption.clampedInt(input.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1000);
            return {
                arrowSize: EditorIntOption.clampedInt(input.arrowSize, this.defaultValue.arrowSize, 0, 1000),
                vertical: _scrollbarVisibilityFromString(input.vertical, this.defaultValue.vertical),
                horizontal: _scrollbarVisibilityFromString(input.horizontal, this.defaultValue.horizontal),
                useShadows: boolean(input.useShadows, this.defaultValue.useShadows),
                verticalHasArrows: boolean(input.verticalHasArrows, this.defaultValue.verticalHasArrows),
                horizontalHasArrows: boolean(input.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
                handleMouseWheel: boolean(input.handleMouseWheel, this.defaultValue.handleMouseWheel),
                alwaysConsumeMouseWheel: boolean(input.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
                horizontalScrollbarSize: horizontalScrollbarSize,
                horizontalSliderSize: EditorIntOption.clampedInt(input.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),
                verticalScrollbarSize: verticalScrollbarSize,
                verticalSliderSize: EditorIntOption.clampedInt(input.verticalSliderSize, verticalScrollbarSize, 0, 1000),
                scrollByPage: boolean(input.scrollByPage, this.defaultValue.scrollByPage),
                ignoreHorizontalScrollbarInContentHeight: boolean(input.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight),
            };
        }
    }
    /**
     * @internal
    */
    exports.inUntrustedWorkspace = 'inUntrustedWorkspace';
    /**
     * @internal
     */
    exports.unicodeHighlightConfigKeys = {
        allowedCharacters: 'editor.unicodeHighlight.allowedCharacters',
        invisibleCharacters: 'editor.unicodeHighlight.invisibleCharacters',
        nonBasicASCII: 'editor.unicodeHighlight.nonBasicASCII',
        ambiguousCharacters: 'editor.unicodeHighlight.ambiguousCharacters',
        includeComments: 'editor.unicodeHighlight.includeComments',
        includeStrings: 'editor.unicodeHighlight.includeStrings',
        allowedLocales: 'editor.unicodeHighlight.allowedLocales',
    };
    class UnicodeHighlight extends BaseEditorOption {
        constructor() {
            const defaults = {
                nonBasicASCII: exports.inUntrustedWorkspace,
                invisibleCharacters: true,
                ambiguousCharacters: true,
                includeComments: exports.inUntrustedWorkspace,
                includeStrings: true,
                allowedCharacters: {},
                allowedLocales: { _os: true, _vscode: true },
            };
            super(EditorOption.unicodeHighlighting, 'unicodeHighlight', defaults, {
                [exports.unicodeHighlightConfigKeys.nonBasicASCII]: {
                    restricted: true,
                    type: ['boolean', 'string'],
                    enum: [true, false, exports.inUntrustedWorkspace],
                    default: defaults.nonBasicASCII,
                    description: nls.localize(11888, null)
                },
                [exports.unicodeHighlightConfigKeys.invisibleCharacters]: {
                    restricted: true,
                    type: 'boolean',
                    default: defaults.invisibleCharacters,
                    description: nls.localize(11889, null)
                },
                [exports.unicodeHighlightConfigKeys.ambiguousCharacters]: {
                    restricted: true,
                    type: 'boolean',
                    default: defaults.ambiguousCharacters,
                    description: nls.localize(11890, null)
                },
                [exports.unicodeHighlightConfigKeys.includeComments]: {
                    restricted: true,
                    type: ['boolean', 'string'],
                    enum: [true, false, exports.inUntrustedWorkspace],
                    default: defaults.includeComments,
                    description: nls.localize(11891, null)
                },
                [exports.unicodeHighlightConfigKeys.includeStrings]: {
                    restricted: true,
                    type: ['boolean', 'string'],
                    enum: [true, false, exports.inUntrustedWorkspace],
                    default: defaults.includeStrings,
                    description: nls.localize(11892, null)
                },
                [exports.unicodeHighlightConfigKeys.allowedCharacters]: {
                    restricted: true,
                    type: 'object',
                    default: defaults.allowedCharacters,
                    description: nls.localize(11893, null),
                    additionalProperties: {
                        type: 'boolean'
                    }
                },
                [exports.unicodeHighlightConfigKeys.allowedLocales]: {
                    restricted: true,
                    type: 'object',
                    additionalProperties: {
                        type: 'boolean'
                    },
                    default: defaults.allowedLocales,
                    description: nls.localize(11894, null)
                },
            });
        }
        applyUpdate(value, update) {
            let didChange = false;
            if (update.allowedCharacters && value) {
                // Treat allowedCharacters atomically
                if (!objects.$io(value.allowedCharacters, update.allowedCharacters)) {
                    value = { ...value, allowedCharacters: update.allowedCharacters };
                    didChange = true;
                }
            }
            if (update.allowedLocales && value) {
                // Treat allowedLocales atomically
                if (!objects.$io(value.allowedLocales, update.allowedLocales)) {
                    value = { ...value, allowedLocales: update.allowedLocales };
                    didChange = true;
                }
            }
            const result = super.applyUpdate(value, update);
            if (didChange) {
                return new ApplyUpdateResult(result.newValue, true);
            }
            return result;
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                nonBasicASCII: primitiveSet(input.nonBasicASCII, exports.inUntrustedWorkspace, [true, false, exports.inUntrustedWorkspace]),
                invisibleCharacters: boolean(input.invisibleCharacters, this.defaultValue.invisibleCharacters),
                ambiguousCharacters: boolean(input.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
                includeComments: primitiveSet(input.includeComments, exports.inUntrustedWorkspace, [true, false, exports.inUntrustedWorkspace]),
                includeStrings: primitiveSet(input.includeStrings, exports.inUntrustedWorkspace, [true, false, exports.inUntrustedWorkspace]),
                allowedCharacters: this.c(_input.allowedCharacters, this.defaultValue.allowedCharacters),
                allowedLocales: this.c(_input.allowedLocales, this.defaultValue.allowedLocales),
            };
        }
        c(map, defaultValue) {
            if ((typeof map !== 'object') || !map) {
                return defaultValue;
            }
            const result = {};
            for (const [key, value] of Object.entries(map)) {
                if (value === true) {
                    result[key] = true;
                }
            }
            return result;
        }
    }
    /**
     * Configuration options for inline suggestions
     */
    class InlineEditorSuggest extends BaseEditorOption {
        constructor() {
            const defaults = {
                enabled: true,
                mode: 'subwordSmart',
                showToolbar: 'onHover',
                suppressSuggestions: false,
                keepOnBlur: false,
                fontFamily: 'default'
            };
            super(EditorOption.inlineSuggest, 'inlineSuggest', defaults, {
                'editor.inlineSuggest.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    description: nls.localize(11895, null)
                },
                'editor.inlineSuggest.showToolbar': {
                    type: 'string',
                    default: defaults.showToolbar,
                    enum: ['always', 'onHover', 'never'],
                    enumDescriptions: [
                        nls.localize(11896, null),
                        nls.localize(11897, null),
                        nls.localize(11898, null),
                    ],
                    description: nls.localize(11899, null),
                },
                'editor.inlineSuggest.suppressSuggestions': {
                    type: 'boolean',
                    default: defaults.suppressSuggestions,
                    description: nls.localize(11900, null)
                },
                'editor.inlineSuggest.fontFamily': {
                    type: 'string',
                    default: defaults.fontFamily,
                    description: nls.localize(11901, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                mode: stringSet(input.mode, this.defaultValue.mode, ['prefix', 'subword', 'subwordSmart']),
                showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),
                suppressSuggestions: boolean(input.suppressSuggestions, this.defaultValue.suppressSuggestions),
                keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),
                fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily)
            };
        }
    }
    class InlineEditorEdit extends BaseEditorOption {
        constructor() {
            const defaults = {
                enabled: false,
                showToolbar: 'onHover',
                fontFamily: 'default',
                keepOnBlur: false,
            };
            super(EditorOption.inlineEdit, 'experimentalInlineEdit', defaults, {
                'editor.experimentalInlineEdit.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    description: nls.localize(11902, null)
                },
                'editor.experimentalInlineEdit.showToolbar': {
                    type: 'string',
                    default: defaults.showToolbar,
                    enum: ['always', 'onHover', 'never'],
                    enumDescriptions: [
                        nls.localize(11903, null),
                        nls.localize(11904, null),
                        nls.localize(11905, null),
                    ],
                    description: nls.localize(11906, null),
                },
                'editor.experimentalInlineEdit.fontFamily': {
                    type: 'string',
                    default: defaults.fontFamily,
                    description: nls.localize(11907, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                showToolbar: stringSet(input.showToolbar, this.defaultValue.showToolbar, ['always', 'onHover', 'never']),
                fontFamily: EditorStringOption.string(input.fontFamily, this.defaultValue.fontFamily),
                keepOnBlur: boolean(input.keepOnBlur, this.defaultValue.keepOnBlur),
            };
        }
    }
    /**
     * Configuration options for inline suggestions
     */
    class BracketPairColorization extends BaseEditorOption {
        constructor() {
            const defaults = {
                enabled: textModelDefaults_1.$lt.bracketPairColorizationOptions.enabled,
                independentColorPoolPerBracketType: textModelDefaults_1.$lt.bracketPairColorizationOptions.independentColorPoolPerBracketType,
            };
            super(EditorOption.bracketPairColorization, 'bracketPairColorization', defaults, {
                'editor.bracketPairColorization.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    markdownDescription: nls.localize(11908, null, '`#workbench.colorCustomizations#`')
                },
                'editor.bracketPairColorization.independentColorPoolPerBracketType': {
                    type: 'boolean',
                    default: defaults.independentColorPoolPerBracketType,
                    description: nls.localize(11909, null)
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                independentColorPoolPerBracketType: boolean(input.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType),
            };
        }
    }
    /**
     * Configuration options for inline suggestions
     */
    class GuideOptions extends BaseEditorOption {
        constructor() {
            const defaults = {
                bracketPairs: false,
                bracketPairsHorizontal: 'active',
                highlightActiveBracketPair: true,
                indentation: true,
                highlightActiveIndentation: true
            };
            super(EditorOption.guides, 'guides', defaults, {
                'editor.guides.bracketPairs': {
                    type: ['boolean', 'string'],
                    enum: [true, 'active', false],
                    enumDescriptions: [
                        nls.localize(11910, null),
                        nls.localize(11911, null),
                        nls.localize(11912, null),
                    ],
                    default: defaults.bracketPairs,
                    description: nls.localize(11913, null)
                },
                'editor.guides.bracketPairsHorizontal': {
                    type: ['boolean', 'string'],
                    enum: [true, 'active', false],
                    enumDescriptions: [
                        nls.localize(11914, null),
                        nls.localize(11915, null),
                        nls.localize(11916, null),
                    ],
                    default: defaults.bracketPairsHorizontal,
                    description: nls.localize(11917, null)
                },
                'editor.guides.highlightActiveBracketPair': {
                    type: 'boolean',
                    default: defaults.highlightActiveBracketPair,
                    description: nls.localize(11918, null)
                },
                'editor.guides.indentation': {
                    type: 'boolean',
                    default: defaults.indentation,
                    description: nls.localize(11919, null)
                },
                'editor.guides.highlightActiveIndentation': {
                    type: ['boolean', 'string'],
                    enum: [true, 'always', false],
                    enumDescriptions: [
                        nls.localize(11920, null),
                        nls.localize(11921, null),
                        nls.localize(11922, null),
                    ],
                    default: defaults.highlightActiveIndentation,
                    description: nls.localize(11923, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                bracketPairs: primitiveSet(input.bracketPairs, this.defaultValue.bracketPairs, [true, false, 'active']),
                bracketPairsHorizontal: primitiveSet(input.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [true, false, 'active']),
                highlightActiveBracketPair: boolean(input.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
                indentation: boolean(input.indentation, this.defaultValue.indentation),
                highlightActiveIndentation: primitiveSet(input.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [true, false, 'always']),
            };
        }
    }
    function primitiveSet(value, defaultValue, allowedValues) {
        const idx = allowedValues.indexOf(value);
        if (idx === -1) {
            return defaultValue;
        }
        return allowedValues[idx];
    }
    class EditorSuggest extends BaseEditorOption {
        constructor() {
            const defaults = {
                insertMode: 'insert',
                filterGraceful: true,
                snippetsPreventQuickSuggestions: false,
                localityBonus: false,
                shareSuggestSelections: false,
                selectionMode: 'always',
                showIcons: true,
                showStatusBar: false,
                preview: false,
                previewMode: 'subwordSmart',
                showInlineDetails: true,
                showMethods: true,
                showFunctions: true,
                showConstructors: true,
                showDeprecated: true,
                matchOnWordStartOnly: true,
                showFields: true,
                showVariables: true,
                showClasses: true,
                showStructs: true,
                showInterfaces: true,
                showModules: true,
                showProperties: true,
                showEvents: true,
                showOperators: true,
                showUnits: true,
                showValues: true,
                showConstants: true,
                showEnums: true,
                showEnumMembers: true,
                showKeywords: true,
                showWords: true,
                showColors: true,
                showFiles: true,
                showReferences: true,
                showFolders: true,
                showTypeParameters: true,
                showSnippets: true,
                showUsers: true,
                showIssues: true,
            };
            super(EditorOption.suggest, 'suggest', defaults, {
                'editor.suggest.insertMode': {
                    type: 'string',
                    enum: ['insert', 'replace'],
                    enumDescriptions: [
                        nls.localize(11924, null),
                        nls.localize(11925, null),
                    ],
                    default: defaults.insertMode,
                    description: nls.localize(11926, null)
                },
                'editor.suggest.filterGraceful': {
                    type: 'boolean',
                    default: defaults.filterGraceful,
                    description: nls.localize(11927, null)
                },
                'editor.suggest.localityBonus': {
                    type: 'boolean',
                    default: defaults.localityBonus,
                    description: nls.localize(11928, null)
                },
                'editor.suggest.shareSuggestSelections': {
                    type: 'boolean',
                    default: defaults.shareSuggestSelections,
                    markdownDescription: nls.localize(11929, null)
                },
                'editor.suggest.selectionMode': {
                    type: 'string',
                    enum: ['always', 'never', 'whenTriggerCharacter', 'whenQuickSuggestion'],
                    enumDescriptions: [
                        nls.localize(11930, null),
                        nls.localize(11931, null),
                        nls.localize(11932, null),
                        nls.localize(11933, null),
                    ],
                    default: defaults.selectionMode,
                    markdownDescription: nls.localize(11934, null, '`#editor.quickSuggestions#`', '`#editor.suggestOnTriggerCharacters#`')
                },
                'editor.suggest.snippetsPreventQuickSuggestions': {
                    type: 'boolean',
                    default: defaults.snippetsPreventQuickSuggestions,
                    description: nls.localize(11935, null)
                },
                'editor.suggest.showIcons': {
                    type: 'boolean',
                    default: defaults.showIcons,
                    description: nls.localize(11936, null)
                },
                'editor.suggest.showStatusBar': {
                    type: 'boolean',
                    default: defaults.showStatusBar,
                    description: nls.localize(11937, null)
                },
                'editor.suggest.preview': {
                    type: 'boolean',
                    default: defaults.preview,
                    description: nls.localize(11938, null)
                },
                'editor.suggest.showInlineDetails': {
                    type: 'boolean',
                    default: defaults.showInlineDetails,
                    description: nls.localize(11939, null)
                },
                'editor.suggest.maxVisibleSuggestions': {
                    type: 'number',
                    deprecationMessage: nls.localize(11940, null),
                },
                'editor.suggest.filteredTypes': {
                    type: 'object',
                    deprecationMessage: nls.localize(11941, null)
                },
                'editor.suggest.showMethods': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11942, null)
                },
                'editor.suggest.showFunctions': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11943, null)
                },
                'editor.suggest.showConstructors': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11944, null)
                },
                'editor.suggest.showDeprecated': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11945, null)
                },
                'editor.suggest.matchOnWordStartOnly': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11946, null)
                },
                'editor.suggest.showFields': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11947, null)
                },
                'editor.suggest.showVariables': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11948, null)
                },
                'editor.suggest.showClasses': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11949, null)
                },
                'editor.suggest.showStructs': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11950, null)
                },
                'editor.suggest.showInterfaces': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11951, null)
                },
                'editor.suggest.showModules': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11952, null)
                },
                'editor.suggest.showProperties': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11953, null)
                },
                'editor.suggest.showEvents': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11954, null)
                },
                'editor.suggest.showOperators': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11955, null)
                },
                'editor.suggest.showUnits': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11956, null)
                },
                'editor.suggest.showValues': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11957, null)
                },
                'editor.suggest.showConstants': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11958, null)
                },
                'editor.suggest.showEnums': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11959, null)
                },
                'editor.suggest.showEnumMembers': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11960, null)
                },
                'editor.suggest.showKeywords': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11961, null)
                },
                'editor.suggest.showWords': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11962, null)
                },
                'editor.suggest.showColors': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11963, null)
                },
                'editor.suggest.showFiles': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11964, null)
                },
                'editor.suggest.showReferences': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11965, null)
                },
                'editor.suggest.showCustomcolors': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11966, null)
                },
                'editor.suggest.showFolders': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11967, null)
                },
                'editor.suggest.showTypeParameters': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11968, null)
                },
                'editor.suggest.showSnippets': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11969, null)
                },
                'editor.suggest.showUsers': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11970, null)
                },
                'editor.suggest.showIssues': {
                    type: 'boolean',
                    default: true,
                    markdownDescription: nls.localize(11971, null)
                }
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                insertMode: stringSet(input.insertMode, this.defaultValue.insertMode, ['insert', 'replace']),
                filterGraceful: boolean(input.filterGraceful, this.defaultValue.filterGraceful),
                snippetsPreventQuickSuggestions: boolean(input.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
                localityBonus: boolean(input.localityBonus, this.defaultValue.localityBonus),
                shareSuggestSelections: boolean(input.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
                selectionMode: stringSet(input.selectionMode, this.defaultValue.selectionMode, ['always', 'never', 'whenQuickSuggestion', 'whenTriggerCharacter']),
                showIcons: boolean(input.showIcons, this.defaultValue.showIcons),
                showStatusBar: boolean(input.showStatusBar, this.defaultValue.showStatusBar),
                preview: boolean(input.preview, this.defaultValue.preview),
                previewMode: stringSet(input.previewMode, this.defaultValue.previewMode, ['prefix', 'subword', 'subwordSmart']),
                showInlineDetails: boolean(input.showInlineDetails, this.defaultValue.showInlineDetails),
                showMethods: boolean(input.showMethods, this.defaultValue.showMethods),
                showFunctions: boolean(input.showFunctions, this.defaultValue.showFunctions),
                showConstructors: boolean(input.showConstructors, this.defaultValue.showConstructors),
                showDeprecated: boolean(input.showDeprecated, this.defaultValue.showDeprecated),
                matchOnWordStartOnly: boolean(input.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
                showFields: boolean(input.showFields, this.defaultValue.showFields),
                showVariables: boolean(input.showVariables, this.defaultValue.showVariables),
                showClasses: boolean(input.showClasses, this.defaultValue.showClasses),
                showStructs: boolean(input.showStructs, this.defaultValue.showStructs),
                showInterfaces: boolean(input.showInterfaces, this.defaultValue.showInterfaces),
                showModules: boolean(input.showModules, this.defaultValue.showModules),
                showProperties: boolean(input.showProperties, this.defaultValue.showProperties),
                showEvents: boolean(input.showEvents, this.defaultValue.showEvents),
                showOperators: boolean(input.showOperators, this.defaultValue.showOperators),
                showUnits: boolean(input.showUnits, this.defaultValue.showUnits),
                showValues: boolean(input.showValues, this.defaultValue.showValues),
                showConstants: boolean(input.showConstants, this.defaultValue.showConstants),
                showEnums: boolean(input.showEnums, this.defaultValue.showEnums),
                showEnumMembers: boolean(input.showEnumMembers, this.defaultValue.showEnumMembers),
                showKeywords: boolean(input.showKeywords, this.defaultValue.showKeywords),
                showWords: boolean(input.showWords, this.defaultValue.showWords),
                showColors: boolean(input.showColors, this.defaultValue.showColors),
                showFiles: boolean(input.showFiles, this.defaultValue.showFiles),
                showReferences: boolean(input.showReferences, this.defaultValue.showReferences),
                showFolders: boolean(input.showFolders, this.defaultValue.showFolders),
                showTypeParameters: boolean(input.showTypeParameters, this.defaultValue.showTypeParameters),
                showSnippets: boolean(input.showSnippets, this.defaultValue.showSnippets),
                showUsers: boolean(input.showUsers, this.defaultValue.showUsers),
                showIssues: boolean(input.showIssues, this.defaultValue.showIssues),
            };
        }
    }
    class SmartSelect extends BaseEditorOption {
        constructor() {
            super(EditorOption.smartSelect, 'smartSelect', {
                selectLeadingAndTrailingWhitespace: true,
                selectSubwords: true,
            }, {
                'editor.smartSelect.selectLeadingAndTrailingWhitespace': {
                    description: nls.localize(11972, null),
                    default: true,
                    type: 'boolean'
                },
                'editor.smartSelect.selectSubwords': {
                    description: nls.localize(11973, null),
                    default: true,
                    type: 'boolean'
                }
            });
        }
        validate(input) {
            if (!input || typeof input !== 'object') {
                return this.defaultValue;
            }
            return {
                selectLeadingAndTrailingWhitespace: boolean(input.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
                selectSubwords: boolean(input.selectSubwords, this.defaultValue.selectSubwords),
            };
        }
    }
    //#endregion
    //#region wordSegmenterLocales
    /**
     * Locales used for segmenting lines into words when doing word related navigations or operations.
     *
     * Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.).
     */
    class WordSegmenterLocales extends BaseEditorOption {
        constructor() {
            const defaults = [];
            super(EditorOption.wordSegmenterLocales, 'wordSegmenterLocales', defaults, {
                anyOf: [
                    {
                        description: nls.localize(11974, null),
                        type: 'string',
                    }, {
                        description: nls.localize(11975, null),
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                ]
            });
        }
        validate(input) {
            if (typeof input === 'string') {
                input = [input];
            }
            if (Array.isArray(input)) {
                const validLocales = [];
                for (const locale of input) {
                    if (typeof locale === 'string') {
                        try {
                            if (Intl.Segmenter.supportedLocalesOf(locale).length > 0) {
                                validLocales.push(locale);
                            }
                        }
                        catch {
                            // ignore invalid locales
                        }
                    }
                }
                return validLocales;
            }
            return this.defaultValue;
        }
    }
    //#endregion
    //#region wrappingIndent
    /**
     * Describes how to indent wrapped lines.
     */
    var WrappingIndent;
    (function (WrappingIndent) {
        /**
         * No indentation => wrapped lines begin at column 1.
         */
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        /**
         * Same => wrapped lines get the same indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        /**
         * Indent => wrapped lines get +1 indentation toward the parent.
         */
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
        /**
         * DeepIndent => wrapped lines get +2 indentation toward the parent.
         */
        WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
    })(WrappingIndent || (exports.WrappingIndent = WrappingIndent = {}));
    class WrappingIndentOption extends BaseEditorOption {
        constructor() {
            super(EditorOption.wrappingIndent, 'wrappingIndent', WrappingIndent.Same, {
                'editor.wrappingIndent': {
                    type: 'string',
                    enum: ['none', 'same', 'indent', 'deepIndent'],
                    enumDescriptions: [
                        nls.localize(11976, null),
                        nls.localize(11977, null),
                        nls.localize(11978, null),
                        nls.localize(11979, null),
                    ],
                    description: nls.localize(11980, null),
                    default: 'same'
                }
            });
        }
        validate(input) {
            switch (input) {
                case 'none': return WrappingIndent.None;
                case 'same': return WrappingIndent.Same;
                case 'indent': return WrappingIndent.Indent;
                case 'deepIndent': return WrappingIndent.DeepIndent;
            }
            return WrappingIndent.Same;
        }
        compute(env, options, value) {
            const accessibilitySupport = options.get(EditorOption.accessibilitySupport);
            if (accessibilitySupport === accessibility_1.AccessibilitySupport.Enabled) {
                // if we know for a fact that a screen reader is attached, we use no indent wrapping to
                // help that the editor's wrapping points match the textarea's wrapping points
                return WrappingIndent.None;
            }
            return value;
        }
    }
    class EditorWrappingInfoComputer extends ComputedEditorOption {
        constructor() {
            super(EditorOption.wrappingInfo);
        }
        compute(env, options, _) {
            const layoutInfo = options.get(EditorOption.layoutInfo);
            return {
                isDominatedByLongLines: env.isDominatedByLongLines,
                isWordWrapMinified: layoutInfo.isWordWrapMinified,
                isViewportWrapping: layoutInfo.isViewportWrapping,
                wrappingColumn: layoutInfo.wrappingColumn,
            };
        }
    }
    class EditorDropIntoEditor extends BaseEditorOption {
        constructor() {
            const defaults = { enabled: true, showDropSelector: 'afterDrop' };
            super(EditorOption.dropIntoEditor, 'dropIntoEditor', defaults, {
                'editor.dropIntoEditor.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    markdownDescription: nls.localize(11981, null),
                },
                'editor.dropIntoEditor.showDropSelector': {
                    type: 'string',
                    markdownDescription: nls.localize(11982, null),
                    enum: [
                        'afterDrop',
                        'never'
                    ],
                    enumDescriptions: [
                        nls.localize(11983, null),
                        nls.localize(11984, null),
                    ],
                    default: 'afterDrop',
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                showDropSelector: stringSet(input.showDropSelector, this.defaultValue.showDropSelector, ['afterDrop', 'never']),
            };
        }
    }
    class EditorPasteAs extends BaseEditorOption {
        constructor() {
            const defaults = { enabled: true, showPasteSelector: 'afterPaste' };
            super(EditorOption.pasteAs, 'pasteAs', defaults, {
                'editor.pasteAs.enabled': {
                    type: 'boolean',
                    default: defaults.enabled,
                    markdownDescription: nls.localize(11985, null),
                },
                'editor.pasteAs.showPasteSelector': {
                    type: 'string',
                    markdownDescription: nls.localize(11986, null),
                    enum: [
                        'afterPaste',
                        'never'
                    ],
                    enumDescriptions: [
                        nls.localize(11987, null),
                        nls.localize(11988, null),
                    ],
                    default: 'afterPaste',
                },
            });
        }
        validate(_input) {
            if (!_input || typeof _input !== 'object') {
                return this.defaultValue;
            }
            const input = _input;
            return {
                enabled: boolean(input.enabled, this.defaultValue.enabled),
                showPasteSelector: stringSet(input.showPasteSelector, this.defaultValue.showPasteSelector, ['afterPaste', 'never']),
            };
        }
    }
    //#endregion
    const DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
    const DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
    const DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'monospace\', monospace';
    /**
     * @internal
     */
    exports.EDITOR_FONT_DEFAULTS = {
        fontFamily: (platform.$k ? DEFAULT_MAC_FONT_FAMILY : (platform.$l ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
        fontWeight: 'normal',
        fontSize: (platform.$k ? 12 : 14),
        lineHeight: 0,
        letterSpacing: 0,
    };
    /**
     * @internal
     */
    exports.editorOptionsRegistry = [];
    function register(option) {
        exports.editorOptionsRegistry[option.id] = option;
        return option;
    }
    var EditorOption;
    (function (EditorOption) {
        EditorOption[EditorOption["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
        EditorOption[EditorOption["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
        EditorOption[EditorOption["accessibilitySupport"] = 2] = "accessibilitySupport";
        EditorOption[EditorOption["accessibilityPageSize"] = 3] = "accessibilityPageSize";
        EditorOption[EditorOption["ariaLabel"] = 4] = "ariaLabel";
        EditorOption[EditorOption["ariaRequired"] = 5] = "ariaRequired";
        EditorOption[EditorOption["autoClosingBrackets"] = 6] = "autoClosingBrackets";
        EditorOption[EditorOption["autoClosingComments"] = 7] = "autoClosingComments";
        EditorOption[EditorOption["screenReaderAnnounceInlineSuggestion"] = 8] = "screenReaderAnnounceInlineSuggestion";
        EditorOption[EditorOption["autoClosingDelete"] = 9] = "autoClosingDelete";
        EditorOption[EditorOption["autoClosingOvertype"] = 10] = "autoClosingOvertype";
        EditorOption[EditorOption["autoClosingQuotes"] = 11] = "autoClosingQuotes";
        EditorOption[EditorOption["autoIndent"] = 12] = "autoIndent";
        EditorOption[EditorOption["automaticLayout"] = 13] = "automaticLayout";
        EditorOption[EditorOption["autoSurround"] = 14] = "autoSurround";
        EditorOption[EditorOption["bracketPairColorization"] = 15] = "bracketPairColorization";
        EditorOption[EditorOption["guides"] = 16] = "guides";
        EditorOption[EditorOption["codeLens"] = 17] = "codeLens";
        EditorOption[EditorOption["codeLensFontFamily"] = 18] = "codeLensFontFamily";
        EditorOption[EditorOption["codeLensFontSize"] = 19] = "codeLensFontSize";
        EditorOption[EditorOption["colorDecorators"] = 20] = "colorDecorators";
        EditorOption[EditorOption["colorDecoratorsLimit"] = 21] = "colorDecoratorsLimit";
        EditorOption[EditorOption["columnSelection"] = 22] = "columnSelection";
        EditorOption[EditorOption["comments"] = 23] = "comments";
        EditorOption[EditorOption["contextmenu"] = 24] = "contextmenu";
        EditorOption[EditorOption["copyWithSyntaxHighlighting"] = 25] = "copyWithSyntaxHighlighting";
        EditorOption[EditorOption["cursorBlinking"] = 26] = "cursorBlinking";
        EditorOption[EditorOption["cursorSmoothCaretAnimation"] = 27] = "cursorSmoothCaretAnimation";
        EditorOption[EditorOption["cursorStyle"] = 28] = "cursorStyle";
        EditorOption[EditorOption["cursorSurroundingLines"] = 29] = "cursorSurroundingLines";
        EditorOption[EditorOption["cursorSurroundingLinesStyle"] = 30] = "cursorSurroundingLinesStyle";
        EditorOption[EditorOption["cursorWidth"] = 31] = "cursorWidth";
        EditorOption[EditorOption["disableLayerHinting"] = 32] = "disableLayerHinting";
        EditorOption[EditorOption["disableMonospaceOptimizations"] = 33] = "disableMonospaceOptimizations";
        EditorOption[EditorOption["domReadOnly"] = 34] = "domReadOnly";
        EditorOption[EditorOption["dragAndDrop"] = 35] = "dragAndDrop";
        EditorOption[EditorOption["dropIntoEditor"] = 36] = "dropIntoEditor";
        EditorOption[EditorOption["emptySelectionClipboard"] = 37] = "emptySelectionClipboard";
        EditorOption[EditorOption["experimentalWhitespaceRendering"] = 38] = "experimentalWhitespaceRendering";
        EditorOption[EditorOption["extraEditorClassName"] = 39] = "extraEditorClassName";
        EditorOption[EditorOption["fastScrollSensitivity"] = 40] = "fastScrollSensitivity";
        EditorOption[EditorOption["find"] = 41] = "find";
        EditorOption[EditorOption["fixedOverflowWidgets"] = 42] = "fixedOverflowWidgets";
        EditorOption[EditorOption["folding"] = 43] = "folding";
        EditorOption[EditorOption["foldingStrategy"] = 44] = "foldingStrategy";
        EditorOption[EditorOption["foldingHighlight"] = 45] = "foldingHighlight";
        EditorOption[EditorOption["foldingImportsByDefault"] = 46] = "foldingImportsByDefault";
        EditorOption[EditorOption["foldingMaximumRegions"] = 47] = "foldingMaximumRegions";
        EditorOption[EditorOption["unfoldOnClickAfterEndOfLine"] = 48] = "unfoldOnClickAfterEndOfLine";
        EditorOption[EditorOption["fontFamily"] = 49] = "fontFamily";
        EditorOption[EditorOption["fontInfo"] = 50] = "fontInfo";
        EditorOption[EditorOption["fontLigatures"] = 51] = "fontLigatures";
        EditorOption[EditorOption["fontSize"] = 52] = "fontSize";
        EditorOption[EditorOption["fontWeight"] = 53] = "fontWeight";
        EditorOption[EditorOption["fontVariations"] = 54] = "fontVariations";
        EditorOption[EditorOption["formatOnPaste"] = 55] = "formatOnPaste";
        EditorOption[EditorOption["formatOnType"] = 56] = "formatOnType";
        EditorOption[EditorOption["glyphMargin"] = 57] = "glyphMargin";
        EditorOption[EditorOption["gotoLocation"] = 58] = "gotoLocation";
        EditorOption[EditorOption["hideCursorInOverviewRuler"] = 59] = "hideCursorInOverviewRuler";
        EditorOption[EditorOption["hover"] = 60] = "hover";
        EditorOption[EditorOption["inDiffEditor"] = 61] = "inDiffEditor";
        EditorOption[EditorOption["inlineSuggest"] = 62] = "inlineSuggest";
        EditorOption[EditorOption["inlineEdit"] = 63] = "inlineEdit";
        EditorOption[EditorOption["letterSpacing"] = 64] = "letterSpacing";
        EditorOption[EditorOption["lightbulb"] = 65] = "lightbulb";
        EditorOption[EditorOption["lineDecorationsWidth"] = 66] = "lineDecorationsWidth";
        EditorOption[EditorOption["lineHeight"] = 67] = "lineHeight";
        EditorOption[EditorOption["lineNumbers"] = 68] = "lineNumbers";
        EditorOption[EditorOption["lineNumbersMinChars"] = 69] = "lineNumbersMinChars";
        EditorOption[EditorOption["linkedEditing"] = 70] = "linkedEditing";
        EditorOption[EditorOption["links"] = 71] = "links";
        EditorOption[EditorOption["matchBrackets"] = 72] = "matchBrackets";
        EditorOption[EditorOption["minimap"] = 73] = "minimap";
        EditorOption[EditorOption["mouseStyle"] = 74] = "mouseStyle";
        EditorOption[EditorOption["mouseWheelScrollSensitivity"] = 75] = "mouseWheelScrollSensitivity";
        EditorOption[EditorOption["mouseWheelZoom"] = 76] = "mouseWheelZoom";
        EditorOption[EditorOption["multiCursorMergeOverlapping"] = 77] = "multiCursorMergeOverlapping";
        EditorOption[EditorOption["multiCursorModifier"] = 78] = "multiCursorModifier";
        EditorOption[EditorOption["multiCursorPaste"] = 79] = "multiCursorPaste";
        EditorOption[EditorOption["multiCursorLimit"] = 80] = "multiCursorLimit";
        EditorOption[EditorOption["occurrencesHighlight"] = 81] = "occurrencesHighlight";
        EditorOption[EditorOption["overviewRulerBorder"] = 82] = "overviewRulerBorder";
        EditorOption[EditorOption["overviewRulerLanes"] = 83] = "overviewRulerLanes";
        EditorOption[EditorOption["padding"] = 84] = "padding";
        EditorOption[EditorOption["pasteAs"] = 85] = "pasteAs";
        EditorOption[EditorOption["parameterHints"] = 86] = "parameterHints";
        EditorOption[EditorOption["peekWidgetDefaultFocus"] = 87] = "peekWidgetDefaultFocus";
        EditorOption[EditorOption["placeholder"] = 88] = "placeholder";
        EditorOption[EditorOption["definitionLinkOpensInPeek"] = 89] = "definitionLinkOpensInPeek";
        EditorOption[EditorOption["quickSuggestions"] = 90] = "quickSuggestions";
        EditorOption[EditorOption["quickSuggestionsDelay"] = 91] = "quickSuggestionsDelay";
        EditorOption[EditorOption["readOnly"] = 92] = "readOnly";
        EditorOption[EditorOption["readOnlyMessage"] = 93] = "readOnlyMessage";
        EditorOption[EditorOption["renameOnType"] = 94] = "renameOnType";
        EditorOption[EditorOption["renderControlCharacters"] = 95] = "renderControlCharacters";
        EditorOption[EditorOption["renderFinalNewline"] = 96] = "renderFinalNewline";
        EditorOption[EditorOption["renderLineHighlight"] = 97] = "renderLineHighlight";
        EditorOption[EditorOption["renderLineHighlightOnlyWhenFocus"] = 98] = "renderLineHighlightOnlyWhenFocus";
        EditorOption[EditorOption["renderValidationDecorations"] = 99] = "renderValidationDecorations";
        EditorOption[EditorOption["renderWhitespace"] = 100] = "renderWhitespace";
        EditorOption[EditorOption["revealHorizontalRightPadding"] = 101] = "revealHorizontalRightPadding";
        EditorOption[EditorOption["roundedSelection"] = 102] = "roundedSelection";
        EditorOption[EditorOption["rulers"] = 103] = "rulers";
        EditorOption[EditorOption["scrollbar"] = 104] = "scrollbar";
        EditorOption[EditorOption["scrollBeyondLastColumn"] = 105] = "scrollBeyondLastColumn";
        EditorOption[EditorOption["scrollBeyondLastLine"] = 106] = "scrollBeyondLastLine";
        EditorOption[EditorOption["scrollPredominantAxis"] = 107] = "scrollPredominantAxis";
        EditorOption[EditorOption["selectionClipboard"] = 108] = "selectionClipboard";
        EditorOption[EditorOption["selectionHighlight"] = 109] = "selectionHighlight";
        EditorOption[EditorOption["selectOnLineNumbers"] = 110] = "selectOnLineNumbers";
        EditorOption[EditorOption["showFoldingControls"] = 111] = "showFoldingControls";
        EditorOption[EditorOption["showUnused"] = 112] = "showUnused";
        EditorOption[EditorOption["snippetSuggestions"] = 113] = "snippetSuggestions";
        EditorOption[EditorOption["smartSelect"] = 114] = "smartSelect";
        EditorOption[EditorOption["smoothScrolling"] = 115] = "smoothScrolling";
        EditorOption[EditorOption["stickyScroll"] = 116] = "stickyScroll";
        EditorOption[EditorOption["stickyTabStops"] = 117] = "stickyTabStops";
        EditorOption[EditorOption["stopRenderingLineAfter"] = 118] = "stopRenderingLineAfter";
        EditorOption[EditorOption["suggest"] = 119] = "suggest";
        EditorOption[EditorOption["suggestFontSize"] = 120] = "suggestFontSize";
        EditorOption[EditorOption["suggestLineHeight"] = 121] = "suggestLineHeight";
        EditorOption[EditorOption["suggestOnTriggerCharacters"] = 122] = "suggestOnTriggerCharacters";
        EditorOption[EditorOption["suggestSelection"] = 123] = "suggestSelection";
        EditorOption[EditorOption["tabCompletion"] = 124] = "tabCompletion";
        EditorOption[EditorOption["tabIndex"] = 125] = "tabIndex";
        EditorOption[EditorOption["unicodeHighlighting"] = 126] = "unicodeHighlighting";
        EditorOption[EditorOption["unusualLineTerminators"] = 127] = "unusualLineTerminators";
        EditorOption[EditorOption["useShadowDOM"] = 128] = "useShadowDOM";
        EditorOption[EditorOption["useTabStops"] = 129] = "useTabStops";
        EditorOption[EditorOption["wordBreak"] = 130] = "wordBreak";
        EditorOption[EditorOption["wordSegmenterLocales"] = 131] = "wordSegmenterLocales";
        EditorOption[EditorOption["wordSeparators"] = 132] = "wordSeparators";
        EditorOption[EditorOption["wordWrap"] = 133] = "wordWrap";
        EditorOption[EditorOption["wordWrapBreakAfterCharacters"] = 134] = "wordWrapBreakAfterCharacters";
        EditorOption[EditorOption["wordWrapBreakBeforeCharacters"] = 135] = "wordWrapBreakBeforeCharacters";
        EditorOption[EditorOption["wordWrapColumn"] = 136] = "wordWrapColumn";
        EditorOption[EditorOption["wordWrapOverride1"] = 137] = "wordWrapOverride1";
        EditorOption[EditorOption["wordWrapOverride2"] = 138] = "wordWrapOverride2";
        EditorOption[EditorOption["wrappingIndent"] = 139] = "wrappingIndent";
        EditorOption[EditorOption["wrappingStrategy"] = 140] = "wrappingStrategy";
        EditorOption[EditorOption["showDeprecated"] = 141] = "showDeprecated";
        EditorOption[EditorOption["inlayHints"] = 142] = "inlayHints";
        // Leave these at the end (because they have dependencies!)
        EditorOption[EditorOption["editorClassName"] = 143] = "editorClassName";
        EditorOption[EditorOption["pixelRatio"] = 144] = "pixelRatio";
        EditorOption[EditorOption["tabFocusMode"] = 145] = "tabFocusMode";
        EditorOption[EditorOption["layoutInfo"] = 146] = "layoutInfo";
        EditorOption[EditorOption["wrappingInfo"] = 147] = "wrappingInfo";
        EditorOption[EditorOption["defaultColorDecorators"] = 148] = "defaultColorDecorators";
        EditorOption[EditorOption["colorDecoratorsActivatedOn"] = 149] = "colorDecoratorsActivatedOn";
        EditorOption[EditorOption["inlineCompletionsAccessibilityVerbose"] = 150] = "inlineCompletionsAccessibilityVerbose";
    })(EditorOption || (exports.EditorOption = EditorOption = {}));
    exports.EditorOptions = {
        acceptSuggestionOnCommitCharacter: register(new EditorBooleanOption(EditorOption.acceptSuggestionOnCommitCharacter, 'acceptSuggestionOnCommitCharacter', true, { markdownDescription: nls.localize(11989, null) })),
        acceptSuggestionOnEnter: register(new EditorStringEnumOption(EditorOption.acceptSuggestionOnEnter, 'acceptSuggestionOnEnter', 'on', ['on', 'smart', 'off'], {
            markdownEnumDescriptions: [
                '',
                nls.localize(11990, null),
                ''
            ],
            markdownDescription: nls.localize(11991, null)
        })),
        accessibilitySupport: register(new EditorAccessibilitySupport()),
        accessibilityPageSize: register(new EditorIntOption(EditorOption.accessibilityPageSize, 'accessibilityPageSize', 10, 1, uint_1.Constants.MAX_SAFE_SMALL_INTEGER, {
            description: nls.localize(11992, null),
            tags: ['accessibility']
        })),
        ariaLabel: register(new EditorStringOption(EditorOption.ariaLabel, 'ariaLabel', nls.localize(11993, null))),
        ariaRequired: register(new EditorBooleanOption(EditorOption.ariaRequired, 'ariaRequired', false, undefined)),
        screenReaderAnnounceInlineSuggestion: register(new EditorBooleanOption(EditorOption.screenReaderAnnounceInlineSuggestion, 'screenReaderAnnounceInlineSuggestion', true, {
            description: nls.localize(11994, null),
            tags: ['accessibility']
        })),
        autoClosingBrackets: register(new EditorStringEnumOption(EditorOption.autoClosingBrackets, 'autoClosingBrackets', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {
            enumDescriptions: [
                '',
                nls.localize(11995, null),
                nls.localize(11996, null),
                '',
            ],
            description: nls.localize(11997, null)
        })),
        autoClosingComments: register(new EditorStringEnumOption(EditorOption.autoClosingComments, 'autoClosingComments', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {
            enumDescriptions: [
                '',
                nls.localize(11998, null),
                nls.localize(11999, null),
                '',
            ],
            description: nls.localize(12000, null)
        })),
        autoClosingDelete: register(new EditorStringEnumOption(EditorOption.autoClosingDelete, 'autoClosingDelete', 'auto', ['always', 'auto', 'never'], {
            enumDescriptions: [
                '',
                nls.localize(12001, null),
                '',
            ],
            description: nls.localize(12002, null)
        })),
        autoClosingOvertype: register(new EditorStringEnumOption(EditorOption.autoClosingOvertype, 'autoClosingOvertype', 'auto', ['always', 'auto', 'never'], {
            enumDescriptions: [
                '',
                nls.localize(12003, null),
                '',
            ],
            description: nls.localize(12004, null)
        })),
        autoClosingQuotes: register(new EditorStringEnumOption(EditorOption.autoClosingQuotes, 'autoClosingQuotes', 'languageDefined', ['always', 'languageDefined', 'beforeWhitespace', 'never'], {
            enumDescriptions: [
                '',
                nls.localize(12005, null),
                nls.localize(12006, null),
                '',
            ],
            description: nls.localize(12007, null)
        })),
        autoIndent: register(new EditorEnumOption(EditorOption.autoIndent, 'autoIndent', EditorAutoIndentStrategy.Full, 'full', ['none', 'keep', 'brackets', 'advanced', 'full'], _autoIndentFromString, {
            enumDescriptions: [
                nls.localize(12008, null),
                nls.localize(12009, null),
                nls.localize(12010, null),
                nls.localize(12011, null),
                nls.localize(12012, null),
            ],
            description: nls.localize(12013, null)
        })),
        automaticLayout: register(new EditorBooleanOption(EditorOption.automaticLayout, 'automaticLayout', false)),
        autoSurround: register(new EditorStringEnumOption(EditorOption.autoSurround, 'autoSurround', 'languageDefined', ['languageDefined', 'quotes', 'brackets', 'never'], {
            enumDescriptions: [
                nls.localize(12014, null),
                nls.localize(12015, null),
                nls.localize(12016, null),
                ''
            ],
            description: nls.localize(12017, null)
        })),
        bracketPairColorization: register(new BracketPairColorization()),
        bracketPairGuides: register(new GuideOptions()),
        stickyTabStops: register(new EditorBooleanOption(EditorOption.stickyTabStops, 'stickyTabStops', false, { description: nls.localize(12018, null) })),
        codeLens: register(new EditorBooleanOption(EditorOption.codeLens, 'codeLens', true, { description: nls.localize(12019, null) })),
        codeLensFontFamily: register(new EditorStringOption(EditorOption.codeLensFontFamily, 'codeLensFontFamily', '', { description: nls.localize(12020, null) })),
        codeLensFontSize: register(new EditorIntOption(EditorOption.codeLensFontSize, 'codeLensFontSize', 0, 0, 100, {
            type: 'number',
            default: 0,
            minimum: 0,
            maximum: 100,
            markdownDescription: nls.localize(12021, null)
        })),
        colorDecorators: register(new EditorBooleanOption(EditorOption.colorDecorators, 'colorDecorators', true, { description: nls.localize(12022, null) })),
        colorDecoratorActivatedOn: register(new EditorStringEnumOption(EditorOption.colorDecoratorsActivatedOn, 'colorDecoratorsActivatedOn', 'clickAndHover', ['clickAndHover', 'hover', 'click'], {
            enumDescriptions: [
                nls.localize(12023, null),
                nls.localize(12024, null),
                nls.localize(12025, null)
            ],
            description: nls.localize(12026, null)
        })),
        colorDecoratorsLimit: register(new EditorIntOption(EditorOption.colorDecoratorsLimit, 'colorDecoratorsLimit', 500, 1, 1000000, {
            markdownDescription: nls.localize(12027, null)
        })),
        columnSelection: register(new EditorBooleanOption(EditorOption.columnSelection, 'columnSelection', false, { description: nls.localize(12028, null) })),
        comments: register(new EditorComments()),
        contextmenu: register(new EditorBooleanOption(EditorOption.contextmenu, 'contextmenu', true)),
        copyWithSyntaxHighlighting: register(new EditorBooleanOption(EditorOption.copyWithSyntaxHighlighting, 'copyWithSyntaxHighlighting', true, { description: nls.localize(12029, null) })),
        cursorBlinking: register(new EditorEnumOption(EditorOption.cursorBlinking, 'cursorBlinking', TextEditorCursorBlinkingStyle.Blink, 'blink', ['blink', 'smooth', 'phase', 'expand', 'solid'], _cursorBlinkingStyleFromString, { description: nls.localize(12030, null) })),
        cursorSmoothCaretAnimation: register(new EditorStringEnumOption(EditorOption.cursorSmoothCaretAnimation, 'cursorSmoothCaretAnimation', 'off', ['off', 'explicit', 'on'], {
            enumDescriptions: [
                nls.localize(12031, null),
                nls.localize(12032, null),
                nls.localize(12033, null)
            ],
            description: nls.localize(12034, null)
        })),
        cursorStyle: register(new EditorEnumOption(EditorOption.cursorStyle, 'cursorStyle', TextEditorCursorStyle.Line, 'line', ['line', 'block', 'underline', 'line-thin', 'block-outline', 'underline-thin'], _cursorStyleFromString, { description: nls.localize(12035, null) })),
        cursorSurroundingLines: register(new EditorIntOption(EditorOption.cursorSurroundingLines, 'cursorSurroundingLines', 0, 0, uint_1.Constants.MAX_SAFE_SMALL_INTEGER, { description: nls.localize(12036, null) })),
        cursorSurroundingLinesStyle: register(new EditorStringEnumOption(EditorOption.cursorSurroundingLinesStyle, 'cursorSurroundingLinesStyle', 'default', ['default', 'all'], {
            enumDescriptions: [
                nls.localize(12037, null),
                nls.localize(12038, null)
            ],
            markdownDescription: nls.localize(12039, null)
        })),
        cursorWidth: register(new EditorIntOption(EditorOption.cursorWidth, 'cursorWidth', 0, 0, uint_1.Constants.MAX_SAFE_SMALL_INTEGER, { markdownDescription: nls.localize(12040, null) })),
        disableLayerHinting: register(new EditorBooleanOption(EditorOption.disableLayerHinting, 'disableLayerHinting', false)),
        disableMonospaceOptimizations: register(new EditorBooleanOption(EditorOption.disableMonospaceOptimizations, 'disableMonospaceOptimizations', false)),
        domReadOnly: register(new EditorBooleanOption(EditorOption.domReadOnly, 'domReadOnly', false)),
        dragAndDrop: register(new EditorBooleanOption(EditorOption.dragAndDrop, 'dragAndDrop', true, { description: nls.localize(12041, null) })),
        emptySelectionClipboard: register(new EditorEmptySelectionClipboard()),
        dropIntoEditor: register(new EditorDropIntoEditor()),
        stickyScroll: register(new EditorStickyScroll()),
        experimentalWhitespaceRendering: register(new EditorStringEnumOption(EditorOption.experimentalWhitespaceRendering, 'experimentalWhitespaceRendering', 'svg', ['svg', 'font', 'off'], {
            enumDescriptions: [
                nls.localize(12042, null),
                nls.localize(12043, null),
                nls.localize(12044, null),
            ],
            description: nls.localize(12045, null)
        })),
        extraEditorClassName: register(new EditorStringOption(EditorOption.extraEditorClassName, 'extraEditorClassName', '')),
        fastScrollSensitivity: register(new EditorFloatOption(EditorOption.fastScrollSensitivity, 'fastScrollSensitivity', 5, x => (x <= 0 ? 5 : x), { markdownDescription: nls.localize(12046, null) })),
        find: register(new EditorFind()),
        fixedOverflowWidgets: register(new EditorBooleanOption(EditorOption.fixedOverflowWidgets, 'fixedOverflowWidgets', false)),
        folding: register(new EditorBooleanOption(EditorOption.folding, 'folding', true, { description: nls.localize(12047, null) })),
        foldingStrategy: register(new EditorStringEnumOption(EditorOption.foldingStrategy, 'foldingStrategy', 'auto', ['auto', 'indentation'], {
            enumDescriptions: [
                nls.localize(12048, null),
                nls.localize(12049, null),
            ],
            description: nls.localize(12050, null)
        })),
        foldingHighlight: register(new EditorBooleanOption(EditorOption.foldingHighlight, 'foldingHighlight', true, { description: nls.localize(12051, null) })),
        foldingImportsByDefault: register(new EditorBooleanOption(EditorOption.foldingImportsByDefault, 'foldingImportsByDefault', false, { description: nls.localize(12052, null) })),
        foldingMaximumRegions: register(new EditorIntOption(EditorOption.foldingMaximumRegions, 'foldingMaximumRegions', 5000, 10, 65000, // limit must be less than foldingRanges MAX_FOLDING_REGIONS
        { description: nls.localize(12053, null) })),
        unfoldOnClickAfterEndOfLine: register(new EditorBooleanOption(EditorOption.unfoldOnClickAfterEndOfLine, 'unfoldOnClickAfterEndOfLine', false, { description: nls.localize(12054, null) })),
        fontFamily: register(new EditorStringOption(EditorOption.fontFamily, 'fontFamily', exports.EDITOR_FONT_DEFAULTS.fontFamily, { description: nls.localize(12055, null) })),
        fontInfo: register(new EditorFontInfo()),
        fontLigatures2: register(new EditorFontLigatures()),
        fontSize: register(new EditorFontSize()),
        fontWeight: register(new EditorFontWeight()),
        fontVariations: register(new EditorFontVariations()),
        formatOnPaste: register(new EditorBooleanOption(EditorOption.formatOnPaste, 'formatOnPaste', false, { description: nls.localize(12056, null) })),
        formatOnType: register(new EditorBooleanOption(EditorOption.formatOnType, 'formatOnType', false, { description: nls.localize(12057, null) })),
        glyphMargin: register(new EditorBooleanOption(EditorOption.glyphMargin, 'glyphMargin', true, { description: nls.localize(12058, null) })),
        gotoLocation: register(new EditorGoToLocation()),
        hideCursorInOverviewRuler: register(new EditorBooleanOption(EditorOption.hideCursorInOverviewRuler, 'hideCursorInOverviewRuler', false, { description: nls.localize(12059, null) })),
        hover: register(new EditorHover()),
        inDiffEditor: register(new EditorBooleanOption(EditorOption.inDiffEditor, 'inDiffEditor', false)),
        letterSpacing: register(new EditorFloatOption(EditorOption.letterSpacing, 'letterSpacing', exports.EDITOR_FONT_DEFAULTS.letterSpacing, x => EditorFloatOption.clamp(x, -5, 20), { description: nls.localize(12060, null) })),
        lightbulb: register(new EditorLightbulb()),
        lineDecorationsWidth: register(new EditorLineDecorationsWidth()),
        lineHeight: register(new EditorLineHeight()),
        lineNumbers: register(new EditorRenderLineNumbersOption()),
        lineNumbersMinChars: register(new EditorIntOption(EditorOption.lineNumbersMinChars, 'lineNumbersMinChars', 5, 1, 300)),
        linkedEditing: register(new EditorBooleanOption(EditorOption.linkedEditing, 'linkedEditing', false, { description: nls.localize(12061, null) })),
        links: register(new EditorBooleanOption(EditorOption.links, 'links', true, { description: nls.localize(12062, null) })),
        matchBrackets: register(new EditorStringEnumOption(EditorOption.matchBrackets, 'matchBrackets', 'always', ['always', 'near', 'never'], { description: nls.localize(12063, null) })),
        minimap: register(new EditorMinimap()),
        mouseStyle: register(new EditorStringEnumOption(EditorOption.mouseStyle, 'mouseStyle', 'text', ['text', 'default', 'copy'])),
        mouseWheelScrollSensitivity: register(new EditorFloatOption(EditorOption.mouseWheelScrollSensitivity, 'mouseWheelScrollSensitivity', 1, x => (x === 0 ? 1 : x), { markdownDescription: nls.localize(12064, null) })),
        mouseWheelZoom: register(new EditorBooleanOption(EditorOption.mouseWheelZoom, 'mouseWheelZoom', false, {
            markdownDescription: platform.$k
                ? nls.localize(12065, null)
                : nls.localize(12066, null)
        })),
        multiCursorMergeOverlapping: register(new EditorBooleanOption(EditorOption.multiCursorMergeOverlapping, 'multiCursorMergeOverlapping', true, { description: nls.localize(12067, null) })),
        multiCursorModifier: register(new EditorEnumOption(EditorOption.multiCursorModifier, 'multiCursorModifier', 'altKey', 'alt', ['ctrlCmd', 'alt'], _multiCursorModifierFromString, {
            markdownEnumDescriptions: [
                nls.localize(12068, null),
                nls.localize(12069, null)
            ],
            markdownDescription: nls.localize(12070, null)






        })),
        multiCursorPaste: register(new EditorStringEnumOption(EditorOption.multiCursorPaste, 'multiCursorPaste', 'spread', ['spread', 'full'], {
            markdownEnumDescriptions: [
                nls.localize(12071, null),
                nls.localize(12072, null)
            ],
            markdownDescription: nls.localize(12073, null)
        })),
        multiCursorLimit: register(new EditorIntOption(EditorOption.multiCursorLimit, 'multiCursorLimit', 10000, 1, 100000, {
            markdownDescription: nls.localize(12074, null)
        })),
        occurrencesHighlight: register(new EditorStringEnumOption(EditorOption.occurrencesHighlight, 'occurrencesHighlight', 'singleFile', ['off', 'singleFile', 'multiFile'], {
            markdownEnumDescriptions: [
                nls.localize(12075, null),
                nls.localize(12076, null),
                nls.localize(12077, null)
            ],
            markdownDescription: nls.localize(12078, null)
        })),
        overviewRulerBorder: register(new EditorBooleanOption(EditorOption.overviewRulerBorder, 'overviewRulerBorder', true, { description: nls.localize(12079, null) })),
        overviewRulerLanes: register(new EditorIntOption(EditorOption.overviewRulerLanes, 'overviewRulerLanes', 3, 0, 3)),
        padding: register(new EditorPadding()),
        pasteAs: register(new EditorPasteAs()),
        parameterHints: register(new EditorParameterHints()),
        peekWidgetDefaultFocus: register(new EditorStringEnumOption(EditorOption.peekWidgetDefaultFocus, 'peekWidgetDefaultFocus', 'tree', ['tree', 'editor'], {
            enumDescriptions: [
                nls.localize(12080, null),
                nls.localize(12081, null)
            ],
            description: nls.localize(12082, null)
        })),
        placeholder: register(new PlaceholderOption()),
        definitionLinkOpensInPeek: register(new EditorBooleanOption(EditorOption.definitionLinkOpensInPeek, 'definitionLinkOpensInPeek', false, { description: nls.localize(12083, null) })),
        quickSuggestions: register(new EditorQuickSuggestions()),
        quickSuggestionsDelay: register(new EditorIntOption(EditorOption.quickSuggestionsDelay, 'quickSuggestionsDelay', 10, 0, uint_1.Constants.MAX_SAFE_SMALL_INTEGER, { description: nls.localize(12084, null) })),
        readOnly: register(new EditorBooleanOption(EditorOption.readOnly, 'readOnly', false)),
        readOnlyMessage: register(new ReadonlyMessage()),
        renameOnType: register(new EditorBooleanOption(EditorOption.renameOnType, 'renameOnType', false, { description: nls.localize(12085, null), markdownDeprecationMessage: nls.localize(12086, null) })),
        renderControlCharacters: register(new EditorBooleanOption(EditorOption.renderControlCharacters, 'renderControlCharacters', true, { description: nls.localize(12087, null), restricted: true })),
        renderFinalNewline: register(new EditorStringEnumOption(EditorOption.renderFinalNewline, 'renderFinalNewline', (platform.$l ? 'dimmed' : 'on'), ['off', 'on', 'dimmed'], { description: nls.localize(12088, null) })),
        renderLineHighlight: register(new EditorStringEnumOption(EditorOption.renderLineHighlight, 'renderLineHighlight', 'line', ['none', 'gutter', 'line', 'all'], {
            enumDescriptions: [
                '',
                '',
                '',
                nls.localize(12089, null),
            ],
            description: nls.localize(12090, null)
        })),
        renderLineHighlightOnlyWhenFocus: register(new EditorBooleanOption(EditorOption.renderLineHighlightOnlyWhenFocus, 'renderLineHighlightOnlyWhenFocus', false, { description: nls.localize(12091, null) })),
        renderValidationDecorations: register(new EditorStringEnumOption(EditorOption.renderValidationDecorations, 'renderValidationDecorations', 'editable', ['editable', 'on', 'off'])),
        renderWhitespace: register(new EditorStringEnumOption(EditorOption.renderWhitespace, 'renderWhitespace', 'selection', ['none', 'boundary', 'selection', 'trailing', 'all'], {
            enumDescriptions: [
                '',
                nls.localize(12092, null),
                nls.localize(12093, null),
                nls.localize(12094, null),
                ''
            ],
            description: nls.localize(12095, null)
        })),
        revealHorizontalRightPadding: register(new EditorIntOption(EditorOption.revealHorizontalRightPadding, 'revealHorizontalRightPadding', 15, 0, 1000)),
        roundedSelection: register(new EditorBooleanOption(EditorOption.roundedSelection, 'roundedSelection', true, { description: nls.localize(12096, null) })),
        rulers: register(new EditorRulers()),
        scrollbar: register(new EditorScrollbar()),
        scrollBeyondLastColumn: register(new EditorIntOption(EditorOption.scrollBeyondLastColumn, 'scrollBeyondLastColumn', 4, 0, uint_1.Constants.MAX_SAFE_SMALL_INTEGER, { description: nls.localize(12097, null) })),
        scrollBeyondLastLine: register(new EditorBooleanOption(EditorOption.scrollBeyondLastLine, 'scrollBeyondLastLine', true, { description: nls.localize(12098, null) })),
        scrollPredominantAxis: register(new EditorBooleanOption(EditorOption.scrollPredominantAxis, 'scrollPredominantAxis', true, { description: nls.localize(12099, null) })),
        selectionClipboard: register(new EditorBooleanOption(EditorOption.selectionClipboard, 'selectionClipboard', true, {
            description: nls.localize(12100, null),
            included: platform.$l
        })),
        selectionHighlight: register(new EditorBooleanOption(EditorOption.selectionHighlight, 'selectionHighlight', true, { description: nls.localize(12101, null) })),
        selectOnLineNumbers: register(new EditorBooleanOption(EditorOption.selectOnLineNumbers, 'selectOnLineNumbers', true)),
        showFoldingControls: register(new EditorStringEnumOption(EditorOption.showFoldingControls, 'showFoldingControls', 'mouseover', ['always', 'never', 'mouseover'], {
            enumDescriptions: [
                nls.localize(12102, null),
                nls.localize(12103, null),
                nls.localize(12104, null),
            ],
            description: nls.localize(12105, null)
        })),
        showUnused: register(new EditorBooleanOption(EditorOption.showUnused, 'showUnused', true, { description: nls.localize(12106, null) })),
        showDeprecated: register(new EditorBooleanOption(EditorOption.showDeprecated, 'showDeprecated', true, { description: nls.localize(12107, null) })),
        inlayHints: register(new EditorInlayHints()),
        snippetSuggestions: register(new EditorStringEnumOption(EditorOption.snippetSuggestions, 'snippetSuggestions', 'inline', ['top', 'bottom', 'inline', 'none'], {
            enumDescriptions: [
                nls.localize(12108, null),
                nls.localize(12109, null),
                nls.localize(12110, null),
                nls.localize(12111, null),
            ],
            description: nls.localize(12112, null)
        })),
        smartSelect: register(new SmartSelect()),
        smoothScrolling: register(new EditorBooleanOption(EditorOption.smoothScrolling, 'smoothScrolling', false, { description: nls.localize(12113, null) })),
        stopRenderingLineAfter: register(new EditorIntOption(EditorOption.stopRenderingLineAfter, 'stopRenderingLineAfter', 10000, -1, uint_1.Constants.MAX_SAFE_SMALL_INTEGER)),
        suggest: register(new EditorSuggest()),
        inlineSuggest: register(new InlineEditorSuggest()),
        inlineEdit: register(new InlineEditorEdit()),
        inlineCompletionsAccessibilityVerbose: register(new EditorBooleanOption(EditorOption.inlineCompletionsAccessibilityVerbose, 'inlineCompletionsAccessibilityVerbose', false, { description: nls.localize(12114, null) })),
        suggestFontSize: register(new EditorIntOption(EditorOption.suggestFontSize, 'suggestFontSize', 0, 0, 1000, { markdownDescription: nls.localize(12115, null, '`0`', '`#editor.fontSize#`') })),
        suggestLineHeight: register(new EditorIntOption(EditorOption.suggestLineHeight, 'suggestLineHeight', 0, 0, 1000, { markdownDescription: nls.localize(12116, null, '`0`', '`#editor.lineHeight#`') })),
        suggestOnTriggerCharacters: register(new EditorBooleanOption(EditorOption.suggestOnTriggerCharacters, 'suggestOnTriggerCharacters', true, { description: nls.localize(12117, null) })),
        suggestSelection: register(new EditorStringEnumOption(EditorOption.suggestSelection, 'suggestSelection', 'first', ['first', 'recentlyUsed', 'recentlyUsedByPrefix'], {
            markdownEnumDescriptions: [
                nls.localize(12118, null),
                nls.localize(12119, null),
                nls.localize(12120, null),
            ],
            description: nls.localize(12121, null)
        })),
        tabCompletion: register(new EditorStringEnumOption(EditorOption.tabCompletion, 'tabCompletion', 'off', ['on', 'off', 'onlySnippets'], {
            enumDescriptions: [
                nls.localize(12122, null),
                nls.localize(12123, null),
                nls.localize(12124, null),
            ],
            description: nls.localize(12125, null)
        })),
        tabIndex: register(new EditorIntOption(EditorOption.tabIndex, 'tabIndex', 0, -1, uint_1.Constants.MAX_SAFE_SMALL_INTEGER)),
        unicodeHighlight: register(new UnicodeHighlight()),
        unusualLineTerminators: register(new EditorStringEnumOption(EditorOption.unusualLineTerminators, 'unusualLineTerminators', 'prompt', ['auto', 'off', 'prompt'], {
            enumDescriptions: [
                nls.localize(12126, null),
                nls.localize(12127, null),
                nls.localize(12128, null),
            ],
            description: nls.localize(12129, null)
        })),
        useShadowDOM: register(new EditorBooleanOption(EditorOption.useShadowDOM, 'useShadowDOM', true)),
        useTabStops: register(new EditorBooleanOption(EditorOption.useTabStops, 'useTabStops', true, { description: nls.localize(12130, null) })),
        wordBreak: register(new EditorStringEnumOption(EditorOption.wordBreak, 'wordBreak', 'normal', ['normal', 'keepAll'], {
            markdownEnumDescriptions: [
                nls.localize(12131, null),
                nls.localize(12132, null),
            ],
            description: nls.localize(12133, null)
        })),
        wordSegmenterLocales: register(new WordSegmenterLocales()),
        wordSeparators: register(new EditorStringOption(EditorOption.wordSeparators, 'wordSeparators', wordHelper_1.$mt, { description: nls.localize(12134, null) })),
        wordWrap: register(new EditorStringEnumOption(EditorOption.wordWrap, 'wordWrap', 'off', ['off', 'on', 'wordWrapColumn', 'bounded'], {
            markdownEnumDescriptions: [
                nls.localize(12135, null),
                nls.localize(12136, null),
                nls.localize(12137, null),





                nls.localize(12138, null),






            ],
            description: nls.localize(12139, null)






        })),
        wordWrapBreakAfterCharacters: register(new EditorStringOption(EditorOption.wordWrapBreakAfterCharacters, 'wordWrapBreakAfterCharacters', 
        // allow-any-unicode-next-line
        ' \t})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣')),
        wordWrapBreakBeforeCharacters: register(new EditorStringOption(EditorOption.wordWrapBreakBeforeCharacters, 'wordWrapBreakBeforeCharacters', 
        // allow-any-unicode-next-line
        '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋')),
        wordWrapColumn: register(new EditorIntOption(EditorOption.wordWrapColumn, 'wordWrapColumn', 80, 1, uint_1.Constants.MAX_SAFE_SMALL_INTEGER, {
            markdownDescription: nls.localize(12140, null)






        })),
        wordWrapOverride1: register(new EditorStringEnumOption(EditorOption.wordWrapOverride1, 'wordWrapOverride1', 'inherit', ['off', 'on', 'inherit'])),
        wordWrapOverride2: register(new EditorStringEnumOption(EditorOption.wordWrapOverride2, 'wordWrapOverride2', 'inherit', ['off', 'on', 'inherit'])),
        // Leave these at the end (because they have dependencies!)
        editorClassName: register(new EditorClassName()),
        defaultColorDecorators: register(new EditorBooleanOption(EditorOption.defaultColorDecorators, 'defaultColorDecorators', false, { markdownDescription: nls.localize(12141, null) })),
        pixelRatio: register(new EditorPixelRatio()),
        tabFocusMode: register(new EditorBooleanOption(EditorOption.tabFocusMode, 'tabFocusMode', false, { markdownDescription: nls.localize(12142, null) })),
        layoutInfo: register(new EditorLayoutInfoComputer()),
        wrappingInfo: register(new EditorWrappingInfoComputer()),
        wrappingIndent: register(new WrappingIndentOption()),
        wrappingStrategy: register(new WrappingStrategy())
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[106/*vs/platform/environment/common/environment*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ni = exports.$Mi = void 0;
    exports.$Mi = (0, instantiation_1.$Fi)('environmentService');
    exports.$Ni = (0, instantiation_1.$Gi)(exports.$Mi);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[29/*vs/platform/files/common/files*/], __M([1/*require*/,0/*exports*/,58/*vs/base/common/ternarySearchTree*/,19/*vs/base/common/path*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,9/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/,20/*vs/base/common/platform*/,15/*vs/base/common/network*/,48/*vs/base/common/lazy*/]), function (require, exports, ternarySearchTree_1, path_1, strings_1, types_1, uri_1, nls_1, instantiation_1, platform_1, network_1, lazy_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Il = exports.$Fl = exports.FileKind = exports.$El = exports.$Dl = exports.$Cl = exports.$Bl = exports.$Al = exports.$zl = exports.$yl = exports.FileOperationResult = exports.$xl = exports.$wl = exports.$vl = exports.$tl = exports.FileChangeType = exports.$sl = exports.FileOperation = exports.$ml = exports.FileSystemProviderErrorCode = exports.FileSystemProviderCapabilities = exports.FileChangeFilter = exports.FilePermission = exports.FileType = exports.$al = void 0;
    exports.$bl = $bl;
    exports.$cl = $cl;
    exports.$dl = $dl;
    exports.$el = $el;
    exports.$fl = $fl;
    exports.$gl = $gl;
    exports.$hl = $hl;
    exports.$il = $il;
    exports.$jl = $jl;
    exports.$kl = $kl;
    exports.$ll = $ll;
    exports.$nl = $nl;
    exports.$ol = $ol;
    exports.$pl = $pl;
    exports.$ql = $ql;
    exports.$rl = $rl;
    exports.$ul = $ul;
    exports.$Gl = $Gl;
    exports.$Hl = $Hl;
    exports.$Jl = $Jl;
    //#region file service & providers
    exports.$al = (0, instantiation_1.$Fi)('fileService');
    function $bl(options) {
        return options.create === true;
    }
    var FileType;
    (function (FileType) {
        /**
         * File is unknown (neither file, directory nor symbolic link).
         */
        FileType[FileType["Unknown"] = 0] = "Unknown";
        /**
         * File is a normal file.
         */
        FileType[FileType["File"] = 1] = "File";
        /**
         * File is a directory.
         */
        FileType[FileType["Directory"] = 2] = "Directory";
        /**
         * File is a symbolic link.
         *
         * Note: even when the file is a symbolic link, you can test for
         * `FileType.File` and `FileType.Directory` to know the type of
         * the target the link points to.
         */
        FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType || (exports.FileType = FileType = {}));
    var FilePermission;
    (function (FilePermission) {
        /**
         * File is readonly. Components like editors should not
         * offer to edit the contents.
         */
        FilePermission[FilePermission["Readonly"] = 1] = "Readonly";
        /**
         * File is locked. Components like editors should offer
         * to edit the contents and ask the user upon saving to
         * remove the lock.
         */
        FilePermission[FilePermission["Locked"] = 2] = "Locked";
    })(FilePermission || (exports.FilePermission = FilePermission = {}));
    var FileChangeFilter;
    (function (FileChangeFilter) {
        FileChangeFilter[FileChangeFilter["UPDATED"] = 2] = "UPDATED";
        FileChangeFilter[FileChangeFilter["ADDED"] = 4] = "ADDED";
        FileChangeFilter[FileChangeFilter["DELETED"] = 8] = "DELETED";
    })(FileChangeFilter || (exports.FileChangeFilter = FileChangeFilter = {}));
    function $cl(thing) {
        const candidate = thing;
        return !!candidate && typeof candidate.onDidChange === 'function';
    }
    var FileSystemProviderCapabilities;
    (function (FileSystemProviderCapabilities) {
        /**
         * No capabilities.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["None"] = 0] = "None";
        /**
         * Provider supports unbuffered read/write.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileReadWrite"] = 2] = "FileReadWrite";
        /**
         * Provider supports open/read/write/close low level file operations.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
        /**
         * Provider supports stream based reading.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileReadStream"] = 16] = "FileReadStream";
        /**
         * Provider supports copy operation.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileFolderCopy"] = 8] = "FileFolderCopy";
        /**
         * Provider is path case sensitive.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
        /**
         * All files of the provider are readonly.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["Readonly"] = 2048] = "Readonly";
        /**
         * Provider supports to delete via trash.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["Trash"] = 4096] = "Trash";
        /**
         * Provider support to unlock files for writing.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileWriteUnlock"] = 8192] = "FileWriteUnlock";
        /**
         * Provider support to read files atomically. This implies the
         * provider provides the `FileReadWrite` capability too.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileAtomicRead"] = 16384] = "FileAtomicRead";
        /**
         * Provider support to write files atomically. This implies the
         * provider provides the `FileReadWrite` capability too.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileAtomicWrite"] = 32768] = "FileAtomicWrite";
        /**
         * Provider support to delete atomically.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileAtomicDelete"] = 65536] = "FileAtomicDelete";
        /**
         * Provider support to clone files atomically.
         */
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileClone"] = 131072] = "FileClone";
    })(FileSystemProviderCapabilities || (exports.FileSystemProviderCapabilities = FileSystemProviderCapabilities = {}));
    function $dl(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);
    }
    function $el(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);
    }
    function $fl(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileClone);
    }
    function $gl(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);
    }
    function $hl(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);
    }
    function $il(provider) {
        if (!$dl(provider)) {
            return false; // we require the `FileReadWrite` capability too
        }
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicRead);
    }
    function $jl(provider) {
        if (!$dl(provider)) {
            return false; // we require the `FileReadWrite` capability too
        }
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicWrite);
    }
    function $kl(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.FileAtomicDelete);
    }
    function $ll(provider) {
        return !!(provider.capabilities & FileSystemProviderCapabilities.Readonly);
    }
    var FileSystemProviderErrorCode;
    (function (FileSystemProviderErrorCode) {
        FileSystemProviderErrorCode["FileExists"] = "EntryExists";
        FileSystemProviderErrorCode["FileNotFound"] = "EntryNotFound";
        FileSystemProviderErrorCode["FileNotADirectory"] = "EntryNotADirectory";
        FileSystemProviderErrorCode["FileIsADirectory"] = "EntryIsADirectory";
        FileSystemProviderErrorCode["FileExceedsStorageQuota"] = "EntryExceedsStorageQuota";
        FileSystemProviderErrorCode["FileTooLarge"] = "EntryTooLarge";
        FileSystemProviderErrorCode["FileWriteLocked"] = "EntryWriteLocked";
        FileSystemProviderErrorCode["NoPermissions"] = "NoPermissions";
        FileSystemProviderErrorCode["Unavailable"] = "Unavailable";
        FileSystemProviderErrorCode["Unknown"] = "Unknown";
    })(FileSystemProviderErrorCode || (exports.FileSystemProviderErrorCode = FileSystemProviderErrorCode = {}));
    class $ml extends Error {
        static create(error, code) {
            const providerError = new $ml(error.toString(), code);
            $pl(providerError, code);
            return providerError;
        }
        constructor(message, code) {
            super(message);
            this.code = code;
        }
    }
    exports.$ml = $ml;
    function $nl(error, code) {
        return $ml.create(error, code);
    }
    function $ol(error) {
        if (!error) {
            return $nl((0, nls_1.localize)(10855, null), FileSystemProviderErrorCode.Unknown); // https://github.com/microsoft/vscode/issues/72798
        }
        return error;
    }
    function $pl(error, code) {
        error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
        return error;
    }
    function $ql(error) {
        // Guard against abuse
        if (!error) {
            return FileSystemProviderErrorCode.Unknown;
        }
        // FileSystemProviderError comes with the code
        if (error instanceof $ml) {
            return error.code;
        }
        // Any other error, check for name match by assuming that the error
        // went through the markAsFileSystemProviderError() method
        const match = /^(.+) \(FileSystemError\)$/.exec(error.name);
        if (!match) {
            return FileSystemProviderErrorCode.Unknown;
        }
        switch (match[1]) {
            case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;
            case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;
            case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;
            case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;
            case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;
            case FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;
            case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;
            case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;
        }
        return FileSystemProviderErrorCode.Unknown;
    }
    function $rl(error) {
        // FileSystemProviderError comes with the result already
        if (error instanceof $vl) {
            return error.fileOperationResult;
        }
        // Otherwise try to find from code
        switch ($ql(error)) {
            case FileSystemProviderErrorCode.FileNotFound:
                return FileOperationResult.FILE_NOT_FOUND;
            case FileSystemProviderErrorCode.FileIsADirectory:
                return FileOperationResult.FILE_IS_DIRECTORY;
            case FileSystemProviderErrorCode.FileNotADirectory:
                return FileOperationResult.FILE_NOT_DIRECTORY;
            case FileSystemProviderErrorCode.FileWriteLocked:
                return FileOperationResult.FILE_WRITE_LOCKED;
            case FileSystemProviderErrorCode.NoPermissions:
                return FileOperationResult.FILE_PERMISSION_DENIED;
            case FileSystemProviderErrorCode.FileExists:
                return FileOperationResult.FILE_MOVE_CONFLICT;
            case FileSystemProviderErrorCode.FileTooLarge:
                return FileOperationResult.FILE_TOO_LARGE;
            default:
                return FileOperationResult.FILE_OTHER_ERROR;
        }
    }
    var FileOperation;
    (function (FileOperation) {
        FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
        FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
        FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
        FileOperation[FileOperation["COPY"] = 3] = "COPY";
        FileOperation[FileOperation["WRITE"] = 4] = "WRITE";
    })(FileOperation || (exports.FileOperation = FileOperation = {}));
    class $sl {
        constructor(resource, operation, target) {
            this.resource = resource;
            this.operation = operation;
            this.target = target;
        }
        isOperation(operation) {
            return this.operation === operation;
        }
    }
    exports.$sl = $sl;
    /**
     * Possible changes that can occur to a file.
     */
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
    class $tl {
        static { this.a = null; }
        constructor(changes, c) {
            this.c = c;
            this.b = undefined;
            this.d = new lazy_1.$T(() => {
                const added = ternarySearchTree_1.$Li.forUris(() => this.c);
                added.fill(this.rawAdded.map(resource => [resource, true]));
                return added;
            });
            this.f = new lazy_1.$T(() => {
                const updated = ternarySearchTree_1.$Li.forUris(() => this.c);
                updated.fill(this.rawUpdated.map(resource => [resource, true]));
                return updated;
            });
            this.g = new lazy_1.$T(() => {
                const deleted = ternarySearchTree_1.$Li.forUris(() => this.c);
                deleted.fill(this.rawDeleted.map(resource => [resource, true]));
                return deleted;
            });
            /**
             * @deprecated use the `contains` or `affects` method to efficiently find
             * out if the event relates to a given resource. these methods ensure:
             * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
             * - correctly handles `FileChangeType.DELETED` events
             */
            this.rawAdded = [];
            /**
            * @deprecated use the `contains` or `affects` method to efficiently find
            * out if the event relates to a given resource. these methods ensure:
            * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
            * - correctly handles `FileChangeType.DELETED` events
            */
            this.rawUpdated = [];
            /**
            * @deprecated use the `contains` or `affects` method to efficiently find
            * out if the event relates to a given resource. these methods ensure:
            * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
            * - correctly handles `FileChangeType.DELETED` events
            */
            this.rawDeleted = [];
            for (const change of changes) {
                // Split by type
                switch (change.type) {
                    case FileChangeType.ADDED:
                        this.rawAdded.push(change.resource);
                        break;
                    case FileChangeType.UPDATED:
                        this.rawUpdated.push(change.resource);
                        break;
                    case FileChangeType.DELETED:
                        this.rawDeleted.push(change.resource);
                        break;
                }
                // Figure out events correlation
                if (this.b !== $tl.a) {
                    if (typeof change.cId === 'number') {
                        if (this.b === undefined) {
                            this.b = change.cId; // correlation not yet set, just take it
                        }
                        else if (this.b !== change.cId) {
                            this.b = $tl.a; // correlation mismatch, we have mixed correlation
                        }
                    }
                    else {
                        if (this.b !== undefined) {
                            this.b = $tl.a; // correlation mismatch, we have mixed correlation
                        }
                    }
                }
            }
        }
        /**
         * Find out if the file change events match the provided resource.
         *
         * Note: when passing `FileChangeType.DELETED`, we consider a match
         * also when the parent of the resource got deleted.
         */
        contains(resource, ...types) {
            return this.h(resource, { includeChildren: false }, ...types);
        }
        /**
         * Find out if the file change events either match the provided
         * resource, or contain a child of this resource.
         */
        affects(resource, ...types) {
            return this.h(resource, { includeChildren: true }, ...types);
        }
        h(resource, options, ...types) {
            if (!resource) {
                return false;
            }
            const hasTypesFilter = types.length > 0;
            // Added
            if (!hasTypesFilter || types.includes(FileChangeType.ADDED)) {
                if (this.d.value.get(resource)) {
                    return true;
                }
                if (options.includeChildren && this.d.value.findSuperstr(resource)) {
                    return true;
                }
            }
            // Updated
            if (!hasTypesFilter || types.includes(FileChangeType.UPDATED)) {
                if (this.f.value.get(resource)) {
                    return true;
                }
                if (options.includeChildren && this.f.value.findSuperstr(resource)) {
                    return true;
                }
            }
            // Deleted
            if (!hasTypesFilter || types.includes(FileChangeType.DELETED)) {
                if (this.g.value.findSubstr(resource) /* deleted also considers parent folders */) {
                    return true;
                }
                if (options.includeChildren && this.g.value.findSuperstr(resource)) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns if this event contains added files.
         */
        gotAdded() {
            return this.rawAdded.length > 0;
        }
        /**
         * Returns if this event contains deleted files.
         */
        gotDeleted() {
            return this.rawDeleted.length > 0;
        }
        /**
         * Returns if this event contains updated files.
         */
        gotUpdated() {
            return this.rawUpdated.length > 0;
        }
        /**
         * Returns if this event contains changes that correlate to the
         * provided `correlationId`.
         *
         * File change event correlation is an advanced watch feature that
         * allows to  identify from which watch request the events originate
         * from. This correlation allows to route events specifically
         * only to the requestor and not emit them to all listeners.
         */
        correlates(correlationId) {
            return this.b === correlationId;
        }
        /**
         * Figure out if the event contains changes that correlate to one
         * correlation identifier.
         *
         * File change event correlation is an advanced watch feature that
         * allows to  identify from which watch request the events originate
         * from. This correlation allows to route events specifically
         * only to the requestor and not emit them to all listeners.
         */
        hasCorrelation() {
            return typeof this.b === 'number';
        }
    }
    exports.$tl = $tl;
    function $ul(path, candidate, ignoreCase) {
        if (!path || !candidate || path === candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (candidate.charAt(candidate.length - 1) !== path_1.sep) {
            candidate += path_1.sep;
        }
        if (ignoreCase) {
            return (0, strings_1.$Gf)(path, candidate);
        }
        return path.indexOf(candidate) === 0;
    }
    class $vl extends Error {
        constructor(message, fileOperationResult, options) {
            super(message);
            this.fileOperationResult = fileOperationResult;
            this.options = options;
        }
    }
    exports.$vl = $vl;
    class $wl extends $vl {
        constructor(message, fileOperationResult, size, options) {
            super(message, fileOperationResult, options);
            this.fileOperationResult = fileOperationResult;
            this.size = size;
        }
    }
    exports.$wl = $wl;
    class $xl extends $vl {
        constructor(message, stat, options) {
            super(message, FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);
            this.stat = stat;
        }
    }
    exports.$xl = $xl;
    var FileOperationResult;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 0] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 1] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 2] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 3] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 4] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_WRITE_LOCKED"] = 5] = "FILE_WRITE_LOCKED";
        FileOperationResult[FileOperationResult["FILE_PERMISSION_DENIED"] = 6] = "FILE_PERMISSION_DENIED";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 7] = "FILE_TOO_LARGE";
        FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 8] = "FILE_INVALID_PATH";
        FileOperationResult[FileOperationResult["FILE_NOT_DIRECTORY"] = 9] = "FILE_NOT_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_OTHER_ERROR"] = 10] = "FILE_OTHER_ERROR";
    })(FileOperationResult || (exports.FileOperationResult = FileOperationResult = {}));
    //#endregion
    //#region Settings
    exports.$yl = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange',
        ON_WINDOW_CHANGE: 'onWindowChange'
    };
    exports.$zl = {
        OFF: 'off',
        ON_EXIT: 'onExit',
        ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
    };
    exports.$Al = 'files.associations';
    exports.$Bl = 'files.exclude';
    exports.$Cl = 'files.readonlyInclude';
    exports.$Dl = 'files.readonlyExclude';
    exports.$El = 'files.readonlyFromPermissions';
    //#endregion
    //#region Utilities
    var FileKind;
    (function (FileKind) {
        FileKind[FileKind["FILE"] = 0] = "FILE";
        FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
        FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind || (exports.FileKind = FileKind = {}));
    /**
     * A hint to disable etag checking for reading/writing.
     */
    exports.$Fl = '';
    function $Gl(stat) {
        if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {
            return undefined;
        }
        return stat.mtime.toString(29) + stat.size.toString(31);
    }
    async function $Hl(file, fileService) {
        if (fileService.hasProvider(uri_1.URI.from({ scheme: file.scheme }))) {
            return;
        }
        return new Promise(resolve => {
            const disposable = fileService.onDidChangeFileSystemProviderRegistrations(e => {
                if (e.scheme === file.scheme && e.added) {
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    /**
     * Helper to format a raw byte size into a human readable label.
     */
    class $Il {
        static { this.KB = 1024; }
        static { this.MB = $Il.KB * $Il.KB; }
        static { this.GB = $Il.MB * $Il.KB; }
        static { this.TB = $Il.GB * $Il.KB; }
        static formatSize(size) {
            if (!(0, types_1.$ig)(size)) {
                size = 0;
            }
            if (size < $Il.KB) {
                return (0, nls_1.localize)(10856, null, size.toFixed(0));
            }
            if (size < $Il.MB) {
                return (0, nls_1.localize)(10857, null, (size / $Il.KB).toFixed(2));
            }
            if (size < $Il.GB) {
                return (0, nls_1.localize)(10858, null, (size / $Il.MB).toFixed(2));
            }
            if (size < $Il.TB) {
                return (0, nls_1.localize)(10859, null, (size / $Il.GB).toFixed(2));
            }
            return (0, nls_1.localize)(10860, null, (size / $Il.TB).toFixed(2));
        }
    }
    exports.$Il = $Il;
    function $Jl(arg) {
        const isRemote = typeof arg === 'string' || arg?.scheme === network_1.Schemas.vscodeRemote;
        const isLocal = typeof arg !== 'string' && arg?.scheme === network_1.Schemas.file;
        if (isLocal) {
            // Local almost has no limit in file size
            return 1024 * $Il.MB;
        }
        if (isRemote) {
            // With a remote, pick a low limit to avoid
            // potentially costly file transfers
            return 10 * $Il.MB;
        }
        if (platform_1.$p) {
            // Web: we cannot know for sure if a cost
            // is associated with the file transfer
            // so we pick a reasonably small limit
            return 50 * $Il.MB;
        }
        // Local desktop: almost no limit in file size
        return 1024 * $Il.MB;
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[74/*vs/platform/instantiation/common/serviceCollection*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Di = void 0;
    class $Di {
        constructor(...entries) {
            this.a = new Map();
            for (const [id, service] of entries) {
                this.set(id, service);
            }
        }
        set(id, instanceOrDescriptor) {
            const result = this.a.get(id);
            this.a.set(id, instanceOrDescriptor);
            return result;
        }
        has(id) {
            return this.a.has(id);
        }
        get(id) {
            return this.a.get(id);
        }
    }
    exports.$Di = $Di;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[170/*vs/platform/instantiation/common/instantiationService*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,13/*vs/base/common/errors*/,4/*vs/base/common/lifecycle*/,73/*vs/platform/instantiation/common/descriptors*/,167/*vs/platform/instantiation/common/graph*/,3/*vs/platform/instantiation/common/instantiation*/,74/*vs/platform/instantiation/common/serviceCollection*/,171/*vs/base/common/linkedList*/]), function (require, exports, async_1, errors_1, lifecycle_1, descriptors_1, graph_1, instantiation_1, serviceCollection_1, linkedList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$xr = exports.$wr = void 0;
    // TRACING
    const _enableAllTracing = false;
    class CyclicDependencyError extends Error {
        constructor(graph) {
            super('cyclic dependency between services');
            this.message = graph.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: \n${graph.toString()}`;
        }
    }
    class $wr {
        constructor(i = new serviceCollection_1.$Di(), j = false, k, l = _enableAllTracing) {
            this.i = i;
            this.j = j;
            this.k = k;
            this.l = l;
            this.f = false;
            this.g = new Set();
            this.h = new Set();
            this.t = new Set();
            this.i.set(instantiation_1.$Ei, this);
            this._globalGraph = l ? k?._globalGraph ?? new graph_1.$vr(e => e) : undefined;
        }
        dispose() {
            if (!this.f) {
                this.f = true;
                // dispose all child services
                (0, lifecycle_1.$Pc)(this.h);
                this.h.clear();
                // dispose all services created by this service
                for (const candidate of this.g) {
                    if ((0, lifecycle_1.$Oc)(candidate)) {
                        candidate.dispose();
                    }
                }
                this.g.clear();
            }
        }
        m() {
            if (this.f) {
                throw new Error('InstantiationService has been disposed');
            }
        }
        createChild(services, store) {
            this.m();
            const that = this;
            const result = new class extends $wr {
                dispose() {
                    that.h.delete(result);
                    super.dispose();
                }
            }(services, this.j, this, this.l);
            this.h.add(result);
            store?.add(result);
            return result;
        }
        invokeFunction(fn, ...args) {
            this.m();
            const _trace = $xr.traceInvocation(this.l, fn);
            let _done = false;
            try {
                const accessor = {
                    get: (id) => {
                        if (_done) {
                            throw (0, errors_1.$7)('service accessor is only valid during the invocation of its target method');
                        }
                        const result = this.s(id, _trace);
                        if (!result) {
                            throw new Error(`[invokeFunction] unknown service '${id}'`);
                        }
                        return result;
                    }
                };
                return fn(accessor, ...args);
            }
            finally {
                _done = true;
                _trace.stop();
            }
        }
        createInstance(ctorOrDescriptor, ...rest) {
            this.m();
            let _trace;
            let result;
            if (ctorOrDescriptor instanceof descriptors_1.$Ci) {
                _trace = $xr.traceCreation(this.l, ctorOrDescriptor.ctor);
                result = this.o(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);
            }
            else {
                _trace = $xr.traceCreation(this.l, ctorOrDescriptor);
                result = this.o(ctorOrDescriptor, rest, _trace);
            }
            _trace.stop();
            return result;
        }
        o(ctor, args = [], _trace) {
            // arguments defined by service decorators
            const serviceDependencies = instantiation_1._util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);
            const serviceArgs = [];
            for (const dependency of serviceDependencies) {
                const service = this.s(dependency.id, _trace);
                if (!service) {
                    this.y(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`, false);
                }
                serviceArgs.push(service);
            }
            const firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;
            // check for argument mismatches, adjust static args if needed
            if (args.length !== firstServiceArgPos) {
                console.trace(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);
                const delta = firstServiceArgPos - args.length;
                if (delta > 0) {
                    args = args.concat(new Array(delta));
                }
                else {
                    args = args.slice(0, firstServiceArgPos);
                }
            }
            // now create the instance
            return Reflect.construct(ctor, args.concat(serviceArgs));
        }
        q(id, instance) {
            if (this.i.get(id) instanceof descriptors_1.$Ci) {
                this.i.set(id, instance);
            }
            else if (this.k) {
                this.k.q(id, instance);
            }
            else {
                throw new Error('illegalState - setting UNKNOWN service instance');
            }
        }
        r(id) {
            const instanceOrDesc = this.i.get(id);
            if (!instanceOrDesc && this.k) {
                return this.k.r(id);
            }
            else {
                return instanceOrDesc;
            }
        }
        s(id, _trace) {
            if (this._globalGraph && this.c) {
                this._globalGraph.insertEdge(this.c, String(id));
            }
            const thing = this.r(id);
            if (thing instanceof descriptors_1.$Ci) {
                return this.u(id, thing, _trace.branch(id, true));
            }
            else {
                _trace.branch(id, false);
                return thing;
            }
        }
        u(id, desc, _trace) {
            if (this.t.has(id)) {
                throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);
            }
            this.t.add(id);
            try {
                return this.v(id, desc, _trace);
            }
            finally {
                this.t.delete(id);
            }
        }
        v(id, desc, _trace) {
            const graph = new graph_1.$vr(data => data.id.toString());
            let cycleCount = 0;
            const stack = [{ id, desc, _trace }];
            const seen = new Set();
            while (stack.length) {
                const item = stack.pop();
                if (seen.has(String(item.id))) {
                    continue;
                }
                seen.add(String(item.id));
                graph.lookupOrInsertNode(item);
                // a weak but working heuristic for cycle checks
                if (cycleCount++ > 1000) {
                    throw new CyclicDependencyError(graph);
                }
                // check all dependencies for existence and if they need to be created first
                for (const dependency of instantiation_1._util.getServiceDependencies(item.desc.ctor)) {
                    const instanceOrDesc = this.r(dependency.id);
                    if (!instanceOrDesc) {
                        this.y(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`, true);
                    }
                    // take note of all service dependencies
                    this._globalGraph?.insertEdge(String(item.id), String(dependency.id));
                    if (instanceOrDesc instanceof descriptors_1.$Ci) {
                        const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };
                        graph.insertEdge(item, d);
                        stack.push(d);
                    }
                }
            }
            while (true) {
                const roots = graph.roots();
                // if there is no more roots but still
                // nodes in the graph we have a cycle
                if (roots.length === 0) {
                    if (!graph.isEmpty()) {
                        throw new CyclicDependencyError(graph);
                    }
                    break;
                }
                for (const { data } of roots) {
                    // Repeat the check for this still being a service sync descriptor. That's because
                    // instantiating a dependency might have side-effect and recursively trigger instantiation
                    // so that some dependencies are now fullfilled already.
                    const instanceOrDesc = this.r(data.id);
                    if (instanceOrDesc instanceof descriptors_1.$Ci) {
                        // create instance and overwrite the service collections
                        const instance = this.w(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);
                        this.q(data.id, instance);
                    }
                    graph.removeNode(data);
                }
            }
            return this.r(id);
        }
        w(id, ctor, args = [], supportsDelayedInstantiation, _trace) {
            if (this.i.get(id) instanceof descriptors_1.$Ci) {
                return this.x(id, ctor, args, supportsDelayedInstantiation, _trace, this.g);
            }
            else if (this.k) {
                return this.k.w(id, ctor, args, supportsDelayedInstantiation, _trace);
            }
            else {
                throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);
            }
        }
        x(id, ctor, args = [], supportsDelayedInstantiation, _trace, disposeBucket) {
            if (!supportsDelayedInstantiation) {
                // eager instantiation
                const result = this.o(ctor, args, _trace);
                disposeBucket.add(result);
                return result;
            }
            else {
                const child = new $wr(undefined, this.j, this, this.l);
                child.c = String(id);
                // Return a proxy object that's backed by an idle value. That
                // strategy is to instantiate services in our idle time or when actually
                // needed but not when injected into a consumer
                // return "empty events" when the service isn't instantiated yet
                const earlyListeners = new Map();
                const idle = new async_1.$Yh(() => {
                    const result = child.o(ctor, args, _trace);
                    // early listeners that we kept are now being subscribed to
                    // the real service
                    for (const [key, values] of earlyListeners) {
                        const candidate = result[key];
                        if (typeof candidate === 'function') {
                            for (const value of values) {
                                value.disposable = candidate.apply(result, value.listener);
                            }
                        }
                    }
                    earlyListeners.clear();
                    disposeBucket.add(result);
                    return result;
                });
                return new Proxy(Object.create(null), {
                    get(target, key) {
                        if (!idle.isInitialized) {
                            // looks like an event
                            if (typeof key === 'string' && (key.startsWith('onDid') || key.startsWith('onWill'))) {
                                let list = earlyListeners.get(key);
                                if (!list) {
                                    list = new linkedList_1.$5c();
                                    earlyListeners.set(key, list);
                                }
                                const event = (callback, thisArg, disposables) => {
                                    if (idle.isInitialized) {
                                        return idle.value[key](callback, thisArg, disposables);
                                    }
                                    else {
                                        const entry = { listener: [callback, thisArg, disposables], disposable: undefined };
                                        const rm = list.push(entry);
                                        const result = (0, lifecycle_1.$Sc)(() => {
                                            rm();
                                            entry.disposable?.dispose();
                                        });
                                        return result;
                                    }
                                };
                                return event;
                            }
                        }
                        // value already exists
                        if (key in target) {
                            return target[key];
                        }
                        // create value
                        const obj = idle.value;
                        let prop = obj[key];
                        if (typeof prop !== 'function') {
                            return prop;
                        }
                        prop = prop.bind(obj);
                        target[key] = prop;
                        return prop;
                    },
                    set(_target, p, value) {
                        idle.value[p] = value;
                        return true;
                    },
                    getPrototypeOf(_target) {
                        return ctor.prototype;
                    }
                });
            }
        }
        y(msg, printWarning) {
            if (printWarning) {
                console.warn(msg);
            }
            if (this.j) {
                throw new Error(msg);
            }
        }
    }
    exports.$wr = $wr;
    //#region -- tracing ---
    var TraceType;
    (function (TraceType) {
        TraceType[TraceType["None"] = 0] = "None";
        TraceType[TraceType["Creation"] = 1] = "Creation";
        TraceType[TraceType["Invocation"] = 2] = "Invocation";
        TraceType[TraceType["Branch"] = 3] = "Branch";
    })(TraceType || (TraceType = {}));
    class $xr {
        static { this.all = new Set(); }
        static { this.c = new class extends $xr {
            constructor() { super(TraceType.None, null); }
            stop() { }
            branch() { return this; }
        }; }
        static traceInvocation(_enableTracing, ctor) {
            return !_enableTracing ? $xr.c : new $xr(TraceType.Invocation, ctor.name || new Error().stack.split('\n').slice(3, 4).join('\n'));
        }
        static traceCreation(_enableTracing, ctor) {
            return !_enableTracing ? $xr.c : new $xr(TraceType.Creation, ctor.name);
        }
        static { this.f = 0; }
        constructor(type, name) {
            this.type = type;
            this.name = name;
            this.g = Date.now();
            this.h = [];
        }
        branch(id, first) {
            const child = new $xr(TraceType.Branch, id.toString());
            this.h.push([id, first, child]);
            return child;
        }
        stop() {
            const dur = Date.now() - this.g;
            $xr.f += dur;
            let causedCreation = false;
            function printChild(n, trace) {
                const res = [];
                const prefix = new Array(n + 1).join('\t');
                for (const [id, first, child] of trace.h) {
                    if (first && child) {
                        causedCreation = true;
                        res.push(`${prefix}CREATES -> ${id}`);
                        const nested = printChild(n + 1, child);
                        if (nested) {
                            res.push(nested);
                        }
                    }
                    else {
                        res.push(`${prefix}uses -> ${id}`);
                    }
                }
                return res.join('\n');
            }
            const lines = [
                `${this.type === TraceType.Creation ? 'CREATE' : 'CALL'} ${this.name}`,
                `${printChild(1, this)}`,
                `DONE, took ${dur.toFixed(2)}ms (grand total ${$xr.f.toFixed(2)}ms)`
            ];
            if (dur > 2 || causedCreation) {
                $xr.all.add(lines.join('\n'));
            }
        }
    }
    exports.$xr = $xr;
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[11/*vs/platform/log/common/log*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,42/*vs/base/common/errorMessage*/,6/*vs/base/common/event*/,75/*vs/base/common/hash*/,4/*vs/base/common/lifecycle*/,28/*vs/base/common/map*/,20/*vs/base/common/platform*/,23/*vs/base/common/resources*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,31/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, nls, errorMessage_1, event_1, hash_1, lifecycle_1, map_1, platform_1, resources_1, types_1, uri_1, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$sk = exports.$nk = exports.$mk = exports.$lk = exports.$kk = exports.$jk = exports.$ik = exports.$hk = exports.$gk = exports.$fk = exports.$dk = exports.LogLevel = exports.$bk = exports.$ak = void 0;
    exports.$ck = $ck;
    exports.log = log;
    exports.$ok = $ok;
    exports.$pk = $pk;
    exports.$qk = $qk;
    exports.$rk = $rk;
    nls = __importStar(nls);
    exports.$ak = (0, instantiation_1.$Fi)('logService');
    exports.$bk = (0, instantiation_1.$Fi)('loggerService');
    function now() {
        return new Date().toISOString();
    }
    function $ck(thing) {
        return (0, types_1.$ig)(thing);
    }
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Off"] = 0] = "Off";
        LogLevel[LogLevel["Trace"] = 1] = "Trace";
        LogLevel[LogLevel["Debug"] = 2] = "Debug";
        LogLevel[LogLevel["Info"] = 3] = "Info";
        LogLevel[LogLevel["Warning"] = 4] = "Warning";
        LogLevel[LogLevel["Error"] = 5] = "Error";
    })(LogLevel || (exports.LogLevel = LogLevel = {}));
    exports.$dk = LogLevel.Info;
    function log(logger, level, message) {
        switch (level) {
            case LogLevel.Trace:
                logger.trace(message);
                break;
            case LogLevel.Debug:
                logger.debug(message);
                break;
            case LogLevel.Info:
                logger.info(message);
                break;
            case LogLevel.Warning:
                logger.warn(message);
                break;
            case LogLevel.Error:
                logger.error(message);
                break;
            case LogLevel.Off: /* do nothing */ break;
            default: throw new Error(`Invalid log level ${level}`);
        }
    }
    function format(args, verbose = false) {
        let result = '';
        for (let i = 0; i < args.length; i++) {
            let a = args[i];
            if (a instanceof Error) {
                a = (0, errorMessage_1.$qj)(a, verbose);
            }
            if (typeof a === 'object') {
                try {
                    a = JSON.stringify(a);
                }
                catch (e) { }
            }
            result += (i > 0 ? ' ' : '') + a;
        }
        return result;
    }
    class $fk extends lifecycle_1.$Uc {
        constructor() {
            super(...arguments);
            this.b = exports.$dk;
            this.c = this.B(new event_1.$le());
            this.onDidChangeLogLevel = this.c.event;
        }
        setLevel(level) {
            if (this.b !== level) {
                this.b = level;
                this.c.fire(this.b);
            }
        }
        getLevel() {
            return this.b;
        }
        f(level) {
            return this.b !== LogLevel.Off && this.b <= level;
        }
    }
    exports.$fk = $fk;
    class $gk extends $fk {
        constructor(h) {
            super();
            this.h = h;
        }
        f(level) {
            return this.h || super.f(level);
        }
        trace(message, ...args) {
            if (this.f(LogLevel.Trace)) {
                this.g(LogLevel.Trace, format([message, ...args], true));
            }
        }
        debug(message, ...args) {
            if (this.f(LogLevel.Debug)) {
                this.g(LogLevel.Debug, format([message, ...args]));
            }
        }
        info(message, ...args) {
            if (this.f(LogLevel.Info)) {
                this.g(LogLevel.Info, format([message, ...args]));
            }
        }
        warn(message, ...args) {
            if (this.f(LogLevel.Warning)) {
                this.g(LogLevel.Warning, format([message, ...args]));
            }
        }
        error(message, ...args) {
            if (this.f(LogLevel.Error)) {
                if (message instanceof Error) {
                    const array = Array.prototype.slice.call(arguments);
                    array[0] = message.stack;
                    this.g(LogLevel.Error, format(array));
                }
                else {
                    this.g(LogLevel.Error, format([message, ...args]));
                }
            }
        }
        flush() { }
    }
    exports.$gk = $gk;
    class $hk extends $fk {
        constructor(logLevel = exports.$dk) {
            super();
            this.setLevel(logLevel);
            this.g = !platform_1.$j;
        }
        trace(message, ...args) {
            if (this.f(LogLevel.Trace)) {
                if (this.g) {
                    console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
                }
                else {
                    console.log(`[main ${now()}]`, message, ...args);
                }
            }
        }
        debug(message, ...args) {
            if (this.f(LogLevel.Debug)) {
                if (this.g) {
                    console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
                }
                else {
                    console.log(`[main ${now()}]`, message, ...args);
                }
            }
        }
        info(message, ...args) {
            if (this.f(LogLevel.Info)) {
                if (this.g) {
                    console.log(`\x1b[90m[main ${now()}]\x1b[0m`, message, ...args);
                }
                else {
                    console.log(`[main ${now()}]`, message, ...args);
                }
            }
        }
        warn(message, ...args) {
            if (this.f(LogLevel.Warning)) {
                if (this.g) {
                    console.warn(`\x1b[93m[main ${now()}]\x1b[0m`, message, ...args);
                }
                else {
                    console.warn(`[main ${now()}]`, message, ...args);
                }
            }
        }
        error(message, ...args) {
            if (this.f(LogLevel.Error)) {
                if (this.g) {
                    console.error(`\x1b[91m[main ${now()}]\x1b[0m`, message, ...args);
                }
                else {
                    console.error(`[main ${now()}]`, message, ...args);
                }
            }
        }
        flush() {
            // noop
        }
    }
    exports.$hk = $hk;
    class $ik extends $fk {
        constructor(logLevel = exports.$dk, g = true) {
            super();
            this.g = g;
            this.setLevel(logLevel);
        }
        trace(message, ...args) {
            if (this.f(LogLevel.Trace)) {
                if (this.g) {
                    console.log('%cTRACE', 'color: #888', message, ...args);
                }
                else {
                    console.log(message, ...args);
                }
            }
        }
        debug(message, ...args) {
            if (this.f(LogLevel.Debug)) {
                if (this.g) {
                    console.log('%cDEBUG', 'background: #eee; color: #888', message, ...args);
                }
                else {
                    console.log(message, ...args);
                }
            }
        }
        info(message, ...args) {
            if (this.f(LogLevel.Info)) {
                if (this.g) {
                    console.log('%c INFO', 'color: #33f', message, ...args);
                }
                else {
                    console.log(message, ...args);
                }
            }
        }
        warn(message, ...args) {
            if (this.f(LogLevel.Warning)) {
                if (this.g) {
                    console.log('%c WARN', 'color: #993', message, ...args);
                }
                else {
                    console.log(message, ...args);
                }
            }
        }
        error(message, ...args) {
            if (this.f(LogLevel.Error)) {
                if (this.g) {
                    console.log('%c  ERR', 'color: #f33', message, ...args);
                }
                else {
                    console.error(message, ...args);
                }
            }
        }
        flush() {
            // noop
        }
    }
    exports.$ik = $ik;
    class $jk extends $fk {
        constructor(g, logLevel = exports.$dk) {
            super();
            this.g = g;
            this.setLevel(logLevel);
        }
        trace(message, ...args) {
            if (this.f(LogLevel.Trace)) {
                this.g.log(LogLevel.Trace, [this.h(message), ...args]);
            }
        }
        debug(message, ...args) {
            if (this.f(LogLevel.Debug)) {
                this.g.log(LogLevel.Debug, [this.h(message), ...args]);
            }
        }
        info(message, ...args) {
            if (this.f(LogLevel.Info)) {
                this.g.log(LogLevel.Info, [this.h(message), ...args]);
            }
        }
        warn(message, ...args) {
            if (this.f(LogLevel.Warning)) {
                this.g.log(LogLevel.Warning, [this.h(message), ...args]);
            }
        }
        error(message, ...args) {
            if (this.f(LogLevel.Error)) {
                this.g.log(LogLevel.Error, [this.h(message), ...args]);
            }
        }
        h(msg) {
            if (typeof msg === 'string') {
                return msg;
            }
            return (0, errorMessage_1.$qj)(msg, this.f(LogLevel.Trace));
        }
        flush() {
            // noop
        }
    }
    exports.$jk = $jk;
    class $kk extends $fk {
        constructor(g) {
            super();
            this.g = g;
            if (g.length) {
                this.setLevel(g[0].getLevel());
            }
        }
        setLevel(level) {
            for (const logger of this.g) {
                logger.setLevel(level);
            }
            super.setLevel(level);
        }
        trace(message, ...args) {
            for (const logger of this.g) {
                logger.trace(message, ...args);
            }
        }
        debug(message, ...args) {
            for (const logger of this.g) {
                logger.debug(message, ...args);
            }
        }
        info(message, ...args) {
            for (const logger of this.g) {
                logger.info(message, ...args);
            }
        }
        warn(message, ...args) {
            for (const logger of this.g) {
                logger.warn(message, ...args);
            }
        }
        error(message, ...args) {
            for (const logger of this.g) {
                logger.error(message, ...args);
            }
        }
        flush() {
            for (const logger of this.g) {
                logger.flush();
            }
        }
        dispose() {
            for (const logger of this.g) {
                logger.dispose();
            }
            super.dispose();
        }
    }
    exports.$kk = $kk;
    class $lk extends lifecycle_1.$Uc {
        constructor(h, j, loggerResources) {
            super();
            this.h = h;
            this.j = j;
            this.b = new map_1.$Ac();
            this.c = this.B(new event_1.$le);
            this.onDidChangeLoggers = this.c.event;
            this.f = this.B(new event_1.$le);
            this.onDidChangeLogLevel = this.f.event;
            this.g = this.B(new event_1.$le);
            this.onDidChangeVisibility = this.g.event;
            if (loggerResources) {
                for (const loggerResource of loggerResources) {
                    this.b.set(loggerResource.resource, { logger: undefined, info: loggerResource });
                }
            }
        }
        m(resourceOrId) {
            if ((0, types_1.$eg)(resourceOrId)) {
                return [...this.b.values()].find(logger => logger.info.id === resourceOrId);
            }
            return this.b.get(resourceOrId);
        }
        getLogger(resourceOrId) {
            return this.m(resourceOrId)?.logger;
        }
        createLogger(idOrResource, options) {
            const resource = this.n(idOrResource);
            const id = (0, types_1.$eg)(idOrResource) ? idOrResource : (options?.id ?? (0, hash_1.$tj)(resource.toString()).toString(16));
            let logger = this.b.get(resource)?.logger;
            const logLevel = options?.logLevel === 'always' ? LogLevel.Trace : options?.logLevel;
            if (!logger) {
                logger = this.s(resource, logLevel ?? this.getLogLevel(resource) ?? this.h, { ...options, id });
            }
            const loggerEntry = {
                logger,
                info: { resource, id, logLevel, name: options?.name, hidden: options?.hidden, extensionId: options?.extensionId, when: options?.when }
            };
            this.registerLogger(loggerEntry.info);
            // TODO: @sandy081 Remove this once registerLogger can take ILogger
            this.b.set(resource, loggerEntry);
            return logger;
        }
        n(idOrResource) {
            return (0, types_1.$eg)(idOrResource) ? (0, resources_1.$gh)(this.j, `${idOrResource}.log`) : idOrResource;
        }
        setLogLevel(arg1, arg2) {
            if (uri_1.URI.isUri(arg1)) {
                const resource = arg1;
                const logLevel = arg2;
                const logger = this.b.get(resource);
                if (logger && logLevel !== logger.info.logLevel) {
                    logger.info.logLevel = logLevel === this.h ? undefined : logLevel;
                    logger.logger?.setLevel(logLevel);
                    this.b.set(logger.info.resource, logger);
                    this.f.fire([resource, logLevel]);
                }
            }
            else {
                this.h = arg1;
                for (const [resource, logger] of this.b.entries()) {
                    if (this.b.get(resource)?.info.logLevel === undefined) {
                        logger.logger?.setLevel(this.h);
                    }
                }
                this.f.fire(this.h);
            }
        }
        setVisibility(resourceOrId, visibility) {
            const logger = this.m(resourceOrId);
            if (logger && visibility !== !logger.info.hidden) {
                logger.info.hidden = !visibility;
                this.b.set(logger.info.resource, logger);
                this.g.fire([logger.info.resource, visibility]);
            }
        }
        getLogLevel(resource) {
            let logLevel;
            if (resource) {
                logLevel = this.b.get(resource)?.info.logLevel;
            }
            return logLevel ?? this.h;
        }
        registerLogger(resource) {
            const existing = this.b.get(resource.resource);
            if (existing) {
                if (existing.info.hidden !== resource.hidden) {
                    this.setVisibility(resource.resource, !resource.hidden);
                }
            }
            else {
                this.b.set(resource.resource, { info: resource, logger: undefined });
                this.c.fire({ added: [resource], removed: [] });
            }
        }
        deregisterLogger(resource) {
            const existing = this.b.get(resource);
            if (existing) {
                if (existing.logger) {
                    existing.logger.dispose();
                }
                this.b.delete(resource);
                this.c.fire({ added: [], removed: [existing.info] });
            }
        }
        *getRegisteredLoggers() {
            for (const entry of this.b.values()) {
                yield entry.info;
            }
        }
        getRegisteredLogger(resource) {
            return this.b.get(resource)?.info;
        }
        dispose() {
            this.b.forEach(logger => logger.logger?.dispose());
            this.b.clear();
            super.dispose();
        }
    }
    exports.$lk = $lk;
    class $mk {
        constructor() {
            this.onDidChangeLogLevel = new event_1.$le().event;
        }
        setLevel(level) { }
        getLevel() { return LogLevel.Info; }
        trace(message, ...args) { }
        debug(message, ...args) { }
        info(message, ...args) { }
        warn(message, ...args) { }
        error(message, ...args) { }
        critical(message, ...args) { }
        dispose() { }
        flush() { }
    }
    exports.$mk = $mk;
    class $nk extends $mk {
    }
    exports.$nk = $nk;
    function $ok(environmentService) {
        if (environmentService.verbose) {
            return LogLevel.Trace;
        }
        if (typeof environmentService.logLevel === 'string') {
            const logLevel = $rk(environmentService.logLevel.toLowerCase());
            if (logLevel !== undefined) {
                return logLevel;
            }
        }
        return exports.$dk;
    }
    function $pk(logLevel) {
        switch (logLevel) {
            case LogLevel.Trace: return 'trace';
            case LogLevel.Debug: return 'debug';
            case LogLevel.Info: return 'info';
            case LogLevel.Warning: return 'warn';
            case LogLevel.Error: return 'error';
            case LogLevel.Off: return 'off';
        }
    }
    function $qk(logLevel) {
        switch (logLevel) {
            case LogLevel.Trace: return { original: 'Trace', value: nls.localize(10788, null) };
            case LogLevel.Debug: return { original: 'Debug', value: nls.localize(10789, null) };
            case LogLevel.Info: return { original: 'Info', value: nls.localize(10790, null) };
            case LogLevel.Warning: return { original: 'Warning', value: nls.localize(10791, null) };
            case LogLevel.Error: return { original: 'Error', value: nls.localize(10792, null) };
            case LogLevel.Off: return { original: 'Off', value: nls.localize(10793, null) };
        }
    }
    function $rk(logLevel) {
        switch (logLevel) {
            case 'trace':
                return LogLevel.Trace;
            case 'debug':
                return LogLevel.Debug;
            case 'info':
                return LogLevel.Info;
            case 'warn':
                return LogLevel.Warning;
            case 'error':
                return LogLevel.Error;
            case 'critical':
                return LogLevel.Error;
            case 'off':
                return LogLevel.Off;
        }
        return undefined;
    }
    // Contexts
    exports.$sk = new contextkey_1.$Wj('logLevel', $pk(LogLevel.Info));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[172/*vs/platform/log/common/logService*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,11/*vs/platform/log/common/log*/]), function (require, exports, lifecycle_1, log_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$KR = void 0;
    class $KR extends lifecycle_1.$Uc {
        constructor(primaryLogger, otherLoggers = []) {
            super();
            this.a = new log_1.$kk([primaryLogger, ...otherLoggers]);
            this.B(primaryLogger.onDidChangeLogLevel(level => this.setLevel(level)));
        }
        get onDidChangeLogLevel() {
            return this.a.onDidChangeLogLevel;
        }
        setLevel(level) {
            this.a.setLevel(level);
        }
        getLevel() {
            return this.a.getLevel();
        }
        trace(message, ...args) {
            this.a.trace(message, ...args);
        }
        debug(message, ...args) {
            this.a.debug(message, ...args);
        }
        info(message, ...args) {
            this.a.info(message, ...args);
        }
        warn(message, ...args) {
            this.a.warn(message, ...args);
        }
        error(message, ...args) {
            this.a.error(message, ...args);
        }
        flush() {
            this.a.flush();
        }
    }
    exports.$KR = $KR;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[107/*vs/platform/markers/common/markers*/], __M([1/*require*/,0/*exports*/,35/*vs/base/common/severity*/,9/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, severity_1, nls_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Gu = exports.IMarkerData = exports.MarkerSeverity = exports.MarkerTag = void 0;
    severity_1 = __importDefault(severity_1);
    var MarkerTag;
    (function (MarkerTag) {
        MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
        MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
    })(MarkerTag || (exports.MarkerTag = MarkerTag = {}));
    var MarkerSeverity;
    (function (MarkerSeverity) {
        MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
        MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
        MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
        MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
    })(MarkerSeverity || (exports.MarkerSeverity = MarkerSeverity = {}));
    (function (MarkerSeverity) {
        function compare(a, b) {
            return b - a;
        }
        MarkerSeverity.compare = compare;
        const _displayStrings = Object.create(null);
        _displayStrings[MarkerSeverity.Error] = (0, nls_1.localize)(10785, null);
        _displayStrings[MarkerSeverity.Warning] = (0, nls_1.localize)(10786, null);
        _displayStrings[MarkerSeverity.Info] = (0, nls_1.localize)(10787, null);
        function toString(a) {
            return _displayStrings[a] || '';
        }
        MarkerSeverity.toString = toString;
        function fromSeverity(severity) {
            switch (severity) {
                case severity_1.default.Error: return MarkerSeverity.Error;
                case severity_1.default.Warning: return MarkerSeverity.Warning;
                case severity_1.default.Info: return MarkerSeverity.Info;
                case severity_1.default.Ignore: return MarkerSeverity.Hint;
            }
        }
        MarkerSeverity.fromSeverity = fromSeverity;
        function toSeverity(severity) {
            switch (severity) {
                case MarkerSeverity.Error: return severity_1.default.Error;
                case MarkerSeverity.Warning: return severity_1.default.Warning;
                case MarkerSeverity.Info: return severity_1.default.Info;
                case MarkerSeverity.Hint: return severity_1.default.Ignore;
            }
        }
        MarkerSeverity.toSeverity = toSeverity;
    })(MarkerSeverity || (exports.MarkerSeverity = MarkerSeverity = {}));
    var IMarkerData;
    (function (IMarkerData) {
        const emptyString = '';
        function makeKey(markerData) {
            return makeKeyOptionalMessage(markerData, true);
        }
        IMarkerData.makeKey = makeKey;
        function makeKeyOptionalMessage(markerData, useMessage) {
            const result = [emptyString];
            if (markerData.source) {
                result.push(markerData.source.replace('¦', '\\¦'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.code) {
                if (typeof markerData.code === 'string') {
                    result.push(markerData.code.replace('¦', '\\¦'));
                }
                else {
                    result.push(markerData.code.value.replace('¦', '\\¦'));
                }
            }
            else {
                result.push(emptyString);
            }
            if (markerData.severity !== undefined && markerData.severity !== null) {
                result.push(MarkerSeverity.toString(markerData.severity));
            }
            else {
                result.push(emptyString);
            }
            // Modifed to not include the message as part of the marker key to work around
            // https://github.com/microsoft/vscode/issues/77475
            if (markerData.message && useMessage) {
                result.push(markerData.message.replace('¦', '\\¦'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.startLineNumber !== undefined && markerData.startLineNumber !== null) {
                result.push(markerData.startLineNumber.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.startColumn !== undefined && markerData.startColumn !== null) {
                result.push(markerData.startColumn.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.endLineNumber !== undefined && markerData.endLineNumber !== null) {
                result.push(markerData.endLineNumber.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.endColumn !== undefined && markerData.endColumn !== null) {
                result.push(markerData.endColumn.toString());
            }
            else {
                result.push(emptyString);
            }
            result.push(emptyString);
            return result.join('¦');
        }
        IMarkerData.makeKeyOptionalMessage = makeKeyOptionalMessage;
    })(IMarkerData || (exports.IMarkerData = IMarkerData = {}));
    exports.$Gu = (0, instantiation_1.$Fi)('markerService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[173/*vs/platform/notification/common/notification*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,35/*vs/base/common/severity*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, event_1, severity_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ww = exports.$vw = exports.NotificationsFilter = exports.NeverShowAgainScope = exports.NotificationPriority = exports.$tw = exports.Severity = void 0;
    exports.$uw = $uw;
    severity_1 = __importDefault(severity_1);
    exports.Severity = severity_1.default;
    exports.$tw = (0, instantiation_1.$Fi)('notificationService');
    var NotificationPriority;
    (function (NotificationPriority) {
        /**
         * Default priority: notification will be visible unless do not disturb mode is enabled.
         */
        NotificationPriority[NotificationPriority["DEFAULT"] = 0] = "DEFAULT";
        /**
         * Silent priority: notification will only be visible from the notifications center.
         */
        NotificationPriority[NotificationPriority["SILENT"] = 1] = "SILENT";
        /**
         * Urgent priority: notification will be visible even when do not disturb mode is enabled.
         */
        NotificationPriority[NotificationPriority["URGENT"] = 2] = "URGENT";
    })(NotificationPriority || (exports.NotificationPriority = NotificationPriority = {}));
    var NeverShowAgainScope;
    (function (NeverShowAgainScope) {
        /**
         * Will never show this notification on the current workspace again.
         */
        NeverShowAgainScope[NeverShowAgainScope["WORKSPACE"] = 0] = "WORKSPACE";
        /**
         * Will never show this notification on any workspace of the same
         * profile again.
         */
        NeverShowAgainScope[NeverShowAgainScope["PROFILE"] = 1] = "PROFILE";
        /**
         * Will never show this notification on any workspace across all
         * profiles again.
         */
        NeverShowAgainScope[NeverShowAgainScope["APPLICATION"] = 2] = "APPLICATION";
    })(NeverShowAgainScope || (exports.NeverShowAgainScope = NeverShowAgainScope = {}));
    function $uw(thing) {
        if (thing) {
            const candidate = thing;
            return typeof candidate.id === 'string' && typeof candidate.label === 'string';
        }
        return false;
    }
    var NotificationsFilter;
    (function (NotificationsFilter) {
        /**
         * No filter is enabled.
         */
        NotificationsFilter[NotificationsFilter["OFF"] = 0] = "OFF";
        /**
         * All notifications are silent except error notifications.
        */
        NotificationsFilter[NotificationsFilter["ERROR"] = 1] = "ERROR";
    })(NotificationsFilter || (exports.NotificationsFilter = NotificationsFilter = {}));
    class $vw {
        constructor() {
            this.progress = new $ww();
            this.onDidClose = event_1.Event.None;
            this.onDidChangeVisibility = event_1.Event.None;
        }
        updateSeverity(severity) { }
        updateMessage(message) { }
        updateActions(actions) { }
        close() { }
    }
    exports.$vw = $vw;
    class $ww {
        infinite() { }
        done() { }
        total(value) { }
        worked(value) { }
    }
    exports.$ww = $ww;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[108/*vs/platform/product/common/productService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$uk = exports.$tk = void 0;
    exports.$tk = (0, instantiation_1.$Fi)('productService');
    exports.$uk = 'vscode://schemas/vscode-product';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[76/*vs/platform/progress/common/progress*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,4/*vs/base/common/lifecycle*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, async_1, cancellation_1, lifecycle_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Dw = exports.$Cw = exports.$Bw = exports.$Aw = exports.$zw = exports.$yw = exports.ProgressLocation = exports.$xw = void 0;
    exports.$xw = (0, instantiation_1.$Fi)('progressService');
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["Explorer"] = 1] = "Explorer";
        ProgressLocation[ProgressLocation["Scm"] = 3] = "Scm";
        ProgressLocation[ProgressLocation["Extensions"] = 5] = "Extensions";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
        ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
        ProgressLocation[ProgressLocation["Dialog"] = 20] = "Dialog";
    })(ProgressLocation || (exports.ProgressLocation = ProgressLocation = {}));
    exports.$yw = Object.freeze({
        total() { },
        worked() { },
        done() { }
    });
    class $zw {
        static { this.None = Object.freeze({ report() { } }); }
        get value() { return this.a; }
        constructor(b) {
            this.b = b;
        }
        report(item) {
            this.a = item;
            this.b(this.a);
        }
    }
    exports.$zw = $zw;
    class $Aw {
        get value() { return this.a; }
        constructor(e) {
            this.e = e;
        }
        report(item) {
            if (!this.b) {
                this.b = [item];
            }
            else {
                this.b.push(item);
            }
            this.f();
        }
        async f() {
            if (this.c) {
                return;
            }
            try {
                this.c = true;
                while (this.b && this.b.length) {
                    const item = this.b.shift();
                    this.a = item;
                    await this.e(this.a);
                }
            }
            finally {
                this.c = false;
                const drainListener = this.d;
                this.d = undefined;
                drainListener?.();
            }
        }
        drain() {
            if (this.c) {
                return new Promise(resolve => {
                    const prevListener = this.d;
                    this.d = () => {
                        prevListener?.();
                        resolve();
                    };
                });
            }
            return Promise.resolve();
        }
    }
    exports.$Aw = $Aw;
    /**
     * RAII-style progress instance that allows imperative reporting and hides
     * once `dispose()` is called.
     */
    let $Bw = class $Bw extends lifecycle_1.$Uc {
        constructor(options, progressService) {
            super();
            this.a = new async_1.$3h();
            progressService.withProgress(options, reporter => {
                this.b = reporter;
                if (this.c) {
                    reporter.report(this.c);
                }
                return this.a.p;
            });
            this.B((0, lifecycle_1.$Sc)(() => this.a.complete()));
        }
        report(step) {
            if (this.b) {
                this.b.report(step);
            }
            else {
                this.c = step;
            }
        }
    };
    exports.$Bw = $Bw;
    exports.$Bw = $Bw = __decorate([
        __param(1, exports.$xw)
    ], $Bw);
    class $Cw extends lifecycle_1.$Uc {
        constructor(g) {
            super();
            this.g = g;
            this.a = 0;
            this.b = this.B(new lifecycle_1.$Tc());
        }
        start(progressDelay) {
            // Stop any previous operation
            this.stop();
            // Start new
            const newOperationId = ++this.a;
            const newOperationToken = new cancellation_1.$we();
            this.f = setTimeout(() => {
                if (newOperationId === this.a) {
                    this.c = this.g.show(true);
                }
            }, progressDelay);
            this.b.add((0, lifecycle_1.$Sc)(() => clearTimeout(this.f)));
            this.b.add((0, lifecycle_1.$Sc)(() => newOperationToken.cancel()));
            this.b.add((0, lifecycle_1.$Sc)(() => this.c ? this.c.done() : undefined));
            return {
                id: newOperationId,
                token: newOperationToken.token,
                stop: () => this.h(newOperationId),
                isCurrent: () => this.a === newOperationId
            };
        }
        stop() {
            this.h(this.a);
        }
        h(operationId) {
            if (this.a === operationId) {
                this.b.clear();
            }
        }
    }
    exports.$Cw = $Cw;
    exports.$Dw = (0, instantiation_1.$Fi)('editorProgressService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[30/*vs/platform/registry/common/platform*/], __M([1/*require*/,0/*exports*/,61/*vs/base/common/assert*/,14/*vs/base/common/types*/]), function (require, exports, Assert, Types) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ro = void 0;
    Assert = __importStar(Assert);
    Types = __importStar(Types);
    class RegistryImpl {
        constructor() {
            this.a = new Map();
        }
        add(id, data) {
            Assert.ok(Types.$eg(id));
            Assert.ok(Types.$gg(data));
            Assert.ok(!this.a.has(id), 'There is already an extension with this id');
            this.a.set(id, data);
        }
        knows(id) {
            return this.a.has(id);
        }
        as(id) {
            return this.a.get(id) || null;
        }
    }
    exports.$ro = new RegistryImpl();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[77/*vs/platform/jsonschemas/common/jsonContributionRegistry*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,137/*vs/base/common/jsonSchema*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, event_1, jsonSchema_1, platform) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$so = void 0;
    platform = __importStar(platform);
    exports.$so = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    class JSONContributionRegistry {
        constructor() {
            this.b = new event_1.$le();
            this.onDidChangeSchema = this.b.event;
            this.a = {};
        }
        registerSchema(uri, unresolvedSchemaContent) {
            this.a[normalizeId(uri)] = unresolvedSchemaContent;
            this.b.fire(uri);
        }
        notifySchemaChanged(uri) {
            this.b.fire(uri);
        }
        getSchemaContributions() {
            return {
                schemas: this.a,
            };
        }
        getSchemaContent(uri) {
            const schema = this.a[uri];
            return schema ? (0, jsonSchema_1.$8j)(schema) : undefined;
        }
        hasSchemaContent(uri) {
            return !!this.a[uri];
        }
    }
    const jsonContributionRegistry = new JSONContributionRegistry();
    platform.$ro.add(exports.$so.JSONContribution, jsonContributionRegistry);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[53/*vs/platform/configuration/common/configurationRegistry*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,6/*vs/base/common/event*/,14/*vs/base/common/types*/,9/*vs/nls*/,43/*vs/platform/configuration/common/configuration*/,77/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, arrays_1, event_1, types, nls, configuration_1, jsonContributionRegistry_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Go = exports.$Fo = exports.$Eo = exports.$Do = exports.$Co = exports.$Bo = exports.$Ao = exports.$zo = exports.$yo = exports.$xo = exports.ConfigurationScope = exports.$wo = exports.EditPresentationTypes = void 0;
    exports.$Ho = $Ho;
    exports.$Io = $Io;
    exports.$Jo = $Jo;
    exports.$Ko = $Ko;
    exports.$Lo = $Lo;
    exports.$Mo = $Mo;
    exports.$No = $No;
    types = __importStar(types);
    nls = __importStar(nls);
    var EditPresentationTypes;
    (function (EditPresentationTypes) {
        EditPresentationTypes["Multiline"] = "multilineText";
        EditPresentationTypes["Singleline"] = "singlelineText";
    })(EditPresentationTypes || (exports.EditPresentationTypes = EditPresentationTypes = {}));
    exports.$wo = {
        Configuration: 'base.contributions.configuration'
    };
    var ConfigurationScope;
    (function (ConfigurationScope) {
        /**
         * Application specific configuration, which can be configured only in local user settings.
         */
        ConfigurationScope[ConfigurationScope["APPLICATION"] = 1] = "APPLICATION";
        /**
         * Machine specific configuration, which can be configured only in local and remote user settings.
         */
        ConfigurationScope[ConfigurationScope["MACHINE"] = 2] = "MACHINE";
        /**
         * Window specific configuration, which can be configured in the user or workspace settings.
         */
        ConfigurationScope[ConfigurationScope["WINDOW"] = 3] = "WINDOW";
        /**
         * Resource specific configuration, which can be configured in the user, workspace or folder settings.
         */
        ConfigurationScope[ConfigurationScope["RESOURCE"] = 4] = "RESOURCE";
        /**
         * Resource specific configuration that can be configured in language specific settings
         */
        ConfigurationScope[ConfigurationScope["LANGUAGE_OVERRIDABLE"] = 5] = "LANGUAGE_OVERRIDABLE";
        /**
         * Machine specific configuration that can also be configured in workspace or folder settings.
         */
        ConfigurationScope[ConfigurationScope["MACHINE_OVERRIDABLE"] = 6] = "MACHINE_OVERRIDABLE";
    })(ConfigurationScope || (exports.ConfigurationScope = ConfigurationScope = {}));
    exports.$xo = { properties: {}, patternProperties: {} };
    exports.$yo = { properties: {}, patternProperties: {} };
    exports.$zo = { properties: {}, patternProperties: {} };
    exports.$Ao = { properties: {}, patternProperties: {} };
    exports.$Bo = { properties: {}, patternProperties: {} };
    exports.$Co = { properties: {}, patternProperties: {} };
    exports.$Do = 'vscode://schemas/settings/resourceLanguage';
    exports.$Eo = 'vscode://schemas/settings/configurationDefaults';
    const contributionRegistry = platform_1.$ro.as(jsonContributionRegistry_1.$so.JSONContribution);
    class ConfigurationRegistry {
        constructor() {
            this.a = [];
            this.i = new Set();
            this.j = new event_1.$le();
            this.onDidSchemaChange = this.j.event;
            this.k = new event_1.$le();
            this.onDidUpdateConfiguration = this.k.event;
            this.b = new Map();
            this.c = {
                id: 'defaultOverrides',
                title: nls.localize(11081, null),
                properties: {}
            };
            this.d = [this.c];
            this.h = {
                properties: {},
                patternProperties: {},
                additionalProperties: true,
                allowTrailingCommas: true,
                allowComments: true
            };
            this.e = {};
            this.f = new Map();
            this.g = {};
            contributionRegistry.registerSchema(exports.$Do, this.h);
            this.z();
        }
        registerConfiguration(configuration, validate = true) {
            this.registerConfigurations([configuration], validate);
        }
        registerConfigurations(configurations, validate = true) {
            const properties = new Set();
            this.r(configurations, validate, properties);
            contributionRegistry.registerSchema(exports.$Do, this.h);
            this.j.fire();
            this.k.fire({ properties });
        }
        deregisterConfigurations(configurations) {
            const properties = new Set();
            this.s(configurations, properties);
            contributionRegistry.registerSchema(exports.$Do, this.h);
            this.j.fire();
            this.k.fire({ properties });
        }
        updateConfigurations({ add, remove }) {
            const properties = new Set();
            this.s(remove, properties);
            this.r(add, false, properties);
            contributionRegistry.registerSchema(exports.$Do, this.h);
            this.j.fire();
            this.k.fire({ properties });
        }
        registerDefaultConfigurations(configurationDefaults) {
            const properties = new Set();
            this.l(configurationDefaults, properties);
            this.j.fire();
            this.k.fire({ properties, defaultsOverrides: true });
        }
        l(configurationDefaults, bucket) {
            this.a.push(...configurationDefaults);
            const overrideIdentifiers = [];
            for (const { overrides, source } of configurationDefaults) {
                for (const key in overrides) {
                    bucket.add(key);
                    const configurationDefaultOverridesForKey = this.b.get(key)
                        ?? this.b.set(key, { configurationDefaultOverrides: [] }).get(key);
                    const value = overrides[key];
                    configurationDefaultOverridesForKey.configurationDefaultOverrides.push({ value, source });
                    // Configuration defaults for Override Identifiers
                    if (exports.$Go.test(key)) {
                        const newDefaultOverride = this.o(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);
                        if (!newDefaultOverride) {
                            continue;
                        }
                        configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;
                        this.n(key, newDefaultOverride, source);
                        overrideIdentifiers.push(...$Ho(key));
                    }
                    // Configuration defaults for Configuration Properties
                    else {
                        const newDefaultOverride = this.p(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);
                        if (!newDefaultOverride) {
                            continue;
                        }
                        configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;
                        const property = this.e[key];
                        if (property) {
                            this.A(key, property);
                            this.w(key, property);
                        }
                    }
                }
            }
            this.q(overrideIdentifiers);
        }
        deregisterDefaultConfigurations(defaultConfigurations) {
            const properties = new Set();
            this.m(defaultConfigurations, properties);
            this.j.fire();
            this.k.fire({ properties, defaultsOverrides: true });
        }
        m(defaultConfigurations, bucket) {
            for (const defaultConfiguration of defaultConfigurations) {
                const index = this.a.indexOf(defaultConfiguration);
                if (index !== -1) {
                    this.a.splice(index, 1);
                }
            }
            for (const { overrides, source } of defaultConfigurations) {
                for (const key in overrides) {
                    const configurationDefaultOverridesForKey = this.b.get(key);
                    if (!configurationDefaultOverridesForKey) {
                        continue;
                    }
                    const index = configurationDefaultOverridesForKey.configurationDefaultOverrides
                        .findIndex(configurationDefaultOverride => source ? configurationDefaultOverride.source?.id === source.id : configurationDefaultOverride.value === overrides[key]);
                    if (index === -1) {
                        continue;
                    }
                    configurationDefaultOverridesForKey.configurationDefaultOverrides.splice(index, 1);
                    if (configurationDefaultOverridesForKey.configurationDefaultOverrides.length === 0) {
                        this.b.delete(key);
                    }
                    if (exports.$Go.test(key)) {
                        let configurationDefaultOverrideValue;
                        for (const configurationDefaultOverride of configurationDefaultOverridesForKey.configurationDefaultOverrides) {
                            configurationDefaultOverrideValue = this.o(key, configurationDefaultOverride.value, configurationDefaultOverride.source, configurationDefaultOverrideValue);
                        }
                        if (configurationDefaultOverrideValue && !types.$rg(configurationDefaultOverrideValue.value)) {
                            configurationDefaultOverridesForKey.configurationDefaultOverrideValue = configurationDefaultOverrideValue;
                            this.n(key, configurationDefaultOverrideValue, source);
                        }
                        else {
                            this.b.delete(key);
                            delete this.e[key];
                            delete this.c.properties[key];
                        }
                    }
                    else {
                        let configurationDefaultOverrideValue;
                        for (const configurationDefaultOverride of configurationDefaultOverridesForKey.configurationDefaultOverrides) {
                            configurationDefaultOverrideValue = this.p(key, configurationDefaultOverride.value, configurationDefaultOverride.source, configurationDefaultOverrideValue);
                        }
                        configurationDefaultOverridesForKey.configurationDefaultOverrideValue = configurationDefaultOverrideValue;
                        const property = this.e[key];
                        if (property) {
                            this.A(key, property);
                            this.w(key, property);
                        }
                    }
                    bucket.add(key);
                }
            }
            this.y();
        }
        n(key, newDefaultOverride, source) {
            const property = {
                type: 'object',
                default: newDefaultOverride.value,
                description: nls.localize(11082, null, (0, configuration_1.$jj)(key)),
                $ref: exports.$Do,
                defaultDefaultValue: newDefaultOverride.value,
                source,
                defaultValueSource: source
            };
            this.e[key] = property;
            this.c.properties[key] = property;
        }
        o(overrideIdentifier, configurationValueObject, valueSource, existingDefaultOverride) {
            const defaultValue = existingDefaultOverride?.value || {};
            const source = existingDefaultOverride?.source ?? new Map();
            // This should not happen
            if (!(source instanceof Map)) {
                console.error('objectConfigurationSources is not a Map');
                return undefined;
            }
            for (const propertyKey of Object.keys(configurationValueObject)) {
                const propertyDefaultValue = configurationValueObject[propertyKey];
                const isObjectSetting = types.$gg(propertyDefaultValue) &&
                    (types.$lg(defaultValue[propertyKey]) || types.$gg(defaultValue[propertyKey]));
                // If the default value is an object, merge the objects and store the source of each keys
                if (isObjectSetting) {
                    defaultValue[propertyKey] = { ...(defaultValue[propertyKey] ?? {}), ...propertyDefaultValue };
                    // Track the source of each value in the object
                    if (valueSource) {
                        for (const objectKey in propertyDefaultValue) {
                            source.set(`${propertyKey}.${objectKey}`, valueSource);
                        }
                    }
                }
                // Primitive values are overridden
                else {
                    defaultValue[propertyKey] = propertyDefaultValue;
                    if (valueSource) {
                        source.set(propertyKey, valueSource);
                    }
                    else {
                        source.delete(propertyKey);
                    }
                }
            }
            return { value: defaultValue, source };
        }
        p(propertyKey, value, valuesSource, existingDefaultOverride) {
            const property = this.e[propertyKey];
            const existingDefaultValue = existingDefaultOverride?.value ?? property?.defaultDefaultValue;
            let source = valuesSource;
            const isObjectSetting = types.$gg(value) &&
                (property !== undefined && property.type === 'object' ||
                    property === undefined && (types.$lg(existingDefaultValue) || types.$gg(existingDefaultValue)));
            // If the default value is an object, merge the objects and store the source of each keys
            if (isObjectSetting) {
                source = existingDefaultOverride?.source ?? new Map();
                // This should not happen
                if (!(source instanceof Map)) {
                    console.error('defaultValueSource is not a Map');
                    return undefined;
                }
                for (const objectKey in value) {
                    if (valuesSource) {
                        source.set(`${propertyKey}.${objectKey}`, valuesSource);
                    }
                }
                value = { ...(types.$gg(existingDefaultValue) ? existingDefaultValue : {}), ...value };
            }
            return { value, source };
        }
        deltaConfiguration(delta) {
            // defaults: remove
            let defaultsOverrides = false;
            const properties = new Set();
            if (delta.removedDefaults) {
                this.m(delta.removedDefaults, properties);
                defaultsOverrides = true;
            }
            // defaults: add
            if (delta.addedDefaults) {
                this.l(delta.addedDefaults, properties);
                defaultsOverrides = true;
            }
            // configurations: remove
            if (delta.removedConfigurations) {
                this.s(delta.removedConfigurations, properties);
            }
            // configurations: add
            if (delta.addedConfigurations) {
                this.r(delta.addedConfigurations, false, properties);
            }
            this.j.fire();
            this.k.fire({ properties, defaultsOverrides });
        }
        notifyConfigurationSchemaUpdated(...configurations) {
            this.j.fire();
        }
        registerOverrideIdentifiers(overrideIdentifiers) {
            this.q(overrideIdentifiers);
            this.j.fire();
        }
        q(overrideIdentifiers) {
            for (const overrideIdentifier of overrideIdentifiers) {
                this.i.add(overrideIdentifier);
            }
            this.y();
        }
        r(configurations, validate, bucket) {
            configurations.forEach(configuration => {
                this.u(configuration, validate, configuration.extensionInfo, configuration.restrictedProperties, undefined, bucket);
                this.d.push(configuration);
                this.v(configuration);
            });
        }
        s(configurations, bucket) {
            const deregisterConfiguration = (configuration) => {
                if (configuration.properties) {
                    for (const key in configuration.properties) {
                        bucket.add(key);
                        const property = this.e[key];
                        if (property?.policy?.name) {
                            this.f.delete(property.policy.name);
                        }
                        delete this.e[key];
                        this.x(key, configuration.properties[key]);
                    }
                }
                configuration.allOf?.forEach(node => deregisterConfiguration(node));
            };
            for (const configuration of configurations) {
                deregisterConfiguration(configuration);
                const index = this.d.indexOf(configuration);
                if (index !== -1) {
                    this.d.splice(index, 1);
                }
            }
        }
        u(configuration, validate = true, extensionInfo, restrictedProperties, scope = ConfigurationScope.WINDOW, bucket) {
            scope = types.$ng(configuration.scope) ? scope : configuration.scope;
            const properties = configuration.properties;
            if (properties) {
                for (const key in properties) {
                    const property = properties[key];
                    if (validate && $Ko(key, property)) {
                        delete properties[key];
                        continue;
                    }
                    property.source = extensionInfo;
                    // update default value
                    property.defaultDefaultValue = properties[key].default;
                    this.A(key, property);
                    // update scope
                    if (exports.$Go.test(key)) {
                        property.scope = undefined; // No scope for overridable properties `[${identifier}]`
                    }
                    else {
                        property.scope = types.$ng(property.scope) ? scope : property.scope;
                        property.restricted = types.$ng(property.restricted) ? !!restrictedProperties?.includes(key) : property.restricted;
                    }
                    // Add to properties maps
                    // Property is included by default if 'included' is unspecified
                    if (properties[key].hasOwnProperty('included') && !properties[key].included) {
                        this.g[key] = properties[key];
                        delete properties[key];
                        continue;
                    }
                    else {
                        this.e[key] = properties[key];
                        if (properties[key].policy?.name) {
                            this.f.set(properties[key].policy.name, key);
                        }
                    }
                    if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
                        // If not set, default deprecationMessage to the markdown source
                        properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
                    }
                    bucket.add(key);
                }
            }
            const subNodes = configuration.allOf;
            if (subNodes) {
                for (const node of subNodes) {
                    this.u(node, validate, extensionInfo, restrictedProperties, scope, bucket);
                }
            }
        }
        // TODO: @sandy081 - Remove this method and include required info in getConfigurationProperties
        getConfigurations() {
            return this.d;
        }
        getConfigurationProperties() {
            return this.e;
        }
        getPolicyConfigurations() {
            return this.f;
        }
        getExcludedConfigurationProperties() {
            return this.g;
        }
        getRegisteredDefaultConfigurations() {
            return [...this.a];
        }
        getConfigurationDefaultsOverrides() {
            const configurationDefaultsOverrides = new Map();
            for (const [key, value] of this.b) {
                if (value.configurationDefaultOverrideValue) {
                    configurationDefaultsOverrides.set(key, value.configurationDefaultOverrideValue);
                }
            }
            return configurationDefaultsOverrides;
        }
        v(configuration) {
            const register = (configuration) => {
                const properties = configuration.properties;
                if (properties) {
                    for (const key in properties) {
                        this.w(key, properties[key]);
                    }
                }
                const subNodes = configuration.allOf;
                subNodes?.forEach(register);
            };
            register(configuration);
        }
        w(key, property) {
            exports.$xo.properties[key] = property;
            switch (property.scope) {
                case ConfigurationScope.APPLICATION:
                    exports.$yo.properties[key] = property;
                    break;
                case ConfigurationScope.MACHINE:
                    exports.$zo.properties[key] = property;
                    break;
                case ConfigurationScope.MACHINE_OVERRIDABLE:
                    exports.$Ao.properties[key] = property;
                    break;
                case ConfigurationScope.WINDOW:
                    exports.$Bo.properties[key] = property;
                    break;
                case ConfigurationScope.RESOURCE:
                    exports.$Co.properties[key] = property;
                    break;
                case ConfigurationScope.LANGUAGE_OVERRIDABLE:
                    exports.$Co.properties[key] = property;
                    this.h.properties[key] = property;
                    break;
            }
        }
        x(key, property) {
            delete exports.$xo.properties[key];
            switch (property.scope) {
                case ConfigurationScope.APPLICATION:
                    delete exports.$yo.properties[key];
                    break;
                case ConfigurationScope.MACHINE:
                    delete exports.$zo.properties[key];
                    break;
                case ConfigurationScope.MACHINE_OVERRIDABLE:
                    delete exports.$Ao.properties[key];
                    break;
                case ConfigurationScope.WINDOW:
                    delete exports.$Bo.properties[key];
                    break;
                case ConfigurationScope.RESOURCE:
                case ConfigurationScope.LANGUAGE_OVERRIDABLE:
                    delete exports.$Co.properties[key];
                    delete this.h.properties[key];
                    break;
            }
        }
        y() {
            for (const overrideIdentifier of this.i.values()) {
                const overrideIdentifierProperty = `[${overrideIdentifier}]`;
                const resourceLanguagePropertiesSchema = {
                    type: 'object',
                    description: nls.localize(11083, null),
                    errorMessage: nls.localize(11084, null),
                    $ref: exports.$Do,
                };
                this.A(overrideIdentifierProperty, resourceLanguagePropertiesSchema);
                exports.$xo.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
                exports.$yo.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
                exports.$zo.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
                exports.$Ao.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
                exports.$Bo.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
                exports.$Co.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;
            }
        }
        z() {
            const resourceLanguagePropertiesSchema = {
                type: 'object',
                description: nls.localize(11085, null),
                errorMessage: nls.localize(11086, null),
                $ref: exports.$Do,
            };
            exports.$xo.patternProperties[exports.$Fo] = resourceLanguagePropertiesSchema;
            exports.$yo.patternProperties[exports.$Fo] = resourceLanguagePropertiesSchema;
            exports.$zo.patternProperties[exports.$Fo] = resourceLanguagePropertiesSchema;
            exports.$Ao.patternProperties[exports.$Fo] = resourceLanguagePropertiesSchema;
            exports.$Bo.patternProperties[exports.$Fo] = resourceLanguagePropertiesSchema;
            exports.$Co.patternProperties[exports.$Fo] = resourceLanguagePropertiesSchema;
            this.j.fire();
        }
        A(key, property) {
            const configurationdefaultOverride = this.b.get(key)?.configurationDefaultOverrideValue;
            let defaultValue = undefined;
            let defaultSource = undefined;
            if (configurationdefaultOverride
                && (!property.disallowConfigurationDefault || !configurationdefaultOverride.source) // Prevent overriding the default value if the property is disallowed to be overridden by configuration defaults from extensions
            ) {
                defaultValue = configurationdefaultOverride.value;
                defaultSource = configurationdefaultOverride.source;
            }
            if (types.$lg(defaultValue)) {
                defaultValue = property.defaultDefaultValue;
                defaultSource = undefined;
            }
            if (types.$lg(defaultValue)) {
                defaultValue = $Jo(property.type);
            }
            property.default = defaultValue;
            property.defaultValueSource = defaultSource;
        }
    }
    const OVERRIDE_IDENTIFIER_PATTERN = `\\[([^\\]]+)\\]`;
    const OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, 'g');
    exports.$Fo = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;
    exports.$Go = new RegExp(exports.$Fo);
    function $Ho(key) {
        const identifiers = [];
        if (exports.$Go.test(key)) {
            let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
            while (matches?.length) {
                const identifier = matches[1].trim();
                if (identifier) {
                    identifiers.push(identifier);
                }
                matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
            }
        }
        return (0, arrays_1.$Lb)(identifiers);
    }
    function $Io(overrideIdentifiers) {
        return overrideIdentifiers.reduce((result, overrideIdentifier) => `${result}[${overrideIdentifier}]`, '');
    }
    function $Jo(type) {
        const t = Array.isArray(type) ? type[0] : type;
        switch (t) {
            case 'boolean':
                return false;
            case 'integer':
            case 'number':
                return 0;
            case 'string':
                return '';
            case 'array':
                return [];
            case 'object':
                return {};
            default:
                return null;
        }
    }
    const configurationRegistry = new ConfigurationRegistry();
    platform_1.$ro.add(exports.$wo.Configuration, configurationRegistry);
    function $Ko(property, schema) {
        if (!property.trim()) {
            return nls.localize(11087, null);
        }
        if (exports.$Go.test(property)) {
            return nls.localize(11088, null, property);
        }
        if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {
            return nls.localize(11089, null, property);
        }
        if (schema.policy?.name && configurationRegistry.getPolicyConfigurations().get(schema.policy?.name) !== undefined) {
            return nls.localize(11090, null, property, schema.policy?.name, configurationRegistry.getPolicyConfigurations().get(schema.policy?.name));
        }
        return null;
    }
    function $Lo() {
        const scopes = [];
        const configurationProperties = configurationRegistry.getConfigurationProperties();
        for (const key of Object.keys(configurationProperties)) {
            scopes.push([key, configurationProperties[key].scope]);
        }
        scopes.push(['launch', ConfigurationScope.RESOURCE]);
        scopes.push(['task', ConfigurationScope.RESOURCE]);
        return scopes;
    }
    function $Mo(configurationNode) {
        const result = {};
        for (const configuration of configurationNode) {
            const properties = configuration.properties;
            if (types.$gg(properties)) {
                for (const key in properties) {
                    result[key] = properties[key];
                }
            }
            if (configuration.allOf) {
                Object.assign(result, $Mo(configuration.allOf));
            }
        }
        return result;
    }
    function $No(scope) {
        switch (scope) {
            case 'application':
                return ConfigurationScope.APPLICATION;
            case 'machine':
                return ConfigurationScope.MACHINE;
            case 'resource':
                return ConfigurationScope.RESOURCE;
            case 'machine-overridable':
                return ConfigurationScope.MACHINE_OVERRIDABLE;
            case 'language-overridable':
                return ConfigurationScope.LANGUAGE_OVERRIDABLE;
            default:
                return ConfigurationScope.WINDOW;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[174/*vs/platform/configuration/common/configurationModels*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,6/*vs/base/common/event*/,136/*vs/base/common/json*/,4/*vs/base/common/lifecycle*/,28/*vs/base/common/map*/,25/*vs/base/common/objects*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,43/*vs/platform/configuration/common/configuration*/,53/*vs/platform/configuration/common/configurationRegistry*/,29/*vs/platform/files/common/files*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, arrays, event_1, json, lifecycle_1, map_1, objects, types, uri_1, configuration_1, configurationRegistry_1, files_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$To = exports.$Ro = exports.$Qo = exports.$Po = exports.$Oo = void 0;
    exports.$So = $So;
    arrays = __importStar(arrays);
    json = __importStar(json);
    objects = __importStar(objects);
    types = __importStar(types);
    function freeze(data) {
        return Object.isFrozen(data) ? data : objects.$fo(data);
    }
    class $Oo {
        static createEmptyModel(logService) {
            return new $Oo({}, [], [], undefined, logService);
        }
        constructor(b, c, d, raw, f) {
            this.b = b;
            this.c = c;
            this.d = d;
            this.raw = raw;
            this.f = f;
            this.a = new Map();
        }
        get rawConfiguration() {
            if (!this.g) {
                if (this.raw?.length) {
                    const rawConfigurationModels = this.raw.map(raw => {
                        if (raw instanceof $Oo) {
                            return raw;
                        }
                        const parser = new $Po('', this.f);
                        parser.parseRaw(raw);
                        return parser.configurationModel;
                    });
                    this.g = rawConfigurationModels.reduce((previous, current) => current === previous ? current : previous.merge(current), rawConfigurationModels[0]);
                }
                else {
                    // raw is same as current
                    this.g = this;
                }
            }
            return this.g;
        }
        get contents() {
            return this.b;
        }
        get overrides() {
            return this.d;
        }
        get keys() {
            return this.c;
        }
        isEmpty() {
            return this.c.length === 0 && Object.keys(this.b).length === 0 && this.d.length === 0;
        }
        getValue(section) {
            return section ? (0, configuration_1.$hj)(this.contents, section) : this.contents;
        }
        inspect(section, overrideIdentifier) {
            const that = this;
            return {
                get value() {
                    return freeze(that.rawConfiguration.getValue(section));
                },
                get override() {
                    return overrideIdentifier ? freeze(that.rawConfiguration.getOverrideValue(section, overrideIdentifier)) : undefined;
                },
                get merged() {
                    return freeze(overrideIdentifier ? that.rawConfiguration.override(overrideIdentifier).getValue(section) : that.rawConfiguration.getValue(section));
                },
                get overrides() {
                    const overrides = [];
                    for (const { contents, identifiers, keys } of that.rawConfiguration.overrides) {
                        const value = new $Oo(contents, keys, [], undefined, that.f).getValue(section);
                        if (value !== undefined) {
                            overrides.push({ identifiers, value });
                        }
                    }
                    return overrides.length ? freeze(overrides) : undefined;
                }
            };
        }
        getOverrideValue(section, overrideIdentifier) {
            const overrideContents = this.j(overrideIdentifier);
            return overrideContents
                ? section ? (0, configuration_1.$hj)(overrideContents, section) : overrideContents
                : undefined;
        }
        getKeysForOverrideIdentifier(identifier) {
            const keys = [];
            for (const override of this.overrides) {
                if (override.identifiers.includes(identifier)) {
                    keys.push(...override.keys);
                }
            }
            return arrays.$Lb(keys);
        }
        getAllOverrideIdentifiers() {
            const result = [];
            for (const override of this.overrides) {
                result.push(...override.identifiers);
            }
            return arrays.$Lb(result);
        }
        override(identifier) {
            let overrideConfigurationModel = this.a.get(identifier);
            if (!overrideConfigurationModel) {
                overrideConfigurationModel = this.h(identifier);
                this.a.set(identifier, overrideConfigurationModel);
            }
            return overrideConfigurationModel;
        }
        merge(...others) {
            const contents = objects.$eo(this.contents);
            const overrides = objects.$eo(this.overrides);
            const keys = [...this.keys];
            const raws = this.raw?.length ? [...this.raw] : [this];
            for (const other of others) {
                raws.push(...(other.raw?.length ? other.raw : [other]));
                if (other.isEmpty()) {
                    continue;
                }
                this.i(contents, other.contents);
                for (const otherOverride of other.overrides) {
                    const [override] = overrides.filter(o => arrays.$tb(o.identifiers, otherOverride.identifiers));
                    if (override) {
                        this.i(override.contents, otherOverride.contents);
                        override.keys.push(...otherOverride.keys);
                        override.keys = arrays.$Lb(override.keys);
                    }
                    else {
                        overrides.push(objects.$eo(otherOverride));
                    }
                }
                for (const key of other.keys) {
                    if (keys.indexOf(key) === -1) {
                        keys.push(key);
                    }
                }
            }
            return new $Oo(contents, keys, overrides, raws.every(raw => raw instanceof $Oo) ? undefined : raws, this.f);
        }
        h(identifier) {
            const overrideContents = this.j(identifier);
            if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {
                // If there are no valid overrides, return self
                return this;
            }
            const contents = {};
            for (const key of arrays.$Lb([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
                let contentsForKey = this.contents[key];
                const overrideContentsForKey = overrideContents[key];
                // If there are override contents for the key, clone and merge otherwise use base contents
                if (overrideContentsForKey) {
                    // Clone and merge only if base contents and override contents are of type object otherwise just override
                    if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {
                        contentsForKey = objects.$eo(contentsForKey);
                        this.i(contentsForKey, overrideContentsForKey);
                    }
                    else {
                        contentsForKey = overrideContentsForKey;
                    }
                }
                contents[key] = contentsForKey;
            }
            return new $Oo(contents, this.keys, this.overrides, undefined, this.f);
        }
        i(source, target) {
            for (const key of Object.keys(target)) {
                if (key in source) {
                    if (types.$gg(source[key]) && types.$gg(target[key])) {
                        this.i(source[key], target[key]);
                        continue;
                    }
                }
                source[key] = objects.$eo(target[key]);
            }
        }
        j(identifier) {
            let contentsForIdentifierOnly = null;
            let contents = null;
            const mergeContents = (contentsToMerge) => {
                if (contentsToMerge) {
                    if (contents) {
                        this.i(contents, contentsToMerge);
                    }
                    else {
                        contents = objects.$eo(contentsToMerge);
                    }
                }
            };
            for (const override of this.overrides) {
                if (override.identifiers.length === 1 && override.identifiers[0] === identifier) {
                    contentsForIdentifierOnly = override.contents;
                }
                else if (override.identifiers.includes(identifier)) {
                    mergeContents(override.contents);
                }
            }
            // Merge contents of the identifier only at the end to take precedence.
            mergeContents(contentsForIdentifierOnly);
            return contents;
        }
        toJSON() {
            return {
                contents: this.contents,
                overrides: this.overrides,
                keys: this.keys
            };
        }
        // Update methods
        addValue(key, value) {
            this.k(key, value, true);
        }
        setValue(key, value) {
            this.k(key, value, false);
        }
        removeValue(key) {
            const index = this.keys.indexOf(key);
            if (index === -1) {
                return;
            }
            this.keys.splice(index, 1);
            (0, configuration_1.$gj)(this.contents, key);
            if (configurationRegistry_1.$Go.test(key)) {
                this.overrides.splice(this.overrides.findIndex(o => arrays.$tb(o.identifiers, (0, configurationRegistry_1.$Ho)(key))), 1);
            }
        }
        k(key, value, add) {
            (0, configuration_1.$fj)(this.contents, key, value, e => this.f.error(e));
            add = add || this.keys.indexOf(key) === -1;
            if (add) {
                this.keys.push(key);
            }
            if (configurationRegistry_1.$Go.test(key)) {
                const identifiers = (0, configurationRegistry_1.$Ho)(key);
                const override = {
                    identifiers,
                    keys: Object.keys(this.contents[key]),
                    contents: (0, configuration_1.$ej)(this.contents[key], message => this.f.error(message)),
                };
                const index = this.overrides.findIndex(o => arrays.$tb(o.identifiers, identifiers));
                if (index !== -1) {
                    this.overrides[index] = override;
                }
                else {
                    this.overrides.push(override);
                }
            }
        }
    }
    exports.$Oo = $Oo;
    class $Po {
        constructor(f, g) {
            this.f = f;
            this.g = g;
            this.a = null;
            this.b = null;
            this.c = [];
            this.d = [];
        }
        get configurationModel() {
            return this.b || $Oo.createEmptyModel(this.g);
        }
        get restrictedConfigurations() {
            return this.c;
        }
        get errors() {
            return this.d;
        }
        parse(content, options) {
            if (!types.$ng(content)) {
                const raw = this.h(content);
                this.parseRaw(raw, options);
            }
        }
        reparse(options) {
            if (this.a) {
                this.parseRaw(this.a, options);
            }
        }
        parseRaw(raw, options) {
            this.a = raw;
            const { contents, keys, overrides, restricted, hasExcludedProperties } = this.i(raw, options);
            this.b = new $Oo(contents, keys, overrides, hasExcludedProperties ? [raw] : undefined /* raw has not changed */, this.g);
            this.c = restricted || [];
        }
        h(content) {
            let raw = {};
            let currentProperty = null;
            let currentParent = [];
            const previousParents = [];
            const parseErrors = [];
            function onValue(value) {
                if (Array.isArray(currentParent)) {
                    currentParent.push(value);
                }
                else if (currentProperty !== null) {
                    currentParent[currentProperty] = value;
                }
            }
            const visitor = {
                onObjectBegin: () => {
                    const object = {};
                    onValue(object);
                    previousParents.push(currentParent);
                    currentParent = object;
                    currentProperty = null;
                },
                onObjectProperty: (name) => {
                    currentProperty = name;
                },
                onObjectEnd: () => {
                    currentParent = previousParents.pop();
                },
                onArrayBegin: () => {
                    const array = [];
                    onValue(array);
                    previousParents.push(currentParent);
                    currentParent = array;
                    currentProperty = null;
                },
                onArrayEnd: () => {
                    currentParent = previousParents.pop();
                },
                onLiteralValue: onValue,
                onError: (error, offset, length) => {
                    parseErrors.push({ error, offset, length });
                }
            };
            if (content) {
                try {
                    json.$6n(content, visitor);
                    raw = currentParent[0] || {};
                }
                catch (e) {
                    this.g.error(`Error while parsing settings file ${this.f}: ${e}`);
                    this.d = [e];
                }
            }
            return raw;
        }
        i(raw, options) {
            const configurationProperties = platform_1.$ro.as(configurationRegistry_1.$wo.Configuration).getConfigurationProperties();
            const filtered = this.j(raw, configurationProperties, true, options);
            raw = filtered.raw;
            const contents = (0, configuration_1.$ej)(raw, message => this.g.error(`Conflict in settings file ${this.f}: ${message}`));
            const keys = Object.keys(raw);
            const overrides = this.l(raw, message => this.g.error(`Conflict in settings file ${this.f}: ${message}`));
            return { contents, keys, overrides, restricted: filtered.restricted, hasExcludedProperties: filtered.hasExcludedProperties };
        }
        j(properties, configurationProperties, filterOverriddenProperties, options) {
            let hasExcludedProperties = false;
            if (!options?.scopes && !options?.skipRestricted && !options?.exclude?.length) {
                return { raw: properties, restricted: [], hasExcludedProperties };
            }
            const raw = {};
            const restricted = [];
            for (const key in properties) {
                if (configurationRegistry_1.$Go.test(key) && filterOverriddenProperties) {
                    const result = this.j(properties[key], configurationProperties, false, options);
                    raw[key] = result.raw;
                    hasExcludedProperties = hasExcludedProperties || result.hasExcludedProperties;
                    restricted.push(...result.restricted);
                }
                else {
                    const propertySchema = configurationProperties[key];
                    const scope = propertySchema ? typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : configurationRegistry_1.ConfigurationScope.WINDOW : undefined;
                    if (propertySchema?.restricted) {
                        restricted.push(key);
                    }
                    if (!options.exclude?.includes(key) /* Check exclude */
                        && (options.include?.includes(key) /* Check include */
                            || ((scope === undefined || options.scopes === undefined || options.scopes.includes(scope)) /* Check scopes */
                                && !(options.skipRestricted && propertySchema?.restricted)))) /* Check restricted */ {
                        raw[key] = properties[key];
                    }
                    else {
                        hasExcludedProperties = true;
                    }
                }
            }
            return { raw, restricted, hasExcludedProperties };
        }
        l(raw, conflictReporter) {
            const overrides = [];
            for (const key of Object.keys(raw)) {
                if (configurationRegistry_1.$Go.test(key)) {
                    const overrideRaw = {};
                    for (const keyInOverrideRaw in raw[key]) {
                        overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                    }
                    overrides.push({
                        identifiers: (0, configurationRegistry_1.$Ho)(key),
                        keys: Object.keys(overrideRaw),
                        contents: (0, configuration_1.$ej)(overrideRaw, conflictReporter)
                    });
                }
            }
            return overrides;
        }
    }
    exports.$Po = $Po;
    class $Qo extends lifecycle_1.$Uc {
        constructor(c, f, extUri, g, h) {
            super();
            this.c = c;
            this.f = f;
            this.g = g;
            this.h = h;
            this.b = this.B(new event_1.$le());
            this.onDidChange = this.b.event;
            this.a = new $Po(this.c.toString(), h);
            this.B(this.g.watch(extUri.dirname(this.c)));
            // Also listen to the resource incase the resource is a symlink - https://github.com/microsoft/vscode/issues/118134
            this.B(this.g.watch(this.c));
            this.B(event_1.Event.any(event_1.Event.filter(this.g.onDidFilesChange, e => e.contains(this.c)), event_1.Event.filter(this.g.onDidRunOperation, e => (e.isOperation(files_1.FileOperation.CREATE) || e.isOperation(files_1.FileOperation.COPY) || e.isOperation(files_1.FileOperation.DELETE) || e.isOperation(files_1.FileOperation.WRITE)) && extUri.isEqual(e.resource, c)))(() => this.b.fire()));
        }
        async loadConfiguration() {
            try {
                const content = await this.g.readFile(this.c);
                this.a.parse(content.value.toString() || '{}', this.f);
                return this.a.configurationModel;
            }
            catch (e) {
                return $Oo.createEmptyModel(this.h);
            }
        }
        reparse(parseOptions) {
            if (parseOptions) {
                this.f = parseOptions;
            }
            this.a.reparse(this.f);
            return this.a.configurationModel;
        }
        getRestrictedSettings() {
            return this.a.restrictedConfigurations;
        }
    }
    exports.$Qo = $Qo;
    class ConfigurationInspectValue {
        constructor(a, b, c, overrideIdentifiers, d, f, g, h, i, j, k, l, m) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.overrideIdentifiers = overrideIdentifiers;
            this.d = d;
            this.f = f;
            this.g = g;
            this.h = h;
            this.i = i;
            this.j = j;
            this.k = k;
            this.l = l;
            this.m = m;
        }
        get value() {
            return freeze(this.c);
        }
        n(inspectValue) {
            return inspectValue?.value !== undefined || inspectValue?.override !== undefined || inspectValue?.overrides !== undefined ? inspectValue : undefined;
        }
        get q() {
            if (!this.p) {
                this.p = this.d.inspect(this.a, this.b.overrideIdentifier);
            }
            return this.p;
        }
        get defaultValue() {
            return this.q.merged;
        }
        get default() {
            return this.n(this.q);
        }
        get s() {
            if (this.r === undefined) {
                this.r = this.f ? this.f.inspect(this.a) : null;
            }
            return this.r;
        }
        get policyValue() {
            return this.s?.merged;
        }
        get policy() {
            return this.s?.value !== undefined ? { value: this.s.value } : undefined;
        }
        get u() {
            if (this.t === undefined) {
                this.t = this.g ? this.g.inspect(this.a) : null;
            }
            return this.t;
        }
        get applicationValue() {
            return this.u?.merged;
        }
        get application() {
            return this.n(this.u);
        }
        get w() {
            if (!this.v) {
                this.v = this.h.inspect(this.a, this.b.overrideIdentifier);
            }
            return this.v;
        }
        get userValue() {
            return this.w.merged;
        }
        get user() {
            return this.n(this.w);
        }
        get y() {
            if (!this.x) {
                this.x = this.i.inspect(this.a, this.b.overrideIdentifier);
            }
            return this.x;
        }
        get userLocalValue() {
            return this.y.merged;
        }
        get userLocal() {
            return this.n(this.y);
        }
        get A() {
            if (!this.z) {
                this.z = this.j.inspect(this.a, this.b.overrideIdentifier);
            }
            return this.z;
        }
        get userRemoteValue() {
            return this.A.merged;
        }
        get userRemote() {
            return this.n(this.A);
        }
        get D() {
            if (this.B === undefined) {
                this.B = this.k ? this.k.inspect(this.a, this.b.overrideIdentifier) : null;
            }
            return this.B;
        }
        get workspaceValue() {
            return this.D?.merged;
        }
        get workspace() {
            return this.n(this.D);
        }
        get F() {
            if (this.E === undefined) {
                this.E = this.l ? this.l.inspect(this.a, this.b.overrideIdentifier) : null;
            }
            return this.E;
        }
        get workspaceFolderValue() {
            return this.F?.merged;
        }
        get workspaceFolder() {
            return this.n(this.F);
        }
        get H() {
            if (this.G === undefined) {
                this.G = this.m.inspect(this.a, this.b.overrideIdentifier);
            }
            return this.G;
        }
        get memoryValue() {
            return this.H.merged;
        }
        get memory() {
            return this.n(this.H);
        }
    }
    class $Ro {
        constructor(j, l, m, n, p, q, r, s, t, u) {
            this.j = j;
            this.l = l;
            this.m = m;
            this.n = n;
            this.p = p;
            this.q = q;
            this.r = r;
            this.s = s;
            this.t = t;
            this.u = u;
            this.h = null;
            this.i = new map_1.$Ac();
            this.v = null;
        }
        getValue(section, overrides, workspace) {
            const consolidateConfigurationModel = this.w(section, overrides, workspace);
            return consolidateConfigurationModel.getValue(section);
        }
        updateValue(key, value, overrides = {}) {
            let memoryConfiguration;
            if (overrides.resource) {
                memoryConfiguration = this.t.get(overrides.resource);
                if (!memoryConfiguration) {
                    memoryConfiguration = $Oo.createEmptyModel(this.u);
                    this.t.set(overrides.resource, memoryConfiguration);
                }
            }
            else {
                memoryConfiguration = this.s;
            }
            if (value === undefined) {
                memoryConfiguration.removeValue(key);
            }
            else {
                memoryConfiguration.setValue(key, value);
            }
            if (!overrides.resource) {
                this.h = null;
            }
        }
        inspect(key, overrides, workspace) {
            const consolidateConfigurationModel = this.w(key, overrides, workspace);
            const folderConfigurationModel = this.A(overrides.resource, workspace);
            const memoryConfigurationModel = overrides.resource ? this.t.get(overrides.resource) || this.s : this.s;
            const overrideIdentifiers = new Set();
            for (const override of consolidateConfigurationModel.overrides) {
                for (const overrideIdentifier of override.identifiers) {
                    if (consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== undefined) {
                        overrideIdentifiers.add(overrideIdentifier);
                    }
                }
            }
            return new ConfigurationInspectValue(key, overrides, consolidateConfigurationModel.getValue(key), overrideIdentifiers.size ? [...overrideIdentifiers] : undefined, this.j, this.l.isEmpty() ? undefined : this.l, this.applicationConfiguration.isEmpty() ? undefined : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, workspace ? this.q : undefined, folderConfigurationModel ? folderConfigurationModel : undefined, memoryConfigurationModel);
        }
        keys(workspace) {
            const folderConfigurationModel = this.A(undefined, workspace);
            return {
                default: this.j.keys.slice(0),
                user: this.userConfiguration.keys.slice(0),
                workspace: this.q.keys.slice(0),
                workspaceFolder: folderConfigurationModel ? folderConfigurationModel.keys.slice(0) : []
            };
        }
        updateDefaultConfiguration(defaultConfiguration) {
            this.j = defaultConfiguration;
            this.h = null;
            this.i.clear();
        }
        updatePolicyConfiguration(policyConfiguration) {
            this.l = policyConfiguration;
        }
        updateApplicationConfiguration(applicationConfiguration) {
            this.m = applicationConfiguration;
            this.h = null;
            this.i.clear();
        }
        updateLocalUserConfiguration(localUserConfiguration) {
            this.n = localUserConfiguration;
            this.v = null;
            this.h = null;
            this.i.clear();
        }
        updateRemoteUserConfiguration(remoteUserConfiguration) {
            this.p = remoteUserConfiguration;
            this.v = null;
            this.h = null;
            this.i.clear();
        }
        updateWorkspaceConfiguration(workspaceConfiguration) {
            this.q = workspaceConfiguration;
            this.h = null;
            this.i.clear();
        }
        updateFolderConfiguration(resource, configuration) {
            this.r.set(resource, configuration);
            this.i.delete(resource);
        }
        deleteFolderConfiguration(resource) {
            this.folderConfigurations.delete(resource);
            this.i.delete(resource);
        }
        compareAndUpdateDefaultConfiguration(defaults, keys) {
            const overrides = [];
            if (!keys) {
                const { added, updated, removed } = compare(this.j, defaults);
                keys = [...added, ...updated, ...removed];
            }
            for (const key of keys) {
                for (const overrideIdentifier of (0, configurationRegistry_1.$Ho)(key)) {
                    const fromKeys = this.j.getKeysForOverrideIdentifier(overrideIdentifier);
                    const toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);
                    const keys = [
                        ...toKeys.filter(key => fromKeys.indexOf(key) === -1),
                        ...fromKeys.filter(key => toKeys.indexOf(key) === -1),
                        ...fromKeys.filter(key => !objects.$io(this.j.override(overrideIdentifier).getValue(key), defaults.override(overrideIdentifier).getValue(key)))
                    ];
                    overrides.push([overrideIdentifier, keys]);
                }
            }
            this.updateDefaultConfiguration(defaults);
            return { keys, overrides };
        }
        compareAndUpdatePolicyConfiguration(policyConfiguration) {
            const { added, updated, removed } = compare(this.l, policyConfiguration);
            const keys = [...added, ...updated, ...removed];
            if (keys.length) {
                this.updatePolicyConfiguration(policyConfiguration);
            }
            return { keys, overrides: [] };
        }
        compareAndUpdateApplicationConfiguration(application) {
            const { added, updated, removed, overrides } = compare(this.applicationConfiguration, application);
            const keys = [...added, ...updated, ...removed];
            if (keys.length) {
                this.updateApplicationConfiguration(application);
            }
            return { keys, overrides };
        }
        compareAndUpdateLocalUserConfiguration(user) {
            const { added, updated, removed, overrides } = compare(this.localUserConfiguration, user);
            const keys = [...added, ...updated, ...removed];
            if (keys.length) {
                this.updateLocalUserConfiguration(user);
            }
            return { keys, overrides };
        }
        compareAndUpdateRemoteUserConfiguration(user) {
            const { added, updated, removed, overrides } = compare(this.remoteUserConfiguration, user);
            const keys = [...added, ...updated, ...removed];
            if (keys.length) {
                this.updateRemoteUserConfiguration(user);
            }
            return { keys, overrides };
        }
        compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {
            const { added, updated, removed, overrides } = compare(this.workspaceConfiguration, workspaceConfiguration);
            const keys = [...added, ...updated, ...removed];
            if (keys.length) {
                this.updateWorkspaceConfiguration(workspaceConfiguration);
            }
            return { keys, overrides };
        }
        compareAndUpdateFolderConfiguration(resource, folderConfiguration) {
            const currentFolderConfiguration = this.folderConfigurations.get(resource);
            const { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);
            const keys = [...added, ...updated, ...removed];
            if (keys.length || !currentFolderConfiguration) {
                this.updateFolderConfiguration(resource, folderConfiguration);
            }
            return { keys, overrides };
        }
        compareAndDeleteFolderConfiguration(folder) {
            const folderConfig = this.folderConfigurations.get(folder);
            if (!folderConfig) {
                throw new Error('Unknown folder');
            }
            this.deleteFolderConfiguration(folder);
            const { added, updated, removed, overrides } = compare(folderConfig, undefined);
            return { keys: [...added, ...updated, ...removed], overrides };
        }
        get defaults() {
            return this.j;
        }
        get applicationConfiguration() {
            return this.m;
        }
        get userConfiguration() {
            if (!this.v) {
                this.v = this.p.isEmpty() ? this.n : this.n.merge(this.p);
            }
            return this.v;
        }
        get localUserConfiguration() {
            return this.n;
        }
        get remoteUserConfiguration() {
            return this.p;
        }
        get workspaceConfiguration() {
            return this.q;
        }
        get folderConfigurations() {
            return this.r;
        }
        w(section, overrides, workspace) {
            let configurationModel = this.x(overrides, workspace);
            if (overrides.overrideIdentifier) {
                configurationModel = configurationModel.override(overrides.overrideIdentifier);
            }
            if (!this.l.isEmpty() && this.l.getValue(section) !== undefined) {
                configurationModel = configurationModel.merge(this.l);
            }
            return configurationModel;
        }
        x({ resource }, workspace) {
            let consolidateConfiguration = this.y();
            if (workspace && resource) {
                const root = workspace.getFolder(resource);
                if (root) {
                    consolidateConfiguration = this.z(root.uri) || consolidateConfiguration;
                }
                const memoryConfigurationForResource = this.t.get(resource);
                if (memoryConfigurationForResource) {
                    consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
                }
            }
            return consolidateConfiguration;
        }
        y() {
            if (!this.h) {
                this.h = this.j.merge(this.applicationConfiguration, this.userConfiguration, this.q, this.s);
            }
            return this.h;
        }
        z(folder) {
            let folderConsolidatedConfiguration = this.i.get(folder);
            if (!folderConsolidatedConfiguration) {
                const workspaceConsolidateConfiguration = this.y();
                const folderConfiguration = this.r.get(folder);
                if (folderConfiguration) {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
                    this.i.set(folder, folderConsolidatedConfiguration);
                }
                else {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
                }
            }
            return folderConsolidatedConfiguration;
        }
        A(resource, workspace) {
            if (workspace && resource) {
                const root = workspace.getFolder(resource);
                if (root) {
                    return this.r.get(root.uri);
                }
            }
            return undefined;
        }
        toData() {
            return {
                defaults: {
                    contents: this.j.contents,
                    overrides: this.j.overrides,
                    keys: this.j.keys
                },
                policy: {
                    contents: this.l.contents,
                    overrides: this.l.overrides,
                    keys: this.l.keys
                },
                application: {
                    contents: this.applicationConfiguration.contents,
                    overrides: this.applicationConfiguration.overrides,
                    keys: this.applicationConfiguration.keys
                },
                user: {
                    contents: this.userConfiguration.contents,
                    overrides: this.userConfiguration.overrides,
                    keys: this.userConfiguration.keys
                },
                workspace: {
                    contents: this.q.contents,
                    overrides: this.q.overrides,
                    keys: this.q.keys
                },
                folders: [...this.r.keys()].reduce((result, folder) => {
                    const { contents, overrides, keys } = this.r.get(folder);
                    result.push([folder, { contents, overrides, keys }]);
                    return result;
                }, [])
            };
        }
        allKeys() {
            const keys = new Set();
            this.j.keys.forEach(key => keys.add(key));
            this.userConfiguration.keys.forEach(key => keys.add(key));
            this.q.keys.forEach(key => keys.add(key));
            this.r.forEach(folderConfiguration => folderConfiguration.keys.forEach(key => keys.add(key)));
            return [...keys.values()];
        }
        B() {
            const keys = new Set();
            this.j.getAllOverrideIdentifiers().forEach(key => keys.add(key));
            this.userConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key));
            this.q.getAllOverrideIdentifiers().forEach(key => keys.add(key));
            this.r.forEach(folderConfiguration => folderConfiguration.getAllOverrideIdentifiers().forEach(key => keys.add(key)));
            return [...keys.values()];
        }
        D(overrideIdentifier) {
            const keys = new Set();
            this.j.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
            this.userConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
            this.q.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key));
            this.r.forEach(folderConfiguration => folderConfiguration.getKeysForOverrideIdentifier(overrideIdentifier).forEach(key => keys.add(key)));
            return [...keys.values()];
        }
        static parse(data, logService) {
            const defaultConfiguration = this.E(data.defaults, logService);
            const policyConfiguration = this.E(data.policy, logService);
            const applicationConfiguration = this.E(data.application, logService);
            const userConfiguration = this.E(data.user, logService);
            const workspaceConfiguration = this.E(data.workspace, logService);
            const folders = data.folders.reduce((result, value) => {
                result.set(uri_1.URI.revive(value[0]), this.E(value[1], logService));
                return result;
            }, new map_1.$Ac());
            return new $Ro(defaultConfiguration, policyConfiguration, applicationConfiguration, userConfiguration, $Oo.createEmptyModel(logService), workspaceConfiguration, folders, $Oo.createEmptyModel(logService), new map_1.$Ac(), logService);
        }
        static E(model, logService) {
            return new $Oo(model.contents, model.keys, model.overrides, undefined, logService);
        }
    }
    exports.$Ro = $Ro;
    function $So(...changes) {
        if (changes.length === 0) {
            return { keys: [], overrides: [] };
        }
        if (changes.length === 1) {
            return changes[0];
        }
        const keysSet = new Set();
        const overridesMap = new Map();
        for (const change of changes) {
            change.keys.forEach(key => keysSet.add(key));
            change.overrides.forEach(([identifier, keys]) => {
                const result = (0, map_1.$xc)(overridesMap, identifier, new Set());
                keys.forEach(key => result.add(key));
            });
        }
        const overrides = [];
        overridesMap.forEach((keys, identifier) => overrides.push([identifier, [...keys.values()]]));
        return { keys: [...keysSet.values()], overrides };
    }
    class $To {
        constructor(change, f, g, h, i) {
            this.change = change;
            this.f = f;
            this.g = g;
            this.h = h;
            this.i = i;
            this.a = '\n';
            this.b = this.a.charCodeAt(0);
            this.c = '.'.charCodeAt(0);
            this.affectedKeys = new Set();
            this.j = undefined;
            for (const key of change.keys) {
                this.affectedKeys.add(key);
            }
            for (const [, keys] of change.overrides) {
                for (const key of keys) {
                    this.affectedKeys.add(key);
                }
            }
            // Example: '\nfoo.bar\nabc.def\n'
            this.d = this.a;
            for (const key of this.affectedKeys) {
                this.d += key + this.a;
            }
        }
        get previousConfiguration() {
            if (!this.j && this.f) {
                this.j = $Ro.parse(this.f.data, this.i);
            }
            return this.j;
        }
        affectsConfiguration(section, overrides) {
            // we have one large string with all keys that have changed. we pad (marker) the section
            // and check that either find it padded or before a segment character
            const needle = this.a + section;
            const idx = this.d.indexOf(needle);
            if (idx < 0) {
                // NOT: (marker + section)
                return false;
            }
            const pos = idx + needle.length;
            if (pos >= this.d.length) {
                return false;
            }
            const code = this.d.charCodeAt(pos);
            if (code !== this.b && code !== this.c) {
                // NOT: section + (marker | segment)
                return false;
            }
            if (overrides) {
                const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section, overrides, this.f?.workspace) : undefined;
                const value2 = this.g.getValue(section, overrides, this.h);
                return !objects.$io(value1, value2);
            }
            return true;
        }
    }
    exports.$To = $To;
    function compare(from, to) {
        const { added, removed, updated } = compareConfigurationContents(to?.rawConfiguration, from?.rawConfiguration);
        const overrides = [];
        const fromOverrideIdentifiers = from?.getAllOverrideIdentifiers() || [];
        const toOverrideIdentifiers = to?.getAllOverrideIdentifiers() || [];
        if (to) {
            const addedOverrideIdentifiers = toOverrideIdentifiers.filter(key => !fromOverrideIdentifiers.includes(key));
            for (const identifier of addedOverrideIdentifiers) {
                overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);
            }
        }
        if (from) {
            const removedOverrideIdentifiers = fromOverrideIdentifiers.filter(key => !toOverrideIdentifiers.includes(key));
            for (const identifier of removedOverrideIdentifiers) {
                overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);
            }
        }
        if (to && from) {
            for (const identifier of fromOverrideIdentifiers) {
                if (toOverrideIdentifiers.includes(identifier)) {
                    const result = compareConfigurationContents({ contents: from.getOverrideValue(undefined, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(undefined, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });
                    overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);
                }
            }
        }
        return { added, removed, updated, overrides };
    }
    function compareConfigurationContents(to, from) {
        const added = to
            ? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]
            : [];
        const removed = from
            ? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]
            : [];
        const updated = [];
        if (to && from) {
            for (const key of from.keys) {
                if (to.keys.indexOf(key) !== -1) {
                    const value1 = (0, configuration_1.$hj)(from.contents, key);
                    const value2 = (0, configuration_1.$hj)(to.contents, key);
                    if (!objects.$io(value1, value2)) {
                        updated.push(key);
                    }
                }
            }
        }
        return { added, removed, updated };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[109/*vs/platform/remote/common/remoteAuthorityResolver*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, errors_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ul = exports.RemoteAuthorityResolverErrorCode = exports.$Tl = exports.$Sl = exports.RemoteConnectionType = exports.$Rl = void 0;
    exports.$Vl = $Vl;
    exports.$Rl = (0, instantiation_1.$Fi)('remoteAuthorityResolverService');
    var RemoteConnectionType;
    (function (RemoteConnectionType) {
        RemoteConnectionType[RemoteConnectionType["WebSocket"] = 0] = "WebSocket";
        RemoteConnectionType[RemoteConnectionType["Managed"] = 1] = "Managed";
    })(RemoteConnectionType || (exports.RemoteConnectionType = RemoteConnectionType = {}));
    class $Sl {
        constructor(id) {
            this.id = id;
            this.type = RemoteConnectionType.Managed;
        }
        toString() {
            return `Managed(${this.id})`;
        }
    }
    exports.$Sl = $Sl;
    class $Tl {
        constructor(host, port) {
            this.host = host;
            this.port = port;
            this.type = RemoteConnectionType.WebSocket;
        }
        toString() {
            return `WebSocket(${this.host}:${this.port})`;
        }
    }
    exports.$Tl = $Tl;
    var RemoteAuthorityResolverErrorCode;
    (function (RemoteAuthorityResolverErrorCode) {
        RemoteAuthorityResolverErrorCode["Unknown"] = "Unknown";
        RemoteAuthorityResolverErrorCode["NotAvailable"] = "NotAvailable";
        RemoteAuthorityResolverErrorCode["TemporarilyNotAvailable"] = "TemporarilyNotAvailable";
        RemoteAuthorityResolverErrorCode["NoResolverFound"] = "NoResolverFound";
        RemoteAuthorityResolverErrorCode["InvalidAuthority"] = "InvalidAuthority";
    })(RemoteAuthorityResolverErrorCode || (exports.RemoteAuthorityResolverErrorCode = RemoteAuthorityResolverErrorCode = {}));
    class $Ul extends errors_1.$ab {
        static isNotAvailable(err) {
            return (err instanceof $Ul) && err._code === RemoteAuthorityResolverErrorCode.NotAvailable;
        }
        static isTemporarilyNotAvailable(err) {
            return (err instanceof $Ul) && err._code === RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable;
        }
        static isNoResolverFound(err) {
            return (err instanceof $Ul) && err._code === RemoteAuthorityResolverErrorCode.NoResolverFound;
        }
        static isInvalidAuthority(err) {
            return (err instanceof $Ul) && err._code === RemoteAuthorityResolverErrorCode.InvalidAuthority;
        }
        static isHandled(err) {
            return (err instanceof $Ul) && err.isHandled;
        }
        constructor(message, code = RemoteAuthorityResolverErrorCode.Unknown, detail) {
            super(message);
            this._message = message;
            this._code = code;
            this._detail = detail;
            this.isHandled = (code === RemoteAuthorityResolverErrorCode.NotAvailable) && detail === true;
            // workaround when extending builtin objects and when compiling to ES5, see:
            // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
            Object.setPrototypeOf(this, $Ul.prototype);
        }
    }
    exports.$Ul = $Ul;
    function $Vl(remoteAuthority) {
        const plusIndex = remoteAuthority.indexOf('+');
        if (plusIndex === -1) {
            return remoteAuthority;
        }
        return remoteAuthority.substring(0, plusIndex);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[62/*vs/platform/remote/common/remoteHosts*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/network*/]), function (require, exports, network_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$hn = $hn;
    exports.$in = $in;
    exports.$jn = $jn;
    exports.$kn = $kn;
    function $hn(uri) {
        return uri.scheme === network_1.Schemas.vscodeRemote ? uri.authority : undefined;
    }
    function $in(authority) {
        if (!authority) {
            return undefined;
        }
        const pos = authority.indexOf('+');
        if (pos < 0) {
            // e.g. localhost:8000
            return authority;
        }
        return authority.substr(0, pos);
    }
    function $jn(authority) {
        const { host, port } = parseAuthority(authority);
        if (typeof port === 'undefined') {
            throw new Error(`Invalid remote authority: ${authority}. It must either be a remote of form <remoteName>+<arg> or a remote host of form <host>:<port>.`);
        }
        return { host, port };
    }
    function $kn(authority, defaultPort) {
        let { host, port } = parseAuthority(authority);
        if (typeof port === 'undefined') {
            port = defaultPort;
        }
        return { host, port };
    }
    function parseAuthority(authority) {
        // check for ipv6 with port
        const m1 = authority.match(/^(\[[0-9a-z:]+\]):(\d+)$/);
        if (m1) {
            return { host: m1[1], port: parseInt(m1[2], 10) };
        }
        // check for ipv6 without port
        const m2 = authority.match(/^(\[[0-9a-z:]+\])$/);
        if (m2) {
            return { host: m2[1], port: undefined };
        }
        // anything with a trailing port
        const m3 = authority.match(/(.*):(\d+)$/);
        if (m3) {
            return { host: m3[1], port: parseInt(m3[2], 10) };
        }
        // doesn't contain a port
        return { host: authority, port: undefined };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[18/*vs/platform/extensions/common/extensions*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/strings*/,3/*vs/platform/instantiation/common/instantiation*/,62/*vs/platform/remote/common/remoteHosts*/]), function (require, exports, strings, instantiation_1, remoteHosts_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$An = exports.$tn = exports.$sn = exports.$rn = exports.TargetPlatform = exports.ExtensionType = exports.$qn = exports.$on = exports.$nn = exports.$mn = exports.$ln = void 0;
    exports.$pn = $pn;
    exports.$un = $un;
    exports.$vn = $vn;
    exports.$wn = $wn;
    exports.$xn = $xn;
    exports.$yn = $yn;
    exports.$zn = $zn;
    strings = __importStar(strings);
    exports.$ln = 'extensions.user.cache';
    exports.$mn = 'extensions.builtin.cache';
    exports.$nn = 'undefined_publisher';
    exports.$on = ['ui', 'workspace', 'web'];
    function $pn(supportType) {
        if (typeof supportType === 'object' && supportType !== null) {
            if (supportType.supported !== true) {
                return supportType.description;
            }
        }
        return undefined;
    }
    exports.$qn = [
        'AI',
        'Azure',
        'Chat',
        'Data Science',
        'Debuggers',
        'Extension Packs',
        'Education',
        'Formatters',
        'Keymaps',
        'Language Packs',
        'Linters',
        'Machine Learning',
        'Notebooks',
        'Programming Languages',
        'SCM Providers',
        'Snippets',
        'Testing',
        'Themes',
        'Visualization',
        'Other',
    ];
    var ExtensionType;
    (function (ExtensionType) {
        ExtensionType[ExtensionType["System"] = 0] = "System";
        ExtensionType[ExtensionType["User"] = 1] = "User";
    })(ExtensionType || (exports.ExtensionType = ExtensionType = {}));
    var TargetPlatform;
    (function (TargetPlatform) {
        TargetPlatform["WIN32_X64"] = "win32-x64";
        TargetPlatform["WIN32_ARM64"] = "win32-arm64";
        TargetPlatform["LINUX_X64"] = "linux-x64";
        TargetPlatform["LINUX_ARM64"] = "linux-arm64";
        TargetPlatform["LINUX_ARMHF"] = "linux-armhf";
        TargetPlatform["ALPINE_X64"] = "alpine-x64";
        TargetPlatform["ALPINE_ARM64"] = "alpine-arm64";
        TargetPlatform["DARWIN_X64"] = "darwin-x64";
        TargetPlatform["DARWIN_ARM64"] = "darwin-arm64";
        TargetPlatform["WEB"] = "web";
        TargetPlatform["UNIVERSAL"] = "universal";
        TargetPlatform["UNKNOWN"] = "unknown";
        TargetPlatform["UNDEFINED"] = "undefined";
    })(TargetPlatform || (exports.TargetPlatform = TargetPlatform = {}));
    /**
     * **!Do not construct directly!**
     *
     * **!Only static methods because it gets serialized!**
     *
     * This represents the "canonical" version for an extension identifier. Extension ids
     * have to be case-insensitive (due to the marketplace), but we must ensure case
     * preservation because the extension API is already public at this time.
     *
     * For example, given an extension with the publisher `"Hello"` and the name `"World"`,
     * its canonical extension identifier is `"Hello.World"`. This extension could be
     * referenced in some other extension's dependencies using the string `"hello.world"`.
     *
     * To make matters more complicated, an extension can optionally have an UUID. When two
     * extensions have the same UUID, they are considered equal even if their identifier is different.
     */
    class $rn {
        constructor(value) {
            this.value = value;
            this._lower = value.toLowerCase();
        }
        static equals(a, b) {
            if (typeof a === 'undefined' || a === null) {
                return (typeof b === 'undefined' || b === null);
            }
            if (typeof b === 'undefined' || b === null) {
                return false;
            }
            if (typeof a === 'string' || typeof b === 'string') {
                // At least one of the arguments is an extension id in string form,
                // so we have to use the string comparison which ignores case.
                const aValue = (typeof a === 'string' ? a : a.value);
                const bValue = (typeof b === 'string' ? b : b.value);
                return strings.$Ff(aValue, bValue);
            }
            // Now we know both arguments are ExtensionIdentifier
            return (a._lower === b._lower);
        }
        /**
         * Gives the value by which to index (for equality).
         */
        static toKey(id) {
            if (typeof id === 'string') {
                return id.toLowerCase();
            }
            return id._lower;
        }
    }
    exports.$rn = $rn;
    class $sn {
        get size() {
            return this.c.size;
        }
        constructor(iterable) {
            this.c = new Set();
            if (iterable) {
                for (const value of iterable) {
                    this.add(value);
                }
            }
        }
        add(id) {
            this.c.add($rn.toKey(id));
        }
        delete(extensionId) {
            return this.c.delete($rn.toKey(extensionId));
        }
        has(id) {
            return this.c.has($rn.toKey(id));
        }
    }
    exports.$sn = $sn;
    class $tn {
        constructor() {
            this.c = new Map();
        }
        clear() {
            this.c.clear();
        }
        delete(id) {
            this.c.delete($rn.toKey(id));
        }
        get(id) {
            return this.c.get($rn.toKey(id));
        }
        has(id) {
            return this.c.has($rn.toKey(id));
        }
        set(id, value) {
            this.c.set($rn.toKey(id), value);
        }
        values() {
            return this.c.values();
        }
        forEach(callbackfn) {
            this.c.forEach(callbackfn);
        }
        [Symbol.iterator]() {
            return this.c[Symbol.iterator]();
        }
    }
    exports.$tn = $tn;
    function $un(manifest) {
        return $vn(manifest);
    }
    function $vn(manifest) {
        return manifest.contributes && manifest.contributes.localizations ? manifest.contributes.localizations.length > 0 : false;
    }
    function $wn(manifest) {
        return manifest.contributes && manifest.contributes.authentication ? manifest.contributes.authentication.length > 0 : false;
    }
    function $xn(manifest, remoteAuthority) {
        if (remoteAuthority) {
            const activationEvent = `onResolveRemoteAuthority:${(0, remoteHosts_1.$in)(remoteAuthority)}`;
            return !!manifest.activationEvents?.includes(activationEvent);
        }
        return false;
    }
    function $yn(enabledApiProposals) {
        return enabledApiProposals.map(proposal => {
            const [proposalName, version] = proposal.split('@');
            return { proposalName, version: version ? parseInt(version) : undefined };
        });
    }
    function $zn(enabledApiProposals) {
        return enabledApiProposals.map(proposal => proposal.split('@')[0]);
    }
    exports.$An = (0, instantiation_1.$Fi)('IBuiltinExtensionsScannerService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[110/*vs/platform/extensionManagement/common/extensionManagement*/], __M([1/*require*/,0/*exports*/,20/*vs/base/common/platform*/,9/*vs/nls*/,18/*vs/platform/extensions/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, platform_1, nls_1, extensions_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$up = exports.$tp = exports.$sp = exports.$rp = exports.$qp = exports.$pp = exports.$op = exports.$np = exports.ExtensionManagementErrorCode = exports.$mp = exports.ExtensionGalleryErrorCode = exports.$lp = exports.InstallOperation = exports.StatisticType = exports.SortOrder = exports.SortBy = exports.ExtensionInstallSource = exports.$ep = exports.$dp = exports.$cp = exports.$bp = exports.$ap = exports.$_o = exports.$$o = void 0;
    exports.$fp = $fp;
    exports.$gp = $gp;
    exports.$hp = $hp;
    exports.$ip = $ip;
    exports.$jp = $jp;
    exports.$kp = $kp;
    exports.$$o = '^([a-z0-9A-Z][a-z0-9-A-Z]*)\\.([a-z0-9A-Z][a-z0-9-A-Z]*)$';
    exports.$_o = new RegExp(exports.$$o);
    exports.$ap = '__web_extension';
    exports.$bp = 'skipWalkthrough';
    exports.$cp = 'extensionInstallSource';
    exports.$dp = 'dependecyOrPackExtensionInstall';
    exports.$ep = 'clientTargetPlatform';
    var ExtensionInstallSource;
    (function (ExtensionInstallSource) {
        ExtensionInstallSource["COMMAND"] = "command";
        ExtensionInstallSource["SETTINGS_SYNC"] = "settingsSync";
    })(ExtensionInstallSource || (exports.ExtensionInstallSource = ExtensionInstallSource = {}));
    function $fp(targetPlatform) {
        switch (targetPlatform) {
            case extensions_1.TargetPlatform.WIN32_X64: return 'Windows 64 bit';
            case extensions_1.TargetPlatform.WIN32_ARM64: return 'Windows ARM';
            case extensions_1.TargetPlatform.LINUX_X64: return 'Linux 64 bit';
            case extensions_1.TargetPlatform.LINUX_ARM64: return 'Linux ARM 64';
            case extensions_1.TargetPlatform.LINUX_ARMHF: return 'Linux ARM';
            case extensions_1.TargetPlatform.ALPINE_X64: return 'Alpine Linux 64 bit';
            case extensions_1.TargetPlatform.ALPINE_ARM64: return 'Alpine ARM 64';
            case extensions_1.TargetPlatform.DARWIN_X64: return 'Mac';
            case extensions_1.TargetPlatform.DARWIN_ARM64: return 'Mac Silicon';
            case extensions_1.TargetPlatform.WEB: return 'Web';
            case extensions_1.TargetPlatform.UNIVERSAL: return extensions_1.TargetPlatform.UNIVERSAL;
            case extensions_1.TargetPlatform.UNKNOWN: return extensions_1.TargetPlatform.UNKNOWN;
            case extensions_1.TargetPlatform.UNDEFINED: return extensions_1.TargetPlatform.UNDEFINED;
        }
    }
    function $gp(targetPlatform) {
        switch (targetPlatform) {
            case extensions_1.TargetPlatform.WIN32_X64: return extensions_1.TargetPlatform.WIN32_X64;
            case extensions_1.TargetPlatform.WIN32_ARM64: return extensions_1.TargetPlatform.WIN32_ARM64;
            case extensions_1.TargetPlatform.LINUX_X64: return extensions_1.TargetPlatform.LINUX_X64;
            case extensions_1.TargetPlatform.LINUX_ARM64: return extensions_1.TargetPlatform.LINUX_ARM64;
            case extensions_1.TargetPlatform.LINUX_ARMHF: return extensions_1.TargetPlatform.LINUX_ARMHF;
            case extensions_1.TargetPlatform.ALPINE_X64: return extensions_1.TargetPlatform.ALPINE_X64;
            case extensions_1.TargetPlatform.ALPINE_ARM64: return extensions_1.TargetPlatform.ALPINE_ARM64;
            case extensions_1.TargetPlatform.DARWIN_X64: return extensions_1.TargetPlatform.DARWIN_X64;
            case extensions_1.TargetPlatform.DARWIN_ARM64: return extensions_1.TargetPlatform.DARWIN_ARM64;
            case extensions_1.TargetPlatform.WEB: return extensions_1.TargetPlatform.WEB;
            case extensions_1.TargetPlatform.UNIVERSAL: return extensions_1.TargetPlatform.UNIVERSAL;
            default: return extensions_1.TargetPlatform.UNKNOWN;
        }
    }
    function $hp(platform, arch) {
        switch (platform) {
            case platform_1.Platform.Windows:
                if (arch === 'x64') {
                    return extensions_1.TargetPlatform.WIN32_X64;
                }
                if (arch === 'arm64') {
                    return extensions_1.TargetPlatform.WIN32_ARM64;
                }
                return extensions_1.TargetPlatform.UNKNOWN;
            case platform_1.Platform.Linux:
                if (arch === 'x64') {
                    return extensions_1.TargetPlatform.LINUX_X64;
                }
                if (arch === 'arm64') {
                    return extensions_1.TargetPlatform.LINUX_ARM64;
                }
                if (arch === 'arm') {
                    return extensions_1.TargetPlatform.LINUX_ARMHF;
                }
                return extensions_1.TargetPlatform.UNKNOWN;
            case 'alpine':
                if (arch === 'x64') {
                    return extensions_1.TargetPlatform.ALPINE_X64;
                }
                if (arch === 'arm64') {
                    return extensions_1.TargetPlatform.ALPINE_ARM64;
                }
                return extensions_1.TargetPlatform.UNKNOWN;
            case platform_1.Platform.Mac:
                if (arch === 'x64') {
                    return extensions_1.TargetPlatform.DARWIN_X64;
                }
                if (arch === 'arm64') {
                    return extensions_1.TargetPlatform.DARWIN_ARM64;
                }
                return extensions_1.TargetPlatform.UNKNOWN;
            case platform_1.Platform.Web: return extensions_1.TargetPlatform.WEB;
        }
    }
    function $ip(allTargetPlatforms, productTargetPlatform) {
        // Not a web extension in web target platform
        return productTargetPlatform === extensions_1.TargetPlatform.WEB && !allTargetPlatforms.includes(extensions_1.TargetPlatform.WEB);
    }
    function $jp(extensionTargetPlatform, allTargetPlatforms, productTargetPlatform) {
        // Not compatible when extension is not a web extension in web target platform
        if ($ip(allTargetPlatforms, productTargetPlatform)) {
            return false;
        }
        // Compatible when extension target platform is not defined
        if (extensionTargetPlatform === extensions_1.TargetPlatform.UNDEFINED) {
            return true;
        }
        // Compatible when extension target platform is universal
        if (extensionTargetPlatform === extensions_1.TargetPlatform.UNIVERSAL) {
            return true;
        }
        // Not compatible when extension target platform is unknown
        if (extensionTargetPlatform === extensions_1.TargetPlatform.UNKNOWN) {
            return false;
        }
        // Compatible when extension and product target platforms matches
        if (extensionTargetPlatform === productTargetPlatform) {
            return true;
        }
        return false;
    }
    function $kp(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.id === 'string'
            && (!thing.uuid || typeof thing.uuid === 'string');
    }
    var SortBy;
    (function (SortBy) {
        SortBy[SortBy["NoneOrRelevance"] = 0] = "NoneOrRelevance";
        SortBy[SortBy["LastUpdatedDate"] = 1] = "LastUpdatedDate";
        SortBy[SortBy["Title"] = 2] = "Title";
        SortBy[SortBy["PublisherName"] = 3] = "PublisherName";
        SortBy[SortBy["InstallCount"] = 4] = "InstallCount";
        SortBy[SortBy["PublishedDate"] = 10] = "PublishedDate";
        SortBy[SortBy["AverageRating"] = 6] = "AverageRating";
        SortBy[SortBy["WeightedRating"] = 12] = "WeightedRating";
    })(SortBy || (exports.SortBy = SortBy = {}));
    var SortOrder;
    (function (SortOrder) {
        SortOrder[SortOrder["Default"] = 0] = "Default";
        SortOrder[SortOrder["Ascending"] = 1] = "Ascending";
        SortOrder[SortOrder["Descending"] = 2] = "Descending";
    })(SortOrder || (exports.SortOrder = SortOrder = {}));
    var StatisticType;
    (function (StatisticType) {
        StatisticType["Install"] = "install";
        StatisticType["Uninstall"] = "uninstall";
    })(StatisticType || (exports.StatisticType = StatisticType = {}));
    var InstallOperation;
    (function (InstallOperation) {
        InstallOperation[InstallOperation["None"] = 1] = "None";
        InstallOperation[InstallOperation["Install"] = 2] = "Install";
        InstallOperation[InstallOperation["Update"] = 3] = "Update";
        InstallOperation[InstallOperation["Migrate"] = 4] = "Migrate";
    })(InstallOperation || (exports.InstallOperation = InstallOperation = {}));
    exports.$lp = (0, instantiation_1.$Fi)('extensionGalleryService');
    var ExtensionGalleryErrorCode;
    (function (ExtensionGalleryErrorCode) {
        ExtensionGalleryErrorCode["Timeout"] = "Timeout";
        ExtensionGalleryErrorCode["Cancelled"] = "Cancelled";
        ExtensionGalleryErrorCode["Failed"] = "Failed";
        ExtensionGalleryErrorCode["DownloadFailedWriting"] = "DownloadFailedWriting";
    })(ExtensionGalleryErrorCode || (exports.ExtensionGalleryErrorCode = ExtensionGalleryErrorCode = {}));
    class $mp extends Error {
        constructor(message, code) {
            super(message);
            this.code = code;
            this.name = code;
        }
    }
    exports.$mp = $mp;
    var ExtensionManagementErrorCode;
    (function (ExtensionManagementErrorCode) {
        ExtensionManagementErrorCode["Unsupported"] = "Unsupported";
        ExtensionManagementErrorCode["Deprecated"] = "Deprecated";
        ExtensionManagementErrorCode["Malicious"] = "Malicious";
        ExtensionManagementErrorCode["Incompatible"] = "Incompatible";
        ExtensionManagementErrorCode["IncompatibleApi"] = "IncompatibleApi";
        ExtensionManagementErrorCode["IncompatibleTargetPlatform"] = "IncompatibleTargetPlatform";
        ExtensionManagementErrorCode["ReleaseVersionNotFound"] = "ReleaseVersionNotFound";
        ExtensionManagementErrorCode["Invalid"] = "Invalid";
        ExtensionManagementErrorCode["Download"] = "Download";
        ExtensionManagementErrorCode["DownloadSignature"] = "DownloadSignature";
        ExtensionManagementErrorCode["DownloadFailedWriting"] = "DownloadFailedWriting";
        ExtensionManagementErrorCode["UpdateMetadata"] = "UpdateMetadata";
        ExtensionManagementErrorCode["Extract"] = "Extract";
        ExtensionManagementErrorCode["Scanning"] = "Scanning";
        ExtensionManagementErrorCode["ScanningExtension"] = "ScanningExtension";
        ExtensionManagementErrorCode["ReadUninstalled"] = "ReadUninstalled";
        ExtensionManagementErrorCode["UnsetUninstalled"] = "UnsetUninstalled";
        ExtensionManagementErrorCode["Delete"] = "Delete";
        ExtensionManagementErrorCode["Rename"] = "Rename";
        ExtensionManagementErrorCode["IntializeDefaultProfile"] = "IntializeDefaultProfile";
        ExtensionManagementErrorCode["AddToProfile"] = "AddToProfile";
        ExtensionManagementErrorCode["InstalledExtensionNotFound"] = "InstalledExtensionNotFound";
        ExtensionManagementErrorCode["PostInstall"] = "PostInstall";
        ExtensionManagementErrorCode["CorruptZip"] = "CorruptZip";
        ExtensionManagementErrorCode["IncompleteZip"] = "IncompleteZip";
        ExtensionManagementErrorCode["Signature"] = "Signature";
        ExtensionManagementErrorCode["NotAllowed"] = "NotAllowed";
        ExtensionManagementErrorCode["Gallery"] = "Gallery";
        ExtensionManagementErrorCode["Cancelled"] = "Cancelled";
        ExtensionManagementErrorCode["Unknown"] = "Unknown";
        ExtensionManagementErrorCode["Internal"] = "Internal";
    })(ExtensionManagementErrorCode || (exports.ExtensionManagementErrorCode = ExtensionManagementErrorCode = {}));
    class $np extends Error {
        constructor(message, code) {
            super(message);
            this.code = code;
            this.name = code;
        }
    }
    exports.$np = $np;
    exports.$op = (0, instantiation_1.$Fi)('extensionManagementService');
    exports.$pp = 'extensionsIdentifiers/disabled';
    exports.$qp = 'extensionsIdentifiers/enabled';
    exports.$rp = (0, instantiation_1.$Fi)('IGlobalExtensionEnablementService');
    exports.$sp = (0, instantiation_1.$Fi)('IExtensionTipsService');
    exports.$tp = (0, nls_1.localize2)(10971, "Extensions");
    exports.$up = (0, nls_1.localize2)(10972, 'Preferences');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[111/*vs/platform/extensionManagement/common/implicitActivationEvents*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,18/*vs/platform/extensions/common/extensions*/]), function (require, exports, errors_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$YG = exports.$XG = void 0;
    class $XG {
        constructor() {
            this.a = new Map();
            this.b = new WeakMap();
        }
        register(extensionPointName, generator) {
            this.a.set(extensionPointName, generator);
        }
        /**
         * This can run correctly only on the renderer process because that is the only place
         * where all extension points and all implicit activation events generators are known.
         */
        readActivationEvents(extensionDescription) {
            if (!this.b.has(extensionDescription)) {
                this.b.set(extensionDescription, this.c(extensionDescription));
            }
            return this.b.get(extensionDescription);
        }
        /**
         * This can run correctly only on the renderer process because that is the only place
         * where all extension points and all implicit activation events generators are known.
         */
        createActivationEventsMap(extensionDescriptions) {
            const result = Object.create(null);
            for (const extensionDescription of extensionDescriptions) {
                const activationEvents = this.readActivationEvents(extensionDescription);
                if (activationEvents.length > 0) {
                    result[extensions_1.$rn.toKey(extensionDescription.identifier)] = activationEvents;
                }
            }
            return result;
        }
        c(desc) {
            if (typeof desc.main === 'undefined' && typeof desc.browser === 'undefined') {
                return [];
            }
            const activationEvents = (Array.isArray(desc.activationEvents) ? desc.activationEvents.slice(0) : []);
            for (let i = 0; i < activationEvents.length; i++) {
                // TODO@joao: there's no easy way to contribute this
                if (activationEvents[i] === 'onUri') {
                    activationEvents[i] = `onUri:${extensions_1.$rn.toKey(desc.identifier)}`;
                }
            }
            if (!desc.contributes) {
                // no implicit activation events
                return activationEvents;
            }
            for (const extPointName in desc.contributes) {
                const generator = this.a.get(extPointName);
                if (!generator) {
                    // There's no generator for this extension point
                    continue;
                }
                const contrib = desc.contributes[extPointName];
                const contribArr = Array.isArray(contrib) ? contrib : [contrib];
                try {
                    generator(contribArr, activationEvents);
                }
                catch (err) {
                    (0, errors_1.$Y)(err);
                }
            }
            return activationEvents;
        }
    }
    exports.$XG = $XG;
    exports.$YG = new $XG();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[175/*vs/platform/extensions/common/extensionValidator*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/resources*/,35/*vs/base/common/severity*/,9/*vs/nls*/,281/*vs/base/common/semver/semver*/,18/*vs/platform/extensions/common/extensions*/,104/*vs/platform/extensions/common/extensionsApiProposals*/]), function (require, exports, resources_1, severity_1, nls, semver, extensions_1, extensionsApiProposals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Zp = $Zp;
    exports.$1p = $1p;
    exports.$2p = $2p;
    exports.$3p = $3p;
    exports.$4p = $4p;
    exports.$5p = $5p;
    exports.$6p = $6p;
    exports.$7p = $7p;
    severity_1 = __importDefault(severity_1);
    nls = __importStar(nls);
    semver = __importStar(semver);
    const VERSION_REGEXP = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/;
    const NOT_BEFORE_REGEXP = /^-(\d{4})(\d{2})(\d{2})$/;
    function $Zp(version) {
        version = version.trim();
        return (version === '*' || VERSION_REGEXP.test(version));
    }
    function $1p(version) {
        if (!$Zp(version)) {
            return null;
        }
        version = version.trim();
        if (version === '*') {
            return {
                hasCaret: false,
                hasGreaterEquals: false,
                majorBase: 0,
                majorMustEqual: false,
                minorBase: 0,
                minorMustEqual: false,
                patchBase: 0,
                patchMustEqual: false,
                preRelease: null
            };
        }
        const m = version.match(VERSION_REGEXP);
        if (!m) {
            return null;
        }
        return {
            hasCaret: m[1] === '^',
            hasGreaterEquals: m[1] === '>=',
            majorBase: m[2] === 'x' ? 0 : parseInt(m[2], 10),
            majorMustEqual: (m[2] === 'x' ? false : true),
            minorBase: m[4] === 'x' ? 0 : parseInt(m[4], 10),
            minorMustEqual: (m[4] === 'x' ? false : true),
            patchBase: m[6] === 'x' ? 0 : parseInt(m[6], 10),
            patchMustEqual: (m[6] === 'x' ? false : true),
            preRelease: m[8] || null
        };
    }
    function $2p(version) {
        if (!version) {
            return null;
        }
        const majorBase = version.majorBase;
        const majorMustEqual = version.majorMustEqual;
        const minorBase = version.minorBase;
        let minorMustEqual = version.minorMustEqual;
        const patchBase = version.patchBase;
        let patchMustEqual = version.patchMustEqual;
        if (version.hasCaret) {
            if (majorBase === 0) {
                patchMustEqual = false;
            }
            else {
                minorMustEqual = false;
                patchMustEqual = false;
            }
        }
        let notBefore = 0;
        if (version.preRelease) {
            const match = NOT_BEFORE_REGEXP.exec(version.preRelease);
            if (match) {
                const [, year, month, day] = match;
                notBefore = Date.UTC(Number(year), Number(month) - 1, Number(day));
            }
        }
        return {
            majorBase: majorBase,
            majorMustEqual: majorMustEqual,
            minorBase: minorBase,
            minorMustEqual: minorMustEqual,
            patchBase: patchBase,
            patchMustEqual: patchMustEqual,
            isMinimum: version.hasGreaterEquals,
            notBefore,
        };
    }
    function $3p(_inputVersion, _inputDate, _desiredVersion) {
        let version;
        if (typeof _inputVersion === 'string') {
            version = $2p($1p(_inputVersion));
        }
        else {
            version = _inputVersion;
        }
        let productTs;
        if (_inputDate instanceof Date) {
            productTs = _inputDate.getTime();
        }
        else if (typeof _inputDate === 'string') {
            productTs = new Date(_inputDate).getTime();
        }
        let desiredVersion;
        if (typeof _desiredVersion === 'string') {
            desiredVersion = $2p($1p(_desiredVersion));
        }
        else {
            desiredVersion = _desiredVersion;
        }
        if (!version || !desiredVersion) {
            return false;
        }
        const majorBase = version.majorBase;
        const minorBase = version.minorBase;
        const patchBase = version.patchBase;
        let desiredMajorBase = desiredVersion.majorBase;
        let desiredMinorBase = desiredVersion.minorBase;
        let desiredPatchBase = desiredVersion.patchBase;
        const desiredNotBefore = desiredVersion.notBefore;
        let majorMustEqual = desiredVersion.majorMustEqual;
        let minorMustEqual = desiredVersion.minorMustEqual;
        let patchMustEqual = desiredVersion.patchMustEqual;
        if (desiredVersion.isMinimum) {
            if (majorBase > desiredMajorBase) {
                return true;
            }
            if (majorBase < desiredMajorBase) {
                return false;
            }
            if (minorBase > desiredMinorBase) {
                return true;
            }
            if (minorBase < desiredMinorBase) {
                return false;
            }
            if (productTs && productTs < desiredNotBefore) {
                return false;
            }
            return patchBase >= desiredPatchBase;
        }
        // Anything < 1.0.0 is compatible with >= 1.0.0, except exact matches
        if (majorBase === 1 && desiredMajorBase === 0 && (!majorMustEqual || !minorMustEqual || !patchMustEqual)) {
            desiredMajorBase = 1;
            desiredMinorBase = 0;
            desiredPatchBase = 0;
            majorMustEqual = true;
            minorMustEqual = false;
            patchMustEqual = false;
        }
        if (majorBase < desiredMajorBase) {
            // smaller major version
            return false;
        }
        if (majorBase > desiredMajorBase) {
            // higher major version
            return (!majorMustEqual);
        }
        // at this point, majorBase are equal
        if (minorBase < desiredMinorBase) {
            // smaller minor version
            return false;
        }
        if (minorBase > desiredMinorBase) {
            // higher minor version
            return (!minorMustEqual);
        }
        // at this point, minorBase are equal
        if (patchBase < desiredPatchBase) {
            // smaller patch version
            return false;
        }
        if (patchBase > desiredPatchBase) {
            // higher patch version
            return (!patchMustEqual);
        }
        // at this point, patchBase are equal
        if (productTs && productTs < desiredNotBefore) {
            return false;
        }
        return true;
    }
    function $4p(productVersion, productDate, extensionLocation, extensionManifest, extensionIsBuiltin, validateApiVersion) {
        const validations = [];
        if (typeof extensionManifest.publisher !== 'undefined' && typeof extensionManifest.publisher !== 'string') {
            validations.push([severity_1.default.Error, nls.localize(10902, null)]);
            return validations;
        }
        if (typeof extensionManifest.name !== 'string') {
            validations.push([severity_1.default.Error, nls.localize(10903, null, 'name')]);
            return validations;
        }
        if (typeof extensionManifest.version !== 'string') {
            validations.push([severity_1.default.Error, nls.localize(10904, null, 'version')]);
            return validations;
        }
        if (!extensionManifest.engines) {
            validations.push([severity_1.default.Error, nls.localize(10905, null, 'engines')]);
            return validations;
        }
        if (typeof extensionManifest.engines.vscode !== 'string') {
            validations.push([severity_1.default.Error, nls.localize(10906, null, 'engines.vscode')]);
            return validations;
        }
        if (typeof extensionManifest.extensionDependencies !== 'undefined') {
            if (!isStringArray(extensionManifest.extensionDependencies)) {
                validations.push([severity_1.default.Error, nls.localize(10907, null, 'extensionDependencies')]);
                return validations;
            }
        }
        if (typeof extensionManifest.activationEvents !== 'undefined') {
            if (!isStringArray(extensionManifest.activationEvents)) {
                validations.push([severity_1.default.Error, nls.localize(10908, null, 'activationEvents')]);
                return validations;
            }
            if (typeof extensionManifest.main === 'undefined' && typeof extensionManifest.browser === 'undefined') {
                validations.push([severity_1.default.Error, nls.localize(10909, null, 'activationEvents', 'main', 'browser')]);
                return validations;
            }
        }
        if (typeof extensionManifest.extensionKind !== 'undefined') {
            if (typeof extensionManifest.main === 'undefined') {
                validations.push([severity_1.default.Warning, nls.localize(10910, null, 'extensionKind')]);
                // not a failure case
            }
        }
        if (typeof extensionManifest.main !== 'undefined') {
            if (typeof extensionManifest.main !== 'string') {
                validations.push([severity_1.default.Error, nls.localize(10911, null, 'main')]);
                return validations;
            }
            else {
                const mainLocation = (0, resources_1.$gh)(extensionLocation, extensionManifest.main);
                if (!(0, resources_1.$ah)(mainLocation, extensionLocation)) {
                    validations.push([severity_1.default.Warning, nls.localize(10912, null, mainLocation.path, extensionLocation.path)]);
                    // not a failure case
                }
            }
        }
        if (typeof extensionManifest.browser !== 'undefined') {
            if (typeof extensionManifest.browser !== 'string') {
                validations.push([severity_1.default.Error, nls.localize(10913, null, 'browser')]);
                return validations;
            }
            else {
                const browserLocation = (0, resources_1.$gh)(extensionLocation, extensionManifest.browser);
                if (!(0, resources_1.$ah)(browserLocation, extensionLocation)) {
                    validations.push([severity_1.default.Warning, nls.localize(10914, null, browserLocation.path, extensionLocation.path)]);
                    // not a failure case
                }
            }
        }
        if (!semver.valid(extensionManifest.version)) {
            validations.push([severity_1.default.Error, nls.localize(10915, null)]);
            return validations;
        }
        const notices = [];
        const validExtensionVersion = $5p(productVersion, productDate, extensionManifest, extensionIsBuiltin, notices);
        if (!validExtensionVersion) {
            for (const notice of notices) {
                validations.push([severity_1.default.Error, notice]);
            }
        }
        if (validateApiVersion && extensionManifest.enabledApiProposals?.length) {
            const incompatibleNotices = [];
            if (!$7p([...extensionManifest.enabledApiProposals], incompatibleNotices)) {
                for (const notice of incompatibleNotices) {
                    validations.push([severity_1.default.Error, notice]);
                }
            }
        }
        return validations;
    }
    function $5p(productVersion, productDate, extensionManifest, extensionIsBuiltin, notices) {
        if (extensionIsBuiltin || (typeof extensionManifest.main === 'undefined' && typeof extensionManifest.browser === 'undefined')) {
            // No version check for builtin or declarative extensions
            return true;
        }
        return isVersionValid(productVersion, productDate, extensionManifest.engines.vscode, notices);
    }
    function $6p(engine, version, date) {
        // TODO@joao: discuss with alex '*' doesn't seem to be a valid engine version
        return engine === '*' || isVersionValid(version, date, engine);
    }
    function $7p(apiProposals, arg1) {
        if (apiProposals.length === 0) {
            return true;
        }
        const notices = Array.isArray(arg1) ? arg1 : undefined;
        const productApiProposals = (notices ? undefined : arg1) ?? extensionsApiProposals_1.allApiProposals;
        const incompatibleNotices = [];
        const parsedProposals = (0, extensions_1.$yn)(apiProposals);
        for (const { proposalName, version } of parsedProposals) {
            const existingProposal = productApiProposals[proposalName];
            if (!existingProposal) {
                continue;
            }
            if (!version) {
                continue;
            }
            if (existingProposal.version !== version) {
                incompatibleNotices.push(nls.localize(10916, null, proposalName));
            }
        }
        notices?.push(...incompatibleNotices);
        return incompatibleNotices.length === 0;
    }
    function isVersionValid(currentVersion, date, requestedVersion, notices = []) {
        const desiredVersion = $2p($1p(requestedVersion));
        if (!desiredVersion) {
            notices.push(nls.localize(10917, null, requestedVersion));
            return false;
        }
        // enforce that a breaking API version is specified.
        // for 0.X.Y, that means up to 0.X must be specified
        // otherwise for Z.X.Y, that means Z must be specified
        if (desiredVersion.majorBase === 0) {
            // force that major and minor must be specific
            if (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {
                notices.push(nls.localize(10918, null, requestedVersion));
                return false;
            }
        }
        else {
            // force that major must be specific
            if (!desiredVersion.majorMustEqual) {
                notices.push(nls.localize(10919, null, requestedVersion));
                return false;
            }
        }
        if (!$3p(currentVersion, date, desiredVersion)) {
            notices.push(nls.localize(10920, null, currentVersion, requestedVersion));
            return false;
        }
        return true;
    }
    function isStringArray(arr) {
        if (!Array.isArray(arr)) {
            return false;
        }
        for (let i = 0, len = arr.length; i < len; i++) {
            if (typeof arr[i] !== 'string') {
                return false;
            }
        }
        return true;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[176/*vs/platform/request/common/request*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,13/*vs/base/common/errors*/,4/*vs/base/common/lifecycle*/,9/*vs/nls*/,53/*vs/platform/configuration/common/configurationRegistry*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, buffer_1, errors_1, lifecycle_1, nls_1, configurationRegistry_1, instantiation_1, log_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$9p = exports.$8p = void 0;
    exports.$0p = $0p;
    exports.$$p = $$p;
    exports.$_p = $_p;
    exports.$aq = $aq;
    exports.$bq = $bq;
    exports.$cq = $cq;
    exports.$8p = (0, instantiation_1.$Fi)('requestService');
    class LoggableHeaders {
        constructor(b) {
            this.b = b;
        }
        toJSON() {
            if (!this.a) {
                const headers = Object.create(null);
                for (const key in this.b) {
                    if (key.toLowerCase() === 'authorization' || key.toLowerCase() === 'proxy-authorization') {
                        headers[key] = '*****';
                    }
                    else {
                        headers[key] = this.b[key];
                    }
                }
                this.a = headers;
            }
            return this.a;
        }
    }
    class $9p extends lifecycle_1.$Uc {
        constructor(loggerService) {
            super();
            this.b = 0;
            this.a = loggerService.createLogger('network', {
                name: (0, nls_1.localize)(10689, null),
                when: log_1.$sk.isEqualTo((0, log_1.$pk)(log_1.LogLevel.Trace)).serialize()
            });
        }
        async c(stack, options, request) {
            const prefix = `${stack} #${++this.b}: ${options.url}`;
            this.a.trace(`${prefix} - begin`, options.type, new LoggableHeaders(options.headers ?? {}));
            try {
                const result = await request();
                this.a.trace(`${prefix} - end`, options.type, result.res.statusCode, result.res.headers);
                return result;
            }
            catch (error) {
                this.a.error(`${prefix} - error`, options.type, (0, errors_1.$9)(error));
                throw error;
            }
        }
    }
    exports.$9p = $9p;
    function $0p(context) {
        return (context.res.statusCode && context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;
    }
    function $$p(context) {
        return context.res.statusCode === 204;
    }
    async function $_p(context) {
        if ($$p(context)) {
            return null;
        }
        const buffer = await (0, buffer_1.$Ze)(context.stream);
        return buffer.toString();
    }
    async function $aq(context) {
        if (!$0p(context)) {
            throw new Error('Server returned ' + context.res.statusCode);
        }
        return $_p(context);
    }
    async function $bq(context) {
        if (!$0p(context)) {
            throw new Error('Server returned ' + context.res.statusCode);
        }
        if ($$p(context)) {
            return null;
        }
        const buffer = await (0, buffer_1.$Ze)(context.stream);
        const str = buffer.toString();
        try {
            return JSON.parse(str);
        }
        catch (err) {
            err.message += ':\n' + str;
            throw err;
        }
    }
    function $cq(scope) {
        registerProxyConfigurations(scope);
    }
    let proxyConfiguration;
    function registerProxyConfigurations(scope) {
        const configurationRegistry = platform_1.$ro.as(configurationRegistry_1.$wo.Configuration);
        const oldProxyConfiguration = proxyConfiguration;
        proxyConfiguration = {
            id: 'http',
            order: 15,
            title: (0, nls_1.localize)(10690, null),
            type: 'object',
            scope,
            properties: {
                'http.proxy': {
                    type: 'string',
                    pattern: '^(https?|socks|socks4a?|socks5h?)://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$',
                    markdownDescription: (0, nls_1.localize)(10691, null),
                    restricted: true
                },
                'http.proxyStrictSSL': {
                    type: 'boolean',
                    default: true,
                    description: (0, nls_1.localize)(10692, null),
                    restricted: true
                },
                'http.proxyKerberosServicePrincipal': {
                    type: 'string',
                    markdownDescription: (0, nls_1.localize)(10693, null),
                    restricted: true
                },
                'http.noProxy': {
                    type: 'array',
                    items: { type: 'string' },
                    markdownDescription: (0, nls_1.localize)(10694, null),
                    restricted: true
                },
                'http.proxyAuthorization': {
                    type: ['null', 'string'],
                    default: null,
                    markdownDescription: (0, nls_1.localize)(10695, null),
                    restricted: true
                },
                'http.proxySupport': {
                    type: 'string',
                    enum: ['off', 'on', 'fallback', 'override'],
                    enumDescriptions: [
                        (0, nls_1.localize)(10696, null),
                        (0, nls_1.localize)(10697, null),
                        (0, nls_1.localize)(10698, null),
                        (0, nls_1.localize)(10699, null),
                    ],
                    default: 'override',
                    description: (0, nls_1.localize)(10700, null),
                    restricted: true
                },
                'http.systemCertificates': {
                    type: 'boolean',
                    default: true,
                    description: (0, nls_1.localize)(10701, null),
                    restricted: true
                },
                'http.experimental.systemCertificatesV2': {
                    type: 'boolean',
                    tags: ['experimental'],
                    default: false,
                    description: (0, nls_1.localize)(10702, null),
                    restricted: true
                }
            }
        };
        configurationRegistry.updateConfigurations({ add: [proxyConfiguration], remove: oldProxyConfiguration ? [oldProxyConfiguration] : [] });
    }
    registerProxyConfigurations(configurationRegistry_1.ConfigurationScope.APPLICATION);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[177/*vs/platform/telemetry/common/commonProperties*/], __M([1/*require*/,0/*exports*/,20/*vs/base/common/platform*/,78/*vs/base/common/process*/,38/*vs/base/common/uuid*/]), function (require, exports, platform_1, process_1, uuid_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vp = $vp;
    exports.$wp = $wp;
    function getPlatformDetail(hostname) {
        if (platform_1.$v === platform_1.Platform.Linux && /^penguin(\.|$)/i.test(hostname)) {
            return 'chromebook';
        }
        return undefined;
    }
    function $vp(release, hostname, arch, commit, version, machineId, sqmId, devDeviceId, isInternalTelemetry, product) {
        const result = Object.create(null);
        // __GDPR__COMMON__ "common.machineId" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
        result['common.machineId'] = machineId;
        // __GDPR__COMMON__ "common.sqmId" : { "endPoint": "SqmMachineId", "classification": "EndUserPseudonymizedInformation", "purpose": "BusinessInsight" }
        result['common.sqmId'] = sqmId;
        // __GDPR__COMMON__ "common.devDeviceId" : { "endPoint": "SqmMachineId", "classification": "EndUserPseudonymizedInformation", "purpose": "BusinessInsight" }
        result['common.devDeviceId'] = devDeviceId;
        // __GDPR__COMMON__ "sessionID" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['sessionID'] = (0, uuid_1.$2g)() + Date.now();
        // __GDPR__COMMON__ "commitHash" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['commitHash'] = commit;
        // __GDPR__COMMON__ "version" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['version'] = version;
        // __GDPR__COMMON__ "common.platformVersion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['common.platformVersion'] = (release || '').replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, '$1$2$3');
        // __GDPR__COMMON__ "common.platform" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['common.platform'] = (0, platform_1.$i)(platform_1.$v);
        // __GDPR__COMMON__ "common.nodePlatform" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['common.nodePlatform'] = process_1.$dc;
        // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['common.nodeArch'] = arch;
        // __GDPR__COMMON__ "common.product" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['common.product'] = product || 'desktop';
        if (isInternalTelemetry) {
            // __GDPR__COMMON__ "common.msftInternal" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
            result['common.msftInternal'] = isInternalTelemetry;
        }
        // dynamic properties which value differs on each call
        let seq = 0;
        const startTime = Date.now();
        Object.defineProperties(result, {
            // __GDPR__COMMON__ "timestamp" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            'timestamp': {
                get: () => new Date(),
                enumerable: true
            },
            // __GDPR__COMMON__ "common.timesincesessionstart" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
            'common.timesincesessionstart': {
                get: () => Date.now() - startTime,
                enumerable: true
            },
            // __GDPR__COMMON__ "common.sequence" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
            'common.sequence': {
                get: () => seq++,
                enumerable: true
            }
        });
        if (platform_1.$m) {
            // __GDPR__COMMON__ "common.snap" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            result['common.snap'] = 'true';
        }
        const platformDetail = getPlatformDetail(hostname);
        if (platformDetail) {
            // __GDPR__COMMON__ "common.platformDetail" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            result['common.platformDetail'] = platformDetail;
        }
        return result;
    }
    function $wp(domainList) {
        const userDnsDomain = process_1.env['USERDNSDOMAIN'];
        if (!userDnsDomain) {
            return false;
        }
        const domain = userDnsDomain.toLowerCase();
        return domainList.some(msftDomain => domain === msftDomain);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[112/*vs/platform/telemetry/common/telemetry*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TelemetryConfiguration = exports.TelemetryLevel = exports.$km = exports.$jm = exports.$im = exports.$hm = exports.$gm = exports.$fm = exports.$em = exports.$dm = exports.$cm = exports.$bm = exports.$am = exports.$_l = void 0;
    exports.$_l = (0, instantiation_1.$Fi)('telemetryService');
    exports.$am = (0, instantiation_1.$Fi)('customEndpointTelemetryService');
    // Keys
    exports.$bm = 'telemetry.currentSessionDate';
    exports.$cm = 'telemetry.firstSessionDate';
    exports.$dm = 'telemetry.lastSessionDate';
    exports.$em = 'telemetry.machineId';
    exports.$fm = 'telemetry.sqmId';
    exports.$gm = 'telemetry.devDeviceId';
    // Configuration Keys
    exports.$hm = 'telemetry';
    exports.$im = 'telemetry.telemetryLevel';
    exports.$jm = 'telemetry.enableCrashReporter';
    exports.$km = 'telemetry.enableTelemetry';
    var TelemetryLevel;
    (function (TelemetryLevel) {
        TelemetryLevel[TelemetryLevel["NONE"] = 0] = "NONE";
        TelemetryLevel[TelemetryLevel["CRASH"] = 1] = "CRASH";
        TelemetryLevel[TelemetryLevel["ERROR"] = 2] = "ERROR";
        TelemetryLevel[TelemetryLevel["USAGE"] = 3] = "USAGE";
    })(TelemetryLevel || (exports.TelemetryLevel = TelemetryLevel = {}));
    var TelemetryConfiguration;
    (function (TelemetryConfiguration) {
        TelemetryConfiguration["OFF"] = "off";
        TelemetryConfiguration["CRASH"] = "crash";
        TelemetryConfiguration["ERROR"] = "error";
        TelemetryConfiguration["ON"] = "all";
    })(TelemetryConfiguration || (exports.TelemetryConfiguration = TelemetryConfiguration = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[63/*vs/platform/telemetry/common/telemetryUtils*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/objects*/,14/*vs/base/common/types*/,62/*vs/platform/remote/common/remoteHosts*/,177/*vs/platform/telemetry/common/commonProperties*/,112/*vs/platform/telemetry/common/telemetry*/]), function (require, exports, objects_1, types_1, remoteHosts_1, commonProperties_1, telemetry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Dp = exports.$Cp = exports.$Bp = exports.$Ap = exports.$zp = exports.$yp = exports.$xp = void 0;
    exports.$Ep = $Ep;
    exports.$Fp = $Fp;
    exports.$Gp = $Gp;
    exports.$Hp = $Hp;
    exports.$Ip = $Ip;
    exports.$Jp = $Jp;
    exports.$Kp = $Kp;
    exports.$Lp = $Lp;
    /**
     * A special class used to denoting a telemetry value which should not be clean.
     * This is because that value is "Trusted" not to contain identifiable information such as paths.
     * NOTE: This is used as an API type as well, and should not be changed.
     */
    class $xp {
        constructor(value) {
            this.value = value;
            // This is merely used as an identifier as the instance will be lost during serialization over the exthost
            this.isTrustedTelemetryValue = true;
        }
    }
    exports.$xp = $xp;
    class $yp {
        constructor() {
            this.telemetryLevel = telemetry_1.TelemetryLevel.NONE;
            this.sessionId = 'someValue.sessionId';
            this.machineId = 'someValue.machineId';
            this.sqmId = 'someValue.sqmId';
            this.devDeviceId = 'someValue.devDeviceId';
            this.firstSessionDate = 'someValue.firstSessionDate';
            this.sendErrorTelemetry = false;
        }
        publicLog() { }
        publicLog2() { }
        publicLogError() { }
        publicLogError2() { }
        setExperimentProperty() { }
    }
    exports.$yp = $yp;
    exports.$zp = new $yp();
    class $Ap {
        async publicLog(_endpoint, _eventName, _data) {
            // noop
        }
        async publicLogError(_endpoint, _errorEventName, _data) {
            // noop
        }
    }
    exports.$Ap = $Ap;
    exports.$Bp = 'telemetry';
    exports.$Cp = 'extensionTelemetryLog';
    exports.$Dp = { log: () => null, flush: () => Promise.resolve(null) };
    /**
     * Determines whether or not we support logging telemetry.
     * This checks if the product is capable of collecting telemetry but not whether or not it can send it
     * For checking the user setting and what telemetry you can send please check `getTelemetryLevel`.
     * This returns true if `--disable-telemetry` wasn't used, the product.json allows for telemetry, and we're not testing an extension
     * If false telemetry is disabled throughout the product
     * @param productService
     * @param environmentService
     * @returns false - telemetry is completely disabled, true - telemetry is logged locally, but may not be sent
     */
    function $Ep(productService, environmentService) {
        // If it's OSS and telemetry isn't disabled via the CLI we will allow it for logging only purposes
        if (!environmentService.isBuilt && !environmentService.disableTelemetry) {
            return true;
        }
        return !(environmentService.disableTelemetry || !productService.enableTelemetry);
    }
    /**
     * Checks to see if we're in logging only mode to debug telemetry.
     * This is if telemetry is enabled and we're in OSS, but no telemetry key is provided so it's not being sent just logged.
     * @param productService
     * @param environmentService
     * @returns True if telemetry is actually disabled and we're only logging for debug purposes
     */
    function $Fp(productService, environmentService) {
        // If we're testing an extension, log telemetry for debug purposes
        if (environmentService.extensionTestsLocationURI) {
            return true;
        }
        // Logging only mode is only for OSS
        if (environmentService.isBuilt) {
            return false;
        }
        if (environmentService.disableTelemetry) {
            return false;
        }
        if (productService.enableTelemetry && productService.aiConfig?.ariaKey) {
            return false;
        }
        return true;
    }
    /**
     * Determines how telemetry is handled based on the user's configuration.
     *
     * @param configurationService
     * @returns OFF, ERROR, ON
     */
    function $Gp(configurationService) {
        const newConfig = configurationService.getValue(telemetry_1.$im);
        const crashReporterConfig = configurationService.getValue(telemetry_1.$jm);
        const oldConfig = configurationService.getValue(telemetry_1.$km);
        // If `telemetry.enableCrashReporter` is false or `telemetry.enableTelemetry' is false, disable telemetry
        if (oldConfig === false || crashReporterConfig === false) {
            return telemetry_1.TelemetryLevel.NONE;
        }
        // Maps new telemetry setting to a telemetry level
        switch (newConfig ?? telemetry_1.TelemetryConfiguration.ON) {
            case telemetry_1.TelemetryConfiguration.ON:
                return telemetry_1.TelemetryLevel.USAGE;
            case telemetry_1.TelemetryConfiguration.ERROR:
                return telemetry_1.TelemetryLevel.ERROR;
            case telemetry_1.TelemetryConfiguration.CRASH:
                return telemetry_1.TelemetryLevel.CRASH;
            case telemetry_1.TelemetryConfiguration.OFF:
                return telemetry_1.TelemetryLevel.NONE;
        }
    }
    function $Hp(data) {
        const properties = {};
        const measurements = {};
        const flat = {};
        flatten(data, flat);
        for (let prop in flat) {
            // enforce property names less than 150 char, take the last 150 char
            prop = prop.length > 150 ? prop.substr(prop.length - 149) : prop;
            const value = flat[prop];
            if (typeof value === 'number') {
                measurements[prop] = value;
            }
            else if (typeof value === 'boolean') {
                measurements[prop] = value ? 1 : 0;
            }
            else if (typeof value === 'string') {
                if (value.length > 8192) {
                    console.warn(`Telemetry property: ${prop} has been trimmed to 8192, the original length is ${value.length}`);
                }
                //enforce property value to be less than 8192 char, take the first 8192 char
                // https://docs.microsoft.com/en-us/azure/azure-monitor/app/api-custom-events-metrics#limits
                properties[prop] = value.substring(0, 8191);
            }
            else if (typeof value !== 'undefined' && value !== null) {
                properties[prop] = value;
            }
        }
        return {
            properties,
            measurements
        };
    }
    const telemetryAllowedAuthorities = new Set(['ssh-remote', 'dev-container', 'attached-container', 'wsl', 'tunnel', 'codespaces', 'amlext']);
    function $Ip(remoteAuthority) {
        if (!remoteAuthority) {
            return 'none';
        }
        const remoteName = (0, remoteHosts_1.$in)(remoteAuthority);
        return telemetryAllowedAuthorities.has(remoteName) ? remoteName : 'other';
    }
    function flatten(obj, result, order = 0, prefix) {
        if (!obj) {
            return;
        }
        for (const item of Object.getOwnPropertyNames(obj)) {
            const value = obj[item];
            const index = prefix ? prefix + item : item;
            if (Array.isArray(value)) {
                result[index] = (0, objects_1.$jo)(value);
            }
            else if (value instanceof Date) {
                // TODO unsure why this is here and not in _getData
                result[index] = value.toISOString();
            }
            else if ((0, types_1.$gg)(value)) {
                if (order < 2) {
                    flatten(value, result, order + 1, index + '.');
                }
                else {
                    result[index] = (0, objects_1.$jo)(value);
                }
            }
            else {
                result[index] = value;
            }
        }
    }
    /**
     * Whether or not this is an internal user
     * @param productService The product service
     * @param configService The config servivce
     * @returns true if internal, false otherwise
     */
    function $Jp(productService, configService) {
        const msftInternalDomains = productService.msftInternalDomains || [];
        const internalTesting = configService.getValue('telemetry.internalTesting');
        return (0, commonProperties_1.$wp)(msftInternalDomains) || internalTesting;
    }
    function $Kp(paths) {
        return [paths.appRoot, paths.extensionsPath, paths.userHome.fsPath, paths.tmpDir.fsPath, paths.userDataPath];
    }
    //#region Telemetry Cleaning
    /**
     * Cleans a given stack of possible paths
     * @param stack The stack to sanitize
     * @param cleanupPatterns Cleanup patterns to remove from the stack
     * @returns The cleaned stack
     */
    function anonymizeFilePaths(stack, cleanupPatterns) {
        // Fast check to see if it is a file path to avoid doing unnecessary heavy regex work
        if (!stack || (!stack.includes('/') && !stack.includes('\\'))) {
            return stack;
        }
        let updatedStack = stack;
        const cleanUpIndexes = [];
        for (const regexp of cleanupPatterns) {
            while (true) {
                const result = regexp.exec(stack);
                if (!result) {
                    break;
                }
                cleanUpIndexes.push([result.index, regexp.lastIndex]);
            }
        }
        const nodeModulesRegex = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
        const fileRegex = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
        let lastIndex = 0;
        updatedStack = '';
        while (true) {
            const result = fileRegex.exec(stack);
            if (!result) {
                break;
            }
            // Check to see if the any cleanupIndexes partially overlap with this match
            const overlappingRange = cleanUpIndexes.some(([start, end]) => result.index < end && start < fileRegex.lastIndex);
            // anoynimize user file paths that do not need to be retained or cleaned up.
            if (!nodeModulesRegex.test(result[0]) && !overlappingRange) {
                updatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';
                lastIndex = fileRegex.lastIndex;
            }
        }
        if (lastIndex < stack.length) {
            updatedStack += stack.substr(lastIndex);
        }
        return updatedStack;
    }
    /**
     * Attempts to remove commonly leaked PII
     * @param property The property which will be removed if it contains user data
     * @returns The new value for the property
     */
    function removePropertiesWithPossibleUserInfo(property) {
        // If for some reason it is undefined we skip it (this shouldn't be possible);
        if (!property) {
            return property;
        }
        const userDataRegexes = [
            { label: 'Google API Key', regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
            { label: 'Slack Token', regex: /xox[pbar]\-[A-Za-z0-9]/ },
            { label: 'GitHub Token', regex: /(gh[psuro]_[a-zA-Z0-9]{36}|github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59})/ },
            { label: 'Generic Secret', regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/i },
            { label: 'CLI Credentials', regex: /((login|psexec|(certutil|psexec)\.exe).{1,50}(\s-u(ser(name)?)?\s+.{3,100})?\s-(admin|user|vm|root)?p(ass(word)?)?\s+["']?[^$\-\/\s]|(^|[\s\r\n\\])net(\.exe)?.{1,5}(user\s+|share\s+\/user:| user -? secrets ? set) \s + [^ $\s \/])/ },
            { label: 'Email', regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/ } // Regex which matches @*.site
        ];
        // Check for common user data in the telemetry events
        for (const secretRegex of userDataRegexes) {
            if (secretRegex.regex.test(property)) {
                return `<REDACTED: ${secretRegex.label}>`;
            }
        }
        return property;
    }
    /**
     * Does a best possible effort to clean a data object from any possible PII.
     * @param data The data object to clean
     * @param paths Any additional patterns that should be removed from the data set
     * @returns A new object with the PII removed
     */
    function $Lp(data, cleanUpPatterns) {
        return (0, objects_1.$go)(data, value => {
            // If it's a trusted value it means it's okay to skip cleaning so we don't clean it
            if (value instanceof $xp || Object.hasOwnProperty.call(value, 'isTrustedTelemetryValue')) {
                return value.value;
            }
            // We only know how to clean strings
            if (typeof value === 'string') {
                let updatedProperty = value.replaceAll('%20', ' ');
                // First we anonymize any possible file paths
                updatedProperty = anonymizeFilePaths(updatedProperty, cleanUpPatterns);
                // Then we do a simple regex replace with the defined patterns
                for (const regexp of cleanUpPatterns) {
                    updatedProperty = updatedProperty.replace(regexp, '');
                }
                // Lastly, remove commonly leaked PII
                updatedProperty = removePropertiesWithPossibleUserInfo(updatedProperty);
                return updatedProperty;
            }
            return undefined;
        });
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[178/*vs/platform/extensionManagement/common/extensionManagementUtil*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/strings*/,110/*vs/platform/extensionManagement/common/extensionManagement*/,18/*vs/platform/extensions/common/extensions*/,20/*vs/base/common/platform*/,2/*vs/base/common/uri*/,13/*vs/base/common/errors*/,78/*vs/base/common/process*/,63/*vs/platform/telemetry/common/telemetryUtils*/]), function (require, exports, strings_1, extensionManagement_1, extensions_1, platform_1, uri_1, errors_1, process_1, telemetryUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Vp = exports.$Np = void 0;
    exports.$Mp = $Mp;
    exports.$Op = $Op;
    exports.$Pp = $Pp;
    exports.$Qp = $Qp;
    exports.$Rp = $Rp;
    exports.$Sp = $Sp;
    exports.$Tp = $Tp;
    exports.$Up = $Up;
    exports.$Wp = $Wp;
    exports.$Xp = $Xp;
    function $Mp(a, b) {
        if (a.uuid && b.uuid) {
            return a.uuid === b.uuid;
        }
        if (a.id === b.id) {
            return true;
        }
        return (0, strings_1.$Af)(a.id, b.id) === 0;
    }
    const ExtensionKeyRegex = /^([^.]+\..+)-(\d+\.\d+\.\d+)(-(.+))?$/;
    class $Np {
        static create(extension) {
            const version = extension.manifest ? extension.manifest.version : extension.version;
            const targetPlatform = extension.manifest ? extension.targetPlatform : extension.properties.targetPlatform;
            return new $Np(extension.identifier, version, targetPlatform);
        }
        static parse(key) {
            const matches = ExtensionKeyRegex.exec(key);
            return matches && matches[1] && matches[2] ? new $Np({ id: matches[1] }, matches[2], matches[4] || undefined) : null;
        }
        constructor(identifier, version, targetPlatform = extensions_1.TargetPlatform.UNDEFINED) {
            this.identifier = identifier;
            this.version = version;
            this.targetPlatform = targetPlatform;
            this.id = identifier.id;
        }
        toString() {
            return `${this.id}-${this.version}${this.targetPlatform !== extensions_1.TargetPlatform.UNDEFINED ? `-${this.targetPlatform}` : ''}`;
        }
        equals(o) {
            if (!(o instanceof $Np)) {
                return false;
            }
            return $Mp(this, o) && this.version === o.version && this.targetPlatform === o.targetPlatform;
        }
    }
    exports.$Np = $Np;
    const EXTENSION_IDENTIFIER_WITH_VERSION_REGEX = /^([^.]+\..+)@((prerelease)|(\d+\.\d+\.\d+(-.*)?))$/;
    function $Op(id) {
        const matches = EXTENSION_IDENTIFIER_WITH_VERSION_REGEX.exec(id);
        if (matches && matches[1]) {
            return [$Qp(matches[1]), matches[2]];
        }
        return [$Qp(id), undefined];
    }
    function $Pp(publisher, name) {
        return `${publisher}.${name}`;
    }
    function $Qp(id) {
        return id.toLowerCase();
    }
    function $Rp(publisher, name) {
        return $Qp($Pp(publisher ?? extensions_1.$nn, name));
    }
    function $Sp(extensions, getExtensionIdentifier) {
        const byExtension = [];
        const findGroup = (extension) => {
            for (const group of byExtension) {
                if (group.some(e => $Mp(getExtensionIdentifier(e), getExtensionIdentifier(extension)))) {
                    return group;
                }
            }
            return null;
        };
        for (const extension of extensions) {
            const group = findGroup(extension);
            if (group) {
                group.push(extension);
            }
            else {
                byExtension.push([extension]);
            }
        }
        return byExtension;
    }
    function $Tp(extension) {
        return {
            id: extension.identifier.id,
            name: extension.manifest.name,
            galleryId: null,
            publisherId: extension.publisherId,
            publisherName: extension.manifest.publisher,
            publisherDisplayName: extension.publisherDisplayName,
            dependencies: extension.manifest.extensionDependencies && extension.manifest.extensionDependencies.length > 0
        };
    }
    /* __GDPR__FRAGMENT__
        "GalleryExtensionTelemetryData" : {
            "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "name": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "version": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "galleryId": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherId": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherDisplayName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "isPreReleaseVersion": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "dependencies": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
            "isSigned": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "${include}": [
                "${GalleryExtensionTelemetryData2}"
            ]
        }
    */
    function $Up(extension) {
        return {
            id: new telemetryUtils_1.$xp(extension.identifier.id),
            name: new telemetryUtils_1.$xp(extension.name),
            version: extension.version,
            galleryId: extension.identifier.uuid,
            publisherId: extension.publisherId,
            publisherName: extension.publisher,
            publisherDisplayName: extension.publisherDisplayName,
            isPreReleaseVersion: extension.properties.isPreReleaseVersion,
            dependencies: !!(extension.properties.dependencies && extension.properties.dependencies.length > 0),
            isSigned: extension.isSigned,
            ...extension.telemetryData
        };
    }
    exports.$Vp = new extensions_1.$rn('pprice.better-merge');
    function $Wp(installedExtensions, extension) {
        const dependencies = [];
        const extensions = extension.manifest.extensionDependencies?.slice(0) ?? [];
        while (extensions.length) {
            const id = extensions.shift();
            if (id && dependencies.every(e => !$Mp(e.identifier, { id }))) {
                const ext = installedExtensions.filter(e => $Mp(e.identifier, { id }));
                if (ext.length === 1) {
                    dependencies.push(ext[0]);
                    extensions.push(...ext[0].manifest.extensionDependencies?.slice(0) ?? []);
                }
            }
        }
        return dependencies;
    }
    async function isAlpineLinux(fileService, logService) {
        if (!platform_1.$l) {
            return false;
        }
        let content;
        try {
            const fileContent = await fileService.readFile(uri_1.URI.file('/etc/os-release'));
            content = fileContent.value.toString();
        }
        catch (error) {
            try {
                const fileContent = await fileService.readFile(uri_1.URI.file('/usr/lib/os-release'));
                content = fileContent.value.toString();
            }
            catch (error) {
                /* Ignore */
                logService.debug(`Error while getting the os-release file.`, (0, errors_1.$9)(error));
            }
        }
        return !!content && (content.match(/^ID=([^\u001b\r\n]*)/m) || [])[1] === 'alpine';
    }
    async function $Xp(fileService, logService) {
        const alpineLinux = await isAlpineLinux(fileService, logService);
        const targetPlatform = (0, extensionManagement_1.$hp)(alpineLinux ? 'alpine' : platform_1.$v, process_1.$ec);
        logService.debug('ComputeTargetPlatform:', targetPlatform);
        return targetPlatform;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[179/*vs/platform/terminal/common/environmentVariableShared*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Fs = $Fs;
    exports.$Gs = $Gs;
    exports.$Hs = $Hs;
    exports.$Is = $Is;
    exports.$Js = $Js;
    exports.$Ks = $Ks;
    // This file is shared between the renderer and extension host
    function $Fs(collection) {
        return [...collection.entries()];
    }
    function $Gs(descriptionMap) {
        return descriptionMap ? [...descriptionMap.entries()] : [];
    }
    function $Hs(serializedCollection) {
        return new Map(serializedCollection);
    }
    function $Is(serializableEnvironmentDescription) {
        return new Map(serializableEnvironmentDescription ?? []);
    }
    function $Js(collections) {
        return Array.from(collections.entries()).map(e => {
            return [e[0], $Fs(e[1].map), $Gs(e[1].descriptionMap)];
        });
    }
    function $Ks(serializedCollection) {
        return new Map(serializedCollection.map(e => {
            return [e[0], { map: $Hs(e[1]), descriptionMap: $Is(e[2]) }];
        }));
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[180/*vs/platform/terminal/common/terminal*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/contextkey/common/contextkey*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, instantiation_1, contextkey_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ss = exports.$rs = exports.$qs = exports.TerminalExitReason = exports.ShellIntegrationStatus = exports.ProfileSource = exports.FlowControlConstants = exports.LocalReconnectConstants = exports.TerminalLocationString = exports.TerminalLocation = exports.HeartbeatConstants = exports.$ps = exports.ProcessPropertyType = exports.TerminalIpcChannels = exports.TitleEventSource = exports.WindowsShellType = exports.PosixShellType = exports.TerminalSettingId = exports.TerminalSettingPrefix = exports.$os = void 0;
    exports.$os = new contextkey_1.$Wj('terminalTabFocusMode', false, true);
    var TerminalSettingPrefix;
    (function (TerminalSettingPrefix) {
        TerminalSettingPrefix["AutomationProfile"] = "terminal.integrated.automationProfile.";
        TerminalSettingPrefix["DefaultProfile"] = "terminal.integrated.defaultProfile.";
        TerminalSettingPrefix["Profiles"] = "terminal.integrated.profiles.";
    })(TerminalSettingPrefix || (exports.TerminalSettingPrefix = TerminalSettingPrefix = {}));
    var TerminalSettingId;
    (function (TerminalSettingId) {
        TerminalSettingId["SendKeybindingsToShell"] = "terminal.integrated.sendKeybindingsToShell";
        TerminalSettingId["AutomationProfileLinux"] = "terminal.integrated.automationProfile.linux";
        TerminalSettingId["AutomationProfileMacOs"] = "terminal.integrated.automationProfile.osx";
        TerminalSettingId["AutomationProfileWindows"] = "terminal.integrated.automationProfile.windows";
        TerminalSettingId["ProfilesWindows"] = "terminal.integrated.profiles.windows";
        TerminalSettingId["ProfilesMacOs"] = "terminal.integrated.profiles.osx";
        TerminalSettingId["ProfilesLinux"] = "terminal.integrated.profiles.linux";
        TerminalSettingId["DefaultProfileLinux"] = "terminal.integrated.defaultProfile.linux";
        TerminalSettingId["DefaultProfileMacOs"] = "terminal.integrated.defaultProfile.osx";
        TerminalSettingId["DefaultProfileWindows"] = "terminal.integrated.defaultProfile.windows";
        TerminalSettingId["UseWslProfiles"] = "terminal.integrated.useWslProfiles";
        TerminalSettingId["TabsDefaultColor"] = "terminal.integrated.tabs.defaultColor";
        TerminalSettingId["TabsDefaultIcon"] = "terminal.integrated.tabs.defaultIcon";
        TerminalSettingId["TabsEnabled"] = "terminal.integrated.tabs.enabled";
        TerminalSettingId["TabsEnableAnimation"] = "terminal.integrated.tabs.enableAnimation";
        TerminalSettingId["TabsHideCondition"] = "terminal.integrated.tabs.hideCondition";
        TerminalSettingId["TabsShowActiveTerminal"] = "terminal.integrated.tabs.showActiveTerminal";
        TerminalSettingId["TabsShowActions"] = "terminal.integrated.tabs.showActions";
        TerminalSettingId["TabsLocation"] = "terminal.integrated.tabs.location";
        TerminalSettingId["TabsFocusMode"] = "terminal.integrated.tabs.focusMode";
        TerminalSettingId["MacOptionIsMeta"] = "terminal.integrated.macOptionIsMeta";
        TerminalSettingId["MacOptionClickForcesSelection"] = "terminal.integrated.macOptionClickForcesSelection";
        TerminalSettingId["AltClickMovesCursor"] = "terminal.integrated.altClickMovesCursor";
        TerminalSettingId["CopyOnSelection"] = "terminal.integrated.copyOnSelection";
        TerminalSettingId["EnableMultiLinePasteWarning"] = "terminal.integrated.enableMultiLinePasteWarning";
        TerminalSettingId["DrawBoldTextInBrightColors"] = "terminal.integrated.drawBoldTextInBrightColors";
        TerminalSettingId["FontFamily"] = "terminal.integrated.fontFamily";
        TerminalSettingId["FontSize"] = "terminal.integrated.fontSize";
        TerminalSettingId["LetterSpacing"] = "terminal.integrated.letterSpacing";
        TerminalSettingId["LineHeight"] = "terminal.integrated.lineHeight";
        TerminalSettingId["MinimumContrastRatio"] = "terminal.integrated.minimumContrastRatio";
        TerminalSettingId["TabStopWidth"] = "terminal.integrated.tabStopWidth";
        TerminalSettingId["FastScrollSensitivity"] = "terminal.integrated.fastScrollSensitivity";
        TerminalSettingId["MouseWheelScrollSensitivity"] = "terminal.integrated.mouseWheelScrollSensitivity";
        TerminalSettingId["BellDuration"] = "terminal.integrated.bellDuration";
        TerminalSettingId["FontWeight"] = "terminal.integrated.fontWeight";
        TerminalSettingId["FontWeightBold"] = "terminal.integrated.fontWeightBold";
        TerminalSettingId["CursorBlinking"] = "terminal.integrated.cursorBlinking";
        TerminalSettingId["CursorStyle"] = "terminal.integrated.cursorStyle";
        TerminalSettingId["CursorStyleInactive"] = "terminal.integrated.cursorStyleInactive";
        TerminalSettingId["CursorWidth"] = "terminal.integrated.cursorWidth";
        TerminalSettingId["Scrollback"] = "terminal.integrated.scrollback";
        TerminalSettingId["DetectLocale"] = "terminal.integrated.detectLocale";
        TerminalSettingId["DefaultLocation"] = "terminal.integrated.defaultLocation";
        TerminalSettingId["GpuAcceleration"] = "terminal.integrated.gpuAcceleration";
        TerminalSettingId["TerminalTitleSeparator"] = "terminal.integrated.tabs.separator";
        TerminalSettingId["TerminalTitle"] = "terminal.integrated.tabs.title";
        TerminalSettingId["TerminalDescription"] = "terminal.integrated.tabs.description";
        TerminalSettingId["RightClickBehavior"] = "terminal.integrated.rightClickBehavior";
        TerminalSettingId["MiddleClickBehavior"] = "terminal.integrated.middleClickBehavior";
        TerminalSettingId["Cwd"] = "terminal.integrated.cwd";
        TerminalSettingId["ConfirmOnExit"] = "terminal.integrated.confirmOnExit";
        TerminalSettingId["ConfirmOnKill"] = "terminal.integrated.confirmOnKill";
        TerminalSettingId["EnableBell"] = "terminal.integrated.enableBell";
        TerminalSettingId["EnableVisualBell"] = "terminal.integrated.enableVisualBell";
        TerminalSettingId["CommandsToSkipShell"] = "terminal.integrated.commandsToSkipShell";
        TerminalSettingId["AllowChords"] = "terminal.integrated.allowChords";
        TerminalSettingId["AllowMnemonics"] = "terminal.integrated.allowMnemonics";
        TerminalSettingId["TabFocusMode"] = "terminal.integrated.tabFocusMode";
        TerminalSettingId["EnvMacOs"] = "terminal.integrated.env.osx";
        TerminalSettingId["EnvLinux"] = "terminal.integrated.env.linux";
        TerminalSettingId["EnvWindows"] = "terminal.integrated.env.windows";
        TerminalSettingId["EnvironmentChangesIndicator"] = "terminal.integrated.environmentChangesIndicator";
        TerminalSettingId["EnvironmentChangesRelaunch"] = "terminal.integrated.environmentChangesRelaunch";
        TerminalSettingId["ShowExitAlert"] = "terminal.integrated.showExitAlert";
        TerminalSettingId["SplitCwd"] = "terminal.integrated.splitCwd";
        TerminalSettingId["WindowsEnableConpty"] = "terminal.integrated.windowsEnableConpty";
        TerminalSettingId["WordSeparators"] = "terminal.integrated.wordSeparators";
        TerminalSettingId["EnableFileLinks"] = "terminal.integrated.enableFileLinks";
        TerminalSettingId["AllowedLinkSchemes"] = "terminal.integrated.allowedLinkSchemes";
        TerminalSettingId["UnicodeVersion"] = "terminal.integrated.unicodeVersion";
        TerminalSettingId["EnablePersistentSessions"] = "terminal.integrated.enablePersistentSessions";
        TerminalSettingId["PersistentSessionReviveProcess"] = "terminal.integrated.persistentSessionReviveProcess";
        TerminalSettingId["HideOnStartup"] = "terminal.integrated.hideOnStartup";
        TerminalSettingId["CustomGlyphs"] = "terminal.integrated.customGlyphs";
        TerminalSettingId["RescaleOverlappingGlyphs"] = "terminal.integrated.rescaleOverlappingGlyphs";
        TerminalSettingId["PersistentSessionScrollback"] = "terminal.integrated.persistentSessionScrollback";
        TerminalSettingId["InheritEnv"] = "terminal.integrated.inheritEnv";
        TerminalSettingId["ShowLinkHover"] = "terminal.integrated.showLinkHover";
        TerminalSettingId["IgnoreProcessNames"] = "terminal.integrated.ignoreProcessNames";
        TerminalSettingId["AutoReplies"] = "terminal.integrated.autoReplies";
        TerminalSettingId["ShellIntegrationEnabled"] = "terminal.integrated.shellIntegration.enabled";
        TerminalSettingId["ShellIntegrationShowWelcome"] = "terminal.integrated.shellIntegration.showWelcome";
        TerminalSettingId["ShellIntegrationDecorationsEnabled"] = "terminal.integrated.shellIntegration.decorationsEnabled";
        TerminalSettingId["ShellIntegrationCommandHistory"] = "terminal.integrated.shellIntegration.history";
        TerminalSettingId["EnableImages"] = "terminal.integrated.enableImages";
        TerminalSettingId["SmoothScrolling"] = "terminal.integrated.smoothScrolling";
        TerminalSettingId["IgnoreBracketedPasteMode"] = "terminal.integrated.ignoreBracketedPasteMode";
        TerminalSettingId["FocusAfterRun"] = "terminal.integrated.focusAfterRun";
        // Debug settings that are hidden from user
        /** Simulated latency applied to all calls made to the pty host */
        TerminalSettingId["DeveloperPtyHostLatency"] = "terminal.integrated.developer.ptyHost.latency";
        /** Simulated startup delay of the pty host process */
        TerminalSettingId["DeveloperPtyHostStartupDelay"] = "terminal.integrated.developer.ptyHost.startupDelay";
        /** Shows the textarea element */
        TerminalSettingId["DevMode"] = "terminal.integrated.developer.devMode";
    })(TerminalSettingId || (exports.TerminalSettingId = TerminalSettingId = {}));
    var PosixShellType;
    (function (PosixShellType) {
        PosixShellType["PowerShell"] = "pwsh";
        PosixShellType["Bash"] = "bash";
        PosixShellType["Fish"] = "fish";
        PosixShellType["Sh"] = "sh";
        PosixShellType["Csh"] = "csh";
        PosixShellType["Ksh"] = "ksh";
        PosixShellType["Zsh"] = "zsh";
        PosixShellType["Python"] = "python";
    })(PosixShellType || (exports.PosixShellType = PosixShellType = {}));
    var WindowsShellType;
    (function (WindowsShellType) {
        WindowsShellType["CommandPrompt"] = "cmd";
        WindowsShellType["PowerShell"] = "pwsh";
        WindowsShellType["Wsl"] = "wsl";
        WindowsShellType["GitBash"] = "gitbash";
        WindowsShellType["Python"] = "python";
    })(WindowsShellType || (exports.WindowsShellType = WindowsShellType = {}));
    var TitleEventSource;
    (function (TitleEventSource) {
        /** From the API or the rename command that overrides any other type */
        TitleEventSource[TitleEventSource["Api"] = 0] = "Api";
        /** From the process name property*/
        TitleEventSource[TitleEventSource["Process"] = 1] = "Process";
        /** From the VT sequence */
        TitleEventSource[TitleEventSource["Sequence"] = 2] = "Sequence";
        /** Config changed */
        TitleEventSource[TitleEventSource["Config"] = 3] = "Config";
    })(TitleEventSource || (exports.TitleEventSource = TitleEventSource = {}));
    var TerminalIpcChannels;
    (function (TerminalIpcChannels) {
        /**
         * Communicates between the renderer process and shared process.
         */
        TerminalIpcChannels["LocalPty"] = "localPty";
        /**
         * Communicates between the shared process and the pty host process.
         */
        TerminalIpcChannels["PtyHost"] = "ptyHost";
        /**
         * Communicates between the renderer process and the pty host process.
         */
        TerminalIpcChannels["PtyHostWindow"] = "ptyHostWindow";
        /**
         * Deals with logging from the pty host process.
         */
        TerminalIpcChannels["Logger"] = "logger";
        /**
         * Enables the detection of unresponsive pty hosts.
         */
        TerminalIpcChannels["Heartbeat"] = "heartbeat";
    })(TerminalIpcChannels || (exports.TerminalIpcChannels = TerminalIpcChannels = {}));
    var ProcessPropertyType;
    (function (ProcessPropertyType) {
        ProcessPropertyType["Cwd"] = "cwd";
        ProcessPropertyType["InitialCwd"] = "initialCwd";
        ProcessPropertyType["FixedDimensions"] = "fixedDimensions";
        ProcessPropertyType["Title"] = "title";
        ProcessPropertyType["ShellType"] = "shellType";
        ProcessPropertyType["HasChildProcesses"] = "hasChildProcesses";
        ProcessPropertyType["ResolvedShellLaunchConfig"] = "resolvedShellLaunchConfig";
        ProcessPropertyType["OverrideDimensions"] = "overrideDimensions";
        ProcessPropertyType["FailedShellIntegrationActivation"] = "failedShellIntegrationActivation";
        ProcessPropertyType["UsedShellIntegrationInjection"] = "usedShellIntegrationInjection";
    })(ProcessPropertyType || (exports.ProcessPropertyType = ProcessPropertyType = {}));
    exports.$ps = (0, instantiation_1.$Fi)('ptyService');
    var HeartbeatConstants;
    (function (HeartbeatConstants) {
        /**
         * The duration between heartbeats
         */
        HeartbeatConstants[HeartbeatConstants["BeatInterval"] = 5000] = "BeatInterval";
        /**
         * The duration of the first heartbeat while the pty host is starting up. This is much larger
         * than the regular BeatInterval to accommodate slow machines, we still want to warn about the
         * pty host's unresponsiveness eventually though.
         */
        HeartbeatConstants[HeartbeatConstants["ConnectingBeatInterval"] = 20000] = "ConnectingBeatInterval";
        /**
         * Defines a multiplier for BeatInterval for how long to wait before starting the second wait
         * timer.
         */
        HeartbeatConstants[HeartbeatConstants["FirstWaitMultiplier"] = 1.2] = "FirstWaitMultiplier";
        /**
         * Defines a multiplier for BeatInterval for how long to wait before telling the user about
         * non-responsiveness. The second timer is to avoid informing the user incorrectly when waking
         * the computer up from sleep
         */
        HeartbeatConstants[HeartbeatConstants["SecondWaitMultiplier"] = 1] = "SecondWaitMultiplier";
        /**
         * How long to wait before telling the user about non-responsiveness when they try to create a
         * process. This short circuits the standard wait timeouts to tell the user sooner and only
         * create process is handled to avoid additional perf overhead.
         */
        HeartbeatConstants[HeartbeatConstants["CreateProcessTimeout"] = 5000] = "CreateProcessTimeout";
    })(HeartbeatConstants || (exports.HeartbeatConstants = HeartbeatConstants = {}));
    var TerminalLocation;
    (function (TerminalLocation) {
        TerminalLocation[TerminalLocation["Panel"] = 1] = "Panel";
        TerminalLocation[TerminalLocation["Editor"] = 2] = "Editor";
    })(TerminalLocation || (exports.TerminalLocation = TerminalLocation = {}));
    var TerminalLocationString;
    (function (TerminalLocationString) {
        TerminalLocationString["TerminalView"] = "view";
        TerminalLocationString["Editor"] = "editor";
    })(TerminalLocationString || (exports.TerminalLocationString = TerminalLocationString = {}));
    var LocalReconnectConstants;
    (function (LocalReconnectConstants) {
        /**
         * If there is no reconnection within this time-frame, consider the connection permanently closed...
        */
        LocalReconnectConstants[LocalReconnectConstants["GraceTime"] = 60000] = "GraceTime";
        /**
         * Maximal grace time between the first and the last reconnection...
        */
        LocalReconnectConstants[LocalReconnectConstants["ShortGraceTime"] = 6000] = "ShortGraceTime";
    })(LocalReconnectConstants || (exports.LocalReconnectConstants = LocalReconnectConstants = {}));
    var FlowControlConstants;
    (function (FlowControlConstants) {
        /**
         * The number of _unacknowledged_ chars to have been sent before the pty is paused in order for
         * the client to catch up.
         */
        FlowControlConstants[FlowControlConstants["HighWatermarkChars"] = 100000] = "HighWatermarkChars";
        /**
         * After flow control pauses the pty for the client the catch up, this is the number of
         * _unacknowledged_ chars to have been caught up to on the client before resuming the pty again.
         * This is used to attempt to prevent pauses in the flowing data; ideally while the pty is
         * paused the number of unacknowledged chars would always be greater than 0 or the client will
         * appear to stutter. In reality this balance is hard to accomplish though so heavy commands
         * will likely pause as latency grows, not flooding the connection is the important thing as
         * it's shared with other core functionality.
         */
        FlowControlConstants[FlowControlConstants["LowWatermarkChars"] = 5000] = "LowWatermarkChars";
        /**
         * The number characters that are accumulated on the client side before sending an ack event.
         * This must be less than or equal to LowWatermarkChars or the terminal max never unpause.
         */
        FlowControlConstants[FlowControlConstants["CharCountAckSize"] = 5000] = "CharCountAckSize";
    })(FlowControlConstants || (exports.FlowControlConstants = FlowControlConstants = {}));
    var ProfileSource;
    (function (ProfileSource) {
        ProfileSource["GitBash"] = "Git Bash";
        ProfileSource["Pwsh"] = "PowerShell";
    })(ProfileSource || (exports.ProfileSource = ProfileSource = {}));
    var ShellIntegrationStatus;
    (function (ShellIntegrationStatus) {
        /** No shell integration sequences have been encountered. */
        ShellIntegrationStatus[ShellIntegrationStatus["Off"] = 0] = "Off";
        /** Final term shell integration sequences have been encountered. */
        ShellIntegrationStatus[ShellIntegrationStatus["FinalTerm"] = 1] = "FinalTerm";
        /** VS Code shell integration sequences have been encountered. Supercedes FinalTerm. */
        ShellIntegrationStatus[ShellIntegrationStatus["VSCode"] = 2] = "VSCode";
    })(ShellIntegrationStatus || (exports.ShellIntegrationStatus = ShellIntegrationStatus = {}));
    var TerminalExitReason;
    (function (TerminalExitReason) {
        TerminalExitReason[TerminalExitReason["Unknown"] = 0] = "Unknown";
        TerminalExitReason[TerminalExitReason["Shutdown"] = 1] = "Shutdown";
        TerminalExitReason[TerminalExitReason["Process"] = 2] = "Process";
        TerminalExitReason[TerminalExitReason["User"] = 3] = "User";
        TerminalExitReason[TerminalExitReason["Extension"] = 4] = "Extension";
    })(TerminalExitReason || (exports.TerminalExitReason = TerminalExitReason = {}));
    exports.$qs = {
        Backend: 'workbench.contributions.terminal.processBackend'
    };
    class TerminalBackendRegistry {
        constructor() {
            this.a = new Map();
        }
        get backends() { return this.a; }
        registerTerminalBackend(backend) {
            const key = this.b(backend.remoteAuthority);
            if (this.a.has(key)) {
                throw new Error(`A terminal backend with remote authority '${key}' was already registered.`);
            }
            this.a.set(key, backend);
        }
        getTerminalBackend(remoteAuthority) {
            return this.a.get(this.b(remoteAuthority));
        }
        b(remoteAuthority) {
            // Normalize the key to lowercase as the authority is case-insensitive
            return remoteAuthority?.toLowerCase() ?? '';
        }
    }
    platform_1.$ro.add(exports.$qs.Backend, new TerminalBackendRegistry());
    exports.$rs = (0, instantiation_1.$Fi)('localPtyService');
    exports.$ss = (0, instantiation_1.$Fi)('terminalLogService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[181/*vs/platform/terminal/common/terminalDataBuffering*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Uxb = void 0;
    class $Uxb {
        constructor(b) {
            this.b = b;
            this.a = new Map();
        }
        dispose() {
            for (const buffer of this.a.values()) {
                buffer.dispose();
            }
        }
        startBuffering(id, event, throttleBy = 5) {
            const disposable = event((e) => {
                const data = (typeof e === 'string' ? e : e.data);
                let buffer = this.a.get(id);
                if (buffer) {
                    buffer.data.push(data);
                    return;
                }
                const timeoutId = setTimeout(() => this.flushBuffer(id), throttleBy);
                buffer = {
                    data: [data],
                    timeoutId: timeoutId,
                    dispose: () => {
                        clearTimeout(timeoutId);
                        this.flushBuffer(id);
                        disposable.dispose();
                    }
                };
                this.a.set(id, buffer);
            });
            return disposable;
        }
        stopBuffering(id) {
            const buffer = this.a.get(id);
            buffer?.dispose();
        }
        flushBuffer(id) {
            const buffer = this.a.get(id);
            if (buffer) {
                this.a.delete(id);
                this.b(id, buffer.data.join(''));
            }
        }
    }
    exports.$Uxb = $Uxb;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[182/*vs/platform/theme/common/iconRegistry*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,97/*vs/base/common/codicons*/,282/*vs/base/common/codiconsUtil*/,34/*vs/base/common/themables*/,6/*vs/base/common/event*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,9/*vs/nls*/,77/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, async_1, codicons_1, codiconsUtil_1, themables_1, event_1, types_1, uri_1, nls_1, jsonContributionRegistry_1, platform) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ix = exports.$Hx = exports.$Gx = exports.$Fx = exports.$Ex = exports.$Dx = exports.IconFontDefinition = exports.IconContribution = exports.$Ax = void 0;
    exports.$Bx = $Bx;
    exports.$Cx = $Cx;
    platform = __importStar(platform);
    //  ------ API types
    // icon registry
    exports.$Ax = {
        IconContribution: 'base.contributions.icons'
    };
    var IconContribution;
    (function (IconContribution) {
        function getDefinition(contribution, registry) {
            let definition = contribution.defaults;
            while (themables_1.ThemeIcon.isThemeIcon(definition)) {
                const c = iconRegistry.getIcon(definition.id);
                if (!c) {
                    return undefined;
                }
                definition = c.defaults;
            }
            return definition;
        }
        IconContribution.getDefinition = getDefinition;
    })(IconContribution || (exports.IconContribution = IconContribution = {}));
    var IconFontDefinition;
    (function (IconFontDefinition) {
        function toJSONObject(iconFont) {
            return {
                weight: iconFont.weight,
                style: iconFont.style,
                src: iconFont.src.map(s => ({ format: s.format, location: s.location.toString() }))
            };
        }
        IconFontDefinition.toJSONObject = toJSONObject;
        function fromJSONObject(json) {
            const stringOrUndef = (s) => (0, types_1.$eg)(s) ? s : undefined;
            if (json && Array.isArray(json.src) && json.src.every((s) => (0, types_1.$eg)(s.format) && (0, types_1.$eg)(s.location))) {
                return {
                    weight: stringOrUndef(json.weight),
                    style: stringOrUndef(json.style),
                    src: json.src.map((s) => ({ format: s.format, location: uri_1.URI.parse(s.location) }))
                };
            }
            return undefined;
        }
        IconFontDefinition.fromJSONObject = fromJSONObject;
    })(IconFontDefinition || (exports.IconFontDefinition = IconFontDefinition = {}));
    class IconRegistry {
        constructor() {
            this.a = new event_1.$le();
            this.onDidChange = this.a.event;
            this.d = {
                definitions: {
                    icons: {
                        type: 'object',
                        properties: {
                            fontId: { type: 'string', description: (0, nls_1.localize)(10621, null) },
                            fontCharacter: { type: 'string', description: (0, nls_1.localize)(10622, null) }
                        },
                        additionalProperties: false,
                        defaultSnippets: [{ body: { fontCharacter: '\\\\e030' } }]
                    }
                },
                type: 'object',
                properties: {}
            };
            this.e = { type: 'string', pattern: `^${themables_1.ThemeIcon.iconNameExpression}$`, enum: [], enumDescriptions: [] };
            this.b = {};
            this.f = {};
        }
        registerIcon(id, defaults, description, deprecationMessage) {
            const existing = this.b[id];
            if (existing) {
                if (description && !existing.description) {
                    existing.description = description;
                    this.d.properties[id].markdownDescription = `${description} $(${id})`;
                    const enumIndex = this.e.enum.indexOf(id);
                    if (enumIndex !== -1) {
                        this.e.enumDescriptions[enumIndex] = description;
                    }
                    this.a.fire();
                }
                return existing;
            }
            const iconContribution = { id, description, defaults, deprecationMessage };
            this.b[id] = iconContribution;
            const propertySchema = { $ref: '#/definitions/icons' };
            if (deprecationMessage) {
                propertySchema.deprecationMessage = deprecationMessage;
            }
            if (description) {
                propertySchema.markdownDescription = `${description}: $(${id})`;
            }
            this.d.properties[id] = propertySchema;
            this.e.enum.push(id);
            this.e.enumDescriptions.push(description || '');
            this.a.fire();
            return { id };
        }
        deregisterIcon(id) {
            delete this.b[id];
            delete this.d.properties[id];
            const index = this.e.enum.indexOf(id);
            if (index !== -1) {
                this.e.enum.splice(index, 1);
                this.e.enumDescriptions.splice(index, 1);
            }
            this.a.fire();
        }
        getIcons() {
            return Object.keys(this.b).map(id => this.b[id]);
        }
        getIcon(id) {
            return this.b[id];
        }
        getIconSchema() {
            return this.d;
        }
        getIconReferenceSchema() {
            return this.e;
        }
        registerIconFont(id, definition) {
            const existing = this.f[id];
            if (existing) {
                return existing;
            }
            this.f[id] = definition;
            this.a.fire();
            return definition;
        }
        deregisterIconFont(id) {
            delete this.f[id];
        }
        getIconFont(id) {
            return this.f[id];
        }
        toString() {
            const sorter = (i1, i2) => {
                return i1.id.localeCompare(i2.id);
            };
            const classNames = (i) => {
                while (themables_1.ThemeIcon.isThemeIcon(i.defaults)) {
                    i = this.b[i.defaults.id];
                }
                return `codicon codicon-${i ? i.id : ''}`;
            };
            const reference = [];
            reference.push(`| preview     | identifier                        | default codicon ID                | description`);
            reference.push(`| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |`);
            const contributions = Object.keys(this.b).map(key => this.b[key]);
            for (const i of contributions.filter(i => !!i.description).sort(sorter)) {
                reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|${themables_1.ThemeIcon.isThemeIcon(i.defaults) ? i.defaults.id : i.id}|${i.description || ''}|`);
            }
            reference.push(`| preview     | identifier                        `);
            reference.push(`| ----------- | --------------------------------- |`);
            for (const i of contributions.filter(i => !themables_1.ThemeIcon.isThemeIcon(i.defaults)).sort(sorter)) {
                reference.push(`|<i class="${classNames(i)}"></i>|${i.id}|`);
            }
            return reference.join('\n');
        }
    }
    const iconRegistry = new IconRegistry();
    platform.$ro.add(exports.$Ax.IconContribution, iconRegistry);
    function $Bx(id, defaults, description, deprecationMessage) {
        return iconRegistry.registerIcon(id, defaults, description, deprecationMessage);
    }
    function $Cx() {
        return iconRegistry;
    }
    function initialize() {
        const codiconFontCharacters = (0, codiconsUtil_1.$1j)();
        for (const icon in codiconFontCharacters) {
            const fontCharacter = '\\' + codiconFontCharacters[icon].toString(16);
            iconRegistry.registerIcon(icon, { fontCharacter });
        }
    }
    initialize();
    exports.$Dx = 'vscode://schemas/icons';
    const schemaRegistry = platform.$ro.as(jsonContributionRegistry_1.$so.JSONContribution);
    schemaRegistry.registerSchema(exports.$Dx, iconRegistry.getIconSchema());
    const delayer = new async_1.$Rh(() => schemaRegistry.notifySchemaChanged(exports.$Dx), 200);
    iconRegistry.onDidChange(() => {
        if (!delayer.isScheduled()) {
            delayer.schedule();
        }
    });
    //setTimeout(_ => console.log(iconRegistry.toString()), 5000);
    // common icons
    exports.$Ex = $Bx('widget-close', codicons_1.$5j.close, (0, nls_1.localize)(10623, null));
    exports.$Fx = $Bx('goto-previous-location', codicons_1.$5j.arrowUp, (0, nls_1.localize)(10624, null));
    exports.$Gx = $Bx('goto-next-location', codicons_1.$5j.arrowDown, (0, nls_1.localize)(10625, null));
    exports.$Hx = themables_1.ThemeIcon.modify(codicons_1.$5j.sync, 'spin');
    exports.$Ix = themables_1.ThemeIcon.modify(codicons_1.$5j.loading, 'spin');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[183/*vs/platform/tunnel/common/tunnel*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,20/*vs/base/common/platform*/,2/*vs/base/common/uri*/,43/*vs/platform/configuration/common/configuration*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/]), function (require, exports, event_1, lifecycle_1, platform_1, uri_1, configuration_1, instantiation_1, log_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Pw = exports.$Ow = exports.$Lw = exports.$Jw = exports.ProvidedOnAutoForward = exports.TunnelPrivacyId = exports.TunnelProtocol = exports.$Fw = exports.$Ew = void 0;
    exports.$Gw = $Gw;
    exports.$Hw = $Hw;
    exports.$Iw = $Iw;
    exports.$Kw = $Kw;
    exports.$Mw = $Mw;
    exports.$Nw = $Nw;
    exports.$Ew = (0, instantiation_1.$Fi)('tunnelService');
    exports.$Fw = (0, instantiation_1.$Fi)('sharedTunnelsService');
    var TunnelProtocol;
    (function (TunnelProtocol) {
        TunnelProtocol["Http"] = "http";
        TunnelProtocol["Https"] = "https";
    })(TunnelProtocol || (exports.TunnelProtocol = TunnelProtocol = {}));
    var TunnelPrivacyId;
    (function (TunnelPrivacyId) {
        TunnelPrivacyId["ConstantPrivate"] = "constantPrivate";
        TunnelPrivacyId["Private"] = "private";
        TunnelPrivacyId["Public"] = "public";
    })(TunnelPrivacyId || (exports.TunnelPrivacyId = TunnelPrivacyId = {}));
    function $Gw(addressOrTunnelProvider) {
        return !!addressOrTunnelProvider.forwardPort;
    }
    var ProvidedOnAutoForward;
    (function (ProvidedOnAutoForward) {
        ProvidedOnAutoForward[ProvidedOnAutoForward["Notify"] = 1] = "Notify";
        ProvidedOnAutoForward[ProvidedOnAutoForward["OpenBrowser"] = 2] = "OpenBrowser";
        ProvidedOnAutoForward[ProvidedOnAutoForward["OpenPreview"] = 3] = "OpenPreview";
        ProvidedOnAutoForward[ProvidedOnAutoForward["Silent"] = 4] = "Silent";
        ProvidedOnAutoForward[ProvidedOnAutoForward["Ignore"] = 5] = "Ignore";
        ProvidedOnAutoForward[ProvidedOnAutoForward["OpenBrowserOnce"] = 6] = "OpenBrowserOnce";
    })(ProvidedOnAutoForward || (exports.ProvidedOnAutoForward = ProvidedOnAutoForward = {}));
    function $Hw(uri) {
        if (uri.scheme !== 'http' && uri.scheme !== 'https') {
            return undefined;
        }
        const localhostMatch = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(uri.authority);
        if (!localhostMatch) {
            return undefined;
        }
        return {
            address: localhostMatch[1],
            port: +localhostMatch[2],
        };
    }
    function $Iw(uri) {
        if (uri.scheme !== 'http' && uri.scheme !== 'https' || !uri.query) {
            return undefined;
        }
        const keyvalues = uri.query.split('&');
        for (const keyvalue of keyvalues) {
            const value = keyvalue.split('=')[1];
            if (/^https?:/.exec(value)) {
                const result = $Hw(uri_1.URI.parse(value));
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
    exports.$Jw = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];
    function $Kw(host) {
        return exports.$Jw.indexOf(host) >= 0;
    }
    exports.$Lw = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];
    function $Mw(host) {
        return exports.$Lw.indexOf(host) >= 0;
    }
    function $Nw(port, host, os, osRelease) {
        if (os === platform_1.OperatingSystem.Windows) {
            return false;
        }
        if (os === platform_1.OperatingSystem.Macintosh) {
            if ($Mw(host)) {
                const osVersion = (/(\d+)\.(\d+)\.(\d+)/g).exec(osRelease);
                if (osVersion?.length === 4) {
                    const major = parseInt(osVersion[1]);
                    if (major >= 18 /* since macOS Mojave, darwin version 18.0.0 */) {
                        return false;
                    }
                }
            }
        }
        return port < 1024;
    }
    class $Ow {
        constructor(remoteAddress, localAddress, b) {
            this.remoteAddress = remoteAddress;
            this.localAddress = localAddress;
            this.b = b;
            this.a = new event_1.$le();
            this.onDidDispose = this.a.event;
        }
        dispose() {
            this.a.fire();
            return this.b();
        }
    }
    exports.$Ow = $Ow;
    let $Pw = class $Pw extends lifecycle_1.$Uc {
        constructor(r, s) {
            super();
            this.r = r;
            this.s = s;
            this.a = new event_1.$le();
            this.onTunnelOpened = this.a.event;
            this.b = new event_1.$le();
            this.onTunnelClosed = this.b.event;
            this.c = new event_1.$le();
            this.onAddedTunnelProvider = this.c.event;
            this.f = new Map();
            this.h = false;
            this.j = true;
            this.m = [];
            this.n = new Set();
        }
        get hasTunnelProvider() {
            return !!this.g;
        }
        get t() {
            const settingValue = this.s.getValue('remote.localPortHost');
            return (!settingValue || settingValue === 'localhost') ? '127.0.0.1' : '0.0.0.0';
        }
        setTunnelProvider(provider) {
            this.g = provider;
            if (!provider) {
                // clear features
                this.h = false;
                this.m = [];
                this.c.fire();
                return {
                    dispose: () => { }
                };
            }
            this.c.fire();
            return {
                dispose: () => {
                    this.g = undefined;
                    this.h = false;
                    this.m = [];
                }
            };
        }
        setTunnelFeatures(features) {
            this.h = features.elevation;
            this.m = features.privacyOptions;
            this.j = features.protocol;
        }
        get canChangeProtocol() {
            return this.j;
        }
        get canElevate() {
            return this.h;
        }
        get canChangePrivacy() {
            return this.m.length > 0;
        }
        get privacyOptions() {
            return this.m;
        }
        get tunnels() {
            return this.u();
        }
        async u() {
            const tunnels = [];
            const tunnelArray = Array.from(this.f.values());
            for (const portMap of tunnelArray) {
                const portArray = Array.from(portMap.values());
                for (const x of portArray) {
                    const tunnelValue = await x.value;
                    if (tunnelValue && (typeof tunnelValue !== 'string')) {
                        tunnels.push(tunnelValue);
                    }
                }
            }
            return tunnels;
        }
        async dispose() {
            super.dispose();
            for (const portMap of this.f.values()) {
                for (const { value } of portMap.values()) {
                    await value.then(tunnel => typeof tunnel !== 'string' ? tunnel?.dispose() : undefined);
                }
                portMap.clear();
            }
            this.f.clear();
        }
        setEnvironmentTunnel(remoteHost, remotePort, localAddress, privacy, protocol) {
            this.z(remoteHost, remotePort, Promise.resolve({
                tunnelRemoteHost: remoteHost,
                tunnelRemotePort: remotePort,
                localAddress,
                privacy,
                protocol,
                dispose: () => Promise.resolve()
            }));
        }
        async getExistingTunnel(remoteHost, remotePort) {
            if ($Mw(remoteHost) || $Kw(remoteHost)) {
                remoteHost = exports.$Jw[0];
            }
            const existing = this.D(remoteHost, remotePort);
            if (existing) {
                ++existing.refcount;
                return existing.value;
            }
            return undefined;
        }
        openTunnel(addressProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded = false, privacy, protocol) {
            this.r.trace(`ForwardedPorts: (TunnelService) openTunnel request for ${remoteHost}:${remotePort} on local port ${localPort}.`);
            const addressOrTunnelProvider = this.g ?? addressProvider;
            if (!addressOrTunnelProvider) {
                return undefined;
            }
            if (!remoteHost) {
                remoteHost = 'localhost';
            }
            if (!localHost) {
                localHost = this.t;
            }
            // Prevent tunnel factories from calling openTunnel from within the factory
            if (this.g && this.n.has(remotePort)) {
                this.r.debug(`ForwardedPorts: (TunnelService) Another call to create a tunnel with the same address has occurred before the last one completed. This call will be ignored.`);
                return;
            }
            const resolvedTunnel = this.F(addressOrTunnelProvider, remoteHost, remotePort, localHost, localPort, elevateIfNeeded, privacy, protocol);
            if (!resolvedTunnel) {
                this.r.trace(`ForwardedPorts: (TunnelService) Tunnel was not created.`);
                return resolvedTunnel;
            }
            return resolvedTunnel.then(tunnel => {
                if (!tunnel) {
                    this.r.trace('ForwardedPorts: (TunnelService) New tunnel is undefined.');
                    this.C(remoteHost, remotePort);
                    return undefined;
                }
                else if (typeof tunnel === 'string') {
                    this.r.trace('ForwardedPorts: (TunnelService) The tunnel provider returned an error when creating the tunnel.');
                    this.C(remoteHost, remotePort);
                    return tunnel;
                }
                this.r.trace('ForwardedPorts: (TunnelService) New tunnel established.');
                const newTunnel = this.w(tunnel);
                if (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {
                    this.r.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');
                }
                if (privacy && tunnel.privacy !== privacy) {
                    this.r.warn('ForwardedPorts: (TunnelService) Created tunnel does not match requirements of requested tunnel. Privacy mismatch.');
                }
                this.a.fire(newTunnel);
                return newTunnel;
            });
        }
        w(tunnel) {
            return {
                tunnelRemotePort: tunnel.tunnelRemotePort,
                tunnelRemoteHost: tunnel.tunnelRemoteHost,
                tunnelLocalPort: tunnel.tunnelLocalPort,
                localAddress: tunnel.localAddress,
                privacy: tunnel.privacy,
                protocol: tunnel.protocol,
                dispose: async () => {
                    this.r.trace(`ForwardedPorts: (TunnelService) dispose request for ${tunnel.tunnelRemoteHost}:${tunnel.tunnelRemotePort} `);
                    const existingHost = this.f.get(tunnel.tunnelRemoteHost);
                    if (existingHost) {
                        const existing = existingHost.get(tunnel.tunnelRemotePort);
                        if (existing) {
                            existing.refcount--;
                            await this.y(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);
                        }
                    }
                }
            };
        }
        async y(remoteHost, remotePort, tunnel) {
            if (tunnel.refcount <= 0) {
                this.r.trace(`ForwardedPorts: (TunnelService) Tunnel is being disposed ${remoteHost}:${remotePort}.`);
                const disposePromise = tunnel.value.then(async (tunnel) => {
                    if (tunnel && (typeof tunnel !== 'string')) {
                        await tunnel.dispose(true);
                        this.b.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });
                    }
                });
                if (this.f.has(remoteHost)) {
                    this.f.get(remoteHost).delete(remotePort);
                }
                return disposePromise;
            }
        }
        async closeTunnel(remoteHost, remotePort) {
            this.r.trace(`ForwardedPorts: (TunnelService) close request for ${remoteHost}:${remotePort} `);
            const portMap = this.f.get(remoteHost);
            if (portMap && portMap.has(remotePort)) {
                const value = portMap.get(remotePort);
                value.refcount = 0;
                await this.y(remoteHost, remotePort, value);
            }
        }
        z(remoteHost, remotePort, tunnel) {
            if (!this.f.has(remoteHost)) {
                this.f.set(remoteHost, new Map());
            }
            this.f.get(remoteHost).set(remotePort, { refcount: 1, value: tunnel });
        }
        async C(remoteHost, remotePort) {
            const hostMap = this.f.get(remoteHost);
            if (hostMap) {
                const tunnel = hostMap.get(remotePort);
                const tunnelResult = tunnel ? await tunnel.value : undefined;
                if (!tunnelResult || (typeof tunnelResult === 'string')) {
                    hostMap.delete(remotePort);
                }
                if (hostMap.size === 0) {
                    this.f.delete(remoteHost);
                }
            }
        }
        D(remoteHost, remotePort) {
            const hosts = [remoteHost];
            // Order matters. We want the original host to be first.
            if ($Kw(remoteHost)) {
                hosts.push(...exports.$Jw);
                // For localhost, we add the all interfaces hosts because if the tunnel is already available at all interfaces,
                // then of course it is available at localhost.
                hosts.push(...exports.$Lw);
            }
            else if ($Mw(remoteHost)) {
                hosts.push(...exports.$Lw);
            }
            const existingPortMaps = hosts.map(host => this.f.get(host));
            for (const map of existingPortMaps) {
                const existingTunnel = map?.get(remotePort);
                if (existingTunnel) {
                    return existingTunnel;
                }
            }
            return undefined;
        }
        canTunnel(uri) {
            return !!$Hw(uri);
        }
        G(tunnelProvider, remoteHost, remotePort, localPort, elevateIfNeeded, privacy, protocol) {
            this.r.trace(`ForwardedPorts: (TunnelService) Creating tunnel with provider ${remoteHost}:${remotePort} on local port ${localPort}.`);
            const key = remotePort;
            this.n.add(key);
            const preferredLocalPort = localPort === undefined ? remotePort : localPort;
            const creationInfo = { elevationRequired: elevateIfNeeded ? this.isPortPrivileged(preferredLocalPort) : false };
            const tunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort, privacy, public: privacy ? (privacy !== TunnelPrivacyId.Private) : undefined, protocol };
            const tunnel = tunnelProvider.forwardPort(tunnelOptions, creationInfo);
            if (tunnel) {
                this.z(remoteHost, remotePort, tunnel);
                tunnel.finally(() => {
                    this.r.trace('ForwardedPorts: (TunnelService) Tunnel created by provider.');
                    this.n.delete(key);
                });
            }
            else {
                this.n.delete(key);
            }
            return tunnel;
        }
    };
    exports.$Pw = $Pw;
    exports.$Pw = $Pw = __decorate([
        __param(0, log_1.$ak),
        __param(1, configuration_1.$_i)
    ], $Pw);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[184/*vs/platform/uriIdentity/common/uriIdentity*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Kl = void 0;
    exports.$Kl = (0, instantiation_1.$Fi)('IUriIdentityService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[185/*vs/platform/workspace/common/editSessions*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditSessionIdentityMatch = exports.$Qw = void 0;
    exports.$Qw = (0, instantiation_1.$Fi)('editSessionIdentityService');
    var EditSessionIdentityMatch;
    (function (EditSessionIdentityMatch) {
        EditSessionIdentityMatch[EditSessionIdentityMatch["Complete"] = 100] = "Complete";
        EditSessionIdentityMatch[EditSessionIdentityMatch["Partial"] = 50] = "Partial";
        EditSessionIdentityMatch[EditSessionIdentityMatch["None"] = 0] = "None";
    })(EditSessionIdentityMatch || (exports.EditSessionIdentityMatch = EditSessionIdentityMatch = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[186/*vs/platform/workspace/common/virtualWorkspace*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/network*/]), function (require, exports, network_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$hN = $hN;
    exports.$iN = $iN;
    exports.$jN = $jN;
    exports.$kN = $kN;
    exports.$lN = $lN;
    function $hN(resource) {
        return resource.scheme !== network_1.Schemas.file && resource.scheme !== network_1.Schemas.vscodeRemote;
    }
    function $iN(workspace) {
        if (workspace.folders.length) {
            return workspace.folders.every(f => $hN(f.uri)) ? workspace.folders[0].uri : undefined;
        }
        else if (workspace.configuration && $hN(workspace.configuration)) {
            return workspace.configuration;
        }
        return undefined;
    }
    function $jN(workspace) {
        return $iN(workspace)?.scheme;
    }
    function $kN(workspace) {
        return $iN(workspace)?.authority;
    }
    function $lN(workspace) {
        return $iN(workspace) !== undefined;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[49/*vs/platform/workspace/common/workspace*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,19/*vs/base/common/path*/,58/*vs/base/common/ternarySearchTree*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,15/*vs/base/common/network*/]), function (require, exports, nls_1, path_1, ternarySearchTree_1, resources_1, uri_1, instantiation_1, network_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$8i = exports.$5i = exports.$4i = exports.$3i = exports.$2i = exports.$Zi = exports.$Yi = exports.WorkbenchState = exports.$Si = exports.$Ri = exports.$Oi = void 0;
    exports.$Pi = $Pi;
    exports.$Qi = $Qi;
    exports.$Ti = $Ti;
    exports.$Ui = $Ui;
    exports.$Vi = $Vi;
    exports.$Wi = $Wi;
    exports.$Xi = $Xi;
    exports.$1i = $1i;
    exports.$6i = $6i;
    exports.$7i = $7i;
    exports.$9i = $9i;
    exports.$0i = $0i;
    exports.$$i = $$i;
    exports.$Oi = (0, instantiation_1.$Fi)('contextService');
    function $Pi(obj) {
        const singleFolderIdentifier = obj;
        return typeof singleFolderIdentifier?.id === 'string' && uri_1.URI.isUri(singleFolderIdentifier.uri);
    }
    function $Qi(obj) {
        const emptyWorkspaceIdentifier = obj;
        return typeof emptyWorkspaceIdentifier?.id === 'string'
            && !$Pi(obj)
            && !$Ui(obj);
    }
    exports.$Ri = { id: 'ext-dev' };
    exports.$Si = { id: 'empty-window' };
    function $Ti(arg0, isExtensionDevelopment) {
        // Empty workspace
        if (typeof arg0 === 'string' || typeof arg0 === 'undefined') {
            // With a backupPath, the basename is the empty workspace identifier
            if (typeof arg0 === 'string') {
                return {
                    id: (0, path_1.$nc)(arg0)
                };
            }
            // Extension development empty windows have backups disabled
            // so we return a constant workspace identifier for extension
            // authors to allow to restore their workspace state even then.
            if (isExtensionDevelopment) {
                return exports.$Ri;
            }
            return exports.$Si;
        }
        // Multi root
        const workspace = arg0;
        if (workspace.configuration) {
            return {
                id: workspace.id,
                configPath: workspace.configuration
            };
        }
        // Single folder
        if (workspace.folders.length === 1) {
            return {
                id: workspace.id,
                uri: workspace.folders[0].uri
            };
        }
        // Empty window
        return {
            id: workspace.id
        };
    }
    function $Ui(obj) {
        const workspaceIdentifier = obj;
        return typeof workspaceIdentifier?.id === 'string' && uri_1.URI.isUri(workspaceIdentifier.configPath);
    }
    function $Vi(identifier) {
        // Single Folder
        const singleFolderIdentifierCandidate = identifier;
        if (singleFolderIdentifierCandidate?.uri) {
            return { id: singleFolderIdentifierCandidate.id, uri: uri_1.URI.revive(singleFolderIdentifierCandidate.uri) };
        }
        // Multi folder
        const workspaceIdentifierCandidate = identifier;
        if (workspaceIdentifierCandidate?.configPath) {
            return { id: workspaceIdentifierCandidate.id, configPath: uri_1.URI.revive(workspaceIdentifierCandidate.configPath) };
        }
        // Empty
        if (identifier?.id) {
            return { id: identifier.id };
        }
        return undefined;
    }
    var WorkbenchState;
    (function (WorkbenchState) {
        WorkbenchState[WorkbenchState["EMPTY"] = 1] = "EMPTY";
        WorkbenchState[WorkbenchState["FOLDER"] = 2] = "FOLDER";
        WorkbenchState[WorkbenchState["WORKSPACE"] = 3] = "WORKSPACE";
    })(WorkbenchState || (exports.WorkbenchState = WorkbenchState = {}));
    function $Wi(thing) {
        const candidate = thing;
        return !!(candidate && typeof candidate === 'object'
            && typeof candidate.id === 'string'
            && Array.isArray(candidate.folders));
    }
    function $Xi(thing) {
        const candidate = thing;
        return !!(candidate && typeof candidate === 'object'
            && uri_1.URI.isUri(candidate.uri)
            && typeof candidate.name === 'string'
            && typeof candidate.toResource === 'function');
    }
    class $Yi {
        constructor(h, folders, j, k, l) {
            this.h = h;
            this.j = j;
            this.k = k;
            this.l = l;
            this.c = ternarySearchTree_1.$Li.forUris(this.l, () => true);
            this.folders = folders;
        }
        update(workspace) {
            this.h = workspace.id;
            this.k = workspace.configuration;
            this.j = workspace.transient;
            this.l = workspace.l;
            this.folders = workspace.folders;
        }
        get folders() {
            return this.g;
        }
        set folders(folders) {
            this.g = folders;
            this.n();
        }
        get id() {
            return this.h;
        }
        get transient() {
            return this.j;
        }
        get configuration() {
            return this.k;
        }
        set configuration(configuration) {
            this.k = configuration;
        }
        getFolder(resource) {
            if (!resource) {
                return null;
            }
            return this.c.findSubstr(resource) || null;
        }
        n() {
            this.c = ternarySearchTree_1.$Li.forUris(this.l, () => true);
            for (const folder of this.folders) {
                this.c.set(folder.uri, folder);
            }
        }
        toJSON() {
            return { id: this.id, folders: this.folders, transient: this.transient, configuration: this.configuration };
        }
    }
    exports.$Yi = $Yi;
    class $Zi {
        constructor(data, 
        /**
         * Provides access to the original metadata for this workspace
         * folder. This can be different from the metadata provided in
         * this class:
         * - raw paths can be relative
         * - raw paths are not normalized
         */
        raw) {
            this.raw = raw;
            this.uri = data.uri;
            this.index = data.index;
            this.name = data.name;
        }
        toResource(relativePath) {
            return (0, resources_1.$gh)(this.uri, relativePath);
        }
        toJSON() {
            return { uri: this.uri, name: this.name, index: this.index };
        }
    }
    exports.$Zi = $Zi;
    function $1i(resource) {
        return new $Zi({ uri: resource, index: 0, name: (0, resources_1.$ch)(resource) }, { uri: resource.toString() });
    }
    exports.$2i = 'code-workspace';
    exports.$3i = `.${exports.$2i}`;
    exports.$4i = [{ name: (0, nls_1.localize)(10500, null), extensions: [exports.$2i] }];
    exports.$5i = 'workspace.json';
    function $6i(path, environmentService) {
        return resources_1.$0g.isEqualOrParent(path, environmentService.untitledWorkspacesHome);
    }
    function $7i(arg1) {
        let path;
        if (uri_1.URI.isUri(arg1)) {
            path = arg1;
        }
        else {
            path = arg1.configuration;
        }
        return path?.scheme === network_1.Schemas.tmp;
    }
    exports.$8i = '4064f6ec-cb38-4ad0-af64-ee6467e63c82';
    function $9i(workspace) {
        return workspace.id === exports.$8i;
    }
    function $0i(path, environmentService) {
        return !$6i(path, environmentService) && !$7i(path);
    }
    function $$i(path) {
        const ext = (typeof path === 'string') ? (0, path_1.$oc)(path) : (0, resources_1.$eh)(path);
        return ext === exports.$3i;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[113/*vs/platform/userDataProfile/common/userDataProfile*/], __M([1/*require*/,0/*exports*/,75/*vs/base/common/hash*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,9/*vs/nls*/,106/*vs/platform/environment/common/environment*/,29/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,49/*vs/platform/workspace/common/workspace*/,28/*vs/base/common/map*/,184/*vs/platform/uriIdentity/common/uriIdentity*/,10/*vs/base/common/async*/,38/*vs/base/common/uuid*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/]), function (require, exports, hash_1, event_1, lifecycle_1, resources_1, uri_1, nls_1, environment_1, files_1, instantiation_1, log_1, workspace_1, map_1, uriIdentity_1, async_1, uuid_1, strings_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ql = exports.$Pl = exports.$Ml = exports.ProfileResourceType = void 0;
    exports.$Ll = $Ll;
    exports.$Nl = $Nl;
    exports.$Ol = $Ol;
    var ProfileResourceType;
    (function (ProfileResourceType) {
        ProfileResourceType["Settings"] = "settings";
        ProfileResourceType["Keybindings"] = "keybindings";
        ProfileResourceType["Snippets"] = "snippets";
        ProfileResourceType["Tasks"] = "tasks";
        ProfileResourceType["Extensions"] = "extensions";
        ProfileResourceType["GlobalState"] = "globalState";
    })(ProfileResourceType || (exports.ProfileResourceType = ProfileResourceType = {}));
    function $Ll(thing) {
        const candidate = thing;
        return !!(candidate && typeof candidate === 'object'
            && typeof candidate.id === 'string'
            && typeof candidate.isDefault === 'boolean'
            && typeof candidate.name === 'string'
            && uri_1.URI.isUri(candidate.location)
            && uri_1.URI.isUri(candidate.globalStorageHome)
            && uri_1.URI.isUri(candidate.settingsResource)
            && uri_1.URI.isUri(candidate.keybindingsResource)
            && uri_1.URI.isUri(candidate.tasksResource)
            && uri_1.URI.isUri(candidate.snippetsHome)
            && uri_1.URI.isUri(candidate.extensionsResource));
    }
    exports.$Ml = (0, instantiation_1.$Fi)('IUserDataProfilesService');
    function $Nl(profile, scheme) {
        return {
            id: profile.id,
            isDefault: profile.isDefault,
            name: profile.name,
            shortName: profile.shortName,
            icon: profile.icon,
            location: uri_1.URI.revive(profile.location).with({ scheme }),
            globalStorageHome: uri_1.URI.revive(profile.globalStorageHome).with({ scheme }),
            settingsResource: uri_1.URI.revive(profile.settingsResource).with({ scheme }),
            keybindingsResource: uri_1.URI.revive(profile.keybindingsResource).with({ scheme }),
            tasksResource: uri_1.URI.revive(profile.tasksResource).with({ scheme }),
            snippetsHome: uri_1.URI.revive(profile.snippetsHome).with({ scheme }),
            extensionsResource: uri_1.URI.revive(profile.extensionsResource).with({ scheme }),
            cacheHome: uri_1.URI.revive(profile.cacheHome).with({ scheme }),
            useDefaultFlags: profile.useDefaultFlags,
            isTransient: profile.isTransient,
        };
    }
    function $Ol(id, name, location, profilesCacheHome, options, defaultProfile) {
        return {
            id,
            name,
            location,
            isDefault: false,
            shortName: options?.shortName,
            icon: options?.icon,
            globalStorageHome: defaultProfile && options?.useDefaultFlags?.globalState ? defaultProfile.globalStorageHome : (0, resources_1.$gh)(location, 'globalStorage'),
            settingsResource: defaultProfile && options?.useDefaultFlags?.settings ? defaultProfile.settingsResource : (0, resources_1.$gh)(location, 'settings.json'),
            keybindingsResource: defaultProfile && options?.useDefaultFlags?.keybindings ? defaultProfile.keybindingsResource : (0, resources_1.$gh)(location, 'keybindings.json'),
            tasksResource: defaultProfile && options?.useDefaultFlags?.tasks ? defaultProfile.tasksResource : (0, resources_1.$gh)(location, 'tasks.json'),
            snippetsHome: defaultProfile && options?.useDefaultFlags?.snippets ? defaultProfile.snippetsHome : (0, resources_1.$gh)(location, 'snippets'),
            extensionsResource: defaultProfile && options?.useDefaultFlags?.extensions ? defaultProfile.extensionsResource : (0, resources_1.$gh)(location, 'extensions.json'),
            cacheHome: (0, resources_1.$gh)(profilesCacheHome, id),
            useDefaultFlags: options?.useDefaultFlags,
            isTransient: options?.transient
        };
    }
    let $Pl = class $Pl extends lifecycle_1.$Uc {
        static { this.b = 'userDataProfiles'; }
        static { this.c = 'profileAssociations'; }
        get defaultProfile() { return this.profiles[0]; }
        get profiles() { return [...this.C.profiles, ...this.s.profiles]; }
        constructor(t, u, w, y) {
            super();
            this.t = t;
            this.u = u;
            this.w = w;
            this.y = y;
            this.f = true;
            this.h = this.B(new event_1.$le());
            this.onDidChangeProfiles = this.h.event;
            this.j = this.B(new event_1.$le());
            this.onWillCreateProfile = this.j.event;
            this.m = this.B(new event_1.$le());
            this.onWillRemoveProfile = this.m.event;
            this.n = this.B(new event_1.$le());
            this.onDidResetWorkspaces = this.n.event;
            this.r = new Map();
            this.s = {
                profiles: [],
                folders: new map_1.$Ac(),
                workspaces: new map_1.$Ac(),
                emptyWindows: new Map()
            };
            this.profilesHome = (0, resources_1.$gh)(this.t.userRoamingDataHome, 'profiles');
            this.g = (0, resources_1.$gh)(this.t.cacheHome, 'CachedProfilesData');
        }
        init() {
            this.z = undefined;
        }
        setEnablement(enabled) {
            if (this.f !== enabled) {
                this.z = undefined;
                this.f = enabled;
            }
        }
        isEnabled() {
            return this.f;
        }
        get C() {
            if (!this.z) {
                const defaultProfile = this.D();
                const profiles = [defaultProfile];
                if (this.f) {
                    try {
                        for (const storedProfile of this.O()) {
                            if (!storedProfile.name || !(0, types_1.$eg)(storedProfile.name) || !storedProfile.location) {
                                this.y.warn('Skipping the invalid stored profile', storedProfile.location || storedProfile.name);
                                continue;
                            }
                            profiles.push($Ol((0, resources_1.$dh)(storedProfile.location), storedProfile.name, storedProfile.location, this.g, { shortName: storedProfile.shortName, icon: storedProfile.icon, useDefaultFlags: storedProfile.useDefaultFlags }, defaultProfile));
                        }
                    }
                    catch (error) {
                        this.y.error(error);
                    }
                }
                const workspaces = new map_1.$Ac();
                const emptyWindows = new Map();
                if (profiles.length) {
                    try {
                        const profileAssociaitions = this.Q();
                        if (profileAssociaitions.workspaces) {
                            for (const [workspacePath, profileId] of Object.entries(profileAssociaitions.workspaces)) {
                                const workspace = uri_1.URI.parse(workspacePath);
                                const profile = profiles.find(p => p.id === profileId);
                                if (profile) {
                                    workspaces.set(workspace, profile);
                                }
                            }
                        }
                        if (profileAssociaitions.emptyWindows) {
                            for (const [windowId, profileId] of Object.entries(profileAssociaitions.emptyWindows)) {
                                const profile = profiles.find(p => p.id === profileId);
                                if (profile) {
                                    emptyWindows.set(windowId, profile);
                                }
                            }
                        }
                    }
                    catch (error) {
                        this.y.error(error);
                    }
                }
                this.z = { profiles, workspaces, emptyWindows };
            }
            return this.z;
        }
        D() {
            const defaultProfile = $Ol('__default__profile__', (0, nls_1.localize)(10547, null), this.t.userRoamingDataHome, this.g);
            return { ...defaultProfile, extensionsResource: this.S() ?? defaultProfile.extensionsResource, isDefault: true };
        }
        async createTransientProfile(workspaceIdentifier) {
            const namePrefix = `Temp`;
            const nameRegEx = new RegExp(`${(0, strings_1.$hf)(namePrefix)}\\s(\\d+)`);
            let nameIndex = 0;
            for (const profile of this.profiles) {
                const matches = nameRegEx.exec(profile.name);
                const index = matches ? parseInt(matches[1]) : 0;
                nameIndex = index > nameIndex ? index : nameIndex;
            }
            const name = `${namePrefix} ${nameIndex + 1}`;
            return this.createProfile((0, hash_1.$tj)((0, uuid_1.$2g)()).toString(16), name, { transient: true }, workspaceIdentifier);
        }
        async createNamedProfile(name, options, workspaceIdentifier) {
            return this.createProfile((0, hash_1.$tj)((0, uuid_1.$2g)()).toString(16), name, options, workspaceIdentifier);
        }
        async createProfile(id, name, options, workspaceIdentifier) {
            if (!this.f) {
                throw new Error(`Profiles are disabled in the current environment.`);
            }
            const profile = await this.F(id, name, options);
            if (workspaceIdentifier) {
                await this.setProfileForWorkspace(workspaceIdentifier, profile);
            }
            return profile;
        }
        async F(id, name, options) {
            if (!(0, types_1.$eg)(name) || !name) {
                throw new Error('Name of the profile is mandatory and must be of type `string`');
            }
            let profileCreationPromise = this.r.get(name);
            if (!profileCreationPromise) {
                profileCreationPromise = (async () => {
                    try {
                        const existing = this.profiles.find(p => p.name === name || p.id === id);
                        if (existing) {
                            throw new Error(`Profile with ${name} name already exists`);
                        }
                        const profile = $Ol(id, name, (0, resources_1.$gh)(this.profilesHome, id), this.g, options, this.defaultProfile);
                        await this.u.createFolder(profile.location);
                        const joiners = [];
                        this.j.fire({
                            profile,
                            join(promise) {
                                joiners.push(promise);
                            }
                        });
                        await async_1.Promises.settled(joiners);
                        this.I([profile], [], []);
                        return profile;
                    }
                    finally {
                        this.r.delete(name);
                    }
                })();
                this.r.set(name, profileCreationPromise);
            }
            return profileCreationPromise;
        }
        async updateProfile(profileToUpdate, options) {
            if (!this.f) {
                throw new Error(`Profiles are disabled in the current environment.`);
            }
            let profile = this.profiles.find(p => p.id === profileToUpdate.id);
            if (!profile) {
                throw new Error(`Profile '${profileToUpdate.name}' does not exist`);
            }
            profile = $Ol(profile.id, options.name ?? profile.name, profile.location, this.g, {
                shortName: options.shortName ?? profile.shortName,
                icon: options.icon === null ? undefined : options.icon ?? profile.icon,
                transient: options.transient ?? profile.isTransient,
                useDefaultFlags: options.useDefaultFlags ?? profile.useDefaultFlags
            }, this.defaultProfile);
            this.I([], [], [profile]);
            return profile;
        }
        async removeProfile(profileToRemove) {
            if (!this.f) {
                throw new Error(`Profiles are disabled in the current environment.`);
            }
            if (profileToRemove.isDefault) {
                throw new Error('Cannot remove default profile');
            }
            const profile = this.profiles.find(p => p.id === profileToRemove.id);
            if (!profile) {
                throw new Error(`Profile '${profileToRemove.name}' does not exist`);
            }
            const joiners = [];
            this.m.fire({
                profile,
                join(promise) {
                    joiners.push(promise);
                }
            });
            try {
                await Promise.allSettled(joiners);
            }
            catch (error) {
                this.y.error(error);
            }
            for (const windowId of [...this.C.emptyWindows.keys()]) {
                if (profile.id === this.C.emptyWindows.get(windowId)?.id) {
                    this.C.emptyWindows.delete(windowId);
                }
            }
            for (const workspace of [...this.C.workspaces.keys()]) {
                if (profile.id === this.C.workspaces.get(workspace)?.id) {
                    this.C.workspaces.delete(workspace);
                }
            }
            this.M();
            this.I([], [profile], []);
            try {
                await this.u.del(profile.cacheHome, { recursive: true });
            }
            catch (error) {
                if ((0, files_1.$rl)(error) !== files_1.FileOperationResult.FILE_NOT_FOUND) {
                    this.y.error(error);
                }
            }
        }
        async setProfileForWorkspace(workspaceIdentifier, profileToSet) {
            if (!this.f) {
                throw new Error(`Profiles are disabled in the current environment.`);
            }
            const profile = this.profiles.find(p => p.id === profileToSet.id);
            if (!profile) {
                throw new Error(`Profile '${profileToSet.name}' does not exist`);
            }
            this.L(workspaceIdentifier, profile);
        }
        unsetWorkspace(workspaceIdentifier, transient) {
            if (!this.f) {
                throw new Error(`Profiles are disabled in the current environment.`);
            }
            this.L(workspaceIdentifier, undefined, transient);
        }
        async resetWorkspaces() {
            this.s.folders.clear();
            this.s.workspaces.clear();
            this.s.emptyWindows.clear();
            this.C.workspaces.clear();
            this.C.emptyWindows.clear();
            this.M();
            this.n.fire();
        }
        async cleanUp() {
            if (!this.f) {
                return;
            }
            if (await this.u.exists(this.profilesHome)) {
                const stat = await this.u.resolve(this.profilesHome);
                await Promise.all((stat.children || [])
                    .filter(child => child.isDirectory && this.profiles.every(p => !this.w.extUri.isEqual(p.location, child.resource)))
                    .map(child => this.u.del(child.resource, { recursive: true })));
            }
        }
        async cleanUpTransientProfiles() {
            if (!this.f) {
                return;
            }
            const unAssociatedTransientProfiles = this.s.profiles.filter(p => !this.H(p));
            await Promise.allSettled(unAssociatedTransientProfiles.map(p => this.removeProfile(p)));
        }
        getProfileForWorkspace(workspaceIdentifier) {
            const workspace = this.G(workspaceIdentifier);
            const profile = uri_1.URI.isUri(workspace) ? this.C.workspaces.get(workspace) : this.C.emptyWindows.get(workspace);
            if (profile) {
                return profile;
            }
            if ((0, workspace_1.$Pi)(workspaceIdentifier)) {
                return this.s.folders.get(workspaceIdentifier.uri);
            }
            if ((0, workspace_1.$Ui)(workspaceIdentifier)) {
                return this.s.workspaces.get(workspaceIdentifier.configPath);
            }
            return this.s.emptyWindows.get(workspaceIdentifier.id);
        }
        G(workspaceIdentifier) {
            if ((0, workspace_1.$Pi)(workspaceIdentifier)) {
                return workspaceIdentifier.uri;
            }
            if ((0, workspace_1.$Ui)(workspaceIdentifier)) {
                return workspaceIdentifier.configPath;
            }
            return workspaceIdentifier.id;
        }
        H(profile) {
            if ([...this.C.emptyWindows.values()].some(windowProfile => this.w.extUri.isEqual(windowProfile.location, profile.location))) {
                return true;
            }
            if ([...this.C.workspaces.values()].some(workspaceProfile => this.w.extUri.isEqual(workspaceProfile.location, profile.location))) {
                return true;
            }
            if ([...this.s.emptyWindows.values()].some(windowProfile => this.w.extUri.isEqual(windowProfile.location, profile.location))) {
                return true;
            }
            if ([...this.s.workspaces.values()].some(workspaceProfile => this.w.extUri.isEqual(workspaceProfile.location, profile.location))) {
                return true;
            }
            if ([...this.s.folders.values()].some(workspaceProfile => this.w.extUri.isEqual(workspaceProfile.location, profile.location))) {
                return true;
            }
            return false;
        }
        I(added, removed, updated) {
            const allProfiles = [...this.profiles, ...added];
            const storedProfiles = [];
            const transientProfiles = this.s.profiles;
            this.s.profiles = [];
            for (let profile of allProfiles) {
                if (profile.isDefault) {
                    continue;
                }
                if (removed.some(p => profile.id === p.id)) {
                    continue;
                }
                profile = updated.find(p => profile.id === p.id) ?? profile;
                const transientProfile = transientProfiles.find(p => profile.id === p.id);
                if (profile.isTransient) {
                    this.s.profiles.push(profile);
                }
                else {
                    if (transientProfile) {
                        for (const [windowId, p] of this.s.emptyWindows.entries()) {
                            if (profile.id === p.id) {
                                this.L({ id: windowId }, profile);
                                break;
                            }
                        }
                        for (const [workspace, p] of this.s.workspaces.entries()) {
                            if (profile.id === p.id) {
                                this.L({ id: '', configPath: workspace }, profile);
                                break;
                            }
                        }
                        for (const [folder, p] of this.s.folders.entries()) {
                            if (profile.id === p.id) {
                                this.L({ id: '', uri: folder }, profile);
                                break;
                            }
                        }
                    }
                    storedProfiles.push({ location: profile.location, name: profile.name, shortName: profile.shortName, icon: profile.icon, useDefaultFlags: profile.useDefaultFlags });
                }
            }
            this.P(storedProfiles);
            this.z = undefined;
            this.J(added, removed, updated);
        }
        J(added, removed, updated) {
            this.h.fire({ added, removed, updated, all: this.profiles });
        }
        L(workspaceIdentifier, newProfile, transient) {
            // Force transient if the new profile to associate is transient
            transient = newProfile?.isTransient ? true : transient;
            if (transient) {
                if ((0, workspace_1.$Pi)(workspaceIdentifier)) {
                    this.s.folders.delete(workspaceIdentifier.uri);
                    if (newProfile) {
                        this.s.folders.set(workspaceIdentifier.uri, newProfile);
                    }
                }
                else if ((0, workspace_1.$Ui)(workspaceIdentifier)) {
                    this.s.workspaces.delete(workspaceIdentifier.configPath);
                    if (newProfile) {
                        this.s.workspaces.set(workspaceIdentifier.configPath, newProfile);
                    }
                }
                else {
                    this.s.emptyWindows.delete(workspaceIdentifier.id);
                    if (newProfile) {
                        this.s.emptyWindows.set(workspaceIdentifier.id, newProfile);
                    }
                }
            }
            else {
                // Unset the transiet workspace association if any
                this.L(workspaceIdentifier, undefined, true);
                const workspace = this.G(workspaceIdentifier);
                // Folder or Multiroot workspace
                if (uri_1.URI.isUri(workspace)) {
                    this.C.workspaces.delete(workspace);
                    if (newProfile) {
                        this.C.workspaces.set(workspace, newProfile);
                    }
                }
                // Empty Window
                else {
                    this.C.emptyWindows.delete(workspace);
                    if (newProfile) {
                        this.C.emptyWindows.set(workspace, newProfile);
                    }
                }
                this.M();
            }
        }
        M() {
            const workspaces = {};
            for (const [workspace, profile] of this.C.workspaces.entries()) {
                workspaces[workspace.toString()] = profile.id;
            }
            const emptyWindows = {};
            for (const [windowId, profile] of this.C.emptyWindows.entries()) {
                emptyWindows[windowId.toString()] = profile.id;
            }
            this.R({ workspaces, emptyWindows });
            this.z = undefined;
        }
        // TODO: @sandy081 Remove migration after couple of releases
        N(storedProfileAssociations) {
            const workspaces = {};
            const defaultProfile = this.D();
            if (storedProfileAssociations.workspaces) {
                for (const [workspace, location] of Object.entries(storedProfileAssociations.workspaces)) {
                    const uri = uri_1.URI.parse(location);
                    workspaces[workspace] = this.w.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.w.extUri.basename(uri);
                }
            }
            const emptyWindows = {};
            if (storedProfileAssociations.emptyWindows) {
                for (const [workspace, location] of Object.entries(storedProfileAssociations.emptyWindows)) {
                    const uri = uri_1.URI.parse(location);
                    emptyWindows[workspace] = this.w.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.w.extUri.basename(uri);
                }
            }
            return { workspaces, emptyWindows };
        }
        O() { return []; }
        P(storedProfiles) { throw new Error('not implemented'); }
        Q() { return {}; }
        R(storedProfileAssociations) { throw new Error('not implemented'); }
        S() { return undefined; }
    };
    exports.$Pl = $Pl;
    exports.$Pl = $Pl = __decorate([
        __param(0, environment_1.$Mi),
        __param(1, files_1.$al),
        __param(2, uriIdentity_1.$Kl),
        __param(3, log_1.$ak)
    ], $Pl);
    class $Ql extends $Pl {
        constructor() {
            super(...arguments);
            this.a = [];
            this.X = {};
        }
        O() { return this.a; }
        P(storedProfiles) { this.a = storedProfiles; }
        Q() { return this.X; }
        R(storedProfileAssociations) { this.X = storedProfileAssociations; }
    }
    exports.$Ql = $Ql;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[187/*vs/platform/storage/common/storage*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,64/*vs/base/common/performance*/,14/*vs/base/common/types*/,152/*vs/base/parts/storage/common/storage*/,3/*vs/platform/instantiation/common/instantiation*/,113/*vs/platform/userDataProfile/common/userDataProfile*/]), function (require, exports, async_1, event_1, lifecycle_1, performance_1, types_1, storage_1, instantiation_1, userDataProfile_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$mq = exports.$kq = exports.StorageTarget = exports.StorageScope = exports.WillSaveStateReason = exports.$iq = exports.$hq = exports.$gq = void 0;
    exports.$jq = $jq;
    exports.$lq = $lq;
    exports.$nq = $nq;
    exports.$gq = '__$__isNewStorageMarker';
    exports.$hq = '__$__targetStorageMarker';
    exports.$iq = (0, instantiation_1.$Fi)('storageService');
    var WillSaveStateReason;
    (function (WillSaveStateReason) {
        /**
         * No specific reason to save state.
         */
        WillSaveStateReason[WillSaveStateReason["NONE"] = 0] = "NONE";
        /**
         * A hint that the workbench is about to shutdown.
         */
        WillSaveStateReason[WillSaveStateReason["SHUTDOWN"] = 1] = "SHUTDOWN";
    })(WillSaveStateReason || (exports.WillSaveStateReason = WillSaveStateReason = {}));
    var StorageScope;
    (function (StorageScope) {
        /**
         * The stored data will be scoped to all workspaces across all profiles.
         */
        StorageScope[StorageScope["APPLICATION"] = -1] = "APPLICATION";
        /**
         * The stored data will be scoped to all workspaces of the same profile.
         */
        StorageScope[StorageScope["PROFILE"] = 0] = "PROFILE";
        /**
         * The stored data will be scoped to the current workspace.
         */
        StorageScope[StorageScope["WORKSPACE"] = 1] = "WORKSPACE";
    })(StorageScope || (exports.StorageScope = StorageScope = {}));
    var StorageTarget;
    (function (StorageTarget) {
        /**
         * The stored data is user specific and applies across machines.
         */
        StorageTarget[StorageTarget["USER"] = 0] = "USER";
        /**
         * The stored data is machine specific.
         */
        StorageTarget[StorageTarget["MACHINE"] = 1] = "MACHINE";
    })(StorageTarget || (exports.StorageTarget = StorageTarget = {}));
    function $jq(storage) {
        const keysRaw = storage.get(exports.$hq);
        if (keysRaw) {
            try {
                return JSON.parse(keysRaw);
            }
            catch (error) {
                // Fail gracefully
            }
        }
        return Object.create(null);
    }
    class $kq extends lifecycle_1.$Uc {
        static { this.a = 60 * 1000; } // every minute
        constructor(m = { flushInterval: $kq.a }) {
            super();
            this.m = m;
            this.b = this.B(new event_1.$oe());
            this.c = this.B(new event_1.$oe());
            this.onDidChangeTarget = this.c.event;
            this.f = this.B(new event_1.$le());
            this.onWillSaveState = this.f.event;
            this.h = this.B(new async_1.$Rh(() => this.n(), this.m.flushInterval));
            this.j = this.B(new lifecycle_1.$Vc());
            this.C = undefined;
            this.F = undefined;
            this.H = undefined;
        }
        onDidChangeValue(scope, key, disposable) {
            return event_1.Event.filter(this.b.event, e => e.scope === scope && (key === undefined || e.key === key), disposable);
        }
        n() {
            this.j.value = (0, async_1.$Vh)(() => {
                if (this.r()) {
                    this.flush();
                }
                // repeat
                this.h.schedule();
            });
        }
        r() {
            return true;
        }
        t() {
            (0, lifecycle_1.$Pc)([this.j, this.h]);
        }
        initialize() {
            if (!this.g) {
                this.g = (async () => {
                    // Init all storage locations
                    (0, performance_1.mark)('code/willInitStorage');
                    try {
                        await this.O(); // Ask subclasses to initialize storage
                    }
                    finally {
                        (0, performance_1.mark)('code/didInitStorage');
                    }
                    // On some OS we do not get enough time to persist state on shutdown (e.g. when
                    // Windows restarts after applying updates). In other cases, VSCode might crash,
                    // so we periodically save state to reduce the chance of loosing any state.
                    // In the browser we do not have support for long running unload sequences. As such,
                    // we cannot ask for saving state in that moment, because that would result in a
                    // long running operation.
                    // Instead, periodically ask customers to save save. The library will be clever enough
                    // to only save state that has actually changed.
                    this.h.schedule();
                })();
            }
            return this.g;
        }
        u(scope, event) {
            const { key, external } = event;
            // Specially handle `TARGET_KEY`
            if (key === exports.$hq) {
                // Clear our cached version which is now out of date
                switch (scope) {
                    case StorageScope.APPLICATION:
                        this.H = undefined;
                        break;
                    case StorageScope.PROFILE:
                        this.F = undefined;
                        break;
                    case StorageScope.WORKSPACE:
                        this.C = undefined;
                        break;
                }
                // Emit as `didChangeTarget` event
                this.c.fire({ scope });
            }
            // Emit any other key to outside
            else {
                this.b.fire({ scope, key, target: this.J(scope)[key], external });
            }
        }
        w(reason) {
            this.f.fire({ reason });
        }
        get(key, scope, fallbackValue) {
            return this.P(scope)?.get(key, fallbackValue);
        }
        getBoolean(key, scope, fallbackValue) {
            return this.P(scope)?.getBoolean(key, fallbackValue);
        }
        getNumber(key, scope, fallbackValue) {
            return this.P(scope)?.getNumber(key, fallbackValue);
        }
        getObject(key, scope, fallbackValue) {
            return this.P(scope)?.getObject(key, fallbackValue);
        }
        storeAll(entries, external) {
            this.y(() => {
                for (const entry of entries) {
                    this.store(entry.key, entry.value, entry.scope, entry.target, external);
                }
            });
        }
        store(key, value, scope, target, external = false) {
            // We remove the key for undefined/null values
            if ((0, types_1.$ng)(value)) {
                this.remove(key, scope, external);
                return;
            }
            // Update our datastructures but send events only after
            this.y(() => {
                // Update key-target map
                this.z(key, scope, target);
                // Store actual value
                this.P(scope)?.set(key, value, external);
            });
        }
        remove(key, scope, external = false) {
            // Update our datastructures but send events only after
            this.y(() => {
                // Update key-target map
                this.z(key, scope, undefined);
                // Remove actual key
                this.P(scope)?.delete(key, external);
            });
        }
        y(fn) {
            // Pause emitters
            this.b.pause();
            this.c.pause();
            try {
                fn();
            }
            finally {
                // Resume emitters
                this.b.resume();
                this.c.resume();
            }
        }
        keys(scope, target) {
            const keys = [];
            const keyTargets = this.J(scope);
            for (const key of Object.keys(keyTargets)) {
                const keyTarget = keyTargets[key];
                if (keyTarget === target) {
                    keys.push(key);
                }
            }
            return keys;
        }
        z(key, scope, target, external = false) {
            // Add
            const keyTargets = this.J(scope);
            if (typeof target === 'number') {
                if (keyTargets[key] !== target) {
                    keyTargets[key] = target;
                    this.P(scope)?.set(exports.$hq, JSON.stringify(keyTargets), external);
                }
            }
            // Remove
            else {
                if (typeof keyTargets[key] === 'number') {
                    delete keyTargets[key];
                    this.P(scope)?.set(exports.$hq, JSON.stringify(keyTargets), external);
                }
            }
        }
        get D() {
            if (!this.C) {
                this.C = this.L(StorageScope.WORKSPACE);
            }
            return this.C;
        }
        get G() {
            if (!this.F) {
                this.F = this.L(StorageScope.PROFILE);
            }
            return this.F;
        }
        get I() {
            if (!this.H) {
                this.H = this.L(StorageScope.APPLICATION);
            }
            return this.H;
        }
        J(scope) {
            switch (scope) {
                case StorageScope.APPLICATION:
                    return this.I;
                case StorageScope.PROFILE:
                    return this.G;
                default:
                    return this.D;
            }
        }
        L(scope) {
            const storage = this.P(scope);
            return storage ? $jq(storage) : Object.create(null);
        }
        isNew(scope) {
            return this.getBoolean(exports.$gq, scope) === true;
        }
        async flush(reason = WillSaveStateReason.NONE) {
            // Signal event to collect changes
            this.f.fire({ reason });
            const applicationStorage = this.P(StorageScope.APPLICATION);
            const profileStorage = this.P(StorageScope.PROFILE);
            const workspaceStorage = this.P(StorageScope.WORKSPACE);
            switch (reason) {
                // Unspecific reason: just wait when data is flushed
                case WillSaveStateReason.NONE:
                    await async_1.Promises.settled([
                        applicationStorage?.whenFlushed() ?? Promise.resolve(),
                        profileStorage?.whenFlushed() ?? Promise.resolve(),
                        workspaceStorage?.whenFlushed() ?? Promise.resolve()
                    ]);
                    break;
                // Shutdown: we want to flush as soon as possible
                // and not hit any delays that might be there
                case WillSaveStateReason.SHUTDOWN:
                    await async_1.Promises.settled([
                        applicationStorage?.flush(0) ?? Promise.resolve(),
                        profileStorage?.flush(0) ?? Promise.resolve(),
                        workspaceStorage?.flush(0) ?? Promise.resolve()
                    ]);
                    break;
            }
        }
        async log() {
            const applicationItems = this.P(StorageScope.APPLICATION)?.items ?? new Map();
            const profileItems = this.P(StorageScope.PROFILE)?.items ?? new Map();
            const workspaceItems = this.P(StorageScope.WORKSPACE)?.items ?? new Map();
            return $nq(applicationItems, profileItems, workspaceItems, this.Q(StorageScope.APPLICATION) ?? '', this.Q(StorageScope.PROFILE) ?? '', this.Q(StorageScope.WORKSPACE) ?? '');
        }
        async optimize(scope) {
            // Await pending data to be flushed to the DB
            // before attempting to optimize the DB
            await this.flush();
            return this.P(scope)?.optimize();
        }
        async switch(to, preserveData) {
            // Signal as event so that clients can store data before we switch
            this.w(WillSaveStateReason.NONE);
            if ((0, userDataProfile_1.$Ll)(to)) {
                return this.R(to, preserveData);
            }
            return this.S(to, preserveData);
        }
        M(from, to) {
            if (from.id === to.id) {
                return false; // both profiles are same
            }
            if ($lq(to) && $lq(from)) {
                return false; // both profiles are using default
            }
            return true;
        }
        N(oldStorage, newStorage, scope) {
            this.y(() => {
                // Signal storage keys that have changed
                const handledkeys = new Set();
                for (const [key, oldValue] of oldStorage) {
                    handledkeys.add(key);
                    const newValue = newStorage.get(key);
                    if (newValue !== oldValue) {
                        this.u(scope, { key, external: true });
                    }
                }
                for (const [key] of newStorage.items) {
                    if (!handledkeys.has(key)) {
                        this.u(scope, { key, external: true });
                    }
                }
            });
        }
    }
    exports.$kq = $kq;
    function $lq(profile) {
        return profile.isDefault || !!profile.useDefaultFlags?.globalState;
    }
    class $mq extends $kq {
        constructor() {
            super();
            this.U = this.B(new storage_1.$eq(new storage_1.$fq(), { hint: storage_1.StorageHint.STORAGE_IN_MEMORY }));
            this.W = this.B(new storage_1.$eq(new storage_1.$fq(), { hint: storage_1.StorageHint.STORAGE_IN_MEMORY }));
            this.X = this.B(new storage_1.$eq(new storage_1.$fq(), { hint: storage_1.StorageHint.STORAGE_IN_MEMORY }));
            this.B(this.X.onDidChangeStorage(e => this.u(StorageScope.WORKSPACE, e)));
            this.B(this.W.onDidChangeStorage(e => this.u(StorageScope.PROFILE, e)));
            this.B(this.U.onDidChangeStorage(e => this.u(StorageScope.APPLICATION, e)));
        }
        P(scope) {
            switch (scope) {
                case StorageScope.APPLICATION:
                    return this.U;
                case StorageScope.PROFILE:
                    return this.W;
                default:
                    return this.X;
            }
        }
        Q(scope) {
            switch (scope) {
                case StorageScope.APPLICATION:
                    return 'inMemory (application)';
                case StorageScope.PROFILE:
                    return 'inMemory (profile)';
                default:
                    return 'inMemory (workspace)';
            }
        }
        async O() { }
        async R() {
            // no-op when in-memory
        }
        async S() {
            // no-op when in-memory
        }
        r() {
            return false;
        }
        hasScope(scope) {
            return false;
        }
    }
    exports.$mq = $mq;
    async function $nq(application, profile, workspace, applicationPath, profilePath, workspacePath) {
        const safeParse = (value) => {
            try {
                return JSON.parse(value);
            }
            catch (error) {
                return value;
            }
        };
        const applicationItems = new Map();
        const applicationItemsParsed = new Map();
        application.forEach((value, key) => {
            applicationItems.set(key, value);
            applicationItemsParsed.set(key, safeParse(value));
        });
        const profileItems = new Map();
        const profileItemsParsed = new Map();
        profile.forEach((value, key) => {
            profileItems.set(key, value);
            profileItemsParsed.set(key, safeParse(value));
        });
        const workspaceItems = new Map();
        const workspaceItemsParsed = new Map();
        workspace.forEach((value, key) => {
            workspaceItems.set(key, value);
            workspaceItemsParsed.set(key, safeParse(value));
        });
        if (applicationPath !== profilePath) {
            console.group(`Storage: Application (path: ${applicationPath})`);
        }
        else {
            console.group(`Storage: Application & Profile (path: ${applicationPath}, default profile)`);
        }
        const applicationValues = [];
        applicationItems.forEach((value, key) => {
            applicationValues.push({ key, value });
        });
        console.table(applicationValues);
        console.groupEnd();
        console.log(applicationItemsParsed);
        if (applicationPath !== profilePath) {
            console.group(`Storage: Profile (path: ${profilePath}, profile specific)`);
            const profileValues = [];
            profileItems.forEach((value, key) => {
                profileValues.push({ key, value });
            });
            console.table(profileValues);
            console.groupEnd();
            console.log(profileItemsParsed);
        }
        console.group(`Storage: Workspace (path: ${workspacePath})`);
        const workspaceValues = [];
        workspaceItems.forEach((value, key) => {
            workspaceValues.push({ key, value });
        });
        console.table(workspaceValues);
        console.groupEnd();
        console.log(workspaceItemsParsed);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[79/*vs/workbench/api/common/cache*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ppc = void 0;
    class $ppc {
        static { this.a = false; }
        constructor(d) {
            this.d = d;
            this.b = new Map();
            this.c = 1;
        }
        add(item) {
            const id = this.c++;
            this.b.set(id, item);
            this.e();
            return id;
        }
        get(pid, id) {
            return this.b.has(pid) ? this.b.get(pid)[id] : undefined;
        }
        delete(id) {
            this.b.delete(id);
            this.e();
        }
        e() {
            if (!$ppc.a) {
                return;
            }
            console.log(`${this.d} cache size - ${this.b.size}`);
        }
    }
    exports.$ppc = $ppc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[50/*vs/workbench/api/common/extHostFileSystemInfo*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/network*/,23/*vs/base/common/resources*/,29/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, network_1, resources_1, files_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vpc = exports.$upc = void 0;
    class $upc {
        constructor() {
            this.a = new Set(Object.keys(network_1.Schemas));
            this.b = new Map();
            this.extUri = new resources_1.$8g(uri => {
                const capabilities = this.b.get(uri.scheme);
                if (capabilities === undefined) {
                    // default: not ignore
                    return false;
                }
                if (capabilities & files_1.FileSystemProviderCapabilities.PathCaseSensitive) {
                    // configured as case sensitive
                    return false;
                }
                return true;
            });
        }
        $acceptProviderInfos(uri, capabilities) {
            if (capabilities === null) {
                this.b.delete(uri.scheme);
            }
            else {
                this.b.set(uri.scheme, capabilities);
            }
        }
        isFreeScheme(scheme) {
            return !this.b.has(scheme) && !this.a.has(scheme);
        }
        getCapabilities(scheme) {
            return this.b.get(scheme);
        }
    }
    exports.$upc = $upc;
    exports.$vpc = (0, instantiation_1.$Fi)('IExtHostFileSystemInfo');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[26/*vs/workbench/api/common/extHostInitDataService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$AQ = void 0;
    exports.$AQ = (0, instantiation_1.$Fi)('IExtHostInitDataService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[188/*vs/workbench/api/common/extHostLogService*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,11/*vs/platform/log/common/log*/,172/*vs/platform/log/common/logService*/,26/*vs/workbench/api/common/extHostInitDataService*/]), function (require, exports, nls_1, log_1, logService_1, extHostInitDataService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Drc = void 0;
    let $Drc = class $Drc extends logService_1.$KR {
        constructor(isWorker, loggerService, initData) {
            const id = initData.remote.isRemote ? 'remoteexthost' : isWorker ? 'workerexthost' : 'exthost';
            const name = initData.remote.isRemote ? (0, nls_1.localize)(11256, null) : isWorker ? (0, nls_1.localize)(11257, null) : (0, nls_1.localize)(11258, null);
            super(loggerService.createLogger(id, { name }));
        }
    };
    exports.$Drc = $Drc;
    exports.$Drc = $Drc = __decorate([
        __param(1, log_1.$bk),
        __param(2, extHostInitDataService_1.$AQ)
    ], $Drc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[189/*vs/workbench/api/common/extHostMemento*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/]), function (require, exports, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$bqc = exports.$aqc = void 0;
    class $aqc {
        constructor(id, global, storage) {
            this.h = new Map();
            this.a = id;
            this.b = global;
            this.c = storage;
            this.d = this.c.initializeExtensionStorage(this.b, this.a, Object.create(null)).then(value => {
                this.f = value;
                return this;
            });
            this.g = this.c.onDidChangeStorage(e => {
                if (e.shared === this.b && e.key === this.a) {
                    this.f = e.value;
                }
            });
            this.i = new async_1.$Rh(() => {
                const records = this.h;
                this.h = new Map();
                (async () => {
                    try {
                        await this.c.setValue(this.b, this.a, this.f);
                        for (const value of records.values()) {
                            value.complete();
                        }
                    }
                    catch (e) {
                        for (const value of records.values()) {
                            value.error(e);
                        }
                    }
                })();
            }, 0);
        }
        keys() {
            // Filter out `undefined` values, as they can stick around in the `_value` until the `onDidChangeStorage` event runs
            return Object.entries(this.f ?? {}).filter(([, value]) => value !== undefined).map(([key]) => key);
        }
        get whenReady() {
            return this.d;
        }
        get(key, defaultValue) {
            let value = this.f[key];
            if (typeof value === 'undefined') {
                value = defaultValue;
            }
            return value;
        }
        update(key, value) {
            this.f[key] = value;
            const record = this.h.get(key);
            if (record !== undefined) {
                return record.p;
            }
            const promise = new async_1.$3h();
            this.h.set(key, promise);
            if (!this.i.isScheduled()) {
                this.i.schedule();
            }
            return promise.p;
        }
        dispose() {
            this.g.dispose();
        }
    }
    exports.$aqc = $aqc;
    class $bqc extends $aqc {
        setKeysForSync(keys) {
            this.c.registerExtensionStorageKeysToSync({ id: this.a, version: this.j.version }, keys);
        }
        constructor(extensionDescription, storage) {
            super(extensionDescription.identifier.value, true, storage);
            this.j = extensionDescription;
        }
    }
    exports.$bqc = $bqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[190/*vs/workbench/api/common/extHostNotebookDocuments*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,2/*vs/base/common/uri*/]), function (require, exports, event_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$8qc = void 0;
    class $8qc {
        constructor(c) {
            this.c = c;
            this.a = new event_1.$le();
            this.onDidSaveNotebookDocument = this.a.event;
            this.b = new event_1.$le();
            this.onDidChangeNotebookDocument = this.b.event;
        }
        $acceptModelChanged(uri, event, isDirty, newMetadata) {
            const document = this.c.getNotebookDocument(uri_1.URI.revive(uri));
            const e = document.acceptModelChanged(event.value, isDirty, newMetadata);
            this.b.fire(e);
        }
        $acceptDirtyStateChanged(uri, isDirty) {
            const document = this.c.getNotebookDocument(uri_1.URI.revive(uri));
            document.acceptDirty(isDirty);
        }
        $acceptModelSaved(uri) {
            const document = this.c.getNotebookDocument(uri_1.URI.revive(uri));
            this.a.fire(document.apiNotebook);
        }
    }
    exports.$8qc = $8qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[16/*vs/workbench/api/common/extHostRpcService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$lQ = exports.$kQ = void 0;
    exports.$kQ = (0, instantiation_1.$Fi)('IExtHostRpcService');
    class $lQ {
        constructor(rpcProtocol) {
            this.getProxy = rpcProtocol.getProxy.bind(rpcProtocol);
            this.set = rpcProtocol.set.bind(rpcProtocol);
            this.dispose = rpcProtocol.dispose.bind(rpcProtocol);
            this.assertRegistered = rpcProtocol.assertRegistered.bind(rpcProtocol);
            this.drain = rpcProtocol.drain.bind(rpcProtocol);
        }
    }
    exports.$lQ = $lQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[191/*vs/workbench/api/common/extHostSecrets*/], __M([1/*require*/,0/*exports*/,18/*vs/platform/extensions/common/extensions*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/]), function (require, exports, extensions_1, event_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$kqc = void 0;
    class $kqc {
        #secretState;
        constructor(extensionDescription, secretState) {
            this.disposables = new lifecycle_1.$Tc();
            this.a = extensions_1.$rn.toKey(extensionDescription.identifier);
            this.#secretState = secretState;
            this.onDidChange = event_1.Event.map(event_1.Event.filter(this.#secretState.onDidChangePassword, e => e.extensionId === this.a), e => ({ key: e.key }), this.disposables);
        }
        dispose() {
            this.disposables.dispose();
        }
        get(key) {
            return this.#secretState.get(this.a, key);
        }
        store(key, value) {
            return this.#secretState.store(this.a, key, value);
        }
        delete(key) {
            return this.#secretState.delete(this.a, key);
        }
    }
    exports.$kqc = $kqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[65/*vs/workbench/api/common/extHostUriTransformerService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Lpc = exports.$Kpc = void 0;
    exports.$Kpc = (0, instantiation_1.$Fi)('IURITransformerService');
    class $Lpc {
        constructor(delegate) {
            if (!delegate) {
                this.transformIncoming = arg => arg;
                this.transformOutgoing = arg => arg;
                this.transformOutgoingURI = arg => arg;
                this.transformOutgoingScheme = arg => arg;
            }
            else {
                this.transformIncoming = delegate.transformIncoming.bind(delegate);
                this.transformOutgoing = delegate.transformOutgoing.bind(delegate);
                this.transformOutgoingURI = delegate.transformOutgoingURI.bind(delegate);
                this.transformOutgoingScheme = delegate.transformOutgoingScheme.bind(delegate);
            }
        }
    }
    exports.$Lpc = $Lpc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[114/*vs/workbench/common/editor*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,4/*vs/base/common/lifecycle*/,3/*vs/platform/instantiation/common/instantiation*/,30/*vs/platform/registry/common/platform*/,29/*vs/platform/files/common/files*/,15/*vs/base/common/network*/,42/*vs/base/common/errorMessage*/,164/*vs/base/common/actions*/,35/*vs/base/common/severity*/]), function (require, exports, nls_1, types_1, uri_1, lifecycle_1, instantiation_1, platform_1, files_1, network_1, errorMessage_1, actions_1, severity_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EditorsOrder = exports.CloseDirection = exports.$qG = exports.EditorCloseMethod = exports.SideBySideEditor = exports.GroupModelChangeKind = exports.EditorCloseContext = exports.$gG = exports.EditorInputCapabilities = exports.$fG = exports.SaveReason = exports.Verbosity = exports.EditorPaneSelectionCompareResult = exports.EditorPaneSelectionChangeReason = exports.$8F = exports.$7F = exports.$6F = exports.$5F = exports.$4F = void 0;
    exports.$9F = $9F;
    exports.$0F = $0F;
    exports.$$F = $$F;
    exports.$_F = $_F;
    exports.$aG = $aG;
    exports.$bG = $bG;
    exports.$cG = $cG;
    exports.$dG = $dG;
    exports.$eG = $eG;
    exports.$hG = $hG;
    exports.$iG = $iG;
    exports.$jG = $jG;
    exports.$kG = $kG;
    exports.$lG = $lG;
    exports.$mG = $mG;
    exports.$nG = $nG;
    exports.$oG = $oG;
    exports.$pG = $pG;
    exports.$rG = $rG;
    exports.$sG = $sG;
    exports.$tG = $tG;
    exports.$uG = $uG;
    severity_1 = __importDefault(severity_1);
    // Static values for editor contributions
    exports.$4F = {
        EditorPane: 'workbench.contributions.editors',
        EditorFactory: 'workbench.contributions.editor.inputFactories'
    };
    // Static information regarding the text editor
    exports.$5F = {
        id: 'default',
        displayName: (0, nls_1.localize)(12473, null),
        providerDisplayName: (0, nls_1.localize)(12474, null)
    };
    /**
     * Side by side editor id.
     */
    exports.$6F = 'workbench.editor.sidebysideEditor';
    /**
     * Text diff editor id.
     */
    exports.$7F = 'workbench.editors.textDiffEditor';
    /**
     * Binary diff editor id.
     */
    exports.$8F = 'workbench.editors.binaryResourceDiffEditor';
    var EditorPaneSelectionChangeReason;
    (function (EditorPaneSelectionChangeReason) {
        /**
         * The selection was changed as a result of a programmatic
         * method invocation.
         *
         * For a text editor pane, this for example can be a selection
         * being restored from previous view state automatically.
         */
        EditorPaneSelectionChangeReason[EditorPaneSelectionChangeReason["PROGRAMMATIC"] = 1] = "PROGRAMMATIC";
        /**
         * The selection was changed by the user.
         *
         * This typically means the user changed the selection
         * with mouse or keyboard.
         */
        EditorPaneSelectionChangeReason[EditorPaneSelectionChangeReason["USER"] = 2] = "USER";
        /**
         * The selection was changed as a result of editing in
         * the editor pane.
         *
         * For a text editor pane, this for example can be typing
         * in the text of the editor pane.
         */
        EditorPaneSelectionChangeReason[EditorPaneSelectionChangeReason["EDIT"] = 3] = "EDIT";
        /**
         * The selection was changed as a result of a navigation
         * action.
         *
         * For a text editor pane, this for example can be a result
         * of selecting an entry from a text outline view.
         */
        EditorPaneSelectionChangeReason[EditorPaneSelectionChangeReason["NAVIGATION"] = 4] = "NAVIGATION";
        /**
         * The selection was changed as a result of a jump action
         * from within the editor pane.
         *
         * For a text editor pane, this for example can be a result
         * of invoking "Go to definition" from a symbol.
         */
        EditorPaneSelectionChangeReason[EditorPaneSelectionChangeReason["JUMP"] = 5] = "JUMP";
    })(EditorPaneSelectionChangeReason || (exports.EditorPaneSelectionChangeReason = EditorPaneSelectionChangeReason = {}));
    var EditorPaneSelectionCompareResult;
    (function (EditorPaneSelectionCompareResult) {
        /**
         * The selections are identical.
         */
        EditorPaneSelectionCompareResult[EditorPaneSelectionCompareResult["IDENTICAL"] = 1] = "IDENTICAL";
        /**
         * The selections are similar.
         *
         * For a text editor this can mean that the one
         * selection is in close proximity to the other
         * selection.
         *
         * Upstream clients may decide in this case to
         * not treat the selection different from the
         * previous one because it is not distinct enough.
         */
        EditorPaneSelectionCompareResult[EditorPaneSelectionCompareResult["SIMILAR"] = 2] = "SIMILAR";
        /**
         * The selections are entirely different.
         */
        EditorPaneSelectionCompareResult[EditorPaneSelectionCompareResult["DIFFERENT"] = 3] = "DIFFERENT";
    })(EditorPaneSelectionCompareResult || (exports.EditorPaneSelectionCompareResult = EditorPaneSelectionCompareResult = {}));
    function $9F(editorPane) {
        const candidate = editorPane;
        return !!candidate && typeof candidate.getSelection === 'function' && !!candidate.onDidChangeSelection;
    }
    function $0F(editorPane) {
        const candidate = editorPane;
        return !!candidate && typeof candidate.getScrollPosition === 'function' && typeof candidate.setScrollPosition === 'function' && !!candidate.onDidChangeScroll;
    }
    /**
     * Try to retrieve the view state for the editor pane that
     * has the provided editor input opened, if at all.
     *
     * This method will return `undefined` if the editor input
     * is not visible in any of the opened editor panes.
     */
    function $$F(input, group, editorService) {
        for (const editorPane of editorService.visibleEditorPanes) {
            if (editorPane.group.id === group && input.matches(editorPane.input)) {
                return editorPane.getViewState();
            }
        }
        return undefined;
    }
    function $_F(editor) {
        if ($hG(editor)) {
            return false; // make sure to not accidentally match on typed editor inputs
        }
        const candidate = editor;
        return uri_1.URI.isUri(candidate?.resource);
    }
    function $aG(editor) {
        if ($hG(editor)) {
            return false; // make sure to not accidentally match on typed editor inputs
        }
        const candidate = editor;
        return candidate?.original !== undefined && candidate.modified !== undefined;
    }
    function $bG(editor) {
        if ($hG(editor)) {
            return false; // make sure to not accidentally match on typed editor inputs
        }
        const candidate = editor;
        if (!candidate) {
            return false;
        }
        if (candidate.resources && !Array.isArray(candidate.resources)) {
            return false;
        }
        return !!candidate.resources || !!candidate.multiDiffSource;
    }
    function $cG(editor) {
        if ($hG(editor)) {
            return false; // make sure to not accidentally match on typed editor inputs
        }
        if ($aG(editor)) {
            return false; // make sure to not accidentally match on diff editors
        }
        const candidate = editor;
        return candidate?.primary !== undefined && candidate.secondary !== undefined;
    }
    function $dG(editor) {
        if ($hG(editor)) {
            return false; // make sure to not accidentally match on typed editor inputs
        }
        const candidate = editor;
        if (!candidate) {
            return false;
        }
        return candidate.resource === undefined || candidate.resource.scheme === network_1.Schemas.untitled || candidate.forceUntitled === true;
    }
    function $eG(editor) {
        if ($hG(editor)) {
            return false; // make sure to not accidentally match on typed editor inputs
        }
        const candidate = editor;
        return uri_1.URI.isUri(candidate?.base?.resource) && uri_1.URI.isUri(candidate?.input1?.resource) && uri_1.URI.isUri(candidate?.input2?.resource) && uri_1.URI.isUri(candidate?.result?.resource);
    }
    var Verbosity;
    (function (Verbosity) {
        Verbosity[Verbosity["SHORT"] = 0] = "SHORT";
        Verbosity[Verbosity["MEDIUM"] = 1] = "MEDIUM";
        Verbosity[Verbosity["LONG"] = 2] = "LONG";
    })(Verbosity || (exports.Verbosity = Verbosity = {}));
    var SaveReason;
    (function (SaveReason) {
        /**
         * Explicit user gesture.
         */
        SaveReason[SaveReason["EXPLICIT"] = 1] = "EXPLICIT";
        /**
         * Auto save after a timeout.
         */
        SaveReason[SaveReason["AUTO"] = 2] = "AUTO";
        /**
         * Auto save after editor focus change.
         */
        SaveReason[SaveReason["FOCUS_CHANGE"] = 3] = "FOCUS_CHANGE";
        /**
         * Auto save after window change.
         */
        SaveReason[SaveReason["WINDOW_CHANGE"] = 4] = "WINDOW_CHANGE";
    })(SaveReason || (exports.SaveReason = SaveReason = {}));
    class SaveSourceFactory {
        constructor() {
            this.a = new Map();
        }
        /**
         * Registers a `SaveSource` with an identifier and label
         * to the registry so that it can be used in save operations.
         */
        registerSource(id, label) {
            let sourceDescriptor = this.a.get(id);
            if (!sourceDescriptor) {
                sourceDescriptor = { source: id, label };
                this.a.set(id, sourceDescriptor);
            }
            return sourceDescriptor.source;
        }
        getSourceLabel(source) {
            return this.a.get(source)?.label ?? source;
        }
    }
    exports.$fG = new SaveSourceFactory();
    var EditorInputCapabilities;
    (function (EditorInputCapabilities) {
        /**
         * Signals no specific capability for the input.
         */
        EditorInputCapabilities[EditorInputCapabilities["None"] = 0] = "None";
        /**
         * Signals that the input is readonly.
         */
        EditorInputCapabilities[EditorInputCapabilities["Readonly"] = 2] = "Readonly";
        /**
         * Signals that the input is untitled.
         */
        EditorInputCapabilities[EditorInputCapabilities["Untitled"] = 4] = "Untitled";
        /**
         * Signals that the input can only be shown in one group
         * and not be split into multiple groups.
         */
        EditorInputCapabilities[EditorInputCapabilities["Singleton"] = 8] = "Singleton";
        /**
         * Signals that the input requires workspace trust.
         */
        EditorInputCapabilities[EditorInputCapabilities["RequiresTrust"] = 16] = "RequiresTrust";
        /**
         * Signals that the editor can split into 2 in the same
         * editor group.
         */
        EditorInputCapabilities[EditorInputCapabilities["CanSplitInGroup"] = 32] = "CanSplitInGroup";
        /**
         * Signals that the editor wants its description to be
         * visible when presented to the user. By default, a UI
         * component may decide to hide the description portion
         * for brevity.
         */
        EditorInputCapabilities[EditorInputCapabilities["ForceDescription"] = 64] = "ForceDescription";
        /**
         * Signals that the editor supports dropping into the
         * editor by holding shift.
         */
        EditorInputCapabilities[EditorInputCapabilities["CanDropIntoEditor"] = 128] = "CanDropIntoEditor";
        /**
         * Signals that the editor is composed of multiple editors
         * within.
         */
        EditorInputCapabilities[EditorInputCapabilities["MultipleEditors"] = 256] = "MultipleEditors";
        /**
         * Signals that the editor cannot be in a dirty state
         * and may still have unsaved changes
         */
        EditorInputCapabilities[EditorInputCapabilities["Scratchpad"] = 512] = "Scratchpad";
    })(EditorInputCapabilities || (exports.EditorInputCapabilities = EditorInputCapabilities = {}));
    class $gG extends lifecycle_1.$Uc {
    }
    exports.$gG = $gG;
    function $hG(editor) {
        return editor instanceof $gG;
    }
    function isEditorInputWithPreferredResource(editor) {
        const candidate = editor;
        return uri_1.URI.isUri(candidate?.preferredResource);
    }
    function $iG(editor) {
        const candidate = editor;
        return $hG(candidate?.primary) && $hG(candidate?.secondary);
    }
    function $jG(editor) {
        const candidate = editor;
        return $hG(candidate?.modified) && $hG(candidate?.original);
    }
    function $kG(group, input, options, message, preferencesService) {
        return $uG(message, [
            (0, actions_1.$pj)({
                id: 'workbench.action.openLargeFile', label: (0, nls_1.localize)(12475, null), run: () => {
                    const fileEditorOptions = {
                        ...options,
                        limits: {
                            size: Number.MAX_VALUE
                        }
                    };
                    group.openEditor(input, fileEditorOptions);
                }
            }),
            (0, actions_1.$pj)({
                id: 'workbench.action.configureEditorLargeFileConfirmation', label: (0, nls_1.localize)(12476, null), run: () => {
                    return preferencesService.openUserSettings({ query: 'workbench.editorLargeFileConfirmation' });
                }
            }),
        ], {
            forceMessage: true,
            forceSeverity: severity_1.default.Warning
        });
    }
    function $lG(editor) {
        const candidate = editor;
        return $hG(candidate?.editor);
    }
    function $mG(editor) {
        const candidate = editor;
        return $lG(editor) && candidate?.group !== undefined;
    }
    function $nG(identifier) {
        const candidate = identifier;
        return typeof candidate?.groupId === 'number' && $hG(candidate.editor);
    }
    function $oG(context) {
        const candidate = context;
        return typeof candidate?.groupId === 'number';
    }
    /**
     * More information around why an editor was closed in the model.
     */
    var EditorCloseContext;
    (function (EditorCloseContext) {
        /**
         * No specific context for closing (e.g. explicit user gesture).
         */
        EditorCloseContext[EditorCloseContext["UNKNOWN"] = 0] = "UNKNOWN";
        /**
         * The editor closed because it was replaced with another editor.
         * This can either happen via explicit replace call or when an
         * editor is in preview mode and another editor opens.
         */
        EditorCloseContext[EditorCloseContext["REPLACE"] = 1] = "REPLACE";
        /**
         * The editor closed as a result of moving it to another group.
         */
        EditorCloseContext[EditorCloseContext["MOVE"] = 2] = "MOVE";
        /**
         * The editor closed because another editor turned into preview
         * and this used to be the preview editor before.
         */
        EditorCloseContext[EditorCloseContext["UNPIN"] = 3] = "UNPIN";
    })(EditorCloseContext || (exports.EditorCloseContext = EditorCloseContext = {}));
    var GroupModelChangeKind;
    (function (GroupModelChangeKind) {
        /* Group Changes */
        GroupModelChangeKind[GroupModelChangeKind["GROUP_ACTIVE"] = 0] = "GROUP_ACTIVE";
        GroupModelChangeKind[GroupModelChangeKind["GROUP_INDEX"] = 1] = "GROUP_INDEX";
        GroupModelChangeKind[GroupModelChangeKind["GROUP_LABEL"] = 2] = "GROUP_LABEL";
        GroupModelChangeKind[GroupModelChangeKind["GROUP_LOCKED"] = 3] = "GROUP_LOCKED";
        /* Editors Change */
        GroupModelChangeKind[GroupModelChangeKind["EDITORS_SELECTION"] = 4] = "EDITORS_SELECTION";
        /* Editor Changes */
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_OPEN"] = 5] = "EDITOR_OPEN";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_CLOSE"] = 6] = "EDITOR_CLOSE";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_MOVE"] = 7] = "EDITOR_MOVE";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_ACTIVE"] = 8] = "EDITOR_ACTIVE";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_LABEL"] = 9] = "EDITOR_LABEL";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_CAPABILITIES"] = 10] = "EDITOR_CAPABILITIES";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_PIN"] = 11] = "EDITOR_PIN";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_TRANSIENT"] = 12] = "EDITOR_TRANSIENT";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_STICKY"] = 13] = "EDITOR_STICKY";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_DIRTY"] = 14] = "EDITOR_DIRTY";
        GroupModelChangeKind[GroupModelChangeKind["EDITOR_WILL_DISPOSE"] = 15] = "EDITOR_WILL_DISPOSE";
    })(GroupModelChangeKind || (exports.GroupModelChangeKind = GroupModelChangeKind = {}));
    var SideBySideEditor;
    (function (SideBySideEditor) {
        SideBySideEditor[SideBySideEditor["PRIMARY"] = 1] = "PRIMARY";
        SideBySideEditor[SideBySideEditor["SECONDARY"] = 2] = "SECONDARY";
        SideBySideEditor[SideBySideEditor["BOTH"] = 3] = "BOTH";
        SideBySideEditor[SideBySideEditor["ANY"] = 4] = "ANY";
    })(SideBySideEditor || (exports.SideBySideEditor = SideBySideEditor = {}));
    class EditorResourceAccessorImpl {
        getOriginalUri(editor, options) {
            if (!editor) {
                return undefined;
            }
            // Merge editors are handled with `merged` result editor
            if ($eG(editor)) {
                return exports.$qG.getOriginalUri(editor.result, options);
            }
            // Optionally support side-by-side editors
            if (options?.supportSideBySide) {
                const { primary, secondary } = this.a(editor);
                if (primary && secondary) {
                    if (options?.supportSideBySide === SideBySideEditor.BOTH) {
                        return {
                            primary: this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }),
                            secondary: this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme })
                        };
                    }
                    else if (options?.supportSideBySide === SideBySideEditor.ANY) {
                        return this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme });
                    }
                    editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
                }
            }
            if ($aG(editor) || $bG(editor) || $cG(editor) || $eG(editor)) {
                return undefined;
            }
            // Original URI is the `preferredResource` of an editor if any
            const originalResource = isEditorInputWithPreferredResource(editor) ? editor.preferredResource : editor.resource;
            if (!originalResource || !options || !options.filterByScheme) {
                return originalResource;
            }
            return this.b(originalResource, options.filterByScheme);
        }
        a(editor) {
            if ($iG(editor) || $cG(editor)) {
                return { primary: editor.primary, secondary: editor.secondary };
            }
            if ($jG(editor) || $aG(editor)) {
                return { primary: editor.modified, secondary: editor.original };
            }
            return { primary: undefined, secondary: undefined };
        }
        getCanonicalUri(editor, options) {
            if (!editor) {
                return undefined;
            }
            // Merge editors are handled with `merged` result editor
            if ($eG(editor)) {
                return exports.$qG.getCanonicalUri(editor.result, options);
            }
            // Optionally support side-by-side editors
            if (options?.supportSideBySide) {
                const { primary, secondary } = this.a(editor);
                if (primary && secondary) {
                    if (options?.supportSideBySide === SideBySideEditor.BOTH) {
                        return {
                            primary: this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }),
                            secondary: this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme })
                        };
                    }
                    else if (options?.supportSideBySide === SideBySideEditor.ANY) {
                        return this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme });
                    }
                    editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
                }
            }
            if ($aG(editor) || $bG(editor) || $cG(editor) || $eG(editor)) {
                return undefined;
            }
            // Canonical URI is the `resource` of an editor
            const canonicalResource = editor.resource;
            if (!canonicalResource || !options || !options.filterByScheme) {
                return canonicalResource;
            }
            return this.b(canonicalResource, options.filterByScheme);
        }
        b(resource, filter) {
            // Multiple scheme filter
            if (Array.isArray(filter)) {
                if (filter.some(scheme => resource.scheme === scheme)) {
                    return resource;
                }
            }
            // Single scheme filter
            else {
                if (filter === resource.scheme) {
                    return resource;
                }
            }
            return undefined;
        }
    }
    var EditorCloseMethod;
    (function (EditorCloseMethod) {
        EditorCloseMethod[EditorCloseMethod["UNKNOWN"] = 0] = "UNKNOWN";
        EditorCloseMethod[EditorCloseMethod["KEYBOARD"] = 1] = "KEYBOARD";
        EditorCloseMethod[EditorCloseMethod["MOUSE"] = 2] = "MOUSE";
    })(EditorCloseMethod || (exports.EditorCloseMethod = EditorCloseMethod = {}));
    function $pG(group, editor, method, configuration) {
        if (!group.isSticky(editor)) {
            return false; // only interested in sticky editors
        }
        switch (configuration.preventPinnedEditorClose) {
            case 'keyboardAndMouse': return method === EditorCloseMethod.MOUSE || method === EditorCloseMethod.KEYBOARD;
            case 'mouse': return method === EditorCloseMethod.MOUSE;
            case 'keyboard': return method === EditorCloseMethod.KEYBOARD;
        }
        return false;
    }
    exports.$qG = new EditorResourceAccessorImpl();
    var CloseDirection;
    (function (CloseDirection) {
        CloseDirection[CloseDirection["LEFT"] = 0] = "LEFT";
        CloseDirection[CloseDirection["RIGHT"] = 1] = "RIGHT";
    })(CloseDirection || (exports.CloseDirection = CloseDirection = {}));
    class EditorFactoryRegistry {
        constructor() {
            this.c = new Map();
            this.d = new Map();
        }
        start(accessor) {
            const instantiationService = this.a = accessor.get(instantiation_1.$Ei);
            for (const [key, ctor] of this.c) {
                this.e(key, ctor, instantiationService);
            }
            this.c.clear();
        }
        e(editorTypeId, ctor, instantiationService) {
            const instance = instantiationService.createInstance(ctor);
            this.d.set(editorTypeId, instance);
        }
        registerFileEditorFactory(factory) {
            if (this.b) {
                throw new Error('Can only register one file editor factory.');
            }
            this.b = factory;
        }
        getFileEditorFactory() {
            return (0, types_1.$pg)(this.b);
        }
        registerEditorSerializer(editorTypeId, ctor) {
            if (this.c.has(editorTypeId) || this.d.has(editorTypeId)) {
                throw new Error(`A editor serializer with type ID '${editorTypeId}' was already registered.`);
            }
            if (!this.a) {
                this.c.set(editorTypeId, ctor);
            }
            else {
                this.e(editorTypeId, ctor, this.a);
            }
            return (0, lifecycle_1.$Sc)(() => {
                this.c.delete(editorTypeId);
                this.d.delete(editorTypeId);
            });
        }
        getEditorSerializer(arg1) {
            return this.d.get(typeof arg1 === 'string' ? arg1 : arg1.typeId);
        }
    }
    platform_1.$ro.add(exports.$4F.EditorFactory, new EditorFactoryRegistry());
    async function $rG(paths, fileService, logService) {
        if (!paths || !paths.length) {
            return [];
        }
        return await Promise.all(paths.map(async (path) => {
            const resource = uri_1.URI.revive(path.fileUri);
            if (!resource) {
                logService.info('Cannot resolve the path because it is not valid.', path);
                return undefined;
            }
            const canHandleResource = await fileService.canHandleResource(resource);
            if (!canHandleResource) {
                logService.info('Cannot resolve the path because it cannot be handled', path);
                return undefined;
            }
            let exists = path.exists;
            let type = path.type;
            if (typeof exists !== 'boolean' || typeof type !== 'number') {
                try {
                    type = (await fileService.stat(resource)).isDirectory ? files_1.FileType.Directory : files_1.FileType.Unknown;
                    exists = true;
                }
                catch (error) {
                    logService.error(error);
                    exists = false;
                }
            }
            if (!exists && path.openOnlyIfExists) {
                logService.info('Cannot resolve the path because it does not exist', path);
                return undefined;
            }
            if (type === files_1.FileType.Directory) {
                logService.info('Cannot resolve the path because it is a directory', path);
                return undefined;
            }
            const options = {
                ...path.options,
                pinned: true
            };
            if (!exists) {
                return { resource, options, forceUntitled: true };
            }
            return { resource, options };
        }));
    }
    var EditorsOrder;
    (function (EditorsOrder) {
        /**
         * Editors sorted by most recent activity (most recent active first)
         */
        EditorsOrder[EditorsOrder["MOST_RECENTLY_ACTIVE"] = 0] = "MOST_RECENTLY_ACTIVE";
        /**
         * Editors sorted by sequential order
         */
        EditorsOrder[EditorsOrder["SEQUENTIAL"] = 1] = "SEQUENTIAL";
    })(EditorsOrder || (exports.EditorsOrder = EditorsOrder = {}));
    function $sG(candidate) {
        const viewState = candidate;
        if (!viewState) {
            return false;
        }
        const diffEditorViewState = viewState;
        if (diffEditorViewState.modified) {
            return $sG(diffEditorViewState.modified);
        }
        const codeEditorViewState = viewState;
        return !!(codeEditorViewState.contributionsState && codeEditorViewState.viewState && Array.isArray(codeEditorViewState.cursorState));
    }
    function $tG(obj) {
        return (0, errorMessage_1.$rj)(obj);
    }
    function $uG(messageOrError, actions, options) {
        const error = (0, errorMessage_1.$sj)(messageOrError, actions);
        error.forceMessage = options?.forceMessage;
        error.forceSeverity = options?.forceSeverity;
        error.allowDialog = options?.allowDialog;
        return error;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[192/*vs/workbench/common/views*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,9/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/,4/*vs/base/common/lifecycle*/,28/*vs/base/common/map*/,30/*vs/platform/registry/common/platform*/,25/*vs/base/common/objects*/,97/*vs/base/common/codicons*/,182/*vs/platform/theme/common/iconRegistry*/]), function (require, exports, event_1, nls_1, instantiation_1, lifecycle_1, map_1, platform_1, objects_1, codicons_1, iconRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$CG = exports.$BG = exports.TreeItemCollapsibleState = exports.ViewVisibilityState = exports.$AG = exports.ViewContentGroups = exports.$yG = exports.ViewContainerLocation = exports.Extensions = exports.$xG = exports.$wG = exports.$vG = void 0;
    exports.$zG = $zG;
    exports.$vG = 'views';
    exports.$wG = (0, nls_1.localize)(12313, null);
    exports.$xG = (0, iconRegistry_1.$Bx)('default-view-icon', codicons_1.$5j.window, (0, nls_1.localize)(12314, null));
    var Extensions;
    (function (Extensions) {
        Extensions.ViewContainersRegistry = 'workbench.registry.view.containers';
        Extensions.ViewsRegistry = 'workbench.registry.view';
    })(Extensions || (exports.Extensions = Extensions = {}));
    var ViewContainerLocation;
    (function (ViewContainerLocation) {
        ViewContainerLocation[ViewContainerLocation["Sidebar"] = 0] = "Sidebar";
        ViewContainerLocation[ViewContainerLocation["Panel"] = 1] = "Panel";
        ViewContainerLocation[ViewContainerLocation["AuxiliaryBar"] = 2] = "AuxiliaryBar";
    })(ViewContainerLocation || (exports.ViewContainerLocation = ViewContainerLocation = {}));
    exports.$yG = [ViewContainerLocation.Sidebar, ViewContainerLocation.Panel, ViewContainerLocation.AuxiliaryBar];
    function $zG(viewContainerLocation) {
        switch (viewContainerLocation) {
            case ViewContainerLocation.Sidebar: return 'sidebar';
            case ViewContainerLocation.Panel: return 'panel';
            case ViewContainerLocation.AuxiliaryBar: return 'auxiliarybar';
        }
    }
    class ViewContainersRegistryImpl extends lifecycle_1.$Uc {
        constructor() {
            super(...arguments);
            this.c = this.B(new event_1.$le());
            this.onDidRegister = this.c.event;
            this.f = this.B(new event_1.$le());
            this.onDidDeregister = this.f.event;
            this.g = new Map();
            this.h = [];
        }
        get all() {
            return [...this.g.values()].flat();
        }
        registerViewContainer(viewContainerDescriptor, viewContainerLocation, options) {
            const existing = this.get(viewContainerDescriptor.id);
            if (existing) {
                return existing;
            }
            const viewContainer = viewContainerDescriptor;
            viewContainer.openCommandActionDescriptor = options?.doNotRegisterOpenCommand ? undefined : (viewContainer.openCommandActionDescriptor ?? { id: viewContainer.id });
            const viewContainers = (0, map_1.$xc)(this.g, viewContainerLocation, []);
            viewContainers.push(viewContainer);
            if (options?.isDefault) {
                this.h.push(viewContainer);
            }
            this.c.fire({ viewContainer, viewContainerLocation });
            return viewContainer;
        }
        deregisterViewContainer(viewContainer) {
            for (const viewContainerLocation of this.g.keys()) {
                const viewContainers = this.g.get(viewContainerLocation);
                const index = viewContainers?.indexOf(viewContainer);
                if (index !== -1) {
                    viewContainers?.splice(index, 1);
                    if (viewContainers.length === 0) {
                        this.g.delete(viewContainerLocation);
                    }
                    this.f.fire({ viewContainer, viewContainerLocation });
                    return;
                }
            }
        }
        get(id) {
            return this.all.filter(viewContainer => viewContainer.id === id)[0];
        }
        getViewContainers(location) {
            return [...(this.g.get(location) || [])];
        }
        getViewContainerLocation(container) {
            return [...this.g.keys()].filter(location => this.getViewContainers(location).filter(viewContainer => viewContainer?.id === container.id).length > 0)[0];
        }
        getDefaultViewContainer(location) {
            return this.h.find(viewContainer => this.getViewContainerLocation(viewContainer) === location);
        }
    }
    platform_1.$ro.add(Extensions.ViewContainersRegistry, new ViewContainersRegistryImpl());
    var ViewContentGroups;
    (function (ViewContentGroups) {
        ViewContentGroups["Open"] = "2_open";
        ViewContentGroups["Debug"] = "4_debug";
        ViewContentGroups["SCM"] = "5_scm";
        ViewContentGroups["More"] = "9_more";
    })(ViewContentGroups || (exports.ViewContentGroups = ViewContentGroups = {}));
    function compareViewContentDescriptors(a, b) {
        const aGroup = a.group ?? ViewContentGroups.More;
        const bGroup = b.group ?? ViewContentGroups.More;
        if (aGroup !== bGroup) {
            return aGroup.localeCompare(bGroup);
        }
        return (a.order ?? 5) - (b.order ?? 5);
    }
    class ViewsRegistry extends lifecycle_1.$Uc {
        constructor() {
            super(...arguments);
            this.c = this.B(new event_1.$le());
            this.onViewsRegistered = this.c.event;
            this.f = this.B(new event_1.$le());
            this.onViewsDeregistered = this.f.event;
            this.g = this.B(new event_1.$le());
            this.onDidChangeContainer = this.g.event;
            this.h = this.B(new event_1.$le());
            this.onDidChangeViewWelcomeContent = this.h.event;
            this.j = [];
            this.m = new Map();
            this.n = new map_1.$Hc();
        }
        registerViews(views, viewContainer) {
            this.registerViews2([{ views, viewContainer }]);
        }
        registerViews2(views) {
            views.forEach(({ views, viewContainer }) => this.r(views, viewContainer));
            this.c.fire(views);
        }
        deregisterViews(viewDescriptors, viewContainer) {
            const views = this.s(viewDescriptors, viewContainer);
            if (views.length) {
                this.f.fire({ views, viewContainer });
            }
        }
        moveViews(viewsToMove, viewContainer) {
            for (const container of this.m.keys()) {
                if (container !== viewContainer) {
                    const views = this.s(viewsToMove, container);
                    if (views.length) {
                        this.r(views, viewContainer);
                        this.g.fire({ views, from: container, to: viewContainer });
                    }
                }
            }
        }
        getViews(loc) {
            return this.m.get(loc) || [];
        }
        getView(id) {
            for (const viewContainer of this.j) {
                const viewDescriptor = (this.m.get(viewContainer) || []).filter(v => v.id === id)[0];
                if (viewDescriptor) {
                    return viewDescriptor;
                }
            }
            return null;
        }
        getViewContainer(viewId) {
            for (const viewContainer of this.j) {
                const viewDescriptor = (this.m.get(viewContainer) || []).filter(v => v.id === viewId)[0];
                if (viewDescriptor) {
                    return viewContainer;
                }
            }
            return null;
        }
        registerViewWelcomeContent(id, viewContent) {
            this.n.add(id, viewContent);
            this.h.fire(id);
            return (0, lifecycle_1.$Sc)(() => {
                this.n.delete(id, viewContent);
                this.h.fire(id);
            });
        }
        registerViewWelcomeContent2(id, viewContentMap) {
            const disposables = new Map();
            for (const [key, content] of viewContentMap) {
                this.n.add(id, content);
                disposables.set(key, (0, lifecycle_1.$Sc)(() => {
                    this.n.delete(id, content);
                    this.h.fire(id);
                }));
            }
            this.h.fire(id);
            return disposables;
        }
        getViewWelcomeContent(id) {
            const result = [];
            this.n.forEach(id, descriptor => result.push(descriptor));
            return result.sort(compareViewContentDescriptors);
        }
        r(viewDescriptors, viewContainer) {
            let views = this.m.get(viewContainer);
            if (!views) {
                views = [];
                this.m.set(viewContainer, views);
                this.j.push(viewContainer);
            }
            for (const viewDescriptor of viewDescriptors) {
                if (this.getView(viewDescriptor.id) !== null) {
                    throw new Error((0, nls_1.localize)(12315, null, viewDescriptor.id));
                }
                views.push(viewDescriptor);
            }
        }
        s(viewDescriptors, viewContainer) {
            const views = this.m.get(viewContainer);
            if (!views) {
                return [];
            }
            const viewsToDeregister = [];
            const remaningViews = [];
            for (const view of views) {
                if (!viewDescriptors.includes(view)) {
                    remaningViews.push(view);
                }
                else {
                    viewsToDeregister.push(view);
                }
            }
            if (viewsToDeregister.length) {
                if (remaningViews.length) {
                    this.m.set(viewContainer, remaningViews);
                }
                else {
                    this.m.delete(viewContainer);
                    this.j.splice(this.j.indexOf(viewContainer), 1);
                }
            }
            return viewsToDeregister;
        }
    }
    platform_1.$ro.add(Extensions.ViewsRegistry, new ViewsRegistry());
    exports.$AG = (0, instantiation_1.$Fi)('viewDescriptorService');
    var ViewVisibilityState;
    (function (ViewVisibilityState) {
        ViewVisibilityState[ViewVisibilityState["Default"] = 0] = "Default";
        ViewVisibilityState[ViewVisibilityState["Expand"] = 1] = "Expand";
    })(ViewVisibilityState || (exports.ViewVisibilityState = ViewVisibilityState = {}));
    var TreeItemCollapsibleState;
    (function (TreeItemCollapsibleState) {
        TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = TreeItemCollapsibleState = {}));
    class $BG {
        constructor(treeItem, resolve) {
            this.c = false;
            this.d = false;
            (0, objects_1.$ho)(this, treeItem);
            this.d = !!resolve;
            this.resolve = async (token) => {
                if (resolve && !this.c) {
                    const resolvedItem = await resolve(token);
                    if (resolvedItem) {
                        // Resolvable elements. Currently tooltip and command.
                        this.tooltip = this.tooltip ?? resolvedItem.tooltip;
                        this.command = this.command ?? resolvedItem.command;
                    }
                }
                if (!token.isCancellationRequested) {
                    this.c = true;
                }
            };
        }
        get hasResolve() {
            return this.d;
        }
        resetResolve() {
            this.c = false;
        }
        asTreeItem() {
            return {
                handle: this.handle,
                parentHandle: this.parentHandle,
                collapsibleState: this.collapsibleState,
                label: this.label,
                description: this.description,
                icon: this.icon,
                iconDark: this.iconDark,
                themeIcon: this.themeIcon,
                resourceUri: this.resourceUri,
                tooltip: this.tooltip,
                contextValue: this.contextValue,
                command: this.command,
                children: this.children,
                accessibilityInformation: this.accessibilityInformation
            };
        }
    }
    exports.$BG = $BG;
    class $CG extends Error {
        constructor(treeViewId) {
            super((0, nls_1.localize)(12316, null, treeViewId));
            this.name = 'NoTreeViewError';
        }
        static is(err) {
            return err.name === 'NoTreeViewError';
        }
    }
    exports.$CG = $CG;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[193/*vs/workbench/contrib/chat/common/chatContextKeys*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,31/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, nls_1, contextkey_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$WG = exports.$VG = exports.$UG = exports.$TG = exports.$SG = exports.$RG = exports.$QG = exports.$PG = exports.$OG = exports.$NG = exports.$MG = exports.$LG = exports.$KG = exports.$JG = exports.$IG = exports.$HG = exports.$GG = void 0;
    exports.$GG = new contextkey_1.$Wj('chatSessionResponseVote', '', { type: 'string', description: (0, nls_1.localize)(8666, null) });
    exports.$HG = new contextkey_1.$Wj('chatSessionResponseDetectedAgentOrCommand', false, { type: 'boolean', description: (0, nls_1.localize)(8667, null) });
    exports.$IG = new contextkey_1.$Wj('chatResponseSupportsIssueReporting', false, { type: 'boolean', description: (0, nls_1.localize)(8668, null) });
    exports.$JG = new contextkey_1.$Wj('chatSessionResponseFiltered', false, { type: 'boolean', description: (0, nls_1.localize)(8669, null) });
    exports.$KG = new contextkey_1.$Wj('chatSessionRequestInProgress', false, { type: 'boolean', description: (0, nls_1.localize)(8670, null) });
    exports.$LG = new contextkey_1.$Wj('chatResponse', false, { type: 'boolean', description: (0, nls_1.localize)(8671, null) });
    exports.$MG = new contextkey_1.$Wj('chatRequest', false, { type: 'boolean', description: (0, nls_1.localize)(8672, null) });
    exports.$NG = new contextkey_1.$Wj('chatEditApplied', false, { type: 'boolean', description: (0, nls_1.localize)(8673, null) });
    exports.$OG = new contextkey_1.$Wj('chatInputHasText', false, { type: 'boolean', description: (0, nls_1.localize)(8674, null) });
    exports.$PG = new contextkey_1.$Wj('chatInputHasFocus', false, { type: 'boolean', description: (0, nls_1.localize)(8675, null) });
    exports.$QG = new contextkey_1.$Wj('inChatInput', false, { type: 'boolean', description: (0, nls_1.localize)(8676, null) });
    exports.$RG = new contextkey_1.$Wj('inChat', false, { type: 'boolean', description: (0, nls_1.localize)(8677, null) });
    exports.$SG = new contextkey_1.$Wj('chatIsEnabled', false, { type: 'boolean', description: (0, nls_1.localize)(8678, null) });
    exports.$TG = new contextkey_1.$Wj('chatCursorAtTop', false);
    exports.$UG = new contextkey_1.$Wj('chatInputHasAgent', false);
    exports.$VG = new contextkey_1.$Wj('chatLocation', undefined);
    exports.$WG = new contextkey_1.$Wj('quickChatHasFocus', false, { type: 'boolean', description: (0, nls_1.localize)(8679, null) });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[115/*vs/workbench/contrib/chat/common/chatAgents*/], __M([1/*require*/,0/*exports*/,283/*vs/base/common/arraysFind*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,40/*vs/base/common/iterator*/,4/*vs/base/common/lifecycle*/,36/*vs/base/common/marshalling*/,143/*vs/base/common/observableInternal/base*/,12/*vs/base/common/strings*/,31/*vs/platform/contextkey/common/contextkey*/,18/*vs/platform/extensions/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,108/*vs/platform/product/common/productService*/,176/*vs/platform/request/common/request*/,187/*vs/platform/storage/common/storage*/,193/*vs/workbench/contrib/chat/common/chatContextKeys*/]), function (require, exports, arraysFind_1, async_1, cancellation_1, event_1, iterator_1, lifecycle_1, marshalling_1, base_1, strings_1, contextkey_1, extensions_1, instantiation_1, log_1, productService_1, request_1, storage_1, chatContextKeys_1) {
    "use strict";
    var $1H_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$1H = exports.$ZH = exports.$YH = exports.$XH = exports.$WH = exports.ChatAgentLocation = void 0;
    exports.$2H = $2H;
    exports.$3H = $3H;
    var ChatAgentLocation;
    (function (ChatAgentLocation) {
        ChatAgentLocation["Panel"] = "panel";
        ChatAgentLocation["Terminal"] = "terminal";
        ChatAgentLocation["Notebook"] = "notebook";
        ChatAgentLocation["Editor"] = "editor";
    })(ChatAgentLocation || (exports.ChatAgentLocation = ChatAgentLocation = {}));
    (function (ChatAgentLocation) {
        function fromRaw(value) {
            switch (value) {
                case 'panel': return ChatAgentLocation.Panel;
                case 'terminal': return ChatAgentLocation.Terminal;
                case 'notebook': return ChatAgentLocation.Notebook;
                case 'editor': return ChatAgentLocation.Editor;
            }
            return ChatAgentLocation.Panel;
        }
        ChatAgentLocation.fromRaw = fromRaw;
    })(ChatAgentLocation || (exports.ChatAgentLocation = ChatAgentLocation = {}));
    exports.$WH = (0, instantiation_1.$Fi)('chatAgentService');
    let $XH = class $XH {
        static { this.AGENT_LEADER = '@'; }
        constructor(f) {
            this.f = f;
            this.b = new Map();
            this.d = new event_1.$le();
            this.onDidChangeAgents = this.d.event;
            this.g = new Map();
            this.e = chatContextKeys_1.$SG.bindTo(this.f);
        }
        registerAgent(id, data) {
            const existingAgent = this.getAgent(id);
            if (existingAgent) {
                throw new Error(`Agent already registered: ${JSON.stringify(id)}`);
            }
            const that = this;
            const commands = data.slashCommands;
            data = {
                ...data,
                get slashCommands() {
                    return commands.filter(c => !c.when || that.f.contextMatchesRules(contextkey_1.$Dj.deserialize(c.when)));
                }
            };
            const entry = { data };
            this.b.set(id, entry);
            return (0, lifecycle_1.$Sc)(() => {
                this.b.delete(id);
                this.d.fire(undefined);
            });
        }
        registerAgentImplementation(id, agentImpl) {
            const entry = this.b.get(id);
            if (!entry) {
                throw new Error(`Unknown agent: ${JSON.stringify(id)}`);
            }
            if (entry.impl) {
                throw new Error(`Agent already has implementation: ${JSON.stringify(id)}`);
            }
            if (entry.data.isDefault) {
                this.e.set(true);
            }
            entry.impl = agentImpl;
            this.d.fire(new $YH(entry.data, agentImpl));
            return (0, lifecycle_1.$Sc)(() => {
                entry.impl = undefined;
                this.d.fire(undefined);
                if (entry.data.isDefault) {
                    this.e.set(false);
                }
            });
        }
        registerDynamicAgent(data, agentImpl) {
            data.isDynamic = true;
            const agent = { data, impl: agentImpl };
            this.b.set(data.id, agent);
            this.d.fire(new $YH(data, agentImpl));
            return (0, lifecycle_1.$Sc)(() => {
                this.b.delete(data.id);
                this.d.fire(undefined);
            });
        }
        registerAgentCompletionProvider(id, provider) {
            this.g.set(id, provider);
            return {
                dispose: () => { this.g.delete(id); }
            };
        }
        async getAgentCompletionItems(id, query, token) {
            return await this.g.get(id)?.(query, token) ?? [];
        }
        updateAgent(id, updateMetadata) {
            const agent = this.b.get(id);
            if (!agent?.impl) {
                throw new Error(`No activated agent with id ${JSON.stringify(id)} registered`);
            }
            agent.data.metadata = { ...agent.data.metadata, ...updateMetadata };
            this.d.fire(new $YH(agent.data, agent.impl));
        }
        getDefaultAgent(location) {
            return (0, arraysFind_1.$eb)(this.getActivatedAgents(), a => !!a.isDefault && a.locations.includes(location));
        }
        getContributedDefaultAgent(location) {
            return this.getAgents().find(a => !!a.isDefault && a.locations.includes(location));
        }
        getSecondaryAgent() {
            // TODO also static
            return iterator_1.Iterable.find(this.b.values(), a => !!a.data.metadata.isSecondary)?.data;
        }
        getAgent(id) {
            if (!this.h(id)) {
                return;
            }
            return this.b.get(id)?.data;
        }
        h(id) {
            const entry = this.b.get(id);
            return !entry?.data.when || this.f.contextMatchesRules(contextkey_1.$Dj.deserialize(entry.data.when));
        }
        getAgentByFullyQualifiedId(id) {
            const agent = iterator_1.Iterable.find(this.b.values(), a => $2H(a.data) === id)?.data;
            if (agent && !this.h(agent.id)) {
                return;
            }
            return agent;
        }
        /**
         * Returns all agent datas that exist- static registered and dynamic ones.
         */
        getAgents() {
            return Array.from(this.b.values())
                .map(entry => entry.data)
                .filter(a => this.h(a.id));
        }
        getActivatedAgents() {
            return Array.from(this.b.values())
                .filter(a => !!a.impl)
                .filter(a => this.h(a.data.id))
                .map(a => new $YH(a.data, a.impl));
        }
        getAgentsByName(name) {
            return this.getAgents().filter(a => a.name === name);
        }
        agentHasDupeName(id) {
            const agent = this.getAgent(id);
            if (!agent) {
                return false;
            }
            return this.getAgentsByName(agent.name)
                .filter(a => a.extensionId.value !== agent.extensionId.value).length > 0;
        }
        async invokeAgent(id, request, progress, history, token) {
            const data = this.b.get(id);
            if (!data?.impl) {
                throw new Error(`No activated agent with id "${id}"`);
            }
            return await data.impl.invoke(request, progress, history, token);
        }
        async getFollowups(id, request, result, history, token) {
            const data = this.b.get(id);
            if (!data?.impl) {
                throw new Error(`No activated agent with id "${id}"`);
            }
            if (!data.impl?.provideFollowups) {
                return [];
            }
            return data.impl.provideFollowups(request, result, history, token);
        }
    };
    exports.$XH = $XH;
    exports.$XH = $XH = __decorate([
        __param(0, contextkey_1.$Xj)
    ], $XH);
    class $YH {
        constructor(b, d) {
            this.b = b;
            this.d = d;
        }
        get id() { return this.b.id; }
        get name() { return this.b.name ?? ''; }
        get fullName() { return this.b.fullName ?? ''; }
        get description() { return this.b.description ?? ''; }
        get extensionId() { return this.b.extensionId; }
        get extensionPublisherId() { return this.b.extensionPublisherId; }
        get extensionPublisherDisplayName() { return this.b.publisherDisplayName; }
        get extensionDisplayName() { return this.b.extensionDisplayName; }
        get isDefault() { return this.b.isDefault; }
        get metadata() { return this.b.metadata; }
        get slashCommands() { return this.b.slashCommands; }
        get locations() { return this.b.locations; }
        async invoke(request, progress, history, token) {
            return this.d.invoke(request, progress, history, token);
        }
        async provideFollowups(request, result, history, token) {
            if (this.d.provideFollowups) {
                return this.d.provideFollowups(request, result, history, token);
            }
            return [];
        }
        provideWelcomeMessage(location, token) {
            if (this.d.provideWelcomeMessage) {
                return this.d.provideWelcomeMessage(location, token);
            }
            return undefined;
        }
        provideSampleQuestions(location, token) {
            if (this.d.provideSampleQuestions) {
                return this.d.provideSampleQuestions(location, token);
            }
            return undefined;
        }
    }
    exports.$YH = $YH;
    exports.$ZH = (0, instantiation_1.$Fi)('chatAgentNameService');
    let $1H = class $1H {
        static { $1H_1 = this; }
        static { this.b = 'chat.participantNameRegistry'; }
        constructor(productService, g, h, i) {
            this.g = g;
            this.h = h;
            this.i = i;
            this.e = (0, base_1.$6d)(this, Object.create(null));
            this.f = false;
            if (!productService.chatParticipantRegistry) {
                return;
            }
            this.d = productService.chatParticipantRegistry;
            const raw = i.get($1H_1.b, storage_1.StorageScope.APPLICATION);
            try {
                this.e.set(JSON.parse(raw ?? '{}'), undefined);
            }
            catch (err) {
                i.remove($1H_1.b, storage_1.StorageScope.APPLICATION);
            }
            this.j();
        }
        j() {
            if (this.f) {
                return;
            }
            this.k()
                .catch(err => this.h.warn('Failed to fetch chat participant registry', err))
                .then(() => (0, async_1.$Gh)(5 * 60 * 1000)) // every 5 minutes
                .then(() => this.j());
        }
        async k() {
            const context = await this.g.request({ type: 'GET', url: this.d }, cancellation_1.CancellationToken.None);
            if (context.res.statusCode !== 200) {
                throw new Error('Could not get extensions report.');
            }
            const result = await (0, request_1.$bq)(context);
            if (!result || result.version !== 1) {
                throw new Error('Unexpected chat participant registry response.');
            }
            const registry = result.restrictedChatParticipants;
            this.e.set(registry, undefined);
            this.i.store($1H_1.b, JSON.stringify(registry), storage_1.StorageScope.APPLICATION, storage_1.StorageTarget.MACHINE);
        }
        /**
         * Returns true if the agent is allowed to use this name
         */
        getAgentNameRestriction(chatAgentData) {
            // TODO would like to use observables here but nothing uses it downstream and I'm not sure how to combine these two
            const nameAllowed = this.l(chatAgentData.name, chatAgentData).get();
            const fullNameAllowed = !chatAgentData.fullName || this.l(chatAgentData.fullName.replace(/\s/g, ''), chatAgentData).get();
            return nameAllowed && fullNameAllowed;
        }
        l(name, chatAgentData) {
            // Registry is a map of name to an array of extension publisher IDs or extension IDs that are allowed to use it.
            // Look up the list of extensions that are allowed to use this name
            const allowList = this.e.map(registry => registry[name.toLowerCase()]);
            return allowList.map(allowList => {
                if (!allowList) {
                    return true;
                }
                return allowList.some(id => (0, strings_1.$Ff)(id, id.includes('.') ? chatAgentData.extensionId.value : chatAgentData.extensionPublisherId));
            });
        }
        dispose() {
            this.f = true;
        }
    };
    exports.$1H = $1H;
    exports.$1H = $1H = $1H_1 = __decorate([
        __param(0, productService_1.$tk),
        __param(1, request_1.$8p),
        __param(2, log_1.$ak),
        __param(3, storage_1.$iq)
    ], $1H);
    function $2H(chatAgentData) {
        return `${chatAgentData.extensionId.value}.${chatAgentData.id}`;
    }
    function $3H(raw) {
        const agent = 'name' in raw ?
            raw :
            {
                ...raw,
                name: raw.id,
            };
        // Fill in required fields that may be missing from old data
        if (!('extensionPublisherId' in agent)) {
            agent.extensionPublisherId = agent.extensionPublisher ?? '';
        }
        if (!('extensionDisplayName' in agent)) {
            agent.extensionDisplayName = '';
        }
        if (!('extensionId' in agent)) {
            agent.extensionId = new extensions_1.$rn('');
        }
        return (0, marshalling_1.$ci)(agent);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[194/*vs/workbench/contrib/chat/common/chatService*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,32/*vs/editor/common/core/range*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, uri_1, range_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$uH = exports.$tH = exports.ChatCopyKind = exports.ChatAgentVoteDirection = exports.ChatResponseReferencePartStatusKind = void 0;
    exports.$rH = $rH;
    exports.$sH = $sH;
    function $rH(obj) {
        return (!!obj &&
            typeof obj === 'object' &&
            'uri' in obj && obj.uri instanceof uri_1.URI &&
            'version' in obj && typeof obj.version === 'number' &&
            'ranges' in obj && Array.isArray(obj.ranges) && obj.ranges.every(range_1.$Ot.isIRange));
    }
    function $sH(obj) {
        return (!!obj &&
            typeof obj === 'object' &&
            'documents' in obj &&
            Array.isArray(obj.documents) &&
            obj.documents.every($rH));
    }
    var ChatResponseReferencePartStatusKind;
    (function (ChatResponseReferencePartStatusKind) {
        ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind["Complete"] = 1] = "Complete";
        ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind["Partial"] = 2] = "Partial";
        ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind["Omitted"] = 3] = "Omitted";
    })(ChatResponseReferencePartStatusKind || (exports.ChatResponseReferencePartStatusKind = ChatResponseReferencePartStatusKind = {}));
    var ChatAgentVoteDirection;
    (function (ChatAgentVoteDirection) {
        ChatAgentVoteDirection[ChatAgentVoteDirection["Down"] = 0] = "Down";
        ChatAgentVoteDirection[ChatAgentVoteDirection["Up"] = 1] = "Up";
    })(ChatAgentVoteDirection || (exports.ChatAgentVoteDirection = ChatAgentVoteDirection = {}));
    var ChatCopyKind;
    (function (ChatCopyKind) {
        // Keyboard shortcut or context menu
        ChatCopyKind[ChatCopyKind["Action"] = 1] = "Action";
        ChatCopyKind[ChatCopyKind["Toolbar"] = 2] = "Toolbar";
    })(ChatCopyKind || (exports.ChatCopyKind = ChatCopyKind = {}));
    exports.$tH = (0, instantiation_1.$Fi)('IChatService');
    exports.$uH = 'accessibility.voice.keywordActivation';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[195/*vs/workbench/contrib/debug/common/abstractDebugAdapter*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,10/*vs/base/common/async*/,9/*vs/nls*/]), function (require, exports, event_1, async_1, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$7tb = void 0;
    /**
     * Abstract implementation of the low level API for a debug adapter.
     * Missing is how this API communicates with the debug adapter.
     */
    class $7tb {
        constructor() {
            this.f = new Map();
            this.m = [];
            this.n = new event_1.$le();
            this.o = new event_1.$le();
            this.d = 1;
        }
        get onError() {
            return this.n.event;
        }
        get onExit() {
            return this.o.event;
        }
        onMessage(callback) {
            if (this.k) {
                this.n.fire(new Error(`attempt to set more than one 'Message' callback`));
            }
            this.k = callback;
        }
        onEvent(callback) {
            if (this.j) {
                this.n.fire(new Error(`attempt to set more than one 'Event' callback`));
            }
            this.j = callback;
        }
        onRequest(callback) {
            if (this.g) {
                this.n.fire(new Error(`attempt to set more than one 'Request' callback`));
            }
            this.g = callback;
        }
        sendResponse(response) {
            if (response.seq > 0) {
                this.n.fire(new Error(`attempt to send more than one response for command ${response.command}`));
            }
            else {
                this.u('response', response);
            }
        }
        sendRequest(command, args, clb, timeout) {
            const request = {
                command: command
            };
            if (args && Object.keys(args).length > 0) {
                request.arguments = args;
            }
            this.u('request', request);
            if (typeof timeout === 'number') {
                const timer = setTimeout(() => {
                    clearTimeout(timer);
                    const clb = this.f.get(request.seq);
                    if (clb) {
                        this.f.delete(request.seq);
                        const err = {
                            type: 'response',
                            seq: 0,
                            request_seq: request.seq,
                            success: false,
                            command,
                            message: (0, nls_1.localize)(8379, null, timeout, command)
                        };
                        clb(err);
                    }
                }, timeout);
            }
            if (clb) {
                // store callback for this request
                this.f.set(request.seq, clb);
            }
            return request.seq;
        }
        acceptMessage(message) {
            if (this.k) {
                this.k(message);
            }
            else {
                this.m.push(message);
                if (this.m.length === 1) {
                    // first item = need to start processing loop
                    this.s();
                }
            }
        }
        /**
         * Returns whether we should insert a timeout between processing messageA
         * and messageB. Artificially queueing protocol messages guarantees that any
         * microtasks for previous message finish before next message is processed.
         * This is essential ordering when using promises anywhere along the call path.
         *
         * For example, take the following, where `chooseAndSendGreeting` returns
         * a person name and then emits a greeting event:
         *
         * ```
         * let person: string;
         * adapter.onGreeting(() => console.log('hello', person));
         * person = await adapter.chooseAndSendGreeting();
         * ```
         *
         * Because the event is dispatched synchronously, it may fire before person
         * is assigned if they're processed in the same task. Inserting a task
         * boundary avoids this issue.
         */
        q(messageA, messageB) {
            return messageA.type !== 'event' || messageB.type !== 'event';
        }
        /**
         * Reads and dispatches items from the queue until it is empty.
         */
        async s() {
            let message;
            while (this.m.length) {
                if (!message || this.q(this.m[0], message)) {
                    await (0, async_1.$Gh)(0);
                }
                message = this.m.shift();
                if (!message) {
                    return; // may have been disposed of
                }
                switch (message.type) {
                    case 'event':
                        this.j?.(message);
                        break;
                    case 'request':
                        this.g?.(message);
                        break;
                    case 'response': {
                        const response = message;
                        const clb = this.f.get(response.request_seq);
                        if (clb) {
                            this.f.delete(response.request_seq);
                            clb(response);
                        }
                        break;
                    }
                }
            }
        }
        u(typ, message) {
            message.type = typ;
            message.seq = this.d++;
            this.sendMessage(message);
        }
        async w() {
            if (this.f.size === 0) {
                return Promise.resolve();
            }
            const pending = new Map();
            this.f.forEach((value, key) => pending.set(key, value));
            await (0, async_1.$Gh)(500);
            pending.forEach((callback, request_seq) => {
                const err = {
                    type: 'response',
                    seq: 0,
                    request_seq,
                    success: false,
                    command: 'canceled',
                    message: 'canceled'
                };
                callback(err);
                this.f.delete(request_seq);
            });
        }
        getPendingRequestIds() {
            return Array.from(this.f.keys());
        }
        dispose() {
            this.m = [];
        }
    }
    exports.$7tb = $7tb;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[80/*vs/workbench/contrib/debug/common/debug*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,9/*vs/nls*/,31/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, uri_1, nls, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IDebugVisualization = exports.IDebugVisualizationTreeItem = exports.DebugTreeItemCollapsibleState = exports.DebugVisualizationType = exports.BreakpointWidgetContext = exports.$PK = exports.DebuggerString = exports.DebugConfigurationProviderTriggerKind = exports.DataBreakpointSetType = exports.$NK = exports.MemoryRangeType = exports.State = exports.$LK = exports.$KK = exports.$JK = exports.$IK = exports.$HK = exports.$GK = exports.$FK = exports.$EK = exports.$DK = exports.$CK = exports.$BK = exports.$AK = exports.$zK = exports.$yK = exports.$xK = exports.$wK = exports.$vK = exports.$uK = exports.$tK = exports.$sK = exports.$rK = exports.$qK = exports.$pK = exports.$oK = exports.$nK = exports.$mK = exports.$lK = exports.$kK = exports.$jK = exports.$iK = exports.$hK = exports.$gK = exports.$fK = exports.$eK = exports.$dK = exports.$cK = exports.$bK = exports.$aK = exports.$_J = exports.$$J = exports.$0J = exports.$9J = exports.$8J = exports.$7J = exports.$6J = exports.$5J = exports.$4J = exports.$3J = exports.$2J = exports.$1J = exports.$ZJ = exports.$YJ = exports.$XJ = exports.$WJ = exports.$VJ = exports.$UJ = exports.$TJ = exports.$SJ = exports.$RJ = exports.$QJ = exports.$PJ = exports.$OJ = exports.$NJ = exports.$MJ = exports.$LJ = exports.$KJ = exports.$JJ = exports.$IJ = exports.$HJ = exports.$GJ = exports.$FJ = exports.$EJ = exports.$DJ = exports.$CJ = exports.$BJ = exports.$AJ = void 0;
    exports.$MK = $MK;
    exports.$OK = $OK;
    nls = __importStar(nls);
    exports.$AJ = 'workbench.view.debug';
    exports.$BJ = 'workbench.debug.variablesView';
    exports.$CJ = 'workbench.debug.watchExpressionsView';
    exports.$DJ = 'workbench.debug.callStackView';
    exports.$EJ = 'workbench.debug.loadedScriptsView';
    exports.$FJ = 'workbench.debug.breakPointsView';
    exports.$GJ = 'workbench.debug.disassemblyView';
    exports.$HJ = 'workbench.panel.repl';
    exports.$IJ = 'workbench.panel.repl.view';
    exports.$JJ = new contextkey_1.$Wj('debugType', undefined, { type: 'string', description: nls.localize(8316, null) });
    exports.$KJ = new contextkey_1.$Wj('debugConfigurationType', undefined, { type: 'string', description: nls.localize(8317, null) });
    exports.$LJ = new contextkey_1.$Wj('debugState', 'inactive', { type: 'string', description: nls.localize(8318, null) });
    exports.$MJ = 'debugUx';
    exports.$NJ = new contextkey_1.$Wj(exports.$MJ, 'default', { type: 'string', description: nls.localize(8319, null) });
    exports.$OJ = new contextkey_1.$Wj('hasDebugged', false, { type: 'boolean', description: nls.localize(8320, null) });
    exports.$PJ = new contextkey_1.$Wj('inDebugMode', false, { type: 'boolean', description: nls.localize(8321, null) });
    exports.$QJ = new contextkey_1.$Wj('inDebugRepl', false, { type: 'boolean', description: nls.localize(8322, null) });
    exports.$RJ = new contextkey_1.$Wj('breakpointWidgetVisible', false, { type: 'boolean', description: nls.localize(8323, null) });
    exports.$SJ = new contextkey_1.$Wj('inBreakpointWidget', false, { type: 'boolean', description: nls.localize(8324, null) });
    exports.$TJ = new contextkey_1.$Wj('breakpointsFocused', true, { type: 'boolean', description: nls.localize(8325, null) });
    exports.$UJ = new contextkey_1.$Wj('watchExpressionsFocused', true, { type: 'boolean', description: nls.localize(8326, null) });
    exports.$VJ = new contextkey_1.$Wj('watchExpressionsExist', false, { type: 'boolean', description: nls.localize(8327, null) });
    exports.$WJ = new contextkey_1.$Wj('variablesFocused', true, { type: 'boolean', description: nls.localize(8328, null) });
    exports.$XJ = new contextkey_1.$Wj('expressionSelected', false, { type: 'boolean', description: nls.localize(8329, null) });
    exports.$YJ = new contextkey_1.$Wj('breakpointInputFocused', false, { type: 'boolean', description: nls.localize(8330, null) });
    exports.$ZJ = new contextkey_1.$Wj('callStackItemType', undefined, { type: 'string', description: nls.localize(8331, null) });
    exports.$1J = new contextkey_1.$Wj('callStackSessionIsAttach', false, { type: 'boolean', description: nls.localize(8332, null) });
    exports.$2J = new contextkey_1.$Wj('callStackItemStopped', false, { type: 'boolean', description: nls.localize(8333, null) });
    exports.$3J = new contextkey_1.$Wj('callStackSessionHasOneThread', false, { type: 'boolean', description: nls.localize(8334, null) });
    exports.$4J = new contextkey_1.$Wj('watchItemType', undefined, { type: 'string', description: nls.localize(8335, null) });
    exports.$5J = new contextkey_1.$Wj('canViewMemory', undefined, { type: 'boolean', description: nls.localize(8336, null) });
    exports.$6J = new contextkey_1.$Wj('breakpointItemType', undefined, { type: 'string', description: nls.localize(8337, null) });
    exports.$7J = new contextkey_1.$Wj('breakpointItemBytes', undefined, { type: 'boolean', description: nls.localize(8338, null) });
    exports.$8J = new contextkey_1.$Wj('breakpointHasModes', false, { type: 'boolean', description: nls.localize(8339, null) });
    exports.$9J = new contextkey_1.$Wj('breakpointSupportsCondition', false, { type: 'boolean', description: nls.localize(8340, null) });
    exports.$0J = new contextkey_1.$Wj('loadedScriptsSupported', false, { type: 'boolean', description: nls.localize(8341, null) });
    exports.$$J = new contextkey_1.$Wj('loadedScriptsItemType', undefined, { type: 'string', description: nls.localize(8342, null) });
    exports.$_J = new contextkey_1.$Wj('focusedSessionIsAttach', false, { type: 'boolean', description: nls.localize(8343, null) });
    exports.$aK = new contextkey_1.$Wj('focusedSessionIsNoDebug', false, { type: 'boolean', description: nls.localize(8344, null) });
    exports.$bK = new contextkey_1.$Wj('stepBackSupported', false, { type: 'boolean', description: nls.localize(8345, null) });
    exports.$cK = new contextkey_1.$Wj('restartFrameSupported', false, { type: 'boolean', description: nls.localize(8346, null) });
    exports.$dK = new contextkey_1.$Wj('stackFrameSupportsRestart', false, { type: 'boolean', description: nls.localize(8347, null) });
    exports.$eK = new contextkey_1.$Wj('jumpToCursorSupported', false, { type: 'boolean', description: nls.localize(8348, null) });
    exports.$fK = new contextkey_1.$Wj('stepIntoTargetsSupported', false, { type: 'boolean', description: nls.localize(8349, null) });
    exports.$gK = new contextkey_1.$Wj('breakpointsExist', false, { type: 'boolean', description: nls.localize(8350, null) });
    exports.$hK = new contextkey_1.$Wj('debuggersAvailable', false, { type: 'boolean', description: nls.localize(8351, null) });
    exports.$iK = new contextkey_1.$Wj('debugExtensionAvailable', true, { type: 'boolean', description: nls.localize(8352, null) });
    exports.$jK = new contextkey_1.$Wj('debugProtocolVariableMenuContext', undefined, { type: 'string', description: nls.localize(8353, null) });
    exports.$kK = new contextkey_1.$Wj('debugSetVariableSupported', false, { type: 'boolean', description: nls.localize(8354, null) });
    exports.$lK = new contextkey_1.$Wj('debugSetDataBreakpointAddressSupported', false, { type: 'boolean', description: nls.localize(8355, null) });
    exports.$mK = new contextkey_1.$Wj('debugSetExpressionSupported', false, { type: 'boolean', description: nls.localize(8356, null) });
    exports.$nK = new contextkey_1.$Wj('breakWhenValueChangesSupported', false, { type: 'boolean', description: nls.localize(8357, null) });
    exports.$oK = new contextkey_1.$Wj('breakWhenValueIsAccessedSupported', false, { type: 'boolean', description: nls.localize(8358, null) });
    exports.$pK = new contextkey_1.$Wj('breakWhenValueIsReadSupported', false, { type: 'boolean', description: nls.localize(8359, null) });
    exports.$qK = new contextkey_1.$Wj('terminateDebuggeeSupported', false, { type: 'boolean', description: nls.localize(8360, null) });
    exports.$rK = new contextkey_1.$Wj('suspendDebuggeeSupported', false, { type: 'boolean', description: nls.localize(8361, null) });
    exports.$sK = new contextkey_1.$Wj('variableEvaluateNamePresent', false, { type: 'boolean', description: nls.localize(8362, null) });
    exports.$tK = new contextkey_1.$Wj('variableIsReadonly', false, { type: 'boolean', description: nls.localize(8363, null) });
    exports.$uK = new contextkey_1.$Wj('variableValue', false, { type: 'string', description: nls.localize(8364, null) });
    exports.$vK = new contextkey_1.$Wj('variableType', false, { type: 'string', description: nls.localize(8365, null) });
    exports.$wK = new contextkey_1.$Wj('variableInterfaces', false, { type: 'array', description: nls.localize(8366, null) });
    exports.$xK = new contextkey_1.$Wj('variableName', false, { type: 'string', description: nls.localize(8367, null) });
    exports.$yK = new contextkey_1.$Wj('variableLanguage', false, { type: 'string', description: nls.localize(8368, null) });
    exports.$zK = new contextkey_1.$Wj('variableExtensionId', false, { type: 'string', description: nls.localize(8369, null) });
    exports.$AK = new contextkey_1.$Wj('exceptionWidgetVisible', false, { type: 'boolean', description: nls.localize(8370, null) });
    exports.$BK = new contextkey_1.$Wj('multiSessionRepl', false, { type: 'boolean', description: nls.localize(8371, null) });
    exports.$CK = new contextkey_1.$Wj('multiSessionDebug', false, { type: 'boolean', description: nls.localize(8372, null) });
    exports.$DK = new contextkey_1.$Wj('disassembleRequestSupported', false, { type: 'boolean', description: nls.localize(8373, null) });
    exports.$EK = new contextkey_1.$Wj('disassemblyViewFocus', false, { type: 'boolean', description: nls.localize(8374, null) });
    exports.$FK = new contextkey_1.$Wj('languageSupportsDisassembleRequest', false, { type: 'boolean', description: nls.localize(8375, null) });
    exports.$GK = new contextkey_1.$Wj('focusedStackFrameHasInstructionReference', false, { type: 'boolean', description: nls.localize(8376, null) });
    const $HK = (debugType) => nls.localize(8377, null, debugType);
    exports.$HK = $HK;
    exports.$IK = 'editor.contrib.debug';
    exports.$JK = 'editor.contrib.breakpoint';
    exports.$KK = 'debug';
    exports.$LK = {
        enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],
        default: 'openOnFirstSessionStart',
        description: nls.localize(8378, null)
    };
    var State;
    (function (State) {
        State[State["Inactive"] = 0] = "Inactive";
        State[State["Initializing"] = 1] = "Initializing";
        State[State["Stopped"] = 2] = "Stopped";
        State[State["Running"] = 3] = "Running";
    })(State || (exports.State = State = {}));
    function $MK(state) {
        switch (state) {
            case State.Initializing: return 'initializing';
            case State.Stopped: return 'stopped';
            case State.Running: return 'running';
            default: return 'inactive';
        }
    }
    var MemoryRangeType;
    (function (MemoryRangeType) {
        MemoryRangeType[MemoryRangeType["Valid"] = 0] = "Valid";
        MemoryRangeType[MemoryRangeType["Unreadable"] = 1] = "Unreadable";
        MemoryRangeType[MemoryRangeType["Error"] = 2] = "Error";
    })(MemoryRangeType || (exports.MemoryRangeType = MemoryRangeType = {}));
    exports.$NK = 'vscode-debug-memory';
    function $OK(frame) {
        const hint = frame.presentationHint ?? frame.source.presentationHint;
        return hint === 'deemphasize' || hint === 'subtle';
    }
    var DataBreakpointSetType;
    (function (DataBreakpointSetType) {
        DataBreakpointSetType[DataBreakpointSetType["Variable"] = 0] = "Variable";
        DataBreakpointSetType[DataBreakpointSetType["Address"] = 1] = "Address";
    })(DataBreakpointSetType || (exports.DataBreakpointSetType = DataBreakpointSetType = {}));
    var DebugConfigurationProviderTriggerKind;
    (function (DebugConfigurationProviderTriggerKind) {
        /**
         *	`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.
         */
        DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Initial"] = 1] = "Initial";
        /**
         * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the "Select and Start Debugging" command).
         */
        DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Dynamic"] = 2] = "Dynamic";
    })(DebugConfigurationProviderTriggerKind || (exports.DebugConfigurationProviderTriggerKind = DebugConfigurationProviderTriggerKind = {}));
    var DebuggerString;
    (function (DebuggerString) {
        DebuggerString["UnverifiedBreakpoints"] = "unverifiedBreakpoints";
    })(DebuggerString || (exports.DebuggerString = DebuggerString = {}));
    // Debug service interfaces
    exports.$PK = (0, instantiation_1.$Fi)('debugService');
    // Editor interfaces
    var BreakpointWidgetContext;
    (function (BreakpointWidgetContext) {
        BreakpointWidgetContext[BreakpointWidgetContext["CONDITION"] = 0] = "CONDITION";
        BreakpointWidgetContext[BreakpointWidgetContext["HIT_COUNT"] = 1] = "HIT_COUNT";
        BreakpointWidgetContext[BreakpointWidgetContext["LOG_MESSAGE"] = 2] = "LOG_MESSAGE";
        BreakpointWidgetContext[BreakpointWidgetContext["TRIGGER_POINT"] = 3] = "TRIGGER_POINT";
    })(BreakpointWidgetContext || (exports.BreakpointWidgetContext = BreakpointWidgetContext = {}));
    var DebugVisualizationType;
    (function (DebugVisualizationType) {
        DebugVisualizationType[DebugVisualizationType["Command"] = 0] = "Command";
        DebugVisualizationType[DebugVisualizationType["Tree"] = 1] = "Tree";
    })(DebugVisualizationType || (exports.DebugVisualizationType = DebugVisualizationType = {}));
    var DebugTreeItemCollapsibleState;
    (function (DebugTreeItemCollapsibleState) {
        DebugTreeItemCollapsibleState[DebugTreeItemCollapsibleState["None"] = 0] = "None";
        DebugTreeItemCollapsibleState[DebugTreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        DebugTreeItemCollapsibleState[DebugTreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(DebugTreeItemCollapsibleState || (exports.DebugTreeItemCollapsibleState = DebugTreeItemCollapsibleState = {}));
    var IDebugVisualizationTreeItem;
    (function (IDebugVisualizationTreeItem) {
        IDebugVisualizationTreeItem.deserialize = (v) => v;
        IDebugVisualizationTreeItem.serialize = (item) => item;
    })(IDebugVisualizationTreeItem || (exports.IDebugVisualizationTreeItem = IDebugVisualizationTreeItem = {}));
    var IDebugVisualization;
    (function (IDebugVisualization) {
        IDebugVisualization.deserialize = (v) => ({
            id: v.id,
            name: v.name,
            iconPath: v.iconPath && { light: uri_1.URI.revive(v.iconPath.light), dark: uri_1.URI.revive(v.iconPath.dark) },
            iconClass: v.iconClass,
            visualization: v.visualization,
        });
        IDebugVisualization.serialize = (visualizer) => visualizer;
    })(IDebugVisualization || (exports.IDebugVisualization = IDebugVisualization = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[196/*vs/workbench/contrib/debug/common/debugUtils*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/,19/*vs/base/common/path*/,25/*vs/base/common/objects*/,15/*vs/base/common/network*/,32/*vs/editor/common/core/range*/,21/*vs/base/common/cancellation*/,17/*vs/base/common/arrays*/]), function (require, exports, strings_1, uri_1, path_1, objects_1, network_1, range_1, cancellation_1, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$hI = void 0;
    exports.$8H = $8H;
    exports.$9H = $9H;
    exports.$0H = $0H;
    exports.$$H = $$H;
    exports.$_H = $_H;
    exports.$aI = $aI;
    exports.$bI = $bI;
    exports.$cI = $cI;
    exports.$dI = $dI;
    exports.$eI = $eI;
    exports.$fI = $fI;
    exports.$gI = $gI;
    const _formatPIIRegexp = /{([^}]+)}/g;
    function $8H(value, excludePII, args) {
        return value.replace(_formatPIIRegexp, function (match, group) {
            if (excludePII && group.length > 0 && group[0] !== '_') {
                return match;
            }
            return args && args.hasOwnProperty(group) ?
                args[group] :
                match;
        });
    }
    /**
     * Filters exceptions (keys marked with "!") from the given object. Used to
     * ensure exception data is not sent on web remotes, see #97628.
     */
    function $9H(data) {
        const output = {};
        for (const key of Object.keys(data)) {
            if (!key.startsWith('!')) {
                output[key] = data[key];
            }
        }
        return output;
    }
    function $0H(session) {
        return session.configuration.request === 'attach' && !$$H(session) && (!session.parentSession || $0H(session.parentSession));
    }
    /**
     * Returns the session or any parent which is an extension host debug session.
     * Returns undefined if there's none.
     */
    function $$H(session) {
        let type = session.configuration.type;
        if (!type) {
            return;
        }
        if (type === 'vslsShare') {
            type = session.configuration.adapterProxy.configuration.type;
        }
        if ((0, strings_1.$Ff)(type, 'extensionhost') || (0, strings_1.$Ff)(type, 'pwa-extensionhost')) {
            return session;
        }
        return session.parentSession ? $$H(session.parentSession) : undefined;
    }
    // only a debugger contributions with a label, program, or runtime attribute is considered a "defining" or "main" debugger contribution
    function $_H(dbg) {
        return dbg.type && (dbg.label || dbg.program || dbg.runtime);
    }
    function $aI(lineContent, looseStart, looseEnd) {
        let matchingExpression = undefined;
        let startOffset = 0;
        // Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar
        // Match any character except a set of characters which often break interesting sub-expressions
        const expression = /([^()\[\]{}<>\s+\-/%~#^;=|,`!]|\->)+/g;
        let result = null;
        // First find the full expression under the cursor
        while (result = expression.exec(lineContent)) {
            const start = result.index + 1;
            const end = start + result[0].length;
            if (start <= looseStart && end >= looseEnd) {
                matchingExpression = result[0];
                startOffset = start;
                break;
            }
        }
        // If there are non-word characters after the cursor, we want to truncate the expression then.
        // For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.
        if (matchingExpression) {
            const subExpression = /(\w|\p{L})+/gu;
            let subExpressionResult = null;
            while (subExpressionResult = subExpression.exec(matchingExpression)) {
                const subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;
                if (subEnd >= looseEnd) {
                    break;
                }
            }
            if (subExpressionResult) {
                matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);
            }
        }
        return matchingExpression ?
            { start: startOffset, end: startOffset + matchingExpression.length - 1 } :
            { start: 0, end: 0 };
    }
    async function $bI(languageFeaturesService, model, position, token) {
        if (languageFeaturesService.evaluatableExpressionProvider.has(model)) {
            const supports = languageFeaturesService.evaluatableExpressionProvider.ordered(model);
            const results = (0, arrays_1.$Gb)(await Promise.all(supports.map(async (support) => {
                try {
                    return await support.provideEvaluatableExpression(model, position, token ?? cancellation_1.CancellationToken.None);
                }
                catch (err) {
                    return undefined;
                }
            })));
            if (results.length > 0) {
                let matchingExpression = results[0].expression;
                const range = results[0].range;
                if (!matchingExpression) {
                    const lineContent = model.getLineContent(position.lineNumber);
                    matchingExpression = lineContent.substring(range.startColumn - 1, range.endColumn - 1);
                }
                return { range, matchingExpression };
            }
        }
        else { // old one-size-fits-all strategy
            const lineContent = model.getLineContent(position.lineNumber);
            const { start, end } = $aI(lineContent, position.column, position.column);
            // use regex to extract the sub-expression #9821
            const matchingExpression = lineContent.substring(start - 1, end);
            return {
                matchingExpression,
                range: new range_1.$Ot(position.lineNumber, start, position.lineNumber, start + matchingExpression.length)
            };
        }
        return null;
    }
    // RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt
    const _schemePattern = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;
    function $cI(s) {
        // heuristics: a valid uri starts with a scheme and
        // the scheme has at least 2 characters so that it doesn't look like a drive letter.
        return !!(s && s.match(_schemePattern));
    }
    function stringToUri(source) {
        if (typeof source.path === 'string') {
            if (typeof source.sourceReference === 'number' && source.sourceReference > 0) {
                // if there is a source reference, don't touch path
            }
            else {
                if ($cI(source.path)) {
                    return uri_1.URI.parse(source.path);
                }
                else {
                    // assume path
                    if ((0, path_1.$ic)(source.path)) {
                        return uri_1.URI.file(source.path);
                    }
                    else {
                        // leave relative path as is
                    }
                }
            }
        }
        return source.path;
    }
    function uriToString(source) {
        if (typeof source.path === 'object') {
            const u = uri_1.URI.revive(source.path);
            if (u) {
                if (u.scheme === network_1.Schemas.file) {
                    return u.fsPath;
                }
                else {
                    return u.toString();
                }
            }
        }
        return source.path;
    }
    function $dI(message, toUri) {
        const fixPath = toUri ? stringToUri : uriToString;
        // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)
        const msg = (0, objects_1.$eo)(message);
        convertPaths(msg, (toDA, source) => {
            if (toDA && source) {
                source.path = fixPath(source);
            }
        });
        return msg;
    }
    function $eI(message, toUri) {
        const fixPath = toUri ? stringToUri : uriToString;
        // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)
        const msg = (0, objects_1.$eo)(message);
        convertPaths(msg, (toDA, source) => {
            if (!toDA && source) {
                source.path = fixPath(source);
            }
        });
        return msg;
    }
    function convertPaths(msg, fixSourcePath) {
        switch (msg.type) {
            case 'event': {
                const event = msg;
                switch (event.event) {
                    case 'output':
                        fixSourcePath(false, event.body.source);
                        break;
                    case 'loadedSource':
                        fixSourcePath(false, event.body.source);
                        break;
                    case 'breakpoint':
                        fixSourcePath(false, event.body.breakpoint.source);
                        break;
                    default:
                        break;
                }
                break;
            }
            case 'request': {
                const request = msg;
                switch (request.command) {
                    case 'setBreakpoints':
                        fixSourcePath(true, request.arguments.source);
                        break;
                    case 'breakpointLocations':
                        fixSourcePath(true, request.arguments.source);
                        break;
                    case 'source':
                        fixSourcePath(true, request.arguments.source);
                        break;
                    case 'gotoTargets':
                        fixSourcePath(true, request.arguments.source);
                        break;
                    case 'launchVSCode':
                        request.arguments.args.forEach((arg) => fixSourcePath(false, arg));
                        break;
                    default:
                        break;
                }
                break;
            }
            case 'response': {
                const response = msg;
                if (response.success && response.body) {
                    switch (response.command) {
                        case 'stackTrace':
                            response.body.stackFrames.forEach(frame => fixSourcePath(false, frame.source));
                            break;
                        case 'loadedSources':
                            response.body.sources.forEach(source => fixSourcePath(false, source));
                            break;
                        case 'scopes':
                            response.body.scopes.forEach(scope => fixSourcePath(false, scope.source));
                            break;
                        case 'setFunctionBreakpoints':
                            response.body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));
                            break;
                        case 'setBreakpoints':
                            response.body.breakpoints.forEach(bp => fixSourcePath(false, bp.source));
                            break;
                        case 'disassemble':
                            {
                                const di = response;
                                di.body?.instructions.forEach(di => fixSourcePath(false, di.location));
                            }
                            break;
                        default:
                            break;
                    }
                }
                break;
            }
        }
    }
    function $fI(array) {
        return array.filter(config => !config.presentation?.hidden).sort((first, second) => {
            if (!first.presentation) {
                if (!second.presentation) {
                    return 0;
                }
                return 1;
            }
            if (!second.presentation) {
                return -1;
            }
            if (!first.presentation.group) {
                if (!second.presentation.group) {
                    return compareOrders(first.presentation.order, second.presentation.order);
                }
                return 1;
            }
            if (!second.presentation.group) {
                return -1;
            }
            if (first.presentation.group !== second.presentation.group) {
                return first.presentation.group.localeCompare(second.presentation.group);
            }
            return compareOrders(first.presentation.order, second.presentation.order);
        });
    }
    function compareOrders(first, second) {
        if (typeof first !== 'number') {
            if (typeof second !== 'number') {
                return 0;
            }
            return 1;
        }
        if (typeof second !== 'number') {
            return -1;
        }
        return first - second;
    }
    async function $gI(configurationService, editorService) {
        const saveBeforeStartConfig = configurationService.getValue('debug.saveBeforeStart', { overrideIdentifier: editorService.activeTextEditorLanguageId });
        if (saveBeforeStartConfig !== 'none') {
            await editorService.saveAll();
            if (saveBeforeStartConfig === 'allEditorsInActiveGroup') {
                const activeEditor = editorService.activeEditorPane;
                if (activeEditor && activeEditor.input.resource?.scheme === network_1.Schemas.untitled) {
                    // Make sure to save the active editor in case it is in untitled file it wont be saved as part of saveAll #111850
                    await editorService.save({ editor: activeEditor.input, groupId: activeEditor.group.id });
                }
            }
        }
        await configurationService.reloadConfiguration();
    }
    const $hI = (a, b) => !a || !b ? a === b : a.name === b.name && a.path === b.path && a.sourceReference === b.sourceReference;
    exports.$hI = $hI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[197/*vs/workbench/contrib/notebook/common/notebookExecutionService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$XK = exports.CellExecutionUpdateType = void 0;
    var CellExecutionUpdateType;
    (function (CellExecutionUpdateType) {
        CellExecutionUpdateType[CellExecutionUpdateType["Output"] = 1] = "Output";
        CellExecutionUpdateType[CellExecutionUpdateType["OutputItems"] = 2] = "OutputItems";
        CellExecutionUpdateType[CellExecutionUpdateType["ExecutionState"] = 3] = "ExecutionState";
    })(CellExecutionUpdateType || (exports.CellExecutionUpdateType = CellExecutionUpdateType = {}));
    exports.$XK = (0, instantiation_1.$Fi)('INotebookExecutionService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[198/*vs/workbench/contrib/notebook/common/notebookKernelService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$2K = exports.$1K = exports.ProxyKernelState = exports.$ZK = void 0;
    exports.$ZK = 100;
    var ProxyKernelState;
    (function (ProxyKernelState) {
        ProxyKernelState[ProxyKernelState["Disconnected"] = 1] = "Disconnected";
        ProxyKernelState[ProxyKernelState["Connected"] = 2] = "Connected";
        ProxyKernelState[ProxyKernelState["Initializing"] = 3] = "Initializing";
    })(ProxyKernelState || (exports.ProxyKernelState = ProxyKernelState = {}));
    exports.$1K = (0, instantiation_1.$Fi)('INotebookKernelService');
    exports.$2K = (0, instantiation_1.$Fi)('INotebookKernelHistoryService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[199/*vs/workbench/contrib/search/common/cellSearchModel*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,32/*vs/editor/common/core/range*/,52/*vs/editor/common/model*/,162/*vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder*/,102/*vs/editor/common/model/textModelSearch*/]), function (require, exports, lifecycle_1, range_1, model_1, pieceTreeTextBufferBuilder_1, textModelSearch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$j1b = void 0;
    class $j1b extends lifecycle_1.$Uc {
        constructor(_source, b, c) {
            super();
            this._source = _source;
            this.b = b;
            this.c = c;
            this.a = undefined;
        }
        f(buffer) {
            const lineCount = buffer.getLineCount();
            return new range_1.$Ot(1, 1, lineCount, this.g(buffer, lineCount));
        }
        g(buffer, lineNumber) {
            if (lineNumber < 1 || lineNumber > buffer.getLineCount()) {
                throw new Error('Illegal value for lineNumber');
            }
            return buffer.getLineLength(lineNumber) + 1;
        }
        get inputTextBuffer() {
            if (!this.b) {
                const builder = new pieceTreeTextBufferBuilder_1.$wD();
                builder.acceptChunk(this._source);
                const bufferFactory = builder.finish(true);
                const { textBuffer, disposable } = bufferFactory.create(model_1.DefaultEndOfLine.LF);
                this.b = textBuffer;
                this.B(disposable);
            }
            return this.b;
        }
        get outputTextBuffers() {
            if (!this.a) {
                this.a = this.c.map((output) => {
                    const builder = new pieceTreeTextBufferBuilder_1.$wD();
                    builder.acceptChunk(output);
                    const bufferFactory = builder.finish(true);
                    const { textBuffer, disposable } = bufferFactory.create(model_1.DefaultEndOfLine.LF);
                    this.B(disposable);
                    return textBuffer;
                });
            }
            return this.a;
        }
        findInInputs(target) {
            const searchParams = new textModelSearch_1.$kD(target, false, false, null);
            const searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return [];
            }
            const fullInputRange = this.f(this.inputTextBuffer);
            return this.inputTextBuffer.findMatchesLineByLine(fullInputRange, searchData, true, 5000);
        }
        findInOutputs(target) {
            const searchParams = new textModelSearch_1.$kD(target, false, false, null);
            const searchData = searchParams.parseSearchRequest();
            if (!searchData) {
                return [];
            }
            return this.outputTextBuffers.map(buffer => {
                const matches = buffer.findMatchesLineByLine(this.f(buffer), searchData, true, 5000);
                if (matches.length === 0) {
                    return undefined;
                }
                return {
                    textBuffer: buffer,
                    matches
                };
            }).filter((item) => !!item);
        }
    }
    exports.$j1b = $j1b;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[54/*vs/workbench/contrib/testing/common/testId*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$7I = exports.TestPosition = exports.TestIdPathParts = void 0;
    var TestIdPathParts;
    (function (TestIdPathParts) {
        /** Delimiter for path parts in test IDs */
        TestIdPathParts["Delimiter"] = "\0";
    })(TestIdPathParts || (exports.TestIdPathParts = TestIdPathParts = {}));
    /**
     * Enum for describing relative positions of tests. Similar to
     * `node.compareDocumentPosition` in the DOM.
     */
    var TestPosition;
    (function (TestPosition) {
        /** a === b */
        TestPosition[TestPosition["IsSame"] = 0] = "IsSame";
        /** Neither a nor b are a child of one another. They may share a common parent, though. */
        TestPosition[TestPosition["Disconnected"] = 1] = "Disconnected";
        /** b is a child of a */
        TestPosition[TestPosition["IsChild"] = 2] = "IsChild";
        /** b is a parent of a */
        TestPosition[TestPosition["IsParent"] = 3] = "IsParent";
    })(TestPosition || (exports.TestPosition = TestPosition = {}));
    /**
     * The test ID is a stringifiable client that
     */
    class $7I {
        /**
         * Creates a test ID from an ext host test item.
         */
        static fromExtHostTestItem(item, rootId, parent = item.parent) {
            if (item._isRoot) {
                return new $7I([rootId]);
            }
            const path = [item.id];
            for (let i = parent; i && i.id !== rootId; i = i.parent) {
                path.push(i.id);
            }
            path.push(rootId);
            return new $7I(path.reverse());
        }
        /**
         * Cheaply ets whether the ID refers to the root .
         */
        static isRoot(idString) {
            return !idString.includes(TestIdPathParts.Delimiter);
        }
        /**
         * Cheaply gets whether the ID refers to the root .
         */
        static root(idString) {
            const idx = idString.indexOf(TestIdPathParts.Delimiter);
            return idx === -1 ? idString : idString.slice(0, idx);
        }
        /**
         * Creates a test ID from a serialized TestId instance.
         */
        static fromString(idString) {
            return new $7I(idString.split(TestIdPathParts.Delimiter));
        }
        /**
         * Gets the ID resulting from adding b to the base ID.
         */
        static join(base, b) {
            return new $7I([...base.path, b]);
        }
        /**
         * Gets the string ID resulting from adding b to the base ID.
         */
        static joinToString(base, b) {
            return base.toString() + TestIdPathParts.Delimiter + b;
        }
        /**
         * Cheaply gets the parent ID of a test identified with the string.
         */
        static parentId(idString) {
            const idx = idString.lastIndexOf(TestIdPathParts.Delimiter);
            return idx === -1 ? undefined : idString.slice(0, idx);
        }
        /**
         * Cheaply gets the local ID of a test identified with the string.
         */
        static localId(idString) {
            const idx = idString.lastIndexOf(TestIdPathParts.Delimiter);
            return idx === -1 ? idString : idString.slice(idx + TestIdPathParts.Delimiter.length);
        }
        /**
         * Gets whether maybeChild is a child of maybeParent.
         * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better
         */
        static isChild(maybeParent, maybeChild) {
            return maybeChild[maybeParent.length] === TestIdPathParts.Delimiter && maybeChild.startsWith(maybeParent);
        }
        /**
         * Compares the position of the two ID strings.
         * todo@connor4312: review usages of this to see if using the WellDefinedPrefixTree is better
         */
        static compare(a, b) {
            if (a === b) {
                return TestPosition.IsSame;
            }
            if ($7I.isChild(a, b)) {
                return TestPosition.IsChild;
            }
            if ($7I.isChild(b, a)) {
                return TestPosition.IsParent;
            }
            return TestPosition.Disconnected;
        }
        static getLengthOfCommonPrefix(length, getId) {
            if (length === 0) {
                return 0;
            }
            let commonPrefix = 0;
            while (commonPrefix < length - 1) {
                for (let i = 1; i < length; i++) {
                    const a = getId(i - 1);
                    const b = getId(i);
                    if (a.path[commonPrefix] !== b.path[commonPrefix]) {
                        return commonPrefix;
                    }
                }
                commonPrefix++;
            }
            return commonPrefix;
        }
        constructor(path, d = path.length) {
            this.path = path;
            this.d = d;
            if (path.length === 0 || d < 1) {
                throw new Error('cannot create test with empty path');
            }
        }
        /**
         * Gets the ID of the parent test.
         */
        get rootId() {
            return new $7I(this.path, 1);
        }
        /**
         * Gets the ID of the parent test.
         */
        get parentId() {
            return this.d > 1 ? new $7I(this.path, this.d - 1) : undefined;
        }
        /**
         * Gets the local ID of the current full test ID.
         */
        get localId() {
            return this.path[this.d - 1];
        }
        /**
         * Gets whether this ID refers to the root.
         */
        get controllerId() {
            return this.path[0];
        }
        /**
         * Gets whether this ID refers to the root.
         */
        get isRoot() {
            return this.d === 1;
        }
        /**
         * Returns an iterable that yields IDs of all parent items down to and
         * including the current item.
         */
        *idsFromRoot() {
            for (let i = 1; i <= this.d; i++) {
                yield new $7I(this.path, i);
            }
        }
        /**
         * Returns an iterable that yields IDs of the current item up to the root
         * item.
         */
        *idsToRoot() {
            for (let i = this.d; i > 0; i--) {
                yield new $7I(this.path, i);
            }
        }
        /**
         * Compares the other test ID with this one.
         */
        compare(other) {
            if (typeof other === 'string') {
                return $7I.compare(this.toString(), other);
            }
            for (let i = 0; i < other.d && i < this.d; i++) {
                if (other.path[i] !== this.path[i]) {
                    return TestPosition.Disconnected;
                }
            }
            if (other.d > this.d) {
                return TestPosition.IsChild;
            }
            if (other.d < this.d) {
                return TestPosition.IsParent;
            }
            return TestPosition.IsSame;
        }
        /**
         * Serializes the ID.
         */
        toJSON() {
            return this.toString();
        }
        /**
         * Serializes the ID to a string.
         */
        toString() {
            if (!this.c) {
                this.c = this.path[0];
                for (let i = 1; i < this.d; i++) {
                    this.c += TestIdPathParts.Delimiter;
                    this.c += this.path[i];
                }
            }
            return this.c;
        }
    }
    exports.$7I = $7I;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[55/*vs/workbench/contrib/testing/common/testTypes*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,101/*vs/editor/common/core/position*/,32/*vs/editor/common/core/range*/,54/*vs/workbench/contrib/testing/common/testId*/]), function (require, exports, uri_1, position_1, range_1, testId_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$dJ = exports.TestsDiffOp = exports.TestDiffOpType = exports.IStatementCoverage = exports.IDeclarationCoverage = exports.IBranchCoverage = exports.CoverageDetails = exports.DetailType = exports.$cJ = exports.IFileCoverage = exports.ICoverageCount = exports.TestResultItem = exports.$bJ = exports.ITestItemUpdate = exports.InternalTestItem = exports.TestItemExpandState = exports.ITestItem = exports.$aJ = exports.$_I = exports.ITestTaskState = exports.ITestMessage = exports.ITestOutputMessage = exports.$$I = exports.ITestErrorMessage = exports.ITestMessageStackFrame = exports.TestMessageType = exports.IRichLocation = exports.$0I = exports.$9I = exports.TestRunProfileBitset = exports.TestControllerCapability = exports.ExtTestRunProfileKind = exports.$8I = exports.TestResultState = void 0;
    var TestResultState;
    (function (TestResultState) {
        TestResultState[TestResultState["Unset"] = 0] = "Unset";
        TestResultState[TestResultState["Queued"] = 1] = "Queued";
        TestResultState[TestResultState["Running"] = 2] = "Running";
        TestResultState[TestResultState["Passed"] = 3] = "Passed";
        TestResultState[TestResultState["Failed"] = 4] = "Failed";
        TestResultState[TestResultState["Skipped"] = 5] = "Skipped";
        TestResultState[TestResultState["Errored"] = 6] = "Errored";
    })(TestResultState || (exports.TestResultState = TestResultState = {}));
    exports.$8I = {
        [TestResultState.Unset]: 'unset',
        [TestResultState.Queued]: 'queued',
        [TestResultState.Running]: 'running',
        [TestResultState.Passed]: 'passed',
        [TestResultState.Failed]: 'failed',
        [TestResultState.Skipped]: 'skipped',
        [TestResultState.Errored]: 'errored',
    };
    /** note: keep in sync with TestRunProfileKind in vscode.d.ts */
    var ExtTestRunProfileKind;
    (function (ExtTestRunProfileKind) {
        ExtTestRunProfileKind[ExtTestRunProfileKind["Run"] = 1] = "Run";
        ExtTestRunProfileKind[ExtTestRunProfileKind["Debug"] = 2] = "Debug";
        ExtTestRunProfileKind[ExtTestRunProfileKind["Coverage"] = 3] = "Coverage";
    })(ExtTestRunProfileKind || (exports.ExtTestRunProfileKind = ExtTestRunProfileKind = {}));
    var TestControllerCapability;
    (function (TestControllerCapability) {
        TestControllerCapability[TestControllerCapability["Refresh"] = 2] = "Refresh";
        TestControllerCapability[TestControllerCapability["CodeRelatedToTest"] = 4] = "CodeRelatedToTest";
        TestControllerCapability[TestControllerCapability["TestRelatedToCode"] = 8] = "TestRelatedToCode";
    })(TestControllerCapability || (exports.TestControllerCapability = TestControllerCapability = {}));
    var TestRunProfileBitset;
    (function (TestRunProfileBitset) {
        TestRunProfileBitset[TestRunProfileBitset["Run"] = 2] = "Run";
        TestRunProfileBitset[TestRunProfileBitset["Debug"] = 4] = "Debug";
        TestRunProfileBitset[TestRunProfileBitset["Coverage"] = 8] = "Coverage";
        TestRunProfileBitset[TestRunProfileBitset["HasNonDefaultProfile"] = 16] = "HasNonDefaultProfile";
        TestRunProfileBitset[TestRunProfileBitset["HasConfigurable"] = 32] = "HasConfigurable";
        TestRunProfileBitset[TestRunProfileBitset["SupportsContinuousRun"] = 64] = "SupportsContinuousRun";
    })(TestRunProfileBitset || (exports.TestRunProfileBitset = TestRunProfileBitset = {}));
    /**
     * List of all test run profile bitset values.
     */
    exports.$9I = [
        TestRunProfileBitset.Run,
        TestRunProfileBitset.Debug,
        TestRunProfileBitset.Coverage,
        TestRunProfileBitset.HasNonDefaultProfile,
        TestRunProfileBitset.HasConfigurable,
        TestRunProfileBitset.SupportsContinuousRun,
    ];
    const $0I = (t) => 'runId' in t;
    exports.$0I = $0I;
    var IRichLocation;
    (function (IRichLocation) {
        IRichLocation.serialize = (location) => ({
            range: location.range.toJSON(),
            uri: location.uri.toJSON(),
        });
        IRichLocation.deserialize = (uriIdentity, location) => ({
            range: range_1.$Ot.lift(location.range),
            uri: uriIdentity.asCanonicalUri(uri_1.URI.revive(location.uri)),
        });
    })(IRichLocation || (exports.IRichLocation = IRichLocation = {}));
    var TestMessageType;
    (function (TestMessageType) {
        TestMessageType[TestMessageType["Error"] = 0] = "Error";
        TestMessageType[TestMessageType["Output"] = 1] = "Output";
    })(TestMessageType || (exports.TestMessageType = TestMessageType = {}));
    var ITestMessageStackFrame;
    (function (ITestMessageStackFrame) {
        ITestMessageStackFrame.serialize = (stack) => ({
            label: stack.label,
            uri: stack.uri?.toJSON(),
            position: stack.position?.toJSON(),
        });
        ITestMessageStackFrame.deserialize = (uriIdentity, stack) => ({
            label: stack.label,
            uri: stack.uri ? uriIdentity.asCanonicalUri(uri_1.URI.revive(stack.uri)) : undefined,
            position: stack.position ? position_1.$Nt.lift(stack.position) : undefined,
        });
    })(ITestMessageStackFrame || (exports.ITestMessageStackFrame = ITestMessageStackFrame = {}));
    var ITestErrorMessage;
    (function (ITestErrorMessage) {
        ITestErrorMessage.serialize = (message) => ({
            message: message.message,
            type: TestMessageType.Error,
            expected: message.expected,
            actual: message.actual,
            contextValue: message.contextValue,
            location: message.location && IRichLocation.serialize(message.location),
            stackTrace: message.stackTrace?.map(ITestMessageStackFrame.serialize),
        });
        ITestErrorMessage.deserialize = (uriIdentity, message) => ({
            message: message.message,
            type: TestMessageType.Error,
            expected: message.expected,
            actual: message.actual,
            contextValue: message.contextValue,
            location: message.location && IRichLocation.deserialize(uriIdentity, message.location),
            stackTrace: message.stackTrace && message.stackTrace.map(s => ITestMessageStackFrame.deserialize(uriIdentity, s)),
        });
    })(ITestErrorMessage || (exports.ITestErrorMessage = ITestErrorMessage = {}));
    /**
     * Gets the TTY marker ID for either starting or ending
     * an ITestOutputMessage.marker of the given ID.
     */
    const $$I = (marker, start) => `${start ? 's' : 'e'}${marker}`;
    exports.$$I = $$I;
    var ITestOutputMessage;
    (function (ITestOutputMessage) {
        ITestOutputMessage.serialize = (message) => ({
            message: message.message,
            type: TestMessageType.Output,
            offset: message.offset,
            length: message.length,
            location: message.location && IRichLocation.serialize(message.location),
        });
        ITestOutputMessage.deserialize = (uriIdentity, message) => ({
            message: message.message,
            type: TestMessageType.Output,
            offset: message.offset,
            length: message.length,
            location: message.location && IRichLocation.deserialize(uriIdentity, message.location),
        });
    })(ITestOutputMessage || (exports.ITestOutputMessage = ITestOutputMessage = {}));
    var ITestMessage;
    (function (ITestMessage) {
        ITestMessage.serialize = (message) => message.type === TestMessageType.Error ? ITestErrorMessage.serialize(message) : ITestOutputMessage.serialize(message);
        ITestMessage.deserialize = (uriIdentity, message) => message.type === TestMessageType.Error ? ITestErrorMessage.deserialize(uriIdentity, message) : ITestOutputMessage.deserialize(uriIdentity, message);
        ITestMessage.isDiffable = (message) => message.type === TestMessageType.Error && message.actual !== undefined && message.expected !== undefined;
    })(ITestMessage || (exports.ITestMessage = ITestMessage = {}));
    var ITestTaskState;
    (function (ITestTaskState) {
        ITestTaskState.serializeWithoutMessages = (state) => ({
            state: state.state,
            duration: state.duration,
            messages: [],
        });
        ITestTaskState.serialize = (state) => ({
            state: state.state,
            duration: state.duration,
            messages: state.messages.map(ITestMessage.serialize),
        });
        ITestTaskState.deserialize = (uriIdentity, state) => ({
            state: state.state,
            duration: state.duration,
            messages: state.messages.map(m => ITestMessage.deserialize(uriIdentity, m)),
        });
    })(ITestTaskState || (exports.ITestTaskState = ITestTaskState = {}));
    const testTagDelimiter = '\0';
    const $_I = (ctrlId, tagId) => ctrlId + testTagDelimiter + tagId;
    exports.$_I = $_I;
    const $aJ = (namespaced) => {
        const index = namespaced.indexOf(testTagDelimiter);
        return { ctrlId: namespaced.slice(0, index), tagId: namespaced.slice(index + 1) };
    };
    exports.$aJ = $aJ;
    var ITestItem;
    (function (ITestItem) {
        ITestItem.serialize = (item) => ({
            extId: item.extId,
            label: item.label,
            tags: item.tags,
            busy: item.busy,
            children: undefined,
            uri: item.uri?.toJSON(),
            range: item.range?.toJSON() || null,
            description: item.description,
            error: item.error,
            sortText: item.sortText
        });
        ITestItem.deserialize = (uriIdentity, serialized) => ({
            extId: serialized.extId,
            label: serialized.label,
            tags: serialized.tags,
            busy: serialized.busy,
            children: undefined,
            uri: serialized.uri ? uriIdentity.asCanonicalUri(uri_1.URI.revive(serialized.uri)) : undefined,
            range: serialized.range ? range_1.$Ot.lift(serialized.range) : null,
            description: serialized.description,
            error: serialized.error,
            sortText: serialized.sortText
        });
    })(ITestItem || (exports.ITestItem = ITestItem = {}));
    var TestItemExpandState;
    (function (TestItemExpandState) {
        TestItemExpandState[TestItemExpandState["NotExpandable"] = 0] = "NotExpandable";
        TestItemExpandState[TestItemExpandState["Expandable"] = 1] = "Expandable";
        TestItemExpandState[TestItemExpandState["BusyExpanding"] = 2] = "BusyExpanding";
        TestItemExpandState[TestItemExpandState["Expanded"] = 3] = "Expanded";
    })(TestItemExpandState || (exports.TestItemExpandState = TestItemExpandState = {}));
    var InternalTestItem;
    (function (InternalTestItem) {
        InternalTestItem.serialize = (item) => ({
            expand: item.expand,
            item: ITestItem.serialize(item.item)
        });
        InternalTestItem.deserialize = (uriIdentity, serialized) => ({
            // the `controllerId` is derived from the test.item.extId. It's redundant
            // in the non-serialized InternalTestItem too, but there just because it's
            // checked against in many hot paths.
            controllerId: testId_1.$7I.root(serialized.item.extId),
            expand: serialized.expand,
            item: ITestItem.deserialize(uriIdentity, serialized.item)
        });
    })(InternalTestItem || (exports.InternalTestItem = InternalTestItem = {}));
    var ITestItemUpdate;
    (function (ITestItemUpdate) {
        ITestItemUpdate.serialize = (u) => {
            let item;
            if (u.item) {
                item = {};
                if (u.item.label !== undefined) {
                    item.label = u.item.label;
                }
                if (u.item.tags !== undefined) {
                    item.tags = u.item.tags;
                }
                if (u.item.busy !== undefined) {
                    item.busy = u.item.busy;
                }
                if (u.item.uri !== undefined) {
                    item.uri = u.item.uri?.toJSON();
                }
                if (u.item.range !== undefined) {
                    item.range = u.item.range?.toJSON();
                }
                if (u.item.description !== undefined) {
                    item.description = u.item.description;
                }
                if (u.item.error !== undefined) {
                    item.error = u.item.error;
                }
                if (u.item.sortText !== undefined) {
                    item.sortText = u.item.sortText;
                }
            }
            return { extId: u.extId, expand: u.expand, item };
        };
        ITestItemUpdate.deserialize = (u) => {
            let item;
            if (u.item) {
                item = {};
                if (u.item.label !== undefined) {
                    item.label = u.item.label;
                }
                if (u.item.tags !== undefined) {
                    item.tags = u.item.tags;
                }
                if (u.item.busy !== undefined) {
                    item.busy = u.item.busy;
                }
                if (u.item.range !== undefined) {
                    item.range = u.item.range ? range_1.$Ot.lift(u.item.range) : null;
                }
                if (u.item.description !== undefined) {
                    item.description = u.item.description;
                }
                if (u.item.error !== undefined) {
                    item.error = u.item.error;
                }
                if (u.item.sortText !== undefined) {
                    item.sortText = u.item.sortText;
                }
            }
            return { extId: u.extId, expand: u.expand, item };
        };
    })(ITestItemUpdate || (exports.ITestItemUpdate = ITestItemUpdate = {}));
    const $bJ = (internal, patch) => {
        if (patch.expand !== undefined) {
            internal.expand = patch.expand;
        }
        if (patch.item !== undefined) {
            internal.item = internal.item ? Object.assign(internal.item, patch.item) : patch.item;
        }
    };
    exports.$bJ = $bJ;
    var TestResultItem;
    (function (TestResultItem) {
        TestResultItem.serializeWithoutMessages = (original) => ({
            ...InternalTestItem.serialize(original),
            ownComputedState: original.ownComputedState,
            computedState: original.computedState,
            tasks: original.tasks.map(ITestTaskState.serializeWithoutMessages),
        });
        TestResultItem.serialize = (original) => ({
            ...InternalTestItem.serialize(original),
            ownComputedState: original.ownComputedState,
            computedState: original.computedState,
            tasks: original.tasks.map(ITestTaskState.serialize),
        });
        TestResultItem.deserialize = (uriIdentity, serialized) => ({
            ...InternalTestItem.deserialize(uriIdentity, serialized),
            ownComputedState: serialized.ownComputedState,
            computedState: serialized.computedState,
            tasks: serialized.tasks.map(m => ITestTaskState.deserialize(uriIdentity, m)),
            retired: true,
        });
    })(TestResultItem || (exports.TestResultItem = TestResultItem = {}));
    var ICoverageCount;
    (function (ICoverageCount) {
        ICoverageCount.empty = () => ({ covered: 0, total: 0 });
        ICoverageCount.sum = (target, src) => {
            target.covered += src.covered;
            target.total += src.total;
        };
    })(ICoverageCount || (exports.ICoverageCount = ICoverageCount = {}));
    var IFileCoverage;
    (function (IFileCoverage) {
        IFileCoverage.serialize = (original) => ({
            id: original.id,
            statement: original.statement,
            branch: original.branch,
            declaration: original.declaration,
            testIds: original.testIds,
            uri: original.uri.toJSON(),
        });
        IFileCoverage.deserialize = (uriIdentity, serialized) => ({
            id: serialized.id,
            statement: serialized.statement,
            branch: serialized.branch,
            declaration: serialized.declaration,
            testIds: serialized.testIds,
            uri: uriIdentity.asCanonicalUri(uri_1.URI.revive(serialized.uri)),
        });
        IFileCoverage.empty = (id, uri) => ({
            id,
            uri,
            statement: ICoverageCount.empty(),
        });
    })(IFileCoverage || (exports.IFileCoverage = IFileCoverage = {}));
    function serializeThingWithLocation(serialized) {
        return {
            ...serialized,
            location: serialized.location?.toJSON(),
        };
    }
    function deserializeThingWithLocation(serialized) {
        serialized.location = serialized.location ? (position_1.$Nt.isIPosition(serialized.location) ? position_1.$Nt.lift(serialized.location) : range_1.$Ot.lift(serialized.location)) : undefined;
        return serialized;
    }
    /** Number of recent runs in which coverage reports should be retained. */
    exports.$cJ = 3;
    var DetailType;
    (function (DetailType) {
        DetailType[DetailType["Declaration"] = 0] = "Declaration";
        DetailType[DetailType["Statement"] = 1] = "Statement";
        DetailType[DetailType["Branch"] = 2] = "Branch";
    })(DetailType || (exports.DetailType = DetailType = {}));
    var CoverageDetails;
    (function (CoverageDetails) {
        CoverageDetails.serialize = (original) => original.type === DetailType.Declaration ? IDeclarationCoverage.serialize(original) : IStatementCoverage.serialize(original);
        CoverageDetails.deserialize = (serialized) => serialized.type === DetailType.Declaration ? IDeclarationCoverage.deserialize(serialized) : IStatementCoverage.deserialize(serialized);
    })(CoverageDetails || (exports.CoverageDetails = CoverageDetails = {}));
    var IBranchCoverage;
    (function (IBranchCoverage) {
        IBranchCoverage.serialize = serializeThingWithLocation;
        IBranchCoverage.deserialize = deserializeThingWithLocation;
    })(IBranchCoverage || (exports.IBranchCoverage = IBranchCoverage = {}));
    var IDeclarationCoverage;
    (function (IDeclarationCoverage) {
        IDeclarationCoverage.serialize = serializeThingWithLocation;
        IDeclarationCoverage.deserialize = deserializeThingWithLocation;
    })(IDeclarationCoverage || (exports.IDeclarationCoverage = IDeclarationCoverage = {}));
    var IStatementCoverage;
    (function (IStatementCoverage) {
        IStatementCoverage.serialize = (original) => ({
            ...serializeThingWithLocation(original),
            branches: original.branches?.map(IBranchCoverage.serialize),
        });
        IStatementCoverage.deserialize = (serialized) => ({
            ...deserializeThingWithLocation(serialized),
            branches: serialized.branches?.map(IBranchCoverage.deserialize),
        });
    })(IStatementCoverage || (exports.IStatementCoverage = IStatementCoverage = {}));
    var TestDiffOpType;
    (function (TestDiffOpType) {
        /** Adds a new test (with children) */
        TestDiffOpType[TestDiffOpType["Add"] = 0] = "Add";
        /** Shallow-updates an existing test */
        TestDiffOpType[TestDiffOpType["Update"] = 1] = "Update";
        /** Ranges of some tests in a document were synced, so it should be considered up-to-date */
        TestDiffOpType[TestDiffOpType["DocumentSynced"] = 2] = "DocumentSynced";
        /** Removes a test (and all its children) */
        TestDiffOpType[TestDiffOpType["Remove"] = 3] = "Remove";
        /** Changes the number of controllers who are yet to publish their collection roots. */
        TestDiffOpType[TestDiffOpType["IncrementPendingExtHosts"] = 4] = "IncrementPendingExtHosts";
        /** Retires a test/result */
        TestDiffOpType[TestDiffOpType["Retire"] = 5] = "Retire";
        /** Add a new test tag */
        TestDiffOpType[TestDiffOpType["AddTag"] = 6] = "AddTag";
        /** Remove a test tag */
        TestDiffOpType[TestDiffOpType["RemoveTag"] = 7] = "RemoveTag";
    })(TestDiffOpType || (exports.TestDiffOpType = TestDiffOpType = {}));
    var TestsDiffOp;
    (function (TestsDiffOp) {
        TestsDiffOp.deserialize = (uriIdentity, u) => {
            if (u.op === TestDiffOpType.Add) {
                return { op: u.op, item: InternalTestItem.deserialize(uriIdentity, u.item) };
            }
            else if (u.op === TestDiffOpType.Update) {
                return { op: u.op, item: ITestItemUpdate.deserialize(u.item) };
            }
            else if (u.op === TestDiffOpType.DocumentSynced) {
                return { op: u.op, uri: uriIdentity.asCanonicalUri(uri_1.URI.revive(u.uri)), docv: u.docv };
            }
            else {
                return u;
            }
        };
        TestsDiffOp.serialize = (u) => {
            if (u.op === TestDiffOpType.Add) {
                return { op: u.op, item: InternalTestItem.serialize(u.item) };
            }
            else if (u.op === TestDiffOpType.Update) {
                return { op: u.op, item: ITestItemUpdate.serialize(u.item) };
            }
            else {
                return u;
            }
        };
    })(TestsDiffOp || (exports.TestsDiffOp = TestsDiffOp = {}));
    /**
     * Maintains tests in this extension host sent from the main thread.
     */
    class $dJ {
        constructor(l) {
            this.l = l;
            this.f = new Map();
            /**
             * Map of item IDs to test item objects.
             */
            this.g = new Map();
            /**
             * ID of test root items.
             */
            this.h = new Set();
            /**
             * Number of 'busy' controllers.
             */
            this.j = 0;
            /**
             * Number of pending roots.
             */
            this.k = 0;
            /**
             * Known test tags.
             */
            this.tags = this.f;
        }
        /**
         * Applies the diff to the collection.
         */
        apply(diff) {
            const changes = this.x();
            for (const op of diff) {
                switch (op.op) {
                    case TestDiffOpType.Add:
                        this.p(InternalTestItem.deserialize(this.l, op.item), changes);
                        break;
                    case TestDiffOpType.Update:
                        this.q(ITestItemUpdate.deserialize(op.item), changes);
                        break;
                    case TestDiffOpType.Remove:
                        this.v(op.itemId, changes);
                        break;
                    case TestDiffOpType.Retire:
                        this.w(op.itemId);
                        break;
                    case TestDiffOpType.IncrementPendingExtHosts:
                        this.updatePendingRoots(op.amount);
                        break;
                    case TestDiffOpType.AddTag:
                        this.f.set(op.tag.id, op.tag);
                        break;
                    case TestDiffOpType.RemoveTag:
                        this.f.delete(op.id);
                        break;
                }
            }
            changes.complete?.();
        }
        p(item, changes) {
            const parentId = testId_1.$7I.parentId(item.item.extId)?.toString();
            let created;
            if (!parentId) {
                created = this.y(item);
                this.h.add(created);
                this.g.set(item.item.extId, created);
            }
            else if (this.g.has(parentId)) {
                const parent = this.g.get(parentId);
                parent.children.add(item.item.extId);
                created = this.y(item, parent);
                this.g.set(item.item.extId, created);
            }
            else {
                console.error(`Test with unknown parent ID: ${JSON.stringify(item)}`);
                return;
            }
            changes.add?.(created);
            if (item.expand === TestItemExpandState.BusyExpanding) {
                this.j++;
            }
            return created;
        }
        q(patch, changes) {
            const existing = this.g.get(patch.extId);
            if (!existing) {
                return;
            }
            if (patch.expand !== undefined) {
                if (existing.expand === TestItemExpandState.BusyExpanding) {
                    this.j--;
                }
                if (patch.expand === TestItemExpandState.BusyExpanding) {
                    this.j++;
                }
            }
            (0, exports.$bJ)(existing, patch);
            changes.update?.(existing);
            return existing;
        }
        v(itemId, changes) {
            const toRemove = this.g.get(itemId);
            if (!toRemove) {
                return;
            }
            const parentId = testId_1.$7I.parentId(toRemove.item.extId)?.toString();
            if (parentId) {
                const parent = this.g.get(parentId);
                parent.children.delete(toRemove.item.extId);
            }
            else {
                this.h.delete(toRemove);
            }
            const queue = [[itemId]];
            while (queue.length) {
                for (const itemId of queue.pop()) {
                    const existing = this.g.get(itemId);
                    if (existing) {
                        queue.push(existing.children);
                        this.g.delete(itemId);
                        changes.remove?.(existing, existing !== toRemove);
                        if (existing.expand === TestItemExpandState.BusyExpanding) {
                            this.j--;
                        }
                    }
                }
            }
        }
        /**
         * Called when the extension signals a test result should be retired.
         */
        w(testId) {
            // no-op
        }
        /**
         * Updates the number of test root sources who are yet to report. When
         * the total pending test roots reaches 0, the roots for all controllers
         * will exist in the collection.
         */
        updatePendingRoots(delta) {
            this.k += delta;
        }
        /**
         * Called before a diff is applied to create a new change collector.
         */
        x() {
            return {};
        }
    }
    exports.$dJ = $dJ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[200/*vs/workbench/contrib/testing/common/constants*/], __M([1/*require*/,0/*exports*/,98/*vs/base/common/iconLabels*/,9/*vs/nls*/,55/*vs/workbench/contrib/testing/common/testTypes*/]), function (require, exports, iconLabels_1, nls_1, testTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestCommandId = exports.$NGb = exports.$MGb = exports.TestExplorerViewSorting = exports.TestExplorerViewMode = exports.Testing = void 0;
    var Testing;
    (function (Testing) {
        // marked as "extension" so that any existing test extensions are assigned to it.
        Testing["ViewletId"] = "workbench.view.extension.test";
        Testing["ExplorerViewId"] = "workbench.view.testing";
        Testing["OutputPeekContributionId"] = "editor.contrib.testingOutputPeek";
        Testing["DecorationsContributionId"] = "editor.contrib.testingDecorations";
        Testing["CoverageDecorationsContributionId"] = "editor.contrib.coverageDecorations";
        Testing["CoverageViewId"] = "workbench.view.testCoverage";
        Testing["ResultsPanelId"] = "workbench.panel.testResults";
        Testing["ResultsViewId"] = "workbench.panel.testResults.view";
        Testing["MessageLanguageId"] = "vscodeInternalTestMessage";
    })(Testing || (exports.Testing = Testing = {}));
    var TestExplorerViewMode;
    (function (TestExplorerViewMode) {
        TestExplorerViewMode["List"] = "list";
        TestExplorerViewMode["Tree"] = "true";
    })(TestExplorerViewMode || (exports.TestExplorerViewMode = TestExplorerViewMode = {}));
    var TestExplorerViewSorting;
    (function (TestExplorerViewSorting) {
        TestExplorerViewSorting["ByLocation"] = "location";
        TestExplorerViewSorting["ByStatus"] = "status";
        TestExplorerViewSorting["ByDuration"] = "duration";
    })(TestExplorerViewSorting || (exports.TestExplorerViewSorting = TestExplorerViewSorting = {}));
    const testStateNames = {
        [testTypes_1.TestResultState.Errored]: (0, nls_1.localize)(3417, null),
        [testTypes_1.TestResultState.Failed]: (0, nls_1.localize)(3418, null),
        [testTypes_1.TestResultState.Passed]: (0, nls_1.localize)(3419, null),
        [testTypes_1.TestResultState.Queued]: (0, nls_1.localize)(3420, null),
        [testTypes_1.TestResultState.Running]: (0, nls_1.localize)(3421, null),
        [testTypes_1.TestResultState.Skipped]: (0, nls_1.localize)(3422, null),
        [testTypes_1.TestResultState.Unset]: (0, nls_1.localize)(3423, null),
    };
    const $MGb = (label, state) => (0, nls_1.localize)(3424, null, (0, iconLabels_1.$Zk)(label), testStateNames[state]);



    exports.$MGb = $MGb;
    exports.$NGb = {
        [testTypes_1.TestRunProfileBitset.Debug]: (0, nls_1.localize)(3425, null),
        [testTypes_1.TestRunProfileBitset.Run]: (0, nls_1.localize)(3426, null),
        [testTypes_1.TestRunProfileBitset.Coverage]: (0, nls_1.localize)(3427, null),
    };
    var TestCommandId;
    (function (TestCommandId) {
        TestCommandId["CancelTestRefreshAction"] = "testing.cancelTestRefresh";
        TestCommandId["CancelTestRunAction"] = "testing.cancelRun";
        TestCommandId["ClearTestResultsAction"] = "testing.clearTestResults";
        TestCommandId["CollapseAllAction"] = "testing.collapseAll";
        TestCommandId["ConfigureTestProfilesAction"] = "testing.configureProfile";
        TestCommandId["ContinousRunUsingForTest"] = "testing.continuousRunUsingForTest";
        TestCommandId["CoverageAtCursor"] = "testing.coverageAtCursor";
        TestCommandId["CoverageByUri"] = "testing.coverage.uri";
        TestCommandId["CoverageClear"] = "testing.coverage.close";
        TestCommandId["CoverageCurrentFile"] = "testing.coverageCurrentFile";
        TestCommandId["CoverageFilterToTest"] = "testing.coverageFilterToTest";
        TestCommandId["CoverageFilterToTestInEditor"] = "testing.coverageFilterToTestInEditor";
        TestCommandId["CoverageLastRun"] = "testing.coverageLastRun";
        TestCommandId["CoverageSelectedAction"] = "testing.coverageSelected";
        TestCommandId["CoverageToggleToolbar"] = "testing.coverageToggleToolbar";
        TestCommandId["CoverageViewChangeSorting"] = "testing.coverageViewChangeSorting";
        TestCommandId["DebugAction"] = "testing.debug";
        TestCommandId["DebugAllAction"] = "testing.debugAll";
        TestCommandId["DebugAtCursor"] = "testing.debugAtCursor";
        TestCommandId["DebugByUri"] = "testing.debug.uri";
        TestCommandId["DebugCurrentFile"] = "testing.debugCurrentFile";
        TestCommandId["DebugFailedTests"] = "testing.debugFailTests";
        TestCommandId["DebugLastRun"] = "testing.debugLastRun";
        TestCommandId["DebugSelectedAction"] = "testing.debugSelected";
        TestCommandId["FilterAction"] = "workbench.actions.treeView.testExplorer.filter";
        TestCommandId["GetExplorerSelection"] = "_testing.getExplorerSelection";
        TestCommandId["GetSelectedProfiles"] = "testing.getSelectedProfiles";
        TestCommandId["GoToTest"] = "testing.editFocusedTest";
        TestCommandId["GoToRelatedTest"] = "testing.goToRelatedTest";
        TestCommandId["PeekRelatedTest"] = "testing.peekRelatedTest";
        TestCommandId["GoToRelatedCode"] = "testing.goToRelatedCode";
        TestCommandId["PeekRelatedCode"] = "testing.peekRelatedCode";
        TestCommandId["HideTestAction"] = "testing.hideTest";
        TestCommandId["OpenCoverage"] = "testing.openCoverage";
        TestCommandId["OpenOutputPeek"] = "testing.openOutputPeek";
        TestCommandId["RefreshTestsAction"] = "testing.refreshTests";
        TestCommandId["ReRunFailedTests"] = "testing.reRunFailTests";
        TestCommandId["ReRunLastRun"] = "testing.reRunLastRun";
        TestCommandId["RunAction"] = "testing.run";
        TestCommandId["RunAllAction"] = "testing.runAll";
        TestCommandId["RunAllWithCoverageAction"] = "testing.coverageAll";
        TestCommandId["RunAtCursor"] = "testing.runAtCursor";
        TestCommandId["RunByUri"] = "testing.run.uri";
        TestCommandId["RunCurrentFile"] = "testing.runCurrentFile";
        TestCommandId["RunSelectedAction"] = "testing.runSelected";
        TestCommandId["RunUsingProfileAction"] = "testing.runUsing";
        TestCommandId["RunWithCoverageAction"] = "testing.coverage";
        TestCommandId["SearchForTestExtension"] = "testing.searchForTestExtension";
        TestCommandId["SelectDefaultTestProfiles"] = "testing.selectDefaultTestProfiles";
        TestCommandId["ShowMostRecentOutputAction"] = "testing.showMostRecentOutput";
        TestCommandId["StartContinousRun"] = "testing.startContinuousRun";
        TestCommandId["StopContinousRun"] = "testing.stopContinuousRun";
        TestCommandId["TestingSortByDurationAction"] = "testing.sortByDuration";
        TestCommandId["TestingSortByLocationAction"] = "testing.sortByLocation";
        TestCommandId["TestingSortByStatusAction"] = "testing.sortByStatus";
        TestCommandId["TestingViewAsListAction"] = "testing.viewAsList";
        TestCommandId["TestingViewAsTreeAction"] = "testing.viewAsTree";
        TestCommandId["ToggleContinousRunForTest"] = "testing.toggleContinuousRunForTest";
        TestCommandId["ToggleInlineTestOutput"] = "testing.toggleInlineTestOutput";
        TestCommandId["UnhideAllTestsAction"] = "testing.unhideAllTests";
        TestCommandId["UnhideTestAction"] = "testing.unhideTest";
    })(TestCommandId || (exports.TestCommandId = TestCommandId = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[81/*vs/workbench/contrib/testing/common/testItemCollection*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,61/*vs/base/common/assert*/,55/*vs/workbench/contrib/testing/common/testTypes*/,54/*vs/workbench/contrib/testing/common/testId*/]), function (require, exports, async_1, event_1, lifecycle_1, assert_1, testTypes_1, testId_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$eQ = exports.$dQ = exports.$cQ = exports.$bQ = exports.$aQ = exports.TestItemEventOp = void 0;
    var TestItemEventOp;
    (function (TestItemEventOp) {
        TestItemEventOp[TestItemEventOp["Upsert"] = 0] = "Upsert";
        TestItemEventOp[TestItemEventOp["SetTags"] = 1] = "SetTags";
        TestItemEventOp[TestItemEventOp["UpdateCanResolveChildren"] = 2] = "UpdateCanResolveChildren";
        TestItemEventOp[TestItemEventOp["RemoveChild"] = 3] = "RemoveChild";
        TestItemEventOp[TestItemEventOp["SetProp"] = 4] = "SetProp";
        TestItemEventOp[TestItemEventOp["Bulk"] = 5] = "Bulk";
        TestItemEventOp[TestItemEventOp["DocumentSynced"] = 6] = "DocumentSynced";
    })(TestItemEventOp || (exports.TestItemEventOp = TestItemEventOp = {}));
    const strictEqualComparator = (a, b) => a === b;
    const diffableProps = {
        range: (a, b) => {
            if (a === b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            return a.equalsRange(b);
        },
        busy: strictEqualComparator,
        label: strictEqualComparator,
        description: strictEqualComparator,
        error: strictEqualComparator,
        sortText: strictEqualComparator,
        tags: (a, b) => {
            if (a.length !== b.length) {
                return false;
            }
            if (a.some(t1 => !b.includes(t1))) {
                return false;
            }
            return true;
        },
    };
    const diffableEntries = Object.entries(diffableProps);
    const diffTestItems = (a, b) => {
        let output;
        for (const [key, cmp] of diffableEntries) {
            if (!cmp(a[key], b[key])) {
                if (output) {
                    output[key] = b[key];
                }
                else {
                    output = { [key]: b[key] };
                }
            }
        }
        return output;
    };
    /**
     * Maintains a collection of test items for a single controller.
     */
    class $aQ extends lifecycle_1.$Uc {
        get root() {
            return this.s.root;
        }
        constructor(s) {
            super();
            this.s = s;
            this.f = this.B(new async_1.$Rh(() => this.flushDiff(), 200));
            this.g = this.B(new event_1.$le());
            this.tree = new Map();
            this.j = new Map();
            this.m = [];
            /**
             * Fires when an operation happens that should result in a diff.
             */
            this.onDidGenerateDiff = this.g.event;
            this.root.canResolveChildren = true;
            this.z(this.root, undefined);
        }
        /**
         * Handler used for expanding test items.
         */
        set resolveHandler(handler) {
            this.h = handler;
            for (const test of this.tree.values()) {
                this.J(test);
            }
        }
        get resolveHandler() {
            return this.h;
        }
        /**
         * Gets a diff of all changes that have been made, and clears the diff queue.
         */
        collectDiff() {
            const diff = this.m;
            this.m = [];
            return diff;
        }
        /**
         * Pushes a new diff entry onto the collected diff list.
         */
        pushDiff(diff) {
            switch (diff.op) {
                case testTypes_1.TestDiffOpType.DocumentSynced: {
                    for (const existing of this.m) {
                        if (existing.op === testTypes_1.TestDiffOpType.DocumentSynced && existing.uri === diff.uri) {
                            existing.docv = diff.docv;
                            return;
                        }
                    }
                    break;
                }
                case testTypes_1.TestDiffOpType.Update: {
                    // Try to merge updates, since they're invoked per-property
                    const last = this.m[this.m.length - 1];
                    if (last) {
                        if (last.op === testTypes_1.TestDiffOpType.Update && last.item.extId === diff.item.extId) {
                            (0, testTypes_1.$bJ)(last.item, diff.item);
                            return;
                        }
                        if (last.op === testTypes_1.TestDiffOpType.Add && last.item.item.extId === diff.item.extId) {
                            (0, testTypes_1.$bJ)(last.item, diff.item);
                            return;
                        }
                    }
                    break;
                }
            }
            this.m.push(diff);
            if (!this.f.isScheduled()) {
                this.f.schedule();
            }
        }
        /**
         * Expands the test and the given number of `levels` of children. If levels
         * is < 0, then all children will be expanded. If it's 0, then only this
         * item will be expanded.
         */
        expand(testId, levels) {
            const internal = this.tree.get(testId);
            if (!internal) {
                return;
            }
            if (internal.expandLevels === undefined || levels > internal.expandLevels) {
                internal.expandLevels = levels;
            }
            // try to avoid awaiting things if the provider returns synchronously in
            // order to keep everything in a single diff and DOM update.
            if (internal.expand === testTypes_1.TestItemExpandState.Expandable) {
                const r = this.M(internal);
                return !r.isOpen()
                    ? r.wait().then(() => this.L(internal, levels - 1))
                    : this.L(internal, levels - 1);
            }
            else if (internal.expand === testTypes_1.TestItemExpandState.Expanded) {
                return internal.resolveBarrier?.isOpen() === false
                    ? internal.resolveBarrier.wait().then(() => this.L(internal, levels - 1))
                    : this.L(internal, levels - 1);
            }
        }
        dispose() {
            for (const item of this.tree.values()) {
                this.s.getApiFor(item.actual).listener = undefined;
            }
            this.tree.clear();
            this.m = [];
            super.dispose();
        }
        w(internal, evt) {
            switch (evt.op) {
                case TestItemEventOp.RemoveChild:
                    this.O(testId_1.$7I.joinToString(internal.fullId, evt.id));
                    break;
                case TestItemEventOp.Upsert:
                    this.z(evt.item, internal);
                    break;
                case TestItemEventOp.Bulk:
                    for (const op of evt.ops) {
                        this.w(internal, op);
                    }
                    break;
                case TestItemEventOp.SetTags:
                    this.C(evt.new, evt.old, internal.fullId.toString());
                    break;
                case TestItemEventOp.UpdateCanResolveChildren:
                    this.J(internal);
                    break;
                case TestItemEventOp.SetProp:
                    this.pushDiff({
                        op: testTypes_1.TestDiffOpType.Update,
                        item: {
                            extId: internal.fullId.toString(),
                            item: evt.update,
                        }
                    });
                    break;
                case TestItemEventOp.DocumentSynced:
                    this.y(internal.actual.uri);
                    break;
                default:
                    (0, assert_1.$ed)(evt);
            }
        }
        y(uri) {
            if (uri) {
                this.pushDiff({
                    op: testTypes_1.TestDiffOpType.DocumentSynced,
                    uri,
                    docv: this.s.getDocumentVersion(uri)
                });
            }
        }
        z(actual, parent) {
            const fullId = testId_1.$7I.fromExtHostTestItem(actual, this.root.id, parent?.actual);
            // If this test item exists elsewhere in the tree already (exists at an
            // old ID with an existing parent), remove that old item.
            const privateApi = this.s.getApiFor(actual);
            if (privateApi.parent && privateApi.parent !== parent?.actual) {
                this.s.getChildren(privateApi.parent).delete(actual.id);
            }
            let internal = this.tree.get(fullId.toString());
            // Case 1: a brand new item
            if (!internal) {
                internal = {
                    fullId,
                    actual,
                    expandLevels: parent?.expandLevels /* intentionally undefined or 0 */ ? parent.expandLevels - 1 : undefined,
                    expand: testTypes_1.TestItemExpandState.NotExpandable, // updated by `connectItemAndChildren`
                };
                actual.tags.forEach(this.D, this);
                this.tree.set(internal.fullId.toString(), internal);
                this.G(actual, parent);
                this.pushDiff({
                    op: testTypes_1.TestDiffOpType.Add,
                    item: {
                        controllerId: this.s.controllerId,
                        expand: internal.expand,
                        item: this.s.toITestItem(actual),
                    },
                });
                this.I(actual, internal, parent);
                return;
            }
            // Case 2: re-insertion of an existing item, no-op
            if (internal.actual === actual) {
                this.H(actual, internal, parent); // re-connect in case the parent changed
                return; // no-op
            }
            // Case 3: upsert of an existing item by ID, with a new instance
            if (internal.actual.uri?.toString() !== actual.uri?.toString()) {
                // If the item has a new URI, re-insert it; we don't support updating
                // URIs on existing test items.
                this.O(fullId.toString());
                return this.z(actual, parent);
            }
            const oldChildren = this.s.getChildren(internal.actual);
            const oldActual = internal.actual;
            const update = diffTestItems(this.s.toITestItem(oldActual), this.s.toITestItem(actual));
            this.s.getApiFor(oldActual).listener = undefined;
            internal.actual = actual;
            internal.resolveBarrier = undefined;
            internal.expand = testTypes_1.TestItemExpandState.NotExpandable; // updated by `connectItemAndChildren`
            if (update) {
                // tags are handled in a special way
                if (update.hasOwnProperty('tags')) {
                    this.C(actual.tags, oldActual.tags, fullId.toString());
                    delete update.tags;
                }
                this.w(internal, { op: TestItemEventOp.SetProp, update });
            }
            this.I(actual, internal, parent);
            // Remove any orphaned children.
            for (const [_, child] of oldChildren) {
                if (!this.s.getChildren(actual).get(child.id)) {
                    this.O(testId_1.$7I.joinToString(fullId, child.id));
                }
            }
            // Re-expand the element if it was previous expanded (#207574)
            const expandLevels = internal.expandLevels;
            if (expandLevels !== undefined) {
                // Wait until a microtask to allow the extension to finish setting up
                // properties of the element and children before we ask it to expand.
                queueMicrotask(() => {
                    if (internal.expand === testTypes_1.TestItemExpandState.Expandable) {
                        internal.expandLevels = undefined;
                        this.expand(fullId.toString(), expandLevels);
                    }
                });
            }
            // Mark ranges in the document as synced (#161320)
            this.y(internal.actual.uri);
        }
        C(newTags, oldTags, extId) {
            const toDelete = new Set(oldTags.map(t => t.id));
            for (const tag of newTags) {
                if (!toDelete.delete(tag.id)) {
                    this.D(tag);
                }
            }
            this.pushDiff({
                op: testTypes_1.TestDiffOpType.Update,
                item: { extId, item: { tags: newTags.map(v => (0, testTypes_1.$_I)(this.s.controllerId, v.id)) } }
            });
            toDelete.forEach(this.F, this);
        }
        D(tag) {
            const existing = this.j.get(tag.id);
            if (existing) {
                existing.refCount++;
            }
            else {
                this.j.set(tag.id, { refCount: 1 });
                this.pushDiff({
                    op: testTypes_1.TestDiffOpType.AddTag, tag: {
                        id: (0, testTypes_1.$_I)(this.s.controllerId, tag.id),
                    }
                });
            }
        }
        F(tagId) {
            const existing = this.j.get(tagId);
            if (existing && !--existing.refCount) {
                this.j.delete(tagId);
                this.pushDiff({ op: testTypes_1.TestDiffOpType.RemoveTag, id: (0, testTypes_1.$_I)(this.s.controllerId, tagId) });
            }
        }
        G(actual, parent) {
            this.s.getApiFor(actual).parent = parent && parent.actual !== this.root ? parent.actual : undefined;
        }
        H(actual, internal, parent) {
            this.G(actual, parent);
            const api = this.s.getApiFor(actual);
            api.parent = parent?.actual;
            api.listener = evt => this.w(internal, evt);
            this.J(internal);
        }
        I(actual, internal, parent) {
            this.H(actual, internal, parent);
            // Discover any existing children that might have already been added
            for (const [_, child] of this.s.getChildren(actual)) {
                this.z(child, internal);
            }
        }
        /**
         * Updates the `expand` state of the item. Should be called whenever the
         * resolved state of the item changes. Can automatically expand the item
         * if requested by a consumer.
         */
        J(internal) {
            let newState;
            if (!this.h) {
                newState = testTypes_1.TestItemExpandState.NotExpandable;
            }
            else if (internal.resolveBarrier) {
                newState = internal.resolveBarrier.isOpen()
                    ? testTypes_1.TestItemExpandState.Expanded
                    : testTypes_1.TestItemExpandState.BusyExpanding;
            }
            else {
                newState = internal.actual.canResolveChildren
                    ? testTypes_1.TestItemExpandState.Expandable
                    : testTypes_1.TestItemExpandState.NotExpandable;
            }
            if (newState === internal.expand) {
                return;
            }
            internal.expand = newState;
            this.pushDiff({ op: testTypes_1.TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: newState } });
            if (newState === testTypes_1.TestItemExpandState.Expandable && internal.expandLevels !== undefined) {
                this.M(internal);
            }
        }
        /**
         * Expands all children of the item, "levels" deep. If levels is 0, only
         * the children will be expanded. If it's 1, the children and their children
         * will be expanded. If it's <0, it's a no-op.
         */
        L(internal, levels) {
            if (levels < 0) {
                return;
            }
            const expandRequests = [];
            for (const [_, child] of this.s.getChildren(internal.actual)) {
                const promise = this.expand(testId_1.$7I.joinToString(internal.fullId, child.id), levels);
                if ((0, async_1.$rh)(promise)) {
                    expandRequests.push(promise);
                }
            }
            if (expandRequests.length) {
                return Promise.all(expandRequests).then(() => { });
            }
        }
        /**
         * Calls `discoverChildren` on the item, refreshing all its tests.
         */
        M(internal) {
            if (internal.resolveBarrier) {
                return internal.resolveBarrier;
            }
            if (!this.h) {
                const b = new async_1.$Eh();
                b.open();
                return b;
            }
            internal.expand = testTypes_1.TestItemExpandState.BusyExpanding;
            this.N(internal);
            const barrier = internal.resolveBarrier = new async_1.$Eh();
            const applyError = (err) => {
                console.error(`Unhandled error in resolveHandler of test controller "${this.s.controllerId}"`, err);
            };
            let r;
            try {
                r = this.h(internal.actual === this.root ? undefined : internal.actual);
            }
            catch (err) {
                applyError(err);
            }
            if ((0, async_1.$rh)(r)) {
                r.catch(applyError).then(() => {
                    barrier.open();
                    this.J(internal);
                });
            }
            else {
                barrier.open();
                this.J(internal);
            }
            return internal.resolveBarrier;
        }
        N(internal) {
            this.pushDiff({ op: testTypes_1.TestDiffOpType.Update, item: { extId: internal.fullId.toString(), expand: internal.expand } });
        }
        O(childId) {
            const childItem = this.tree.get(childId);
            if (!childItem) {
                throw new Error('attempting to remove non-existent child');
            }
            this.pushDiff({ op: testTypes_1.TestDiffOpType.Remove, itemId: childId });
            const queue = [childItem];
            while (queue.length) {
                const item = queue.pop();
                if (!item) {
                    continue;
                }
                this.s.getApiFor(item.actual).listener = undefined;
                for (const tag of item.actual.tags) {
                    this.F(tag.id);
                }
                this.tree.delete(item.fullId.toString());
                for (const [_, child] of this.s.getChildren(item.actual)) {
                    queue.push(this.tree.get(testId_1.$7I.joinToString(item.fullId, child.id)));
                }
            }
        }
        /**
         * Immediately emits any pending diffs on the collection.
         */
        flushDiff() {
            const diff = this.collectDiff();
            if (diff.length) {
                this.g.fire(diff);
            }
        }
    }
    exports.$aQ = $aQ;
    class $bQ extends Error {
        constructor(id) {
            super(`Attempted to insert a duplicate test item ID ${id}`);
        }
    }
    exports.$bQ = $bQ;
    class $cQ extends Error {
        constructor(id) {
            super(`TestItem with ID "${id}" is invalid. Make sure to create it from the createTestItem method.`);
        }
    }
    exports.$cQ = $cQ;
    class $dQ extends Error {
        constructor(id, ctrlA, ctrlB) {
            super(`TestItem with ID "${id}" is from controller "${ctrlA}" and cannot be added as a child of an item from controller "${ctrlB}".`);
        }
    }
    exports.$dQ = $dQ;
    const $eQ = (api, getApi, checkCtor) => {
        let mapped = new Map();
        return {
            /** @inheritdoc */
            get size() {
                return mapped.size;
            },
            /** @inheritdoc */
            forEach(callback, thisArg) {
                for (const item of mapped.values()) {
                    callback.call(thisArg, item, this);
                }
            },
            /** @inheritdoc */
            [Symbol.iterator]() {
                return mapped.entries();
            },
            /** @inheritdoc */
            replace(items) {
                const newMapped = new Map();
                const toDelete = new Set(mapped.keys());
                const bulk = { op: TestItemEventOp.Bulk, ops: [] };
                for (const item of items) {
                    if (!(item instanceof checkCtor)) {
                        throw new $cQ(item.id);
                    }
                    const itemController = getApi(item).controllerId;
                    if (itemController !== api.controllerId) {
                        throw new $dQ(item.id, itemController, api.controllerId);
                    }
                    if (newMapped.has(item.id)) {
                        throw new $bQ(item.id);
                    }
                    newMapped.set(item.id, item);
                    toDelete.delete(item.id);
                    bulk.ops.push({ op: TestItemEventOp.Upsert, item });
                }
                for (const id of toDelete.keys()) {
                    bulk.ops.push({ op: TestItemEventOp.RemoveChild, id });
                }
                api.listener?.(bulk);
                // important mutations come after firing, so if an error happens no
                // changes will be "saved":
                mapped = newMapped;
            },
            /** @inheritdoc */
            add(item) {
                if (!(item instanceof checkCtor)) {
                    throw new $cQ(item.id);
                }
                mapped.set(item.id, item);
                api.listener?.({ op: TestItemEventOp.Upsert, item });
            },
            /** @inheritdoc */
            delete(id) {
                if (mapped.delete(id)) {
                    api.listener?.({ op: TestItemEventOp.RemoveChild, id });
                }
            },
            /** @inheritdoc */
            get(itemId) {
                return mapped.get(itemId);
            },
            /** JSON serialization function. */
            toJSON() {
                return Array.from(mapped.values());
            },
        };
    };
    exports.$eQ = $eQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[116/*vs/workbench/api/common/extHostTestingPrivateApi*/], __M([1/*require*/,0/*exports*/,81/*vs/workbench/contrib/testing/common/testItemCollection*/]), function (require, exports, testItemCollection_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$gQ = exports.$fQ = void 0;
    const eventPrivateApis = new WeakMap();
    const $fQ = (impl, controllerId) => {
        const api = { controllerId };
        eventPrivateApis.set(impl, api);
        return api;
    };
    exports.$fQ = $fQ;
    /**
     * Gets the private API for a test item implementation. This implementation
     * is a managed object, but we keep a weakmap to avoid exposing any of the
     * internals to extensions.
     */
    const $gQ = (impl) => {
        const api = eventPrivateApis.get(impl);
        if (!api) {
            throw new testItemCollection_1.$cQ(impl?.id || '<unknown>');
        }
        return api;
    };
    exports.$gQ = $gQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[82/*vs/workbench/contrib/webview/common/webview*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/charCode*/,15/*vs/base/common/network*/,2/*vs/base/common/uri*/]), function (require, exports, charCode_1, network_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$DDb = exports.$CDb = exports.$BDb = void 0;
    exports.$EDb = $EDb;
    exports.$FDb = $FDb;
    /**
     * Root from which resources in webviews are loaded.
     *
     * This is hardcoded because we never expect to actually hit it. Instead these requests
     * should always go to a service worker.
     */
    exports.$BDb = 'vscode-cdn.net';
    exports.$CDb = `vscode-resource.${exports.$BDb}`;
    exports.$DDb = `'self' https://*.${exports.$BDb}`;
    /**
     * Construct a uri that can load resources inside a webview
     *
     * We encode the resource component of the uri so that on the main thread
     * we know where to load the resource from (remote or truly local):
     *
     * ```txt
     * ${scheme}+${resource-authority}.vscode-resource.vscode-cdn.net/${path}
     * ```
     *
     * @param resource Uri of the resource to load.
     * @param remoteInfo Optional information about the remote that specifies where `resource` should be resolved from.
     */
    function $EDb(resource, remoteInfo) {
        if (resource.scheme === network_1.Schemas.http || resource.scheme === network_1.Schemas.https) {
            return resource;
        }
        if (remoteInfo && remoteInfo.authority && remoteInfo.isRemote && resource.scheme === network_1.Schemas.file) {
            resource = uri_1.URI.from({
                scheme: network_1.Schemas.vscodeRemote,
                authority: remoteInfo.authority,
                path: resource.path,
            });
        }
        return uri_1.URI.from({
            scheme: network_1.Schemas.https,
            authority: `${resource.scheme}+${encodeAuthority(resource.authority)}.${exports.$CDb}`,
            path: resource.path,
            fragment: resource.fragment,
            query: resource.query,
        });
    }
    function encodeAuthority(authority) {
        return authority.replace(/./g, char => {
            const code = char.charCodeAt(0);
            if ((code >= charCode_1.CharCode.a && code <= charCode_1.CharCode.z)
                || (code >= charCode_1.CharCode.A && code <= charCode_1.CharCode.Z)
                || (code >= charCode_1.CharCode.Digit0 && code <= charCode_1.CharCode.Digit9)) {
                return char;
            }
            return '-' + code.toString(16).padStart(4, '0');
        });
    }
    function $FDb(authority) {
        return authority.replace(/-([0-9a-f]{4})/g, (_, code) => String.fromCharCode(parseInt(code, 16)));
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[201/*vs/workbench/api/common/extHostCodeInsets*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,82/*vs/workbench/contrib/webview/common/webview*/]), function (require, exports, event_1, lifecycle_1, webview_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ipc = void 0;
    class $Ipc {
        constructor(d, e, f) {
            this.d = d;
            this.e = e;
            this.f = f;
            this.a = 0;
            this.b = new lifecycle_1.$Tc();
            this.c = new Map();
            // dispose editor inset whenever the hosting editor goes away
            this.b.add(e.onDidChangeVisibleTextEditors(() => {
                const visibleEditor = e.getVisibleTextEditors();
                for (const value of this.c.values()) {
                    if (visibleEditor.indexOf(value.editor) < 0) {
                        value.inset.dispose(); // will remove from `this._insets`
                    }
                }
            }));
        }
        dispose() {
            this.c.forEach(value => value.inset.dispose());
            this.b.dispose();
        }
        createWebviewEditorInset(editor, line, height, options, extension) {
            let apiEditor;
            for (const candidate of this.e.getVisibleTextEditors(true)) {
                if (candidate.value === editor) {
                    apiEditor = candidate;
                    break;
                }
            }
            if (!apiEditor) {
                throw new Error('not a visible editor');
            }
            const that = this;
            const handle = this.a++;
            const onDidReceiveMessage = new event_1.$le();
            const onDidDispose = new event_1.$le();
            const webview = new class {
                constructor() {
                    this.a = '';
                    this.b = Object.create(null);
                }
                asWebviewUri(resource) {
                    return (0, webview_1.$EDb)(resource, that.f);
                }
                get cspSource() {
                    return webview_1.$DDb;
                }
                set options(value) {
                    this.b = value;
                    that.d.$setOptions(handle, value);
                }
                get options() {
                    return this.b;
                }
                set html(value) {
                    this.a = value;
                    that.d.$setHtml(handle, value);
                }
                get html() {
                    return this.a;
                }
                get onDidReceiveMessage() {
                    return onDidReceiveMessage.event;
                }
                postMessage(message) {
                    return that.d.$postMessage(handle, message);
                }
            };
            const inset = new class {
                constructor() {
                    this.editor = editor;
                    this.line = line;
                    this.height = height;
                    this.webview = webview;
                    this.onDidDispose = onDidDispose.event;
                }
                dispose() {
                    if (that.c.has(handle)) {
                        that.c.delete(handle);
                        that.d.$disposeEditorInset(handle);
                        onDidDispose.fire();
                        // final cleanup
                        onDidDispose.dispose();
                        onDidReceiveMessage.dispose();
                    }
                }
            };
            this.d.$createEditorInset(handle, apiEditor.id, apiEditor.value.document.uri, line + 1, height, options || {}, extension.identifier, extension.extensionLocation);
            this.c.set(handle, { editor, inset, onDidReceiveMessage });
            return inset;
        }
        $onDidDispose(handle) {
            const value = this.c.get(handle);
            if (value) {
                value.inset.dispose();
            }
        }
        $onDidReceiveMessage(handle, message) {
            const value = this.c.get(handle);
            value?.onDidReceiveMessage.fire(message);
        }
    }
    exports.$Ipc = $Ipc;
});

define(__m[117/*vs/workbench/services/authentication/common/authentication*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$OM = exports.$NM = exports.$MM = void 0;
    /**
     * Use this if you don't want the onDidChangeSessions event to fire in the extension host
     */
    exports.$MM = '__';
    exports.$NM = (0, instantiation_1.$Fi)('IAuthenticationService');
    // TODO: Move this into MainThreadAuthentication
    exports.$OM = (0, instantiation_1.$Fi)('IAuthenticationExtensionsService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[202/*vs/workbench/services/configurationResolver/common/configurationResolver*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$_Q = exports.VariableKind = exports.$$Q = void 0;
    exports.$$Q = (0, instantiation_1.$Fi)('configurationResolverService');
    var VariableKind;
    (function (VariableKind) {
        VariableKind["Unknown"] = "unknown";
        VariableKind["Env"] = "env";
        VariableKind["Config"] = "config";
        VariableKind["Command"] = "command";
        VariableKind["Input"] = "input";
        VariableKind["ExtensionInstallFolder"] = "extensionInstallFolder";
        VariableKind["WorkspaceFolder"] = "workspaceFolder";
        VariableKind["Cwd"] = "cwd";
        VariableKind["WorkspaceFolderBasename"] = "workspaceFolderBasename";
        VariableKind["UserHome"] = "userHome";
        VariableKind["LineNumber"] = "lineNumber";
        VariableKind["SelectedText"] = "selectedText";
        VariableKind["File"] = "file";
        VariableKind["FileWorkspaceFolder"] = "fileWorkspaceFolder";
        VariableKind["FileWorkspaceFolderBasename"] = "fileWorkspaceFolderBasename";
        VariableKind["RelativeFile"] = "relativeFile";
        VariableKind["RelativeFileDirname"] = "relativeFileDirname";
        VariableKind["FileDirname"] = "fileDirname";
        VariableKind["FileExtname"] = "fileExtname";
        VariableKind["FileBasename"] = "fileBasename";
        VariableKind["FileBasenameNoExtension"] = "fileBasenameNoExtension";
        VariableKind["FileDirnameBasename"] = "fileDirnameBasename";
        VariableKind["ExecPath"] = "execPath";
        VariableKind["ExecInstallFolder"] = "execInstallFolder";
        VariableKind["PathSeparator"] = "pathSeparator";
        VariableKind["PathSeparatorAlias"] = "/";
    })(VariableKind || (exports.VariableKind = VariableKind = {}));
    class $_Q extends Error {
        constructor(variable, message) {
            super(message);
            this.variable = variable;
        }
    }
    exports.$_Q = $_Q;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[203/*vs/workbench/services/configurationResolver/common/variableResolver*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/path*/,78/*vs/base/common/process*/,14/*vs/base/common/types*/,25/*vs/base/common/objects*/,20/*vs/base/common/platform*/,99/*vs/base/common/labels*/,9/*vs/nls*/,202/*vs/workbench/services/configurationResolver/common/configurationResolver*/,12/*vs/base/common/strings*/]), function (require, exports, paths, process, types, objects, platform_1, labels_1, nls_1, configurationResolver_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oR = void 0;
    paths = __importStar(paths);
    process = __importStar(process);
    types = __importStar(types);
    objects = __importStar(objects);
    class $oR {
        static { this.VARIABLE_LHS = '${'; }
        static { this.VARIABLE_REGEXP = /\$\{(.*?)\}/g; }
        constructor(_context, _labelService, _userHomePromise, _envVariablesPromise) {
            this.h = new Map();
            this.a = _context;
            this.b = _labelService;
            this.g = _userHomePromise;
            if (_envVariablesPromise) {
                this.c = _envVariablesPromise.then(envVariables => {
                    return this.i(envVariables);
                });
            }
        }
        i(envVariables) {
            // windows env variables are case insensitive
            if (platform_1.$j) {
                const ev = Object.create(null);
                Object.keys(envVariables).forEach(key => {
                    ev[key.toLowerCase()] = envVariables[key];
                });
                return ev;
            }
            return envVariables;
        }
        resolveWithEnvironment(environment, root, value) {
            return this.l({ env: this.i(environment), userHome: undefined }, root ? root.uri : undefined, value);
        }
        async resolveAsync(root, value) {
            const environment = {
                env: await this.c,
                userHome: await this.g
            };
            return this.l(environment, root ? root.uri : undefined, value);
        }
        async j(workspaceFolder, config, commandValueMapping, resolvedVariables) {
            const result = objects.$eo(config);
            // hoist platform specific attributes to top level
            if (platform_1.$j && result.windows) {
                Object.keys(result.windows).forEach(key => result[key] = result.windows[key]);
            }
            else if (platform_1.$k && result.osx) {
                Object.keys(result.osx).forEach(key => result[key] = result.osx[key]);
            }
            else if (platform_1.$l && result.linux) {
                Object.keys(result.linux).forEach(key => result[key] = result.linux[key]);
            }
            // delete all platform specific sections
            delete result.windows;
            delete result.osx;
            delete result.linux;
            // substitute all variables recursively in string values
            const environmentPromises = {
                env: await this.c,
                userHome: await this.g
            };
            return this.l(environmentPromises, workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping, resolvedVariables);
        }
        async resolveAnyAsync(workspaceFolder, config, commandValueMapping) {
            return this.j(workspaceFolder, config, commandValueMapping);
        }
        async resolveAnyMap(workspaceFolder, config, commandValueMapping) {
            const resolvedVariables = new Map();
            const newConfig = await this.j(workspaceFolder, config, commandValueMapping, resolvedVariables);
            return { newConfig, resolvedVariables };
        }
        resolveWithInteractionReplace(folder, config, section, variables) {
            throw new Error('resolveWithInteractionReplace not implemented.');
        }
        resolveWithInteraction(folder, config, section, variables) {
            throw new Error('resolveWithInteraction not implemented.');
        }
        contributeVariable(variable, resolution) {
            if (this.h.has(variable)) {
                throw new Error('Variable ' + variable + ' is contributed twice.');
            }
            else {
                this.h.set(variable, resolution);
            }
        }
        async l(environment, folderUri, value, commandValueMapping, resolvedVariables) {
            if (types.$eg(value)) {
                return this.m(environment, folderUri, value, commandValueMapping, resolvedVariables);
            }
            else if (Array.isArray(value)) {
                return Promise.all(value.map(s => this.l(environment, folderUri, s, commandValueMapping, resolvedVariables)));
            }
            else if (types.$gg(value)) {
                const result = Object.create(null);
                const replaced = await Promise.all(Object.keys(value).map(async (key) => {
                    const replaced = await this.m(environment, folderUri, key, commandValueMapping, resolvedVariables);
                    return [replaced, await this.l(environment, folderUri, value[key], commandValueMapping, resolvedVariables)];
                }));
                // two step process to preserve object key order
                for (const [key, value] of replaced) {
                    result[key] = value;
                }
                return result;
            }
            return value;
        }
        m(environment, folderUri, value, commandValueMapping, resolvedVariables) {
            // loop through all variables occurrences in 'value'
            return (0, strings_1.$xf)(value, $oR.VARIABLE_REGEXP, async (match, variable) => {
                // disallow attempted nesting, see #77289. This doesn't exclude variables that resolve to other variables.
                if (variable.includes($oR.VARIABLE_LHS)) {
                    return match;
                }
                let resolvedValue = await this.o(environment, match, variable, folderUri, commandValueMapping);
                resolvedVariables?.set(variable, resolvedValue);
                if ((resolvedValue !== match) && types.$eg(resolvedValue) && resolvedValue.match($oR.VARIABLE_REGEXP)) {
                    resolvedValue = await this.m(environment, folderUri, resolvedValue, commandValueMapping, resolvedVariables);
                }
                return resolvedValue;
            });
        }
        n(displayUri) {
            return this.b ? this.b.getUriLabel(displayUri, { noPrefix: true }) : displayUri.fsPath;
        }
        async o(environment, match, variable, folderUri, commandValueMapping) {
            // try to separate variable arguments from variable name
            let argument;
            const parts = variable.split(':');
            if (parts.length > 1) {
                variable = parts[0];
                argument = parts[1];
            }
            // common error handling for all variables that require an open editor
            const getFilePath = (variableKind) => {
                const filePath = this.a.getFilePath();
                if (filePath) {
                    return (0, labels_1.$1w)(filePath);
                }
                throw new configurationResolver_1.$_Q(variableKind, ((0, nls_1.localize)(2311, null, match)));
            };
            // common error handling for all variables that require an open editor
            const getFolderPathForFile = (variableKind) => {
                const filePath = getFilePath(variableKind); // throws error if no editor open
                if (this.a.getWorkspaceFolderPathForFile) {
                    const folderPath = this.a.getWorkspaceFolderPathForFile();
                    if (folderPath) {
                        return (0, labels_1.$1w)(folderPath);
                    }
                }
                throw new configurationResolver_1.$_Q(variableKind, (0, nls_1.localize)(2312, null, match, paths.$nc(filePath)));
            };
            // common error handling for all variables that require an open folder and accept a folder name argument
            const getFolderUri = (variableKind) => {
                if (argument) {
                    const folder = this.a.getFolderUri(argument);
                    if (folder) {
                        return folder;
                    }
                    throw new configurationResolver_1.$_Q(variableKind, (0, nls_1.localize)(2313, null, match, argument));
                }
                if (folderUri) {
                    return folderUri;
                }
                if (this.a.getWorkspaceFolderCount() > 1) {
                    throw new configurationResolver_1.$_Q(variableKind, (0, nls_1.localize)(2314, null, match));
                }
                throw new configurationResolver_1.$_Q(variableKind, (0, nls_1.localize)(2315, null, match));
            };
            switch (variable) {
                case 'env':
                    if (argument) {
                        if (environment.env) {
                            // Depending on the source of the environment, on Windows, the values may all be lowercase.
                            const env = environment.env[platform_1.$j ? argument.toLowerCase() : argument];
                            if (types.$eg(env)) {
                                return env;
                            }
                        }
                        // For `env` we should do the same as a normal shell does - evaluates undefined envs to an empty string #46436
                        return '';
                    }
                    throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.Env, (0, nls_1.localize)(2316, null, match));
                case 'config':
                    if (argument) {
                        const config = this.a.getConfigurationValue(folderUri, argument);
                        if (types.$ng(config)) {
                            throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.Config, (0, nls_1.localize)(2317, null, match, argument));
                        }
                        if (types.$gg(config)) {
                            throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.Config, (0, nls_1.localize)(2318, null, match, argument));
                        }
                        return config;
                    }
                    throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.Config, (0, nls_1.localize)(2319, null, match));
                case 'command':
                    return this.p(configurationResolver_1.VariableKind.Command, match, argument, commandValueMapping, 'command');
                case 'input':
                    return this.p(configurationResolver_1.VariableKind.Input, match, argument, commandValueMapping, 'input');
                case 'extensionInstallFolder':
                    if (argument) {
                        const ext = await this.a.getExtension(argument);
                        if (!ext) {
                            throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.ExtensionInstallFolder, (0, nls_1.localize)(2320, null, match, argument));
                        }
                        return this.n(ext.extensionLocation);
                    }
                    throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.ExtensionInstallFolder, (0, nls_1.localize)(2321, null, match));
                default: {
                    switch (variable) {
                        case 'workspaceRoot':
                        case 'workspaceFolder':
                            return (0, labels_1.$1w)(this.n(getFolderUri(configurationResolver_1.VariableKind.WorkspaceFolder)));
                        case 'cwd':
                            return ((folderUri || argument) ? (0, labels_1.$1w)(this.n(getFolderUri(configurationResolver_1.VariableKind.Cwd))) : process.cwd());
                        case 'workspaceRootFolderName':
                        case 'workspaceFolderBasename':
                            return (0, labels_1.$1w)(paths.$nc(this.n(getFolderUri(configurationResolver_1.VariableKind.WorkspaceFolderBasename))));
                        case 'userHome': {
                            if (environment.userHome) {
                                return environment.userHome;
                            }
                            throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.UserHome, (0, nls_1.localize)(2322, null, match));
                        }
                        case 'lineNumber': {
                            const lineNumber = this.a.getLineNumber();
                            if (lineNumber) {
                                return lineNumber;
                            }
                            throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.LineNumber, (0, nls_1.localize)(2323, null, match));
                        }
                        case 'selectedText': {
                            const selectedText = this.a.getSelectedText();
                            if (selectedText) {
                                return selectedText;
                            }
                            throw new configurationResolver_1.$_Q(configurationResolver_1.VariableKind.SelectedText, (0, nls_1.localize)(2324, null, match));
                        }
                        case 'file':
                            return getFilePath(configurationResolver_1.VariableKind.File);
                        case 'fileWorkspaceFolder':
                            return getFolderPathForFile(configurationResolver_1.VariableKind.FileWorkspaceFolder);
                        case 'fileWorkspaceFolderBasename':
                            return paths.$nc(getFolderPathForFile(configurationResolver_1.VariableKind.FileWorkspaceFolderBasename));
                        case 'relativeFile':
                            if (folderUri || argument) {
                                return paths.$lc(this.n(getFolderUri(configurationResolver_1.VariableKind.RelativeFile)), getFilePath(configurationResolver_1.VariableKind.RelativeFile));
                            }
                            return getFilePath(configurationResolver_1.VariableKind.RelativeFile);
                        case 'relativeFileDirname': {
                            const dirname = paths.$mc(getFilePath(configurationResolver_1.VariableKind.RelativeFileDirname));
                            if (folderUri || argument) {
                                const relative = paths.$lc(this.n(getFolderUri(configurationResolver_1.VariableKind.RelativeFileDirname)), dirname);
                                return relative.length === 0 ? '.' : relative;
                            }
                            return dirname;
                        }
                        case 'fileDirname':
                            return paths.$mc(getFilePath(configurationResolver_1.VariableKind.FileDirname));
                        case 'fileExtname':
                            return paths.$oc(getFilePath(configurationResolver_1.VariableKind.FileExtname));
                        case 'fileBasename':
                            return paths.$nc(getFilePath(configurationResolver_1.VariableKind.FileBasename));
                        case 'fileBasenameNoExtension': {
                            const basename = paths.$nc(getFilePath(configurationResolver_1.VariableKind.FileBasenameNoExtension));
                            return (basename.slice(0, basename.length - paths.$oc(basename).length));
                        }
                        case 'fileDirnameBasename':
                            return paths.$nc(paths.$mc(getFilePath(configurationResolver_1.VariableKind.FileDirnameBasename)));
                        case 'execPath': {
                            const ep = this.a.getExecPath();
                            if (ep) {
                                return ep;
                            }
                            return match;
                        }
                        case 'execInstallFolder': {
                            const ar = this.a.getAppRoot();
                            if (ar) {
                                return ar;
                            }
                            return match;
                        }
                        case 'pathSeparator':
                        case '/':
                            return paths.sep;
                        default:
                            try {
                                const key = argument ? `${variable}:${argument}` : variable;
                                return this.p(configurationResolver_1.VariableKind.Unknown, match, key, commandValueMapping, undefined);
                            }
                            catch (error) {
                                return match;
                            }
                    }
                }
            }
        }
        p(variableKind, match, argument, commandValueMapping, prefix) {
            if (argument && commandValueMapping) {
                const v = (prefix === undefined) ? commandValueMapping[argument] : commandValueMapping[prefix + ':' + argument];
                if (typeof v === 'string') {
                    return v;
                }
                throw new configurationResolver_1.$_Q(variableKind, (0, nls_1.localize)(2325, null, match));
            }
            return match;
        }
    }
    exports.$oR = $oR;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[118/*vs/workbench/services/editor/common/editorGroupsService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,114/*vs/workbench/common/editor*/]), function (require, exports, instantiation_1, editor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenEditorContext = exports.GroupsOrder = exports.MergeGroupMode = exports.GroupsArrangement = exports.GroupLocation = exports.GroupOrientation = exports.GroupDirection = exports.$tE = void 0;
    exports.$uE = $uE;
    exports.$vE = $vE;
    exports.$wE = $wE;
    exports.$tE = (0, instantiation_1.$Fi)('editorGroupsService');
    var GroupDirection;
    (function (GroupDirection) {
        GroupDirection[GroupDirection["UP"] = 0] = "UP";
        GroupDirection[GroupDirection["DOWN"] = 1] = "DOWN";
        GroupDirection[GroupDirection["LEFT"] = 2] = "LEFT";
        GroupDirection[GroupDirection["RIGHT"] = 3] = "RIGHT";
    })(GroupDirection || (exports.GroupDirection = GroupDirection = {}));
    var GroupOrientation;
    (function (GroupOrientation) {
        GroupOrientation[GroupOrientation["HORIZONTAL"] = 0] = "HORIZONTAL";
        GroupOrientation[GroupOrientation["VERTICAL"] = 1] = "VERTICAL";
    })(GroupOrientation || (exports.GroupOrientation = GroupOrientation = {}));
    var GroupLocation;
    (function (GroupLocation) {
        GroupLocation[GroupLocation["FIRST"] = 0] = "FIRST";
        GroupLocation[GroupLocation["LAST"] = 1] = "LAST";
        GroupLocation[GroupLocation["NEXT"] = 2] = "NEXT";
        GroupLocation[GroupLocation["PREVIOUS"] = 3] = "PREVIOUS";
    })(GroupLocation || (exports.GroupLocation = GroupLocation = {}));
    var GroupsArrangement;
    (function (GroupsArrangement) {
        /**
         * Make the current active group consume the entire
         * editor area.
         */
        GroupsArrangement[GroupsArrangement["MAXIMIZE"] = 0] = "MAXIMIZE";
        /**
         * Make the current active group consume the maximum
         * amount of space possible.
         */
        GroupsArrangement[GroupsArrangement["EXPAND"] = 1] = "EXPAND";
        /**
         * Size all groups evenly.
         */
        GroupsArrangement[GroupsArrangement["EVEN"] = 2] = "EVEN";
    })(GroupsArrangement || (exports.GroupsArrangement = GroupsArrangement = {}));
    var MergeGroupMode;
    (function (MergeGroupMode) {
        MergeGroupMode[MergeGroupMode["COPY_EDITORS"] = 0] = "COPY_EDITORS";
        MergeGroupMode[MergeGroupMode["MOVE_EDITORS"] = 1] = "MOVE_EDITORS";
    })(MergeGroupMode || (exports.MergeGroupMode = MergeGroupMode = {}));
    function $uE(replacement) {
        const candidate = replacement;
        return (0, editor_1.$hG)(candidate?.editor) && (0, editor_1.$hG)(candidate?.replacement);
    }
    var GroupsOrder;
    (function (GroupsOrder) {
        /**
         * Groups sorted by creation order (oldest one first)
         */
        GroupsOrder[GroupsOrder["CREATION_TIME"] = 0] = "CREATION_TIME";
        /**
         * Groups sorted by most recent activity (most recent active first)
         */
        GroupsOrder[GroupsOrder["MOST_RECENTLY_ACTIVE"] = 1] = "MOST_RECENTLY_ACTIVE";
        /**
         * Groups sorted by grid widget order
         */
        GroupsOrder[GroupsOrder["GRID_APPEARANCE"] = 2] = "GRID_APPEARANCE";
    })(GroupsOrder || (exports.GroupsOrder = GroupsOrder = {}));
    var OpenEditorContext;
    (function (OpenEditorContext) {
        OpenEditorContext[OpenEditorContext["NEW_EDITOR"] = 1] = "NEW_EDITOR";
        OpenEditorContext[OpenEditorContext["MOVE_EDITOR"] = 2] = "MOVE_EDITOR";
        OpenEditorContext[OpenEditorContext["COPY_EDITOR"] = 3] = "COPY_EDITOR";
    })(OpenEditorContext || (exports.OpenEditorContext = OpenEditorContext = {}));
    function $vE(obj) {
        const group = obj;
        return !!group && typeof group.id === 'number' && Array.isArray(group.editors);
    }
    //#region Editor Group Helpers
    function $wE(configurationService) {
        const openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');
        if (openSideBySideDirection === 'down') {
            return GroupDirection.DOWN;
        }
        return GroupDirection.RIGHT;
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[204/*vs/workbench/services/editor/common/editorService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,118/*vs/workbench/services/editor/common/editorGroupsService*/]), function (require, exports, instantiation_1, editorGroupsService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$AE = exports.$zE = exports.$yE = exports.$xE = void 0;
    exports.$BE = $BE;
    exports.$xE = (0, instantiation_1.$Fi)('editorService');
    /**
     * Open an editor in the currently active group.
     */
    exports.$yE = -1;
    /**
     * Open an editor to the side of the active group.
     */
    exports.$zE = -2;
    /**
     * Open an editor in a new auxiliary window.
     */
    exports.$AE = -3;
    function $BE(obj) {
        const candidate = obj;
        return typeof obj === 'number' || (0, editorGroupsService_1.$vE)(candidate);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[205/*vs/workbench/services/environment/common/environmentService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,106/*vs/platform/environment/common/environment*/]), function (require, exports, instantiation_1, environment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$8M = void 0;
    exports.$8M = (0, instantiation_1.$Gi)(environment_1.$Mi);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[119/*vs/workbench/services/extensions/common/extensionDescriptionRegistry*/], __M([1/*require*/,0/*exports*/,18/*vs/platform/extensions/common/extensions*/,6/*vs/base/common/event*/,19/*vs/base/common/path*/,4/*vs/base/common/lifecycle*/,10/*vs/base/common/async*/]), function (require, exports, extensions_1, event_1, path, lifecycle_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Pdc = exports.$Odc = exports.$Ndc = exports.$Mdc = exports.$Ldc = void 0;
    path = __importStar(path);
    class $Ldc {
        constructor(versionId, removedDueToLooping) {
            this.versionId = versionId;
            this.removedDueToLooping = removedDueToLooping;
        }
    }
    exports.$Ldc = $Ldc;
    class $Mdc {
        static isHostExtension(extensionId, myRegistry, globalRegistry) {
            if (myRegistry.getExtensionDescription(extensionId)) {
                // I have this extension
                return false;
            }
            const extensionDescription = globalRegistry.getExtensionDescription(extensionId);
            if (!extensionDescription) {
                // unknown extension
                return false;
            }
            if ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === 'none') {
                return true;
            }
            return false;
        }
        constructor(j, extensionDescriptions) {
            this.j = j;
            this.c = new event_1.$le();
            this.onDidChange = this.c.event;
            this.d = 0;
            this.e = extensionDescriptions;
            this.k();
        }
        k() {
            // Ensure extensions are stored in the order: builtin, user, under development
            this.e.sort(extensionCmp);
            this.f = new extensions_1.$tn();
            this.g = [];
            this.h = new Map();
            for (const extensionDescription of this.e) {
                if (this.f.has(extensionDescription.identifier)) {
                    // No overwriting allowed!
                    console.error('Extension `' + extensionDescription.identifier.value + '` is already registered');
                    continue;
                }
                this.f.set(extensionDescription.identifier, extensionDescription);
                this.g.push(extensionDescription);
                const activationEvents = this.j.readActivationEvents(extensionDescription);
                for (const activationEvent of activationEvents) {
                    if (!this.h.has(activationEvent)) {
                        this.h.set(activationEvent, []);
                    }
                    this.h.get(activationEvent).push(extensionDescription);
                }
            }
        }
        set(extensionDescriptions) {
            this.e = extensionDescriptions;
            this.k();
            this.d++;
            this.c.fire(undefined);
            return {
                versionId: this.d
            };
        }
        deltaExtensions(toAdd, toRemove) {
            // It is possible that an extension is removed, only to be added again at a different version
            // so we will first handle removals
            this.e = removeExtensions(this.e, toRemove);
            // Then, handle the extensions to add
            this.e = this.e.concat(toAdd);
            // Immediately remove looping extensions!
            const looping = $Mdc.l(this.e);
            this.e = removeExtensions(this.e, looping.map(ext => ext.identifier));
            this.k();
            this.d++;
            this.c.fire(undefined);
            return new $Ldc(this.d, looping);
        }
        static l(extensionDescriptions) {
            const G = new class {
                constructor() {
                    this.c = new Map();
                    this.d = new Set();
                    this.e = [];
                }
                addNode(id) {
                    if (!this.d.has(id)) {
                        this.d.add(id);
                        this.e.push(id);
                    }
                }
                addArc(from, to) {
                    this.addNode(from);
                    this.addNode(to);
                    if (this.c.has(from)) {
                        this.c.get(from).push(to);
                    }
                    else {
                        this.c.set(from, [to]);
                    }
                }
                getArcs(id) {
                    if (this.c.has(id)) {
                        return this.c.get(id);
                    }
                    return [];
                }
                hasOnlyGoodArcs(id, good) {
                    const dependencies = G.getArcs(id);
                    for (let i = 0; i < dependencies.length; i++) {
                        if (!good.has(dependencies[i])) {
                            return false;
                        }
                    }
                    return true;
                }
                getNodes() {
                    return this.e;
                }
            };
            const descs = new extensions_1.$tn();
            for (const extensionDescription of extensionDescriptions) {
                descs.set(extensionDescription.identifier, extensionDescription);
                if (extensionDescription.extensionDependencies) {
                    for (const depId of extensionDescription.extensionDependencies) {
                        G.addArc(extensions_1.$rn.toKey(extensionDescription.identifier), extensions_1.$rn.toKey(depId));
                    }
                }
            }
            // initialize with all extensions with no dependencies.
            const good = new Set();
            G.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));
            // all other extensions will be processed below.
            const nodes = G.getNodes().filter(id => !good.has(id));
            let madeProgress;
            do {
                madeProgress = false;
                // find one extension which has only good deps
                for (let i = 0; i < nodes.length; i++) {
                    const id = nodes[i];
                    if (G.hasOnlyGoodArcs(id, good)) {
                        nodes.splice(i, 1);
                        i--;
                        good.add(id);
                        madeProgress = true;
                    }
                }
            } while (madeProgress);
            // The remaining nodes are bad and have loops
            return nodes.map(id => descs.get(id));
        }
        containsActivationEvent(activationEvent) {
            return this.h.has(activationEvent);
        }
        containsExtension(extensionId) {
            return this.f.has(extensionId);
        }
        getExtensionDescriptionsForActivationEvent(activationEvent) {
            const extensions = this.h.get(activationEvent);
            return extensions ? extensions.slice(0) : [];
        }
        getAllExtensionDescriptions() {
            return this.g.slice(0);
        }
        getSnapshot() {
            return new $Ndc(this.d, this.getAllExtensionDescriptions());
        }
        getExtensionDescription(extensionId) {
            const extension = this.f.get(extensionId);
            return extension ? extension : undefined;
        }
        getExtensionDescriptionByUUID(uuid) {
            for (const extensionDescription of this.g) {
                if (extensionDescription.uuid === uuid) {
                    return extensionDescription;
                }
            }
            return undefined;
        }
        getExtensionDescriptionByIdOrUUID(extensionId, uuid) {
            return (this.getExtensionDescription(extensionId)
                ?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined));
        }
    }
    exports.$Mdc = $Mdc;
    class $Ndc {
        constructor(versionId, extensions) {
            this.versionId = versionId;
            this.extensions = extensions;
        }
    }
    exports.$Ndc = $Ndc;
    class $Odc {
        constructor(activationEventsReader) {
            this.d = new Lock();
            this.c = new $Mdc(activationEventsReader, []);
        }
        async acquireLock(customerName) {
            const lock = await this.d.acquire(customerName);
            return new $Pdc(this, lock);
        }
        deltaExtensions(acquiredLock, toAdd, toRemove) {
            if (!acquiredLock.isAcquiredFor(this)) {
                throw new Error('Lock is not held');
            }
            return this.c.deltaExtensions(toAdd, toRemove);
        }
        containsActivationEvent(activationEvent) {
            return this.c.containsActivationEvent(activationEvent);
        }
        containsExtension(extensionId) {
            return this.c.containsExtension(extensionId);
        }
        getExtensionDescriptionsForActivationEvent(activationEvent) {
            return this.c.getExtensionDescriptionsForActivationEvent(activationEvent);
        }
        getAllExtensionDescriptions() {
            return this.c.getAllExtensionDescriptions();
        }
        getSnapshot() {
            return this.c.getSnapshot();
        }
        getExtensionDescription(extensionId) {
            return this.c.getExtensionDescription(extensionId);
        }
        getExtensionDescriptionByUUID(uuid) {
            return this.c.getExtensionDescriptionByUUID(uuid);
        }
        getExtensionDescriptionByIdOrUUID(extensionId, uuid) {
            return this.c.getExtensionDescriptionByIdOrUUID(extensionId, uuid);
        }
    }
    exports.$Odc = $Odc;
    class $Pdc extends lifecycle_1.$Uc {
        constructor(f, lock) {
            super();
            this.f = f;
            this.c = false;
            this.B(lock);
        }
        isAcquiredFor(registry) {
            return !this.c && this.f === registry;
        }
    }
    exports.$Pdc = $Pdc;
    class LockCustomer {
        constructor(name) {
            this.name = name;
            const withResolvers = (0, async_1.$yh)();
            this.promise = withResolvers.promise;
            this.c = withResolvers.resolve;
        }
        resolve(value) {
            this.c(value);
        }
    }
    class Lock {
        constructor() {
            this.c = [];
            this.d = false;
        }
        async acquire(customerName) {
            const customer = new LockCustomer(customerName);
            this.c.push(customer);
            this.e();
            return customer.promise;
        }
        e() {
            if (this.d) {
                // cannot advance yet
                return;
            }
            if (this.c.length === 0) {
                // no more waiting customers
                return;
            }
            const customer = this.c.shift();
            this.d = true;
            let customerHoldsLock = true;
            const logLongRunningCustomerTimeout = setTimeout(() => {
                if (customerHoldsLock) {
                    console.warn(`The customer named ${customer.name} has been holding on to the lock for 30s. This might be a problem.`);
                }
            }, 30 * 1000 /* 30 seconds */);
            const releaseLock = () => {
                if (!customerHoldsLock) {
                    return;
                }
                clearTimeout(logLongRunningCustomerTimeout);
                customerHoldsLock = false;
                this.d = false;
                this.e();
            };
            customer.resolve((0, lifecycle_1.$Sc)(releaseLock));
        }
    }
    var SortBucket;
    (function (SortBucket) {
        SortBucket[SortBucket["Builtin"] = 0] = "Builtin";
        SortBucket[SortBucket["User"] = 1] = "User";
        SortBucket[SortBucket["Dev"] = 2] = "Dev";
    })(SortBucket || (SortBucket = {}));
    /**
     * Ensure that:
     * - first are builtin extensions
     * - second are user extensions
     * - third are extensions under development
     *
     * In each bucket, extensions must be sorted alphabetically by their folder name.
     */
    function extensionCmp(a, b) {
        const aSortBucket = (a.isBuiltin ? SortBucket.Builtin : a.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);
        const bSortBucket = (b.isBuiltin ? SortBucket.Builtin : b.isUnderDevelopment ? SortBucket.Dev : SortBucket.User);
        if (aSortBucket !== bSortBucket) {
            return aSortBucket - bSortBucket;
        }
        const aLastSegment = path.$gc.basename(a.extensionLocation.path);
        const bLastSegment = path.$gc.basename(b.extensionLocation.path);
        if (aLastSegment < bLastSegment) {
            return -1;
        }
        if (aLastSegment > bLastSegment) {
            return 1;
        }
        return 0;
    }
    function removeExtensions(arr, toRemove) {
        const toRemoveSet = new extensions_1.$sn(toRemove);
        return arr.filter(extension => !toRemoveSet.has(extension.identifier));
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[83/*vs/workbench/services/extensions/common/extensionHostProtocol*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/]), function (require, exports, buffer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NativeLogMarkers = exports.MessageType = exports.ExtensionHostExitCode = exports.UIKind = void 0;
    exports.$Bn = $Bn;
    exports.$Cn = $Cn;
    var UIKind;
    (function (UIKind) {
        UIKind[UIKind["Desktop"] = 1] = "Desktop";
        UIKind[UIKind["Web"] = 2] = "Web";
    })(UIKind || (exports.UIKind = UIKind = {}));
    var ExtensionHostExitCode;
    (function (ExtensionHostExitCode) {
        // nodejs uses codes 1-13 and exit codes >128 are signal exits
        ExtensionHostExitCode[ExtensionHostExitCode["VersionMismatch"] = 55] = "VersionMismatch";
        ExtensionHostExitCode[ExtensionHostExitCode["UnexpectedError"] = 81] = "UnexpectedError";
    })(ExtensionHostExitCode || (exports.ExtensionHostExitCode = ExtensionHostExitCode = {}));
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["Initialized"] = 0] = "Initialized";
        MessageType[MessageType["Ready"] = 1] = "Ready";
        MessageType[MessageType["Terminate"] = 2] = "Terminate";
    })(MessageType || (exports.MessageType = MessageType = {}));
    function $Bn(type) {
        const result = buffer_1.$Ne.alloc(1);
        switch (type) {
            case MessageType.Initialized:
                result.writeUInt8(1, 0);
                break;
            case MessageType.Ready:
                result.writeUInt8(2, 0);
                break;
            case MessageType.Terminate:
                result.writeUInt8(3, 0);
                break;
        }
        return result;
    }
    function $Cn(message, type) {
        if (message.byteLength !== 1) {
            return false;
        }
        switch (message.readUInt8(0)) {
            case 1: return type === MessageType.Initialized;
            case 2: return type === MessageType.Ready;
            case 3: return type === MessageType.Terminate;
            default: return false;
        }
    }
    var NativeLogMarkers;
    (function (NativeLogMarkers) {
        NativeLogMarkers["Start"] = "START_NATIVE_LOG";
        NativeLogMarkers["End"] = "END_NATIVE_LOG";
    })(NativeLogMarkers || (exports.NativeLogMarkers = NativeLogMarkers = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[66/*vs/workbench/api/common/extHostTelemetry*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,6/*vs/base/common/event*/,112/*vs/platform/telemetry/common/telemetry*/,11/*vs/platform/log/common/log*/,26/*vs/workbench/api/common/extHostInitDataService*/,83/*vs/workbench/services/extensions/common/extensionHostProtocol*/,62/*vs/platform/remote/common/remoteHosts*/,63/*vs/platform/telemetry/common/telemetryUtils*/,25/*vs/base/common/objects*/,2/*vs/base/common/uri*/,4/*vs/base/common/lifecycle*/,9/*vs/nls*/]), function (require, exports, instantiation_1, event_1, telemetry_1, log_1, extHostInitDataService_1, extensionHostProtocol_1, remoteHosts_1, telemetryUtils_1, objects_1, uri_1, lifecycle_1, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$EQ = exports.$CQ = exports.$BQ = void 0;
    exports.$DQ = $DQ;
    let $BQ = class $BQ extends lifecycle_1.$Uc {
        constructor(s, t) {
            super();
            this.s = s;
            this.t = t;
            this.a = this.B(new event_1.$le());
            this.onDidChangeTelemetryEnabled = this.a.event;
            this.b = this.B(new event_1.$le());
            this.onDidChangeTelemetryConfiguration = this.b.event;
            this.c = { usage: true, error: true };
            this.f = telemetry_1.TelemetryLevel.NONE;
            // This holds whether or not we're running with --disable-telemetry, etc. Usings supportsTelemtry() from the main thread
            this.g = false;
            this.j = false;
            this.r = new Map();
            this.m = uri_1.URI.revive(this.s.environment.extensionTelemetryLogResource);
            this.j = this.s.environment.isExtensionTelemetryLoggingOnly;
            this.n = t.createLogger(this.m, { id: telemetryUtils_1.$Cp, name: (0, nls_1.localize)(11251, null, this.j ? ' (Not Sent)' : ''), hidden: true });
            this.B(this.n);
            this.B(t.onDidChangeLogLevel(arg => {
                if ((0, log_1.$ck)(arg)) {
                    this.u();
                }
            }));
            this.n.info('Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace.');
            this.n.info('===========================================================');
        }
        u() {
            this.t.setVisibility(this.m, this.g && this.t.getLogLevel() === log_1.LogLevel.Trace);
        }
        getTelemetryConfiguration() {
            return this.f === telemetry_1.TelemetryLevel.USAGE;
        }
        getTelemetryDetails() {
            return {
                isCrashEnabled: this.f >= telemetry_1.TelemetryLevel.CRASH,
                isErrorsEnabled: this.c.error ? this.f >= telemetry_1.TelemetryLevel.ERROR : false,
                isUsageEnabled: this.c.usage ? this.f >= telemetry_1.TelemetryLevel.USAGE : false
            };
        }
        instantiateLogger(extension, sender, options) {
            const telemetryDetails = this.getTelemetryDetails();
            const logger = new $CQ(sender, options, extension, this.n, this.j, this.getBuiltInCommonProperties(extension), { isUsageEnabled: telemetryDetails.isUsageEnabled, isErrorsEnabled: telemetryDetails.isErrorsEnabled });
            const loggers = this.r.get(extension.identifier.value) ?? [];
            this.r.set(extension.identifier.value, [...loggers, logger]);
            return logger.apiTelemetryLogger;
        }
        $initializeTelemetryLevel(level, supportsTelemetry, productConfig) {
            this.f = level;
            this.g = supportsTelemetry;
            this.c = productConfig ?? { usage: true, error: true };
            this.u();
        }
        getBuiltInCommonProperties(extension) {
            const commonProperties = Object.create(null);
            // TODO @lramos15, does os info like node arch, platform version, etc exist here.
            // Or will first party extensions just mix this in
            commonProperties['common.extname'] = `${extension.publisher}.${extension.name}`;
            commonProperties['common.extversion'] = extension.version;
            commonProperties['common.vscodemachineid'] = this.s.telemetryInfo.machineId;
            commonProperties['common.vscodesessionid'] = this.s.telemetryInfo.sessionId;
            commonProperties['common.sqmid'] = this.s.telemetryInfo.sqmId;
            commonProperties['common.devDeviceId'] = this.s.telemetryInfo.devDeviceId;
            commonProperties['common.vscodeversion'] = this.s.version;
            commonProperties['common.isnewappinstall'] = $DQ(this.s.telemetryInfo.firstSessionDate);
            commonProperties['common.product'] = this.s.environment.appHost;
            switch (this.s.uiKind) {
                case extensionHostProtocol_1.UIKind.Web:
                    commonProperties['common.uikind'] = 'web';
                    break;
                case extensionHostProtocol_1.UIKind.Desktop:
                    commonProperties['common.uikind'] = 'desktop';
                    break;
                default:
                    commonProperties['common.uikind'] = 'unknown';
            }
            commonProperties['common.remotename'] = (0, remoteHosts_1.$in)((0, telemetryUtils_1.$Ip)(this.s.remote.authority));
            return commonProperties;
        }
        $onDidChangeTelemetryLevel(level) {
            this.h = this.getTelemetryConfiguration();
            this.f = level;
            const telemetryDetails = this.getTelemetryDetails();
            // Remove all disposed loggers
            this.r.forEach((loggers, key) => {
                const newLoggers = loggers.filter(l => !l.isDisposed);
                if (newLoggers.length === 0) {
                    this.r.delete(key);
                }
                else {
                    this.r.set(key, newLoggers);
                }
            });
            // Loop through all loggers and update their level
            this.r.forEach(loggers => {
                for (const logger of loggers) {
                    logger.updateTelemetryEnablements(telemetryDetails.isUsageEnabled, telemetryDetails.isErrorsEnabled);
                }
            });
            if (this.h !== this.getTelemetryConfiguration()) {
                this.a.fire(this.getTelemetryConfiguration());
            }
            this.b.fire(this.getTelemetryDetails());
            this.u();
        }
        onExtensionError(extension, error) {
            const loggers = this.r.get(extension.value);
            const nonDisposedLoggers = loggers?.filter(l => !l.isDisposed);
            if (!nonDisposedLoggers) {
                this.r.delete(extension.value);
                return false;
            }
            let errorEmitted = false;
            for (const logger of nonDisposedLoggers) {
                if (logger.ignoreUnhandledExtHostErrors) {
                    continue;
                }
                logger.logError(error);
                errorEmitted = true;
            }
            return errorEmitted;
        }
    };
    exports.$BQ = $BQ;
    exports.$BQ = $BQ = __decorate([
        __param(0, extHostInitDataService_1.$AQ),
        __param(1, log_1.$bk)
    ], $BQ);
    class $CQ {
        static validateSender(sender) {
            if (typeof sender !== 'object') {
                throw new TypeError('TelemetrySender argument is invalid');
            }
            if (typeof sender.sendEventData !== 'function') {
                throw new TypeError('TelemetrySender.sendEventData must be a function');
            }
            if (typeof sender.sendErrorData !== 'function') {
                throw new TypeError('TelemetrySender.sendErrorData must be a function');
            }
            if (typeof sender.flush !== 'undefined' && typeof sender.flush !== 'function') {
                throw new TypeError('TelemetrySender.flush must be a function or undefined');
            }
        }
        constructor(sender, options, g, h, i, j, telemetryEnablements) {
            this.g = g;
            this.h = h;
            this.i = i;
            this.j = j;
            this.a = new event_1.$le();
            this.ignoreUnhandledExtHostErrors = options?.ignoreUnhandledErrors ?? false;
            this.b = options?.ignoreBuiltInCommonProperties ?? false;
            this.c = options?.additionalCommonProperties;
            this.f = sender;
            this.d = { isUsageEnabled: telemetryEnablements.isUsageEnabled, isErrorsEnabled: telemetryEnablements.isErrorsEnabled };
        }
        updateTelemetryEnablements(isUsageEnabled, isErrorsEnabled) {
            if (this.e) {
                this.d = { isUsageEnabled, isErrorsEnabled };
                this.a.fire(this.e);
            }
        }
        mixInCommonPropsAndCleanData(data) {
            // Some telemetry modules prefer to break properties and measurmements up
            // We mix common properties into the properties tab.
            let updatedData = 'properties' in data ? (data.properties ?? {}) : data;
            // We don't clean measurements since they are just numbers
            updatedData = (0, telemetryUtils_1.$Lp)(updatedData, []);
            if (this.c) {
                updatedData = (0, objects_1.$ho)(updatedData, this.c);
            }
            if (!this.b) {
                updatedData = (0, objects_1.$ho)(updatedData, this.j);
            }
            if ('properties' in data) {
                data.properties = updatedData;
            }
            else {
                data = updatedData;
            }
            return data;
        }
        k(eventName, data) {
            // No sender means likely disposed of, we should no-op
            if (!this.f) {
                return;
            }
            // If it's a built-in extension (vscode publisher) we don't prefix the publisher and only the ext name
            if (this.g.publisher === 'vscode') {
                eventName = this.g.name + '/' + eventName;
            }
            else {
                eventName = this.g.identifier.value + '/' + eventName;
            }
            data = this.mixInCommonPropsAndCleanData(data || {});
            if (!this.i) {
                this.f?.sendEventData(eventName, data);
            }
            this.h.trace(eventName, data);
        }
        logUsage(eventName, data) {
            if (!this.d.isUsageEnabled) {
                return;
            }
            this.k(eventName, data);
        }
        logError(eventNameOrException, data) {
            if (!this.d.isErrorsEnabled || !this.f) {
                return;
            }
            if (typeof eventNameOrException === 'string') {
                this.k(eventNameOrException, data);
            }
            else {
                const errorData = {
                    name: eventNameOrException.name,
                    message: eventNameOrException.message,
                    stack: eventNameOrException.stack,
                    cause: eventNameOrException.cause
                };
                const cleanedErrorData = (0, telemetryUtils_1.$Lp)(errorData, []);
                // Reconstruct the error object with the cleaned data
                const cleanedError = new Error(cleanedErrorData.message, {
                    cause: cleanedErrorData.cause
                });
                cleanedError.stack = cleanedErrorData.stack;
                cleanedError.name = cleanedErrorData.name;
                data = this.mixInCommonPropsAndCleanData(data || {});
                if (!this.i) {
                    this.f.sendErrorData(cleanedError, data);
                }
                this.h.trace('exception', data);
            }
        }
        get apiTelemetryLogger() {
            if (!this.e) {
                const that = this;
                const obj = {
                    logUsage: that.logUsage.bind(that),
                    get isUsageEnabled() {
                        return that.d.isUsageEnabled;
                    },
                    get isErrorsEnabled() {
                        return that.d.isErrorsEnabled;
                    },
                    logError: that.logError.bind(that),
                    dispose: that.dispose.bind(that),
                    onDidChangeEnableStates: that.a.event.bind(that)
                };
                this.e = Object.freeze(obj);
            }
            return this.e;
        }
        get isDisposed() {
            return !this.f;
        }
        dispose() {
            if (this.f?.flush) {
                let tempSender = this.f;
                this.f = undefined;
                Promise.resolve(tempSender.flush()).then(tempSender = undefined);
                this.e = undefined;
            }
            else {
                this.f = undefined;
            }
        }
    }
    exports.$CQ = $CQ;
    function $DQ(firstSessionDate) {
        const installAge = Date.now() - new Date(firstSessionDate).getTime();
        return isNaN(installAge) ? false : installAge < 1000 * 60 * 60 * 24; // install age is less than a day
    }
    exports.$EQ = (0, instantiation_1.$Fi)('IExtHostTelemetry');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[24/*vs/workbench/services/extensions/common/extensions*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,2/*vs/base/common/uri*/,178/*vs/platform/extensionManagement/common/extensionManagementUtil*/,111/*vs/platform/extensionManagement/common/implicitActivationEvents*/,18/*vs/platform/extensions/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, event_1, uri_1, extensionManagementUtil_1, implicitActivationEvents_1, extensions_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$lH = exports.ActivationKind = exports.$iH = exports.$hH = exports.$eH = exports.ExtensionHostStartup = exports.$dH = exports.$cH = exports.$bH = exports.$aH = void 0;
    exports.$fH = $fH;
    exports.$gH = $gH;
    exports.$jH = $jH;
    exports.$kH = $kH;
    exports.$aH = Object.freeze({
        identifier: new extensions_1.$rn('nullExtensionDescription'),
        name: 'Null Extension Description',
        version: '0.0.0',
        publisher: 'vscode',
        engines: { vscode: '' },
        extensionLocation: uri_1.URI.parse('void:location'),
        isBuiltin: false,
        targetPlatform: extensions_1.TargetPlatform.UNDEFINED,
        isUserBuiltin: false,
        isUnderDevelopment: false
    });
    exports.$bH = 'extensions.webWorker';
    exports.$cH = (0, instantiation_1.$Fi)('extensionService');
    class $dH {
        constructor(dependency) {
            this.dependency = dependency;
        }
    }
    exports.$dH = $dH;
    var ExtensionHostStartup;
    (function (ExtensionHostStartup) {
        /**
         * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.
         */
        ExtensionHostStartup[ExtensionHostStartup["EagerAutoStart"] = 1] = "EagerAutoStart";
        /**
         * The extension host should be launched immediately and needs a `$startExtensionHost` call.
         */
        ExtensionHostStartup[ExtensionHostStartup["EagerManualStart"] = 2] = "EagerManualStart";
        /**
         * The extension host should be launched lazily and only when it has extensions it needs to host. It needs a `$startExtensionHost` call.
         */
        ExtensionHostStartup[ExtensionHostStartup["Lazy"] = 3] = "Lazy";
    })(ExtensionHostStartup || (exports.ExtensionHostStartup = ExtensionHostStartup = {}));
    class $eH {
        get versionId() {
            return this.c;
        }
        get allExtensions() {
            return this.d;
        }
        get myExtensions() {
            return this.e;
        }
        constructor(versionId, allExtensions, myExtensions) {
            this.c = versionId;
            this.d = allExtensions.slice(0);
            this.e = myExtensions.slice(0);
            this.f = null;
        }
        toSnapshot() {
            return {
                versionId: this.c,
                allExtensions: this.d,
                myExtensions: this.e,
                activationEvents: implicitActivationEvents_1.$YG.createActivationEventsMap(this.d)
            };
        }
        set(versionId, allExtensions, myExtensions) {
            if (this.c > versionId) {
                throw new Error(`ExtensionHostExtensions: invalid versionId ${versionId} (current: ${this.c})`);
            }
            const toRemove = [];
            const toAdd = [];
            const myToRemove = [];
            const myToAdd = [];
            const oldExtensionsMap = extensionDescriptionArrayToMap(this.d);
            const newExtensionsMap = extensionDescriptionArrayToMap(allExtensions);
            const extensionsAreTheSame = (a, b) => {
                return ((a.extensionLocation.toString() === b.extensionLocation.toString())
                    || (a.isBuiltin === b.isBuiltin)
                    || (a.isUserBuiltin === b.isUserBuiltin)
                    || (a.isUnderDevelopment === b.isUnderDevelopment));
            };
            for (const oldExtension of this.d) {
                const newExtension = newExtensionsMap.get(oldExtension.identifier);
                if (!newExtension) {
                    toRemove.push(oldExtension.identifier);
                    oldExtensionsMap.delete(oldExtension.identifier);
                    continue;
                }
                if (!extensionsAreTheSame(oldExtension, newExtension)) {
                    // The new extension is different than the old one
                    // (e.g. maybe it executes in a different location)
                    toRemove.push(oldExtension.identifier);
                    oldExtensionsMap.delete(oldExtension.identifier);
                    continue;
                }
            }
            for (const newExtension of allExtensions) {
                const oldExtension = oldExtensionsMap.get(newExtension.identifier);
                if (!oldExtension) {
                    toAdd.push(newExtension);
                    continue;
                }
                if (!extensionsAreTheSame(oldExtension, newExtension)) {
                    // The new extension is different than the old one
                    // (e.g. maybe it executes in a different location)
                    toRemove.push(oldExtension.identifier);
                    oldExtensionsMap.delete(oldExtension.identifier);
                    continue;
                }
            }
            const myOldExtensionsSet = new extensions_1.$sn(this.e);
            const myNewExtensionsSet = new extensions_1.$sn(myExtensions);
            for (const oldExtensionId of this.e) {
                if (!myNewExtensionsSet.has(oldExtensionId)) {
                    myToRemove.push(oldExtensionId);
                }
            }
            for (const newExtensionId of myExtensions) {
                if (!myOldExtensionsSet.has(newExtensionId)) {
                    myToAdd.push(newExtensionId);
                }
            }
            const addActivationEvents = implicitActivationEvents_1.$YG.createActivationEventsMap(toAdd);
            const delta = { versionId, toRemove, toAdd, addActivationEvents, myToRemove, myToAdd };
            this.delta(delta);
            return delta;
        }
        delta(extensionsDelta) {
            if (this.c >= extensionsDelta.versionId) {
                // ignore older deltas
                return null;
            }
            const { toRemove, toAdd, myToRemove, myToAdd } = extensionsDelta;
            // First handle removals
            const toRemoveSet = new extensions_1.$sn(toRemove);
            const myToRemoveSet = new extensions_1.$sn(myToRemove);
            for (let i = 0; i < this.d.length; i++) {
                if (toRemoveSet.has(this.d[i].identifier)) {
                    this.d.splice(i, 1);
                    i--;
                }
            }
            for (let i = 0; i < this.e.length; i++) {
                if (myToRemoveSet.has(this.e[i])) {
                    this.e.splice(i, 1);
                    i--;
                }
            }
            // Then handle additions
            for (const extension of toAdd) {
                this.d.push(extension);
            }
            for (const extensionId of myToAdd) {
                this.e.push(extensionId);
            }
            // clear cached activation events
            this.f = null;
            return extensionsDelta;
        }
        containsExtension(extensionId) {
            for (const myExtensionId of this.e) {
                if (extensions_1.$rn.equals(myExtensionId, extensionId)) {
                    return true;
                }
            }
            return false;
        }
        containsActivationEvent(activationEvent) {
            if (!this.f) {
                this.f = this.g();
            }
            return this.f.has(activationEvent);
        }
        g() {
            const result = new Set();
            for (const extensionDescription of this.d) {
                if (!this.containsExtension(extensionDescription.identifier)) {
                    continue;
                }
                const activationEvents = implicitActivationEvents_1.$YG.readActivationEvents(extensionDescription);
                for (const activationEvent of activationEvents) {
                    result.add(activationEvent);
                }
            }
            return result;
        }
    }
    exports.$eH = $eH;
    function extensionDescriptionArrayToMap(extensions) {
        const result = new extensions_1.$tn();
        for (const extension of extensions) {
            result.set(extension.identifier, extension);
        }
        return result;
    }
    function $fH(extension, proposal) {
        if (!extension.enabledApiProposals) {
            return false;
        }
        return extension.enabledApiProposals.includes(proposal);
    }
    function $gH(extension, proposal) {
        if (!$fH(extension, proposal)) {
            throw new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
        }
    }
    class $hH {
        constructor(codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
            this.activationReason = activationReason;
        }
    }
    exports.$hH = $hH;
    class $iH {
        constructor(description, value) {
            this.description = description;
            this.value = value;
        }
    }
    exports.$iH = $iH;
    var ActivationKind;
    (function (ActivationKind) {
        ActivationKind[ActivationKind["Normal"] = 0] = "Normal";
        ActivationKind[ActivationKind["Immediate"] = 1] = "Immediate";
    })(ActivationKind || (exports.ActivationKind = ActivationKind = {}));
    function $jH(extensionDescription) {
        return {
            type: extensionDescription.isBuiltin ? extensions_1.ExtensionType.System : extensions_1.ExtensionType.User,
            isBuiltin: extensionDescription.isBuiltin || extensionDescription.isUserBuiltin,
            identifier: { id: (0, extensionManagementUtil_1.$Rp)(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },
            manifest: extensionDescription,
            location: extensionDescription.extensionLocation,
            targetPlatform: extensionDescription.targetPlatform,
            validations: [],
            isValid: true
        };
    }
    function $kH(extension, isUnderDevelopment) {
        const id = (0, extensionManagementUtil_1.$Pp)(extension.manifest.publisher, extension.manifest.name);
        return {
            id,
            identifier: new extensions_1.$rn(id),
            isBuiltin: extension.type === extensions_1.ExtensionType.System,
            isUserBuiltin: extension.type === extensions_1.ExtensionType.User && extension.isBuiltin,
            isUnderDevelopment: !!isUnderDevelopment,
            extensionLocation: extension.location,
            uuid: extension.identifier.uuid,
            targetPlatform: extension.targetPlatform,
            publisherDisplayName: extension.publisherDisplayName,
            ...extension.manifest
        };
    }
    class $lH {
        constructor() {
            this.onDidRegisterExtensions = event_1.Event.None;
            this.onDidChangeExtensionsStatus = event_1.Event.None;
            this.onDidChangeExtensions = event_1.Event.None;
            this.onWillActivateByEvent = event_1.Event.None;
            this.onDidChangeResponsiveChange = event_1.Event.None;
            this.onWillStop = event_1.Event.None;
            this.extensions = [];
        }
        activateByEvent(_activationEvent) { return Promise.resolve(undefined); }
        activateById(extensionId, reason) { return Promise.resolve(undefined); }
        activationEventIsDone(_activationEvent) { return false; }
        whenInstalledExtensionsRegistered() { return Promise.resolve(true); }
        getExtension() { return Promise.resolve(undefined); }
        readExtensionPointContributions(_extPoint) { return Promise.resolve(Object.create(null)); }
        getExtensionsStatus() { return Object.create(null); }
        getInspectPorts(_extensionHostKind, _tryEnableInspector) { return Promise.resolve([]); }
        stopExtensionHosts() { }
        async startExtensionHosts() { }
        async setRemoteEnvironment(_env) { }
        canAddExtension() { return false; }
        canRemoveExtension() { return false; }
    }
    exports.$lH = $lH;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[206/*vs/workbench/api/common/extHostExtensionActivator*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,4/*vs/base/common/lifecycle*/,119/*vs/workbench/services/extensions/common/extensionDescriptionRegistry*/,18/*vs/platform/extensions/common/extensions*/,24/*vs/workbench/services/extensions/common/extensions*/,11/*vs/platform/log/common/log*/,10/*vs/base/common/async*/]), function (require, exports, errors, lifecycle_1, extensionDescriptionRegistry_1, extensions_1, extensions_2, log_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$0pc = exports.$9pc = exports.$8pc = exports.$7pc = exports.$6pc = exports.$5pc = void 0;
    errors = __importStar(errors);
    class $5pc {
        static { this.NONE = new $5pc(false, -1, -1, -1); }
        constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
        }
    }
    exports.$5pc = $5pc;
    class $6pc {
        constructor(startup) {
            this.a = startup;
            this.b = -1;
            this.c = -1;
            this.d = -1;
            this.f = -1;
            this.g = -1;
            this.h = -1;
        }
        j(start, stop) {
            if (start === -1 || stop === -1) {
                return -1;
            }
            return stop - start;
        }
        build() {
            return new $5pc(this.a, this.j(this.b, this.c), this.j(this.d, this.f), this.j(this.g, this.h));
        }
        codeLoadingStart() {
            this.b = Date.now();
        }
        codeLoadingStop() {
            this.c = Date.now();
        }
        activateCallStart() {
            this.d = Date.now();
        }
        activateCallStop() {
            this.f = Date.now();
        }
        activateResolveStart() {
            this.g = Date.now();
        }
        activateResolveStop() {
            this.h = Date.now();
        }
    }
    exports.$6pc = $6pc;
    class $7pc {
        constructor(activationFailed, activationFailedError, activationTimes, module, exports, disposable) {
            this.activationFailed = activationFailed;
            this.activationFailedError = activationFailedError;
            this.activationTimes = activationTimes;
            this.module = module;
            this.exports = exports;
            this.disposable = disposable;
        }
    }
    exports.$7pc = $7pc;
    class $8pc extends $7pc {
        constructor(activationTimes) {
            super(false, null, activationTimes, { activate: undefined, deactivate: undefined }, undefined, lifecycle_1.$Uc.None);
        }
    }
    exports.$8pc = $8pc;
    class $9pc extends $7pc {
        constructor() {
            super(false, null, $5pc.NONE, { activate: undefined, deactivate: undefined }, undefined, lifecycle_1.$Uc.None);
        }
    }
    exports.$9pc = $9pc;
    class FailedExtension extends $7pc {
        constructor(activationError) {
            super(true, activationError, $5pc.NONE, { activate: undefined, deactivate: undefined }, undefined, lifecycle_1.$Uc.None);
        }
    }
    let $0pc = class $0pc {
        constructor(registry, globalRegistry, host, g) {
            this.g = g;
            this.a = registry;
            this.b = globalRegistry;
            this.c = host;
            this.d = new extensions_1.$tn();
            this.f = Object.create(null);
        }
        dispose() {
            for (const [_, op] of this.d) {
                op.dispose();
            }
        }
        async waitForActivatingExtensions() {
            const res = [];
            for (const [_, op] of this.d) {
                res.push(op.wait());
            }
            await Promise.all(res);
        }
        isActivated(extensionId) {
            const op = this.d.get(extensionId);
            return Boolean(op && op.value);
        }
        getActivatedExtension(extensionId) {
            const op = this.d.get(extensionId);
            if (!op || !op.value) {
                throw new Error(`Extension '${extensionId.value}' is not known or not activated`);
            }
            return op.value;
        }
        async activateByEvent(activationEvent, startup) {
            if (this.f[activationEvent]) {
                return;
            }
            const activateExtensions = this.a.getExtensionDescriptionsForActivationEvent(activationEvent);
            await this.h(activateExtensions.map(e => ({
                id: e.identifier,
                reason: { startup, extensionId: e.identifier, activationEvent }
            })));
            this.f[activationEvent] = true;
        }
        activateById(extensionId, reason) {
            const desc = this.a.getExtensionDescription(extensionId);
            if (!desc) {
                throw new Error(`Extension '${extensionId.value}' is not known`);
            }
            return this.h([{ id: desc.identifier, reason }]);
        }
        async h(extensions) {
            const operations = extensions
                .filter((p) => !this.isActivated(p.id))
                .map(ext => this.j(ext));
            await Promise.all(operations.map(op => op.wait()));
        }
        /**
         * Handle semantics related to dependencies for `currentExtension`.
         * We don't need to worry about dependency loops because they are handled by the registry.
         */
        j(currentActivation) {
            if (this.d.has(currentActivation.id)) {
                return this.d.get(currentActivation.id);
            }
            if (this.l(currentActivation.id)) {
                return this.k(currentActivation, null, [], null);
            }
            const currentExtension = this.a.getExtensionDescription(currentActivation.id);
            if (!currentExtension) {
                // Error condition 0: unknown extension
                const error = new Error(`Cannot activate unknown extension '${currentActivation.id.value}'`);
                const result = this.k(currentActivation, null, [], new FailedExtension(error));
                this.c.onExtensionActivationError(currentActivation.id, error, new extensions_2.$dH(currentActivation.id.value));
                return result;
            }
            const deps = [];
            const depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
            for (const depId of depIds) {
                if (this.m(depId)) {
                    // This dependency is already resolved
                    continue;
                }
                const dep = this.d.get(depId);
                if (dep) {
                    deps.push(dep);
                    continue;
                }
                if (this.l(depId)) {
                    // must first wait for the dependency to activate
                    deps.push(this.j({
                        id: this.b.getExtensionDescription(depId).identifier,
                        reason: currentActivation.reason
                    }));
                    continue;
                }
                const depDesc = this.a.getExtensionDescription(depId);
                if (depDesc) {
                    if (!depDesc.main && !depDesc.browser) {
                        // this dependency does not need to activate because it is descriptive only
                        continue;
                    }
                    // must first wait for the dependency to activate
                    deps.push(this.j({
                        id: depDesc.identifier,
                        reason: currentActivation.reason
                    }));
                    continue;
                }
                // Error condition 1: unknown dependency
                const currentExtensionFriendlyName = currentExtension.displayName || currentExtension.identifier.value;
                const error = new Error(`Cannot activate the '${currentExtensionFriendlyName}' extension because it depends on unknown extension '${depId}'`);
                const result = this.k(currentActivation, currentExtension.displayName, [], new FailedExtension(error));
                this.c.onExtensionActivationError(currentExtension.identifier, error, new extensions_2.$dH(depId));
                return result;
            }
            return this.k(currentActivation, currentExtension.displayName, deps, null);
        }
        k(activation, displayName, deps, value) {
            const operation = new ActivationOperation(activation.id, displayName, activation.reason, deps, value, this.c, this.g);
            this.d.set(activation.id, operation);
            return operation;
        }
        l(extensionId) {
            return extensionDescriptionRegistry_1.$Mdc.isHostExtension(extensionId, this.a, this.b);
        }
        m(extensionId) {
            const extensionDescription = this.b.getExtensionDescription(extensionId);
            if (!extensionDescription) {
                // unknown extension
                return false;
            }
            return (!extensionDescription.main && !extensionDescription.browser);
        }
    };
    exports.$0pc = $0pc;
    exports.$0pc = $0pc = __decorate([
        __param(3, log_1.$ak)
    ], $0pc);
    let ActivationOperation = class ActivationOperation {
        get value() {
            return this.h;
        }
        get friendlyName() {
            return this.d || this.c.value;
        }
        constructor(c, d, f, g, h, j, k) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.a = new async_1.$Eh();
            this.b = false;
            this.l();
        }
        dispose() {
            this.b = true;
        }
        wait() {
            return this.a.wait();
        }
        async l() {
            await this.m();
            this.a.open();
        }
        async m() {
            if (this.h) {
                // this operation is already finished
                return;
            }
            while (this.g.length > 0) {
                // remove completed deps
                for (let i = 0; i < this.g.length; i++) {
                    const dep = this.g[i];
                    if (dep.value && !dep.value.activationFailed) {
                        // the dependency is already activated OK
                        this.g.splice(i, 1);
                        i--;
                        continue;
                    }
                    if (dep.value && dep.value.activationFailed) {
                        // Error condition 2: a dependency has already failed activation
                        const error = new Error(`Cannot activate the '${this.friendlyName}' extension because its dependency '${dep.friendlyName}' failed to activate`);
                        error.detail = dep.value.activationFailedError;
                        this.h = new FailedExtension(error);
                        this.j.onExtensionActivationError(this.c, error, null);
                        return;
                    }
                }
                if (this.g.length > 0) {
                    // wait for one dependency
                    await Promise.race(this.g.map(dep => dep.wait()));
                }
            }
            await this.n();
        }
        async n() {
            try {
                this.h = await this.j.actualActivateExtension(this.c, this.f);
            }
            catch (err) {
                const error = new Error();
                if (err && err.name) {
                    error.name = err.name;
                }
                if (err && err.message) {
                    error.message = `Activating extension '${this.c.value}' failed: ${err.message}.`;
                }
                else {
                    error.message = `Activating extension '${this.c.value}' failed: ${err}.`;
                }
                if (err && err.stack) {
                    error.stack = err.stack;
                }
                // Treat the extension as being empty
                this.h = new FailedExtension(error);
                if (this.b && errors.$3(err)) {
                    // It is expected for ongoing activations to fail if the extension host is going down
                    // So simply ignore and don't log canceled errors in this case
                    return;
                }
                this.j.onExtensionActivationError(this.c, error, null);
                this.k.error(`Activating extension ${this.c.value} failed due to an error:`);
                this.k.error(err);
            }
        }
    };
    ActivationOperation = __decorate([
        __param(6, log_1.$ak)
    ], ActivationOperation);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[120/*vs/workbench/services/extensions/common/extensionsRegistry*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,13/*vs/base/common/errors*/,35/*vs/base/common/severity*/,110/*vs/platform/extensionManagement/common/extensionManagement*/,77/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,30/*vs/platform/registry/common/platform*/,18/*vs/platform/extensions/common/extensions*/,108/*vs/platform/product/common/productService*/,111/*vs/platform/extensionManagement/common/implicitActivationEvents*/,104/*vs/platform/extensions/common/extensionsApiProposals*/]), function (require, exports, nls, errors_1, severity_1, extensionManagement_1, jsonContributionRegistry_1, platform_1, extensions_1, productService_1, implicitActivationEvents_1, extensionsApiProposals_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$_G = exports.$$G = exports.$0G = exports.$9G = exports.$8G = exports.$7G = void 0;
    nls = __importStar(nls);
    severity_1 = __importDefault(severity_1);
    const schemaRegistry = platform_1.$ro.as(jsonContributionRegistry_1.$so.JSONContribution);
    class $7G {
        constructor(messageHandler, extension, extensionPointId) {
            this.a = messageHandler;
            this.b = extension;
            this.c = extensionPointId;
        }
        d(type, message) {
            this.a({
                type: type,
                message: message,
                extensionId: this.b.identifier,
                extensionPointId: this.c
            });
        }
        error(message) {
            this.d(severity_1.default.Error, message);
        }
        warn(message) {
            this.d(severity_1.default.Warning, message);
        }
        info(message) {
            this.d(severity_1.default.Info, message);
        }
    }
    exports.$7G = $7G;
    class $8G {
        static a(arr) {
            const result = new extensions_1.$sn();
            for (let i = 0, len = arr.length; i < len; i++) {
                result.add(arr[i].description.identifier);
            }
            return result;
        }
        static compute(previous, current) {
            if (!previous || !previous.length) {
                return new $8G(current, []);
            }
            if (!current || !current.length) {
                return new $8G([], previous);
            }
            const previousSet = this.a(previous);
            const currentSet = this.a(current);
            const added = current.filter(user => !previousSet.has(user.description.identifier));
            const removed = previous.filter(user => !currentSet.has(user.description.identifier));
            return new $8G(added, removed);
        }
        constructor(added, removed) {
            this.added = added;
            this.removed = removed;
        }
    }
    exports.$8G = $8G;
    class $9G {
        constructor(name, defaultExtensionKind) {
            this.name = name;
            this.defaultExtensionKind = defaultExtensionKind;
            this.a = null;
            this.b = null;
            this.c = null;
        }
        setHandler(handler) {
            if (this.a !== null) {
                throw new Error('Handler already set!');
            }
            this.a = handler;
            this.d();
            return {
                dispose: () => {
                    this.a = null;
                }
            };
        }
        acceptUsers(users) {
            this.c = $8G.compute(this.b, users);
            this.b = users;
            this.d();
        }
        d() {
            if (this.a === null || this.b === null || this.c === null) {
                return;
            }
            try {
                this.a(this.b, this.c);
            }
            catch (err) {
                (0, errors_1.$Y)(err);
            }
        }
    }
    exports.$9G = $9G;
    const extensionKindSchema = {
        type: 'string',
        enum: [
            'ui',
            'workspace'
        ],
        enumDescriptions: [
            nls.localize(2076, null),
            nls.localize(2077, null),
        ],
    };
    const schemaId = 'vscode://schemas/vscode-extensions';
    exports.$0G = {
        properties: {
            engines: {
                type: 'object',
                description: nls.localize(2078, null),
                properties: {
                    'vscode': {
                        type: 'string',
                        description: nls.localize(2079, null),
                        default: '^1.22.0',
                    }
                }
            },
            publisher: {
                description: nls.localize(2080, null),
                type: 'string'
            },
            displayName: {
                description: nls.localize(2081, null),
                type: 'string'
            },
            categories: {
                description: nls.localize(2082, null),
                type: 'array',
                uniqueItems: true,
                items: {
                    oneOf: [{
                            type: 'string',
                            enum: extensions_1.$qn,
                        },
                        {
                            type: 'string',
                            const: 'Languages',
                            deprecationMessage: nls.localize(2083, null),
                        }]
                }
            },
            galleryBanner: {
                type: 'object',
                description: nls.localize(2084, null),
                properties: {
                    color: {
                        description: nls.localize(2085, null),
                        type: 'string'
                    },
                    theme: {
                        description: nls.localize(2086, null),
                        type: 'string',
                        enum: ['dark', 'light']
                    }
                }
            },
            contributes: {
                description: nls.localize(2087, null),
                type: 'object',
                properties: {
                // extensions will fill in
                },
                default: {}
            },
            preview: {
                type: 'boolean',
                description: nls.localize(2088, null),
            },
            enableProposedApi: {
                type: 'boolean',
                deprecationMessage: nls.localize(2089, null),
            },
            enabledApiProposals: {
                markdownDescription: nls.localize(2090, null),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string',
                    enum: Object.keys(extensionsApiProposals_1.allApiProposals).map(proposalName => proposalName),
                    markdownEnumDescriptions: Object.values(extensionsApiProposals_1.allApiProposals).map(value => value.proposal)
                }
            },
            api: {
                markdownDescription: nls.localize(2091, null),
                type: 'string',
                enum: ['none'],
                enumDescriptions: [
                    nls.localize(2092, null)
                ]
            },
            activationEvents: {
                description: nls.localize(2093, null),
                type: 'array',
                items: {
                    type: 'string',
                    defaultSnippets: [
                        {
                            label: 'onWebviewPanel',
                            description: nls.localize(2094, null),
                            body: 'onWebviewPanel:viewType'
                        },
                        {
                            label: 'onLanguage',
                            description: nls.localize(2095, null),
                            body: 'onLanguage:${1:languageId}'
                        },
                        {
                            label: 'onCommand',
                            description: nls.localize(2096, null),
                            body: 'onCommand:${2:commandId}'
                        },
                        {
                            label: 'onDebug',
                            description: nls.localize(2097, null),
                            body: 'onDebug'
                        },
                        {
                            label: 'onDebugInitialConfigurations',
                            description: nls.localize(2098, null),
                            body: 'onDebugInitialConfigurations'
                        },
                        {
                            label: 'onDebugDynamicConfigurations',
                            description: nls.localize(2099, null),
                            body: 'onDebugDynamicConfigurations'
                        },
                        {
                            label: 'onDebugResolve',
                            description: nls.localize(2100, null),
                            body: 'onDebugResolve:${6:type}'
                        },
                        {
                            label: 'onDebugAdapterProtocolTracker',
                            description: nls.localize(2101, null),
                            body: 'onDebugAdapterProtocolTracker:${6:type}'
                        },
                        {
                            label: 'workspaceContains',
                            description: nls.localize(2102, null),
                            body: 'workspaceContains:${4:filePattern}'
                        },
                        {
                            label: 'onStartupFinished',
                            description: nls.localize(2103, null),
                            body: 'onStartupFinished'
                        },
                        {
                            label: 'onTaskType',
                            description: nls.localize(2104, null),
                            body: 'onTaskType:${1:taskType}'
                        },
                        {
                            label: 'onFileSystem',
                            description: nls.localize(2105, null),
                            body: 'onFileSystem:${1:scheme}'
                        },
                        {
                            label: 'onEditSession',
                            description: nls.localize(2106, null),
                            body: 'onEditSession:${1:scheme}'
                        },
                        {
                            label: 'onSearch',
                            description: nls.localize(2107, null),
                            body: 'onSearch:${7:scheme}'
                        },
                        {
                            label: 'onView',
                            body: 'onView:${5:viewId}',
                            description: nls.localize(2108, null),
                        },
                        {
                            label: 'onUri',
                            body: 'onUri',
                            description: nls.localize(2109, null),
                        },
                        {
                            label: 'onOpenExternalUri',
                            body: 'onOpenExternalUri',
                            description: nls.localize(2110, null),
                        },
                        {
                            label: 'onCustomEditor',
                            body: 'onCustomEditor:${9:viewType}',
                            description: nls.localize(2111, null),
                        },
                        {
                            label: 'onNotebook',
                            body: 'onNotebook:${1:type}',
                            description: nls.localize(2112, null),
                        },
                        {
                            label: 'onAuthenticationRequest',
                            body: 'onAuthenticationRequest:${11:authenticationProviderId}',
                            description: nls.localize(2113, null)
                        },
                        {
                            label: 'onRenderer',
                            description: nls.localize(2114, null),
                            body: 'onRenderer:${11:rendererId}'
                        },
                        {
                            label: 'onTerminalProfile',
                            body: 'onTerminalProfile:${1:terminalId}',
                            description: nls.localize(2115, null),
                        },
                        {
                            label: 'onTerminalQuickFixRequest',
                            body: 'onTerminalQuickFixRequest:${1:quickFixId}',
                            description: nls.localize(2116, null),
                        },
                        {
                            label: 'onWalkthrough',
                            body: 'onWalkthrough:${1:walkthroughID}',
                            description: nls.localize(2117, null),
                        },
                        {
                            label: 'onIssueReporterOpened',
                            body: 'onIssueReporterOpened',
                            description: nls.localize(2118, null),
                        },
                        {
                            label: 'onChatParticipant',
                            body: 'onChatParticipant:${1:participantId}',
                            description: nls.localize(2119, null),
                        },
                        {
                            label: 'onLanguageModelTool',
                            body: 'onLanguageModelTool:${1:toolName}',
                            description: nls.localize(2120, null),
                        },
                        {
                            label: '*',
                            description: nls.localize(2121, null),
                            body: '*'
                        }
                    ],
                }
            },
            badges: {
                type: 'array',
                description: nls.localize(2122, null),
                items: {
                    type: 'object',
                    required: ['url', 'href', 'description'],
                    properties: {
                        url: {
                            type: 'string',
                            description: nls.localize(2123, null)
                        },
                        href: {
                            type: 'string',
                            description: nls.localize(2124, null)
                        },
                        description: {
                            type: 'string',
                            description: nls.localize(2125, null)
                        }
                    }
                }
            },
            markdown: {
                type: 'string',
                description: nls.localize(2126, null),
                enum: ['github', 'standard'],
                default: 'github'
            },
            qna: {
                default: 'marketplace',
                description: nls.localize(2127, null),
                anyOf: [
                    {
                        type: ['string', 'boolean'],
                        enum: ['marketplace', false]
                    },
                    {
                        type: 'string'
                    }
                ]
            },
            extensionDependencies: {
                description: nls.localize(2128, null),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string',
                    pattern: extensionManagement_1.$$o
                }
            },
            extensionPack: {
                description: nls.localize(2129, null),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string',
                    pattern: extensionManagement_1.$$o
                }
            },
            extensionKind: {
                description: nls.localize(2130, null),
                type: 'array',
                items: extensionKindSchema,
                default: ['workspace'],
                defaultSnippets: [
                    {
                        body: ['ui'],
                        description: nls.localize(2131, null)
                    },
                    {
                        body: ['workspace'],
                        description: nls.localize(2132, null)
                    },
                    {
                        body: ['ui', 'workspace'],
                        description: nls.localize(2133, null)
                    },
                    {
                        body: ['workspace', 'ui'],
                        description: nls.localize(2134, null)
                    },
                    {
                        body: [],
                        description: nls.localize(2135, null)
                    }
                ]
            },
            capabilities: {
                description: nls.localize(2136, null),
                type: 'object',
                properties: {
                    virtualWorkspaces: {
                        description: nls.localize(2137, null),
                        type: ['boolean', 'object'],
                        defaultSnippets: [
                            { label: 'limited', body: { supported: '${1:limited}', description: '${2}' } },
                            { label: 'false', body: { supported: false, description: '${2}' } },
                        ],
                        default: true.valueOf,
                        properties: {
                            supported: {
                                markdownDescription: nls.localize(2138, null),
                                type: ['string', 'boolean'],
                                enum: ['limited', true, false],
                                enumDescriptions: [
                                    nls.localize(2139, null),
                                    nls.localize(2140, null),
                                    nls.localize(2141, null),
                                ]
                            },
                            description: {
                                type: 'string',
                                markdownDescription: nls.localize(2142, null),
                            }
                        }
                    },
                    untrustedWorkspaces: {
                        description: nls.localize(2143, null),
                        type: 'object',
                        required: ['supported'],
                        defaultSnippets: [
                            { body: { supported: '${1:limited}', description: '${2}' } },
                        ],
                        properties: {
                            supported: {
                                markdownDescription: nls.localize(2144, null),
                                type: ['string', 'boolean'],
                                enum: ['limited', true, false],
                                enumDescriptions: [
                                    nls.localize(2145, null),
                                    nls.localize(2146, null),
                                    nls.localize(2147, null),
                                ]
                            },
                            restrictedConfigurations: {
                                description: nls.localize(2148, null),
                                type: 'array',
                                items: {
                                    type: 'string'
                                }
                            },
                            description: {
                                type: 'string',
                                markdownDescription: nls.localize(2149, null),
                            }
                        }
                    }
                }
            },
            sponsor: {
                description: nls.localize(2150, null),
                type: 'object',
                defaultSnippets: [
                    { body: { url: '${1:https:}' } },
                ],
                properties: {
                    'url': {
                        description: nls.localize(2151, null),
                        type: 'string',
                    }
                }
            },
            scripts: {
                type: 'object',
                properties: {
                    'vscode:prepublish': {
                        description: nls.localize(2152, null),
                        type: 'string'
                    },
                    'vscode:uninstall': {
                        description: nls.localize(2153, null),
                        type: 'string'
                    }
                }
            },
            icon: {
                type: 'string',
                description: nls.localize(2154, null)
            },
            l10n: {
                type: 'string',
                description: nls.localize(2155, null)






            },
            pricing: {
                type: 'string',
                markdownDescription: nls.localize(2156, null),
                enum: ['Free', 'Trial'],
                default: 'Free'
            }
        }
    };
    class $$G {
        constructor() {
            this.a = new Map();
        }
        registerExtensionPoint(desc) {
            if (this.a.has(desc.extensionPoint)) {
                throw new Error('Duplicate extension point: ' + desc.extensionPoint);
            }
            const result = new $9G(desc.extensionPoint, desc.defaultExtensionKind);
            this.a.set(desc.extensionPoint, result);
            if (desc.activationEventsGenerator) {
                implicitActivationEvents_1.$YG.register(desc.extensionPoint, desc.activationEventsGenerator);
            }
            exports.$0G.properties['contributes'].properties[desc.extensionPoint] = desc.jsonSchema;
            schemaRegistry.registerSchema(schemaId, exports.$0G);
            return result;
        }
        getExtensionPoints() {
            return Array.from(this.a.values());
        }
    }
    exports.$$G = $$G;
    const PRExtensions = {
        ExtensionsRegistry: 'ExtensionsRegistry'
    };
    platform_1.$ro.add(PRExtensions.ExtensionsRegistry, new $$G());
    exports.$_G = platform_1.$ro.as(PRExtensions.ExtensionsRegistry);
    schemaRegistry.registerSchema(schemaId, exports.$0G);
    schemaRegistry.registerSchema(productService_1.$uk, {
        properties: {
            extensionEnabledApiProposals: {
                description: nls.localize(2157, null),
                type: 'object',
                properties: {},
                additionalProperties: {
                    anyOf: [{
                            type: 'array',
                            uniqueItems: true,
                            items: {
                                type: 'string',
                                enum: Object.keys(extensionsApiProposals_1.allApiProposals),
                                markdownEnumDescriptions: Object.values(extensionsApiProposals_1.allApiProposals).map(value => value.proposal)
                            }
                        }]
                }
            }
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[207/*vs/workbench/contrib/chat/common/languageModels*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,40/*vs/base/common/iterator*/,4/*vs/base/common/lifecycle*/,12/*vs/base/common/strings*/,9/*vs/nls*/,18/*vs/platform/extensions/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,24/*vs/workbench/services/extensions/common/extensions*/,120/*vs/workbench/services/extensions/common/extensionsRegistry*/]), function (require, exports, event_1, iterator_1, lifecycle_1, strings_1, nls_1, extensions_1, instantiation_1, log_1, extensions_2, extensionsRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oH = exports.$nH = exports.$mH = exports.ChatMessageRole = void 0;
    var ChatMessageRole;
    (function (ChatMessageRole) {
        ChatMessageRole[ChatMessageRole["System"] = 0] = "System";
        ChatMessageRole[ChatMessageRole["User"] = 1] = "User";
        ChatMessageRole[ChatMessageRole["Assistant"] = 2] = "Assistant";
    })(ChatMessageRole || (exports.ChatMessageRole = ChatMessageRole = {}));
    exports.$mH = (0, instantiation_1.$Fi)('ILanguageModelsService');
    const languageModelType = {
        type: 'object',
        properties: {
            vendor: {
                type: 'string',
                description: (0, nls_1.localize)(8654, null)
            }
        }
    };
    exports.$nH = extensionsRegistry_1.$_G.registerExtensionPoint({
        extensionPoint: 'languageModels',
        jsonSchema: {
            description: (0, nls_1.localize)(8655, null),
            oneOf: [
                languageModelType,
                {
                    type: 'array',
                    items: languageModelType
                }
            ]
        },
        activationEventsGenerator: (contribs, result) => {
            for (const contrib of contribs) {
                result.push(`onLanguageModelChat:${contrib.vendor}`);
            }
        }
    });
    let $oH = class $oH {
        constructor(e, f) {
            this.e = e;
            this.f = f;
            this.a = new lifecycle_1.$Tc();
            this.b = new Map();
            this.c = new Set();
            this.d = this.a.add(new event_1.$le());
            this.onDidChangeLanguageModels = this.d.event;
            this.a.add(exports.$nH.setHandler((extensions) => {
                this.c.clear();
                for (const extension of extensions) {
                    if (!(0, extensions_2.$fH)(extension.description, 'chatProvider')) {
                        extension.collector.error((0, nls_1.localize)(8656, null));
                        continue;
                    }
                    for (const item of iterator_1.Iterable.wrap(extension.value)) {
                        if (this.c.has(item.vendor)) {
                            extension.collector.error((0, nls_1.localize)(8657, null, item.vendor));
                            continue;
                        }
                        if ((0, strings_1.$cf)(item.vendor)) {
                            extension.collector.error((0, nls_1.localize)(8658, null));
                            continue;
                        }
                        if (item.vendor.trim() !== item.vendor) {
                            extension.collector.error((0, nls_1.localize)(8659, null));
                            continue;
                        }
                        this.c.add(item.vendor);
                    }
                }
                const removed = [];
                for (const [identifier, value] of this.b) {
                    if (!this.c.has(value.metadata.vendor)) {
                        this.b.delete(identifier);
                        removed.push(identifier);
                    }
                }
                if (removed.length > 0) {
                    this.d.fire({ removed });
                }
            }));
        }
        dispose() {
            this.a.dispose();
            this.b.clear();
        }
        getLanguageModelIds() {
            return Array.from(this.b.keys());
        }
        lookupLanguageModel(identifier) {
            return this.b.get(identifier)?.metadata;
        }
        async selectLanguageModels(selector) {
            if (selector.vendor) {
                // selective activation
                await this.e.activateByEvent(`onLanguageModelChat:${selector.vendor}}`);
            }
            else {
                // activate all extensions that do language models
                const all = Array.from(this.c).map(vendor => this.e.activateByEvent(`onLanguageModelChat:${vendor}`));
                await Promise.all(all);
            }
            const result = [];
            for (const [identifier, model] of this.b) {
                if ((selector.vendor === undefined || model.metadata.vendor === selector.vendor)
                    && (selector.family === undefined || model.metadata.family === selector.family)
                    && (selector.version === undefined || model.metadata.version === selector.version)
                    && (selector.identifier === undefined || model.metadata.id === selector.identifier)
                    && (!model.metadata.targetExtensions || model.metadata.targetExtensions.some(candidate => extensions_1.$rn.equals(candidate, selector.extension)))) {
                    result.push(identifier);
                }
            }
            this.f.trace('[LM] selected language models', selector, result);
            return result;
        }
        registerLanguageModelChat(identifier, provider) {
            this.f.trace('[LM] registering language model chat', identifier, provider.metadata);
            if (!this.c.has(provider.metadata.vendor)) {
                throw new Error(`Chat response provider uses UNKNOWN vendor ${provider.metadata.vendor}.`);
            }
            if (this.b.has(identifier)) {
                throw new Error(`Chat response provider with identifier ${identifier} is already registered.`);
            }
            this.b.set(identifier, provider);
            this.d.fire({ added: [{ identifier, metadata: provider.metadata }] });
            return (0, lifecycle_1.$Sc)(() => {
                if (this.b.delete(identifier)) {
                    this.d.fire({ removed: [identifier] });
                    this.f.trace('[LM] UNregistered language model chat', identifier, provider.metadata);
                }
            });
        }
        async sendChatRequest(identifier, from, messages, options, token) {
            const provider = this.b.get(identifier);
            if (!provider) {
                throw new Error(`Chat response provider with identifier ${identifier} is not registered.`);
            }
            return provider.sendChatRequest(messages, from, options, token);
        }
        computeTokenLength(identifier, message, token) {
            const provider = this.b.get(identifier);
            if (!provider) {
                throw new Error(`Chat response provider with identifier ${identifier} is not registered.`);
            }
            return provider.provideTokenCount(message, token);
        }
    };
    exports.$oH = $oH;
    exports.$oH = $oH = __decorate([
        __param(0, extensions_2.$cH),
        __param(1, log_1.$ak)
    ], $oH);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[208/*vs/workbench/contrib/tasks/common/taskDefinitionRegistry*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,14/*vs/base/common/types*/,25/*vs/base/common/objects*/,120/*vs/workbench/services/extensions/common/extensionsRegistry*/,31/*vs/platform/contextkey/common/contextkey*/,6/*vs/base/common/event*/]), function (require, exports, nls, Types, Objects, extensionsRegistry_1, contextkey_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$UI = void 0;
    nls = __importStar(nls);
    Types = __importStar(Types);
    Objects = __importStar(Objects);
    const taskDefinitionSchema = {
        type: 'object',
        additionalProperties: false,
        properties: {
            type: {
                type: 'string',
                description: nls.localize(4155, null)
            },
            required: {
                type: 'array',
                items: {
                    type: 'string'
                }
            },
            properties: {
                type: 'object',
                description: nls.localize(4156, null),
                additionalProperties: {
                    $ref: 'http://json-schema.org/draft-07/schema#'
                }
            },
            when: {
                type: 'string',
                markdownDescription: nls.localize(4157, null),
                default: ''
            }
        }
    };
    var Configuration;
    (function (Configuration) {
        function from(value, extensionId, messageCollector) {
            if (!value) {
                return undefined;
            }
            const taskType = Types.$eg(value.type) ? value.type : undefined;
            if (!taskType || taskType.length === 0) {
                messageCollector.error(nls.localize(4158, null));
                return undefined;
            }
            const required = [];
            if (Array.isArray(value.required)) {
                for (const element of value.required) {
                    if (Types.$eg(element)) {
                        required.push(element);
                    }
                }
            }
            return {
                extensionId: extensionId.value,
                taskType, required: required,
                properties: value.properties ? Objects.$eo(value.properties) : {},
                when: value.when ? contextkey_1.$Dj.deserialize(value.when) : undefined
            };
        }
        Configuration.from = from;
    })(Configuration || (Configuration = {}));
    const taskDefinitionsExtPoint = extensionsRegistry_1.$_G.registerExtensionPoint({
        extensionPoint: 'taskDefinitions',
        activationEventsGenerator: (contributions, result) => {
            for (const task of contributions) {
                if (task.type) {
                    result.push(`onTaskType:${task.type}`);
                }
            }
        },
        jsonSchema: {
            description: nls.localize(4159, null),
            type: 'array',
            items: taskDefinitionSchema
        }
    });
    class TaskDefinitionRegistryImpl {
        constructor() {
            this.d = new event_1.$le();
            this.onDefinitionsChanged = this.d.event;
            this.a = Object.create(null);
            this.b = new Promise((resolve, reject) => {
                taskDefinitionsExtPoint.setHandler((extensions, delta) => {
                    this.c = undefined;
                    try {
                        for (const extension of delta.removed) {
                            const taskTypes = extension.value;
                            for (const taskType of taskTypes) {
                                if (this.a && taskType.type && this.a[taskType.type]) {
                                    delete this.a[taskType.type];
                                }
                            }
                        }
                        for (const extension of delta.added) {
                            const taskTypes = extension.value;
                            for (const taskType of taskTypes) {
                                const type = Configuration.from(taskType, extension.description.identifier, extension.collector);
                                if (type) {
                                    this.a[type.taskType] = type;
                                }
                            }
                        }
                        if ((delta.removed.length > 0) || (delta.added.length > 0)) {
                            this.d.fire();
                        }
                    }
                    catch (error) {
                    }
                    resolve(undefined);
                });
            });
        }
        onReady() {
            return this.b;
        }
        get(key) {
            return this.a[key];
        }
        all() {
            return Object.keys(this.a).map(key => this.a[key]);
        }
        getJsonSchema() {
            if (this.c === undefined) {
                const schemas = [];
                for (const definition of this.all()) {
                    const schema = {
                        type: 'object',
                        additionalProperties: false
                    };
                    if (definition.required.length > 0) {
                        schema.required = definition.required.slice(0);
                    }
                    if (definition.properties !== undefined) {
                        schema.properties = Objects.$eo(definition.properties);
                    }
                    else {
                        schema.properties = Object.create(null);
                    }
                    schema.properties.type = {
                        type: 'string',
                        enum: [definition.taskType]
                    };
                    schemas.push(schema);
                }
                this.c = { oneOf: schemas };
            }
            return this.c;
        }
    }
    exports.$UI = new TaskDefinitionRegistryImpl();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[209/*vs/workbench/contrib/tasks/common/tasks*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,14/*vs/base/common/types*/,23/*vs/base/common/resources*/,25/*vs/base/common/objects*/,31/*vs/platform/contextkey/common/contextkey*/,208/*vs/workbench/contrib/tasks/common/taskDefinitionRegistry*/,43/*vs/platform/configuration/common/configuration*/]), function (require, exports, nls, Types, resources, Objects, contextkey_1, taskDefinitionRegistry_1, configuration_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TaskDefinition = exports.TasksSchemaProperties = exports.TaskSettingId = exports.KeyedTaskIdentifier = exports.TaskEvent = exports.TaskRunSource = exports.TaskRunType = exports.TaskEventKind = exports.$5I = exports.JsonSchemaVersion = exports.ExecutionEngine = exports.$4I = exports.$3I = exports.$2I = exports.$1I = exports.$ZI = exports.RunOptions = exports.RunOnOptions = exports.DependsOrder = exports.TaskSourceKind = exports.TaskScope = exports.TaskGroup = exports.CommandString = exports.RuntimeType = exports.PresentationOptions = exports.PanelKind = exports.RevealProblemKind = exports.RevealKind = exports.CommandOptions = exports.$YI = exports.ShellQuoting = exports.$XI = exports.$WI = exports.$VI = void 0;
    nls = __importStar(nls);
    Types = __importStar(Types);
    resources = __importStar(resources);
    Objects = __importStar(Objects);
    exports.$VI = 'settings';
    exports.$WI = new contextkey_1.$Wj('taskRunning', false, nls.localize(4143, null));
    exports.$XI = nls.localize2(4145, "Tasks");
    var ShellQuoting;
    (function (ShellQuoting) {
        /**
         * Use character escaping.
         */
        ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
        /**
         * Use strong quoting
         */
        ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
        /**
         * Use weak quoting.
         */
        ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
    })(ShellQuoting || (exports.ShellQuoting = ShellQuoting = {}));
    exports.$YI = '$customized';
    (function (ShellQuoting) {
        function from(value) {
            if (!value) {
                return ShellQuoting.Strong;
            }
            switch (value.toLowerCase()) {
                case 'escape':
                    return ShellQuoting.Escape;
                case 'strong':
                    return ShellQuoting.Strong;
                case 'weak':
                    return ShellQuoting.Weak;
                default:
                    return ShellQuoting.Strong;
            }
        }
        ShellQuoting.from = from;
    })(ShellQuoting || (exports.ShellQuoting = ShellQuoting = {}));
    var CommandOptions;
    (function (CommandOptions) {
        CommandOptions.defaults = { cwd: '${workspaceFolder}' };
    })(CommandOptions || (exports.CommandOptions = CommandOptions = {}));
    var RevealKind;
    (function (RevealKind) {
        /**
         * Always brings the terminal to front if the task is executed.
         */
        RevealKind[RevealKind["Always"] = 1] = "Always";
        /**
         * Only brings the terminal to front if a problem is detected executing the task
         * e.g. the task couldn't be started,
         * the task ended with an exit code other than zero,
         * or the problem matcher found an error.
         */
        RevealKind[RevealKind["Silent"] = 2] = "Silent";
        /**
         * The terminal never comes to front when the task is executed.
         */
        RevealKind[RevealKind["Never"] = 3] = "Never";
    })(RevealKind || (exports.RevealKind = RevealKind = {}));
    (function (RevealKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'always':
                    return RevealKind.Always;
                case 'silent':
                    return RevealKind.Silent;
                case 'never':
                    return RevealKind.Never;
                default:
                    return RevealKind.Always;
            }
        }
        RevealKind.fromString = fromString;
    })(RevealKind || (exports.RevealKind = RevealKind = {}));
    var RevealProblemKind;
    (function (RevealProblemKind) {
        /**
         * Never reveals the problems panel when this task is executed.
         */
        RevealProblemKind[RevealProblemKind["Never"] = 1] = "Never";
        /**
         * Only reveals the problems panel if a problem is found.
         */
        RevealProblemKind[RevealProblemKind["OnProblem"] = 2] = "OnProblem";
        /**
         * Never reveals the problems panel when this task is executed.
         */
        RevealProblemKind[RevealProblemKind["Always"] = 3] = "Always";
    })(RevealProblemKind || (exports.RevealProblemKind = RevealProblemKind = {}));
    (function (RevealProblemKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'always':
                    return RevealProblemKind.Always;
                case 'never':
                    return RevealProblemKind.Never;
                case 'onproblem':
                    return RevealProblemKind.OnProblem;
                default:
                    return RevealProblemKind.OnProblem;
            }
        }
        RevealProblemKind.fromString = fromString;
    })(RevealProblemKind || (exports.RevealProblemKind = RevealProblemKind = {}));
    var PanelKind;
    (function (PanelKind) {
        /**
         * Shares a panel with other tasks. This is the default.
         */
        PanelKind[PanelKind["Shared"] = 1] = "Shared";
        /**
         * Uses a dedicated panel for this tasks. The panel is not
         * shared with other tasks.
         */
        PanelKind[PanelKind["Dedicated"] = 2] = "Dedicated";
        /**
         * Creates a new panel whenever this task is executed.
         */
        PanelKind[PanelKind["New"] = 3] = "New";
    })(PanelKind || (exports.PanelKind = PanelKind = {}));
    (function (PanelKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shared':
                    return PanelKind.Shared;
                case 'dedicated':
                    return PanelKind.Dedicated;
                case 'new':
                    return PanelKind.New;
                default:
                    return PanelKind.Shared;
            }
        }
        PanelKind.fromString = fromString;
    })(PanelKind || (exports.PanelKind = PanelKind = {}));
    var PresentationOptions;
    (function (PresentationOptions) {
        PresentationOptions.defaults = {
            echo: true, reveal: RevealKind.Always, revealProblems: RevealProblemKind.Never, focus: false, panel: PanelKind.Shared, showReuseMessage: true, clear: false
        };
    })(PresentationOptions || (exports.PresentationOptions = PresentationOptions = {}));
    var RuntimeType;
    (function (RuntimeType) {
        RuntimeType[RuntimeType["Shell"] = 1] = "Shell";
        RuntimeType[RuntimeType["Process"] = 2] = "Process";
        RuntimeType[RuntimeType["CustomExecution"] = 3] = "CustomExecution";
    })(RuntimeType || (exports.RuntimeType = RuntimeType = {}));
    (function (RuntimeType) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shell':
                    return RuntimeType.Shell;
                case 'process':
                    return RuntimeType.Process;
                case 'customExecution':
                    return RuntimeType.CustomExecution;
                default:
                    return RuntimeType.Process;
            }
        }
        RuntimeType.fromString = fromString;
        function toString(value) {
            switch (value) {
                case RuntimeType.Shell: return 'shell';
                case RuntimeType.Process: return 'process';
                case RuntimeType.CustomExecution: return 'customExecution';
                default: return 'process';
            }
        }
        RuntimeType.toString = toString;
    })(RuntimeType || (exports.RuntimeType = RuntimeType = {}));
    var CommandString;
    (function (CommandString) {
        function value(value) {
            if (Types.$eg(value)) {
                return value;
            }
            else {
                return value.value;
            }
        }
        CommandString.value = value;
    })(CommandString || (exports.CommandString = CommandString = {}));
    var TaskGroup;
    (function (TaskGroup) {
        TaskGroup.Clean = { _id: 'clean', isDefault: false };
        TaskGroup.Build = { _id: 'build', isDefault: false };
        TaskGroup.Rebuild = { _id: 'rebuild', isDefault: false };
        TaskGroup.Test = { _id: 'test', isDefault: false };
        function is(value) {
            return value === TaskGroup.Clean._id || value === TaskGroup.Build._id || value === TaskGroup.Rebuild._id || value === TaskGroup.Test._id;
        }
        TaskGroup.is = is;
        function from(value) {
            if (value === undefined) {
                return undefined;
            }
            else if (Types.$eg(value)) {
                if (is(value)) {
                    return { _id: value, isDefault: false };
                }
                return undefined;
            }
            else {
                return value;
            }
        }
        TaskGroup.from = from;
    })(TaskGroup || (exports.TaskGroup = TaskGroup = {}));
    var TaskScope;
    (function (TaskScope) {
        TaskScope[TaskScope["Global"] = 1] = "Global";
        TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
        TaskScope[TaskScope["Folder"] = 3] = "Folder";
    })(TaskScope || (exports.TaskScope = TaskScope = {}));
    var TaskSourceKind;
    (function (TaskSourceKind) {
        TaskSourceKind.Workspace = 'workspace';
        TaskSourceKind.Extension = 'extension';
        TaskSourceKind.InMemory = 'inMemory';
        TaskSourceKind.WorkspaceFile = 'workspaceFile';
        TaskSourceKind.User = 'user';
        function toConfigurationTarget(kind) {
            switch (kind) {
                case TaskSourceKind.User: return configuration_1.ConfigurationTarget.USER;
                case TaskSourceKind.WorkspaceFile: return configuration_1.ConfigurationTarget.WORKSPACE;
                default: return configuration_1.ConfigurationTarget.WORKSPACE_FOLDER;
            }
        }
        TaskSourceKind.toConfigurationTarget = toConfigurationTarget;
    })(TaskSourceKind || (exports.TaskSourceKind = TaskSourceKind = {}));
    var DependsOrder;
    (function (DependsOrder) {
        DependsOrder["parallel"] = "parallel";
        DependsOrder["sequence"] = "sequence";
    })(DependsOrder || (exports.DependsOrder = DependsOrder = {}));
    var RunOnOptions;
    (function (RunOnOptions) {
        RunOnOptions[RunOnOptions["default"] = 1] = "default";
        RunOnOptions[RunOnOptions["folderOpen"] = 2] = "folderOpen";
    })(RunOnOptions || (exports.RunOnOptions = RunOnOptions = {}));
    var RunOptions;
    (function (RunOptions) {
        RunOptions.defaults = { reevaluateOnRerun: true, runOn: RunOnOptions.default, instanceLimit: 1 };
    })(RunOptions || (exports.RunOptions = RunOptions = {}));
    class $ZI {
        constructor(id, label, type, runOptions, configurationProperties, source) {
            /**
             * The cached label.
             */
            this._label = '';
            this._id = id;
            if (label) {
                this._label = label;
            }
            if (type) {
                this.type = type;
            }
            this.runOptions = runOptions;
            this.configurationProperties = configurationProperties;
            this._source = source;
        }
        getDefinition(useSource) {
            return undefined;
        }
        getMapKey() {
            return this._id;
        }
        getKey() {
            return undefined;
        }
        getCommonTaskId() {
            const key = { folder: this.d(), id: this._id };
            return JSON.stringify(key);
        }
        clone() {
            return this.f(Object.assign({}, this));
        }
        getWorkspaceFolder() {
            return undefined;
        }
        getWorkspaceFileName() {
            return undefined;
        }
        getTelemetryKind() {
            return 'unknown';
        }
        matches(key, compareId = false) {
            if (key === undefined) {
                return false;
            }
            if (Types.$eg(key)) {
                return key === this._label || key === this.configurationProperties.identifier || (compareId && key === this._id);
            }
            const identifier = this.getDefinition(true);
            return identifier !== undefined && identifier._key === key._key;
        }
        getQualifiedLabel() {
            const workspaceFolder = this.getWorkspaceFolder();
            if (workspaceFolder) {
                return `${this._label} (${workspaceFolder.name})`;
            }
            else {
                return this._label;
            }
        }
        getTaskExecution() {
            const result = {
                id: this._id,
                task: this
            };
            return result;
        }
        addTaskLoadMessages(messages) {
            if (this.c === undefined) {
                this.c = [];
            }
            if (messages) {
                this.c = this.c.concat(messages);
            }
        }
        get taskLoadMessages() {
            return this.c;
        }
    }
    exports.$ZI = $ZI;
    /**
     * For tasks of type shell or process, this is created upon parse
     * of the tasks.json or workspace file.
     * For ContributedTasks of all other types, this is the result of
     * resolving a ConfiguringTask.
     */
    class $1I extends $ZI {
        constructor(id, source, label, type, command, hasDefinedMatchers, runOptions, configurationProperties) {
            super(id, label, undefined, runOptions, configurationProperties, source);
            /**
             * The command configuration
             */
            this.command = {};
            this._source = source;
            this.hasDefinedMatchers = hasDefinedMatchers;
            if (command) {
                this.command = command;
            }
        }
        clone() {
            return new $1I(this._id, this._source, this._label, this.type, this.command, this.hasDefinedMatchers, this.runOptions, this.configurationProperties);
        }
        customizes() {
            if (this._source && this._source.customizes) {
                return this._source.customizes;
            }
            return undefined;
        }
        getDefinition(useSource = false) {
            if (useSource && this._source.customizes !== undefined) {
                return this._source.customizes;
            }
            else {
                let type;
                const commandRuntime = this.command ? this.command.runtime : undefined;
                switch (commandRuntime) {
                    case RuntimeType.Shell:
                        type = 'shell';
                        break;
                    case RuntimeType.Process:
                        type = 'process';
                        break;
                    case RuntimeType.CustomExecution:
                        type = 'customExecution';
                        break;
                    case undefined:
                        type = '$composite';
                        break;
                    default:
                        throw new Error('Unexpected task runtime');
                }
                const result = {
                    type,
                    _key: this._id,
                    id: this._id
                };
                return result;
            }
        }
        static is(value) {
            return value instanceof $1I;
        }
        getMapKey() {
            const workspaceFolder = this._source.config.workspaceFolder;
            return workspaceFolder ? `${workspaceFolder.uri.toString()}|${this._id}|${this.instance}` : `${this._id}|${this.instance}`;
        }
        d() {
            return this._source.kind === TaskSourceKind.User ? exports.$VI : this._source.config.workspaceFolder?.uri.toString();
        }
        getCommonTaskId() {
            return this._source.customizes ? super.getCommonTaskId() : (this.getKey() ?? super.getCommonTaskId());
        }
        /**
         * @returns A key representing the task
         */
        getKey() {
            const workspaceFolder = this.d();
            if (!workspaceFolder) {
                return undefined;
            }
            let id = this.configurationProperties.identifier;
            if (this._source.kind !== TaskSourceKind.Workspace) {
                id += this._source.kind;
            }
            const key = { type: exports.$YI, folder: workspaceFolder, id };
            return JSON.stringify(key);
        }
        getWorkspaceFolder() {
            return this._source.config.workspaceFolder;
        }
        getWorkspaceFileName() {
            return (this._source.config.workspace && this._source.config.workspace.configuration) ? resources.$dh(this._source.config.workspace.configuration) : undefined;
        }
        getTelemetryKind() {
            if (this._source.customizes) {
                return 'workspace>extension';
            }
            else {
                return 'workspace';
            }
        }
        f(object) {
            return new $1I(object._id, object._source, object._label, object.type, object.command, object.hasDefinedMatchers, object.runOptions, object.configurationProperties);
        }
    }
    exports.$1I = $1I;
    /**
     * After a contributed task has been parsed, but before
     * the task has been resolved via the extension, its properties
     * are stored in this
     */
    class $2I extends $ZI {
        constructor(id, source, label, type, configures, runOptions, configurationProperties) {
            super(id, label, type, runOptions, configurationProperties, source);
            this._source = source;
            this.configures = configures;
        }
        static is(value) {
            return value instanceof $2I;
        }
        f(object) {
            return object;
        }
        getDefinition() {
            return this.configures;
        }
        getWorkspaceFileName() {
            return (this._source.config.workspace && this._source.config.workspace.configuration) ? resources.$dh(this._source.config.workspace.configuration) : undefined;
        }
        getWorkspaceFolder() {
            return this._source.config.workspaceFolder;
        }
        d() {
            return this._source.kind === TaskSourceKind.User ? exports.$VI : this._source.config.workspaceFolder?.uri.toString();
        }
        getKey() {
            const workspaceFolder = this.d();
            if (!workspaceFolder) {
                return undefined;
            }
            let id = this.configurationProperties.identifier;
            if (this._source.kind !== TaskSourceKind.Workspace) {
                id += this._source.kind;
            }
            const key = { type: exports.$YI, folder: workspaceFolder, id };
            return JSON.stringify(key);
        }
    }
    exports.$2I = $2I;
    /**
     * A task from an extension created via resolveTask or provideTask
     */
    class $3I extends $ZI {
        constructor(id, source, label, type, defines, command, hasDefinedMatchers, runOptions, configurationProperties) {
            super(id, label, type, runOptions, configurationProperties, source);
            this.defines = defines;
            this.hasDefinedMatchers = hasDefinedMatchers;
            this.command = command;
            this.icon = configurationProperties.icon;
            this.hide = configurationProperties.hide;
        }
        clone() {
            return new $3I(this._id, this._source, this._label, this.type, this.defines, this.command, this.hasDefinedMatchers, this.runOptions, this.configurationProperties);
        }
        getDefinition() {
            return this.defines;
        }
        static is(value) {
            return value instanceof $3I;
        }
        getMapKey() {
            const workspaceFolder = this._source.workspaceFolder;
            return workspaceFolder
                ? `${this._source.scope.toString()}|${workspaceFolder.uri.toString()}|${this._id}|${this.instance}`
                : `${this._source.scope.toString()}|${this._id}|${this.instance}`;
        }
        d() {
            if (this._source.scope === TaskScope.Folder && this._source.workspaceFolder) {
                return this._source.workspaceFolder.uri.toString();
            }
            return undefined;
        }
        getKey() {
            const key = { type: 'contributed', scope: this._source.scope, id: this._id };
            key.folder = this.d();
            return JSON.stringify(key);
        }
        getWorkspaceFolder() {
            return this._source.workspaceFolder;
        }
        getTelemetryKind() {
            return 'extension';
        }
        f(object) {
            return new $3I(object._id, object._source, object._label, object.type, object.defines, object.command, object.hasDefinedMatchers, object.runOptions, object.configurationProperties);
        }
    }
    exports.$3I = $3I;
    class $4I extends $ZI {
        constructor(id, source, label, type, runOptions, configurationProperties) {
            super(id, label, type, runOptions, configurationProperties, source);
            this._source = source;
        }
        clone() {
            return new $4I(this._id, this._source, this._label, this.type, this.runOptions, this.configurationProperties);
        }
        static is(value) {
            return value instanceof $4I;
        }
        getTelemetryKind() {
            return 'composite';
        }
        getMapKey() {
            return `${this._id}|${this.instance}`;
        }
        d() {
            return undefined;
        }
        f(object) {
            return new $4I(object._id, object._source, object._label, object.type, object.runOptions, object.configurationProperties);
        }
    }
    exports.$4I = $4I;
    var ExecutionEngine;
    (function (ExecutionEngine) {
        ExecutionEngine[ExecutionEngine["Process"] = 1] = "Process";
        ExecutionEngine[ExecutionEngine["Terminal"] = 2] = "Terminal";
    })(ExecutionEngine || (exports.ExecutionEngine = ExecutionEngine = {}));
    (function (ExecutionEngine) {
        ExecutionEngine._default = ExecutionEngine.Terminal;
    })(ExecutionEngine || (exports.ExecutionEngine = ExecutionEngine = {}));
    var JsonSchemaVersion;
    (function (JsonSchemaVersion) {
        JsonSchemaVersion[JsonSchemaVersion["V0_1_0"] = 1] = "V0_1_0";
        JsonSchemaVersion[JsonSchemaVersion["V2_0_0"] = 2] = "V2_0_0";
    })(JsonSchemaVersion || (exports.JsonSchemaVersion = JsonSchemaVersion = {}));
    class $5I {
        constructor(workspaceFolders) {
            this.c = new Map();
            for (let i = 0; i < workspaceFolders.length; i++) {
                this.c.set(workspaceFolders[i].uri.toString(), i);
            }
        }
        compare(a, b) {
            const aw = a.getWorkspaceFolder();
            const bw = b.getWorkspaceFolder();
            if (aw && bw) {
                let ai = this.c.get(aw.uri.toString());
                ai = ai === undefined ? 0 : ai + 1;
                let bi = this.c.get(bw.uri.toString());
                bi = bi === undefined ? 0 : bi + 1;
                if (ai === bi) {
                    return a._label.localeCompare(b._label);
                }
                else {
                    return ai - bi;
                }
            }
            else if (!aw && bw) {
                return -1;
            }
            else if (aw && !bw) {
                return +1;
            }
            else {
                return 0;
            }
        }
    }
    exports.$5I = $5I;
    var TaskEventKind;
    (function (TaskEventKind) {
        TaskEventKind["DependsOnStarted"] = "dependsOnStarted";
        TaskEventKind["AcquiredInput"] = "acquiredInput";
        TaskEventKind["Start"] = "start";
        TaskEventKind["ProcessStarted"] = "processStarted";
        TaskEventKind["Active"] = "active";
        TaskEventKind["Inactive"] = "inactive";
        TaskEventKind["Changed"] = "changed";
        TaskEventKind["Terminated"] = "terminated";
        TaskEventKind["ProcessEnded"] = "processEnded";
        TaskEventKind["End"] = "end";
    })(TaskEventKind || (exports.TaskEventKind = TaskEventKind = {}));
    var TaskRunType;
    (function (TaskRunType) {
        TaskRunType["SingleRun"] = "singleRun";
        TaskRunType["Background"] = "background";
    })(TaskRunType || (exports.TaskRunType = TaskRunType = {}));
    var TaskRunSource;
    (function (TaskRunSource) {
        TaskRunSource[TaskRunSource["System"] = 0] = "System";
        TaskRunSource[TaskRunSource["User"] = 1] = "User";
        TaskRunSource[TaskRunSource["FolderOpen"] = 2] = "FolderOpen";
        TaskRunSource[TaskRunSource["ConfigurationChange"] = 3] = "ConfigurationChange";
        TaskRunSource[TaskRunSource["Reconnect"] = 4] = "Reconnect";
    })(TaskRunSource || (exports.TaskRunSource = TaskRunSource = {}));
    var TaskEvent;
    (function (TaskEvent) {
        function common(task) {
            return {
                taskId: task._id,
                taskName: task.configurationProperties.name,
                runType: task.configurationProperties.isBackground ? TaskRunType.Background : TaskRunType.SingleRun,
                group: task.configurationProperties.group,
                __task: task,
            };
        }
        function start(task, terminalId, resolvedVariables) {
            return {
                ...common(task),
                kind: TaskEventKind.Start,
                terminalId,
                resolvedVariables,
            };
        }
        TaskEvent.start = start;
        function processStarted(task, terminalId, processId) {
            return {
                ...common(task),
                kind: TaskEventKind.ProcessStarted,
                terminalId,
                processId,
            };
        }
        TaskEvent.processStarted = processStarted;
        function processEnded(task, terminalId, exitCode) {
            return {
                ...common(task),
                kind: TaskEventKind.ProcessEnded,
                terminalId,
                exitCode,
            };
        }
        TaskEvent.processEnded = processEnded;
        function terminated(task, terminalId, exitReason) {
            return {
                ...common(task),
                kind: TaskEventKind.Terminated,
                exitReason,
                terminalId,
            };
        }
        TaskEvent.terminated = terminated;
        function general(kind, task, terminalId) {
            return {
                ...common(task),
                kind,
                terminalId,
            };
        }
        TaskEvent.general = general;
        function changed() {
            return { kind: TaskEventKind.Changed };
        }
        TaskEvent.changed = changed;
    })(TaskEvent || (exports.TaskEvent = TaskEvent = {}));
    var KeyedTaskIdentifier;
    (function (KeyedTaskIdentifier) {
        function sortedStringify(literal) {
            const keys = Object.keys(literal).sort();
            let result = '';
            for (const key of keys) {
                let stringified = literal[key];
                if (stringified instanceof Object) {
                    stringified = sortedStringify(stringified);
                }
                else if (typeof stringified === 'string') {
                    stringified = stringified.replace(/,/g, ',,');
                }
                result += key + ',' + stringified + ',';
            }
            return result;
        }
        function create(value) {
            const resultKey = sortedStringify(value);
            const result = { _key: resultKey, type: value.taskType };
            Object.assign(result, value);
            return result;
        }
        KeyedTaskIdentifier.create = create;
    })(KeyedTaskIdentifier || (exports.KeyedTaskIdentifier = KeyedTaskIdentifier = {}));
    var TaskSettingId;
    (function (TaskSettingId) {
        TaskSettingId["AutoDetect"] = "task.autoDetect";
        TaskSettingId["SaveBeforeRun"] = "task.saveBeforeRun";
        TaskSettingId["ShowDecorations"] = "task.showDecorations";
        TaskSettingId["ProblemMatchersNeverPrompt"] = "task.problemMatchers.neverPrompt";
        TaskSettingId["SlowProviderWarning"] = "task.slowProviderWarning";
        TaskSettingId["QuickOpenHistory"] = "task.quickOpen.history";
        TaskSettingId["QuickOpenDetail"] = "task.quickOpen.detail";
        TaskSettingId["QuickOpenSkip"] = "task.quickOpen.skip";
        TaskSettingId["QuickOpenShowAll"] = "task.quickOpen.showAll";
        TaskSettingId["AllowAutomaticTasks"] = "task.allowAutomaticTasks";
        TaskSettingId["Reconnection"] = "task.reconnection";
        TaskSettingId["VerboseLogging"] = "task.verboseLogging";
    })(TaskSettingId || (exports.TaskSettingId = TaskSettingId = {}));
    var TasksSchemaProperties;
    (function (TasksSchemaProperties) {
        TasksSchemaProperties["Tasks"] = "tasks";
        TasksSchemaProperties["SuppressTaskName"] = "tasks.suppressTaskName";
        TasksSchemaProperties["Windows"] = "tasks.windows";
        TasksSchemaProperties["Osx"] = "tasks.osx";
        TasksSchemaProperties["Linux"] = "tasks.linux";
        TasksSchemaProperties["ShowOutput"] = "tasks.showOutput";
        TasksSchemaProperties["IsShellCommand"] = "tasks.isShellCommand";
        TasksSchemaProperties["ServiceTestSetting"] = "tasks.service.testSetting";
    })(TasksSchemaProperties || (exports.TasksSchemaProperties = TasksSchemaProperties = {}));
    var TaskDefinition;
    (function (TaskDefinition) {
        function createTaskIdentifier(external, reporter) {
            const definition = taskDefinitionRegistry_1.$UI.get(external.type);
            if (definition === undefined) {
                // We have no task definition so we can't sanitize the literal. Take it as is
                const copy = Objects.$eo(external);
                delete copy._key;
                return KeyedTaskIdentifier.create(copy);
            }
            const literal = Object.create(null);
            literal.type = definition.taskType;
            const required = new Set();
            definition.required.forEach(element => required.add(element));
            const properties = definition.properties;
            for (const property of Object.keys(properties)) {
                const value = external[property];
                if (value !== undefined && value !== null) {
                    literal[property] = value;
                }
                else if (required.has(property)) {
                    const schema = properties[property];
                    if (schema.default !== undefined) {
                        literal[property] = Objects.$eo(schema.default);
                    }
                    else {
                        switch (schema.type) {
                            case 'boolean':
                                literal[property] = false;
                                break;
                            case 'number':
                            case 'integer':
                                literal[property] = 0;
                                break;
                            case 'string':
                                literal[property] = '';
                                break;
                            default:
                                reporter.error(nls.localize(4144, null, JSON.stringify(external, undefined, 0), property));
                                return undefined;
                        }
                    }
                }
            }
            return KeyedTaskIdentifier.create(literal);
        }
        TaskDefinition.createTaskIdentifier = createTaskIdentifier;
    })(TaskDefinition || (exports.TaskDefinition = TaskDefinition = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[210/*vs/workbench/services/extensions/common/lazyPromise*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/]), function (require, exports, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Rdc = exports.$Qdc = void 0;
    class $Qdc {
        constructor() {
            this.a = null;
            this.b = null;
            this.d = null;
            this.f = false;
            this.g = null;
            this.h = false;
            this.i = null;
        }
        get [Symbol.toStringTag]() {
            return this.toString();
        }
        j() {
            if (!this.a) {
                this.a = new Promise((c, e) => {
                    this.b = c;
                    this.d = e;
                    if (this.f) {
                        this.b(this.g);
                    }
                    if (this.h) {
                        this.d(this.i);
                    }
                });
            }
            return this.a;
        }
        resolveOk(value) {
            if (this.f || this.h) {
                return;
            }
            this.f = true;
            this.g = value;
            if (this.a) {
                this.b(value);
            }
        }
        resolveErr(err) {
            if (this.f || this.h) {
                return;
            }
            this.h = true;
            this.i = err;
            if (this.a) {
                this.d(err);
            }
            else {
                // If nobody's listening at this point, it is safe to assume they never will,
                // since resolving this promise is always "async"
                (0, errors_1.$Y)(err);
            }
        }
        then(success, error) {
            return this.j().then(success, error);
        }
        catch(error) {
            return this.j().then(undefined, error);
        }
        finally(callback) {
            return this.j().finally(callback);
        }
    }
    exports.$Qdc = $Qdc;
    class $Rdc extends $Qdc {
        constructor() {
            super();
            this.h = true;
            this.i = new errors_1.$4();
        }
    }
    exports.$Rdc = $Rdc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[39/*vs/workbench/services/extensions/common/proxyIdentifier*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Xw = exports.$Uw = void 0;
    exports.$Vw = $Vw;
    exports.$Ww = $Ww;
    class $Uw {
        static { this.count = 0; }
        constructor(sid) {
            this._proxyIdentifierBrand = undefined;
            this.sid = sid;
            this.nid = (++$Uw.count);
        }
    }
    exports.$Uw = $Uw;
    const identifiers = [];
    function $Vw(identifier) {
        const result = new $Uw(identifier);
        identifiers[result.nid] = result;
        return result;
    }
    function $Ww(nid) {
        return identifiers[nid].sid;
    }
    /**
     * Marks the object as containing buffers that should be serialized more efficiently.
     */
    class $Xw {
        constructor(value) {
            this.value = value;
        }
    }
    exports.$Xw = $Xw;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[5/*vs/workbench/api/common/extHost.protocol*/], __M([1/*require*/,0/*exports*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/]), function (require, exports, proxyIdentifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$LN = exports.$KN = exports.ExtHostTestingResource = exports.ISuggestResultDtoField = exports.ISuggestDataDtoField = exports.$JN = exports.CandidatePortSource = exports.NotebookEditorRevealType = exports.CellOutputKind = exports.WebviewMessageArrayBufferViewType = exports.WebviewEditorCapabilities = exports.TabModelOperationKind = exports.TabInputKind = exports.TextEditorRevealType = void 0;
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType || (exports.TextEditorRevealType = TextEditorRevealType = {}));
    //#region --- tabs model
    var TabInputKind;
    (function (TabInputKind) {
        TabInputKind[TabInputKind["UnknownInput"] = 0] = "UnknownInput";
        TabInputKind[TabInputKind["TextInput"] = 1] = "TextInput";
        TabInputKind[TabInputKind["TextDiffInput"] = 2] = "TextDiffInput";
        TabInputKind[TabInputKind["TextMergeInput"] = 3] = "TextMergeInput";
        TabInputKind[TabInputKind["NotebookInput"] = 4] = "NotebookInput";
        TabInputKind[TabInputKind["NotebookDiffInput"] = 5] = "NotebookDiffInput";
        TabInputKind[TabInputKind["CustomEditorInput"] = 6] = "CustomEditorInput";
        TabInputKind[TabInputKind["WebviewEditorInput"] = 7] = "WebviewEditorInput";
        TabInputKind[TabInputKind["TerminalEditorInput"] = 8] = "TerminalEditorInput";
        TabInputKind[TabInputKind["InteractiveEditorInput"] = 9] = "InteractiveEditorInput";
        TabInputKind[TabInputKind["ChatEditorInput"] = 10] = "ChatEditorInput";
        TabInputKind[TabInputKind["MultiDiffEditorInput"] = 11] = "MultiDiffEditorInput";
    })(TabInputKind || (exports.TabInputKind = TabInputKind = {}));
    var TabModelOperationKind;
    (function (TabModelOperationKind) {
        TabModelOperationKind[TabModelOperationKind["TAB_OPEN"] = 0] = "TAB_OPEN";
        TabModelOperationKind[TabModelOperationKind["TAB_CLOSE"] = 1] = "TAB_CLOSE";
        TabModelOperationKind[TabModelOperationKind["TAB_UPDATE"] = 2] = "TAB_UPDATE";
        TabModelOperationKind[TabModelOperationKind["TAB_MOVE"] = 3] = "TAB_MOVE";
    })(TabModelOperationKind || (exports.TabModelOperationKind = TabModelOperationKind = {}));
    var WebviewEditorCapabilities;
    (function (WebviewEditorCapabilities) {
        WebviewEditorCapabilities[WebviewEditorCapabilities["Editable"] = 0] = "Editable";
        WebviewEditorCapabilities[WebviewEditorCapabilities["SupportsHotExit"] = 1] = "SupportsHotExit";
    })(WebviewEditorCapabilities || (exports.WebviewEditorCapabilities = WebviewEditorCapabilities = {}));
    var WebviewMessageArrayBufferViewType;
    (function (WebviewMessageArrayBufferViewType) {
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Int8Array"] = 1] = "Int8Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Uint8Array"] = 2] = "Uint8Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Uint8ClampedArray"] = 3] = "Uint8ClampedArray";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Int16Array"] = 4] = "Int16Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Uint16Array"] = 5] = "Uint16Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Int32Array"] = 6] = "Int32Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Uint32Array"] = 7] = "Uint32Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Float32Array"] = 8] = "Float32Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["Float64Array"] = 9] = "Float64Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["BigInt64Array"] = 10] = "BigInt64Array";
        WebviewMessageArrayBufferViewType[WebviewMessageArrayBufferViewType["BigUint64Array"] = 11] = "BigUint64Array";
    })(WebviewMessageArrayBufferViewType || (exports.WebviewMessageArrayBufferViewType = WebviewMessageArrayBufferViewType = {}));
    var CellOutputKind;
    (function (CellOutputKind) {
        CellOutputKind[CellOutputKind["Text"] = 1] = "Text";
        CellOutputKind[CellOutputKind["Error"] = 2] = "Error";
        CellOutputKind[CellOutputKind["Rich"] = 3] = "Rich";
    })(CellOutputKind || (exports.CellOutputKind = CellOutputKind = {}));
    var NotebookEditorRevealType;
    (function (NotebookEditorRevealType) {
        NotebookEditorRevealType[NotebookEditorRevealType["Default"] = 0] = "Default";
        NotebookEditorRevealType[NotebookEditorRevealType["InCenter"] = 1] = "InCenter";
        NotebookEditorRevealType[NotebookEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        NotebookEditorRevealType[NotebookEditorRevealType["AtTop"] = 3] = "AtTop";
    })(NotebookEditorRevealType || (exports.NotebookEditorRevealType = NotebookEditorRevealType = {}));
    var CandidatePortSource;
    (function (CandidatePortSource) {
        CandidatePortSource[CandidatePortSource["None"] = 0] = "None";
        CandidatePortSource[CandidatePortSource["Process"] = 1] = "Process";
        CandidatePortSource[CandidatePortSource["Output"] = 2] = "Output";
        CandidatePortSource[CandidatePortSource["Hybrid"] = 3] = "Hybrid";
    })(CandidatePortSource || (exports.CandidatePortSource = CandidatePortSource = {}));
    class $JN {
        static { this.a = 0; }
        static mixin(object) {
            object._id = $JN.a++;
            return object;
        }
    }
    exports.$JN = $JN;
    var ISuggestDataDtoField;
    (function (ISuggestDataDtoField) {
        ISuggestDataDtoField["label"] = "a";
        ISuggestDataDtoField["kind"] = "b";
        ISuggestDataDtoField["detail"] = "c";
        ISuggestDataDtoField["documentation"] = "d";
        ISuggestDataDtoField["sortText"] = "e";
        ISuggestDataDtoField["filterText"] = "f";
        ISuggestDataDtoField["preselect"] = "g";
        ISuggestDataDtoField["insertText"] = "h";
        ISuggestDataDtoField["insertTextRules"] = "i";
        ISuggestDataDtoField["range"] = "j";
        ISuggestDataDtoField["commitCharacters"] = "k";
        ISuggestDataDtoField["additionalTextEdits"] = "l";
        ISuggestDataDtoField["kindModifier"] = "m";
        ISuggestDataDtoField["commandIdent"] = "n";
        ISuggestDataDtoField["commandId"] = "o";
        ISuggestDataDtoField["commandArguments"] = "p";
    })(ISuggestDataDtoField || (exports.ISuggestDataDtoField = ISuggestDataDtoField = {}));
    var ISuggestResultDtoField;
    (function (ISuggestResultDtoField) {
        ISuggestResultDtoField["defaultRanges"] = "a";
        ISuggestResultDtoField["completions"] = "b";
        ISuggestResultDtoField["isIncomplete"] = "c";
        ISuggestResultDtoField["duration"] = "d";
    })(ISuggestResultDtoField || (exports.ISuggestResultDtoField = ISuggestResultDtoField = {}));
    var ExtHostTestingResource;
    (function (ExtHostTestingResource) {
        ExtHostTestingResource[ExtHostTestingResource["Workspace"] = 0] = "Workspace";
        ExtHostTestingResource[ExtHostTestingResource["TextDocument"] = 1] = "TextDocument";
    })(ExtHostTestingResource || (exports.ExtHostTestingResource = ExtHostTestingResource = {}));
    // --- proxy identifiers
    exports.$KN = {
        MainThreadAuthentication: (0, proxyIdentifier_1.$Vw)('MainThreadAuthentication'),
        MainThreadBulkEdits: (0, proxyIdentifier_1.$Vw)('MainThreadBulkEdits'),
        MainThreadLanguageModels: (0, proxyIdentifier_1.$Vw)('MainThreadLanguageModels'),
        MainThreadEmbeddings: (0, proxyIdentifier_1.$Vw)('MainThreadEmbeddings'),
        MainThreadChatAgents2: (0, proxyIdentifier_1.$Vw)('MainThreadChatAgents2'),
        MainThreadChatVariables: (0, proxyIdentifier_1.$Vw)('MainThreadChatVariables'),
        MainThreadLanguageModelTools: (0, proxyIdentifier_1.$Vw)('MainThreadChatSkills'),
        MainThreadClipboard: (0, proxyIdentifier_1.$Vw)('MainThreadClipboard'),
        MainThreadCommands: (0, proxyIdentifier_1.$Vw)('MainThreadCommands'),
        MainThreadComments: (0, proxyIdentifier_1.$Vw)('MainThreadComments'),
        MainThreadConfiguration: (0, proxyIdentifier_1.$Vw)('MainThreadConfiguration'),
        MainThreadConsole: (0, proxyIdentifier_1.$Vw)('MainThreadConsole'),
        MainThreadDebugService: (0, proxyIdentifier_1.$Vw)('MainThreadDebugService'),
        MainThreadDecorations: (0, proxyIdentifier_1.$Vw)('MainThreadDecorations'),
        MainThreadDiagnostics: (0, proxyIdentifier_1.$Vw)('MainThreadDiagnostics'),
        MainThreadDialogs: (0, proxyIdentifier_1.$Vw)('MainThreadDiaglogs'),
        MainThreadDocuments: (0, proxyIdentifier_1.$Vw)('MainThreadDocuments'),
        MainThreadDocumentContentProviders: (0, proxyIdentifier_1.$Vw)('MainThreadDocumentContentProviders'),
        MainThreadTextEditors: (0, proxyIdentifier_1.$Vw)('MainThreadTextEditors'),
        MainThreadEditorInsets: (0, proxyIdentifier_1.$Vw)('MainThreadEditorInsets'),
        MainThreadEditorTabs: (0, proxyIdentifier_1.$Vw)('MainThreadEditorTabs'),
        MainThreadErrors: (0, proxyIdentifier_1.$Vw)('MainThreadErrors'),
        MainThreadTreeViews: (0, proxyIdentifier_1.$Vw)('MainThreadTreeViews'),
        MainThreadDownloadService: (0, proxyIdentifier_1.$Vw)('MainThreadDownloadService'),
        MainThreadLanguageFeatures: (0, proxyIdentifier_1.$Vw)('MainThreadLanguageFeatures'),
        MainThreadLanguages: (0, proxyIdentifier_1.$Vw)('MainThreadLanguages'),
        MainThreadLogger: (0, proxyIdentifier_1.$Vw)('MainThreadLogger'),
        MainThreadMessageService: (0, proxyIdentifier_1.$Vw)('MainThreadMessageService'),
        MainThreadOutputService: (0, proxyIdentifier_1.$Vw)('MainThreadOutputService'),
        MainThreadProgress: (0, proxyIdentifier_1.$Vw)('MainThreadProgress'),
        MainThreadQuickDiff: (0, proxyIdentifier_1.$Vw)('MainThreadQuickDiff'),
        MainThreadQuickOpen: (0, proxyIdentifier_1.$Vw)('MainThreadQuickOpen'),
        MainThreadStatusBar: (0, proxyIdentifier_1.$Vw)('MainThreadStatusBar'),
        MainThreadSecretState: (0, proxyIdentifier_1.$Vw)('MainThreadSecretState'),
        MainThreadStorage: (0, proxyIdentifier_1.$Vw)('MainThreadStorage'),
        MainThreadSpeech: (0, proxyIdentifier_1.$Vw)('MainThreadSpeechProvider'),
        MainThreadTelemetry: (0, proxyIdentifier_1.$Vw)('MainThreadTelemetry'),
        MainThreadTerminalService: (0, proxyIdentifier_1.$Vw)('MainThreadTerminalService'),
        MainThreadTerminalShellIntegration: (0, proxyIdentifier_1.$Vw)('MainThreadTerminalShellIntegration'),
        MainThreadWebviews: (0, proxyIdentifier_1.$Vw)('MainThreadWebviews'),
        MainThreadWebviewPanels: (0, proxyIdentifier_1.$Vw)('MainThreadWebviewPanels'),
        MainThreadWebviewViews: (0, proxyIdentifier_1.$Vw)('MainThreadWebviewViews'),
        MainThreadCustomEditors: (0, proxyIdentifier_1.$Vw)('MainThreadCustomEditors'),
        MainThreadUrls: (0, proxyIdentifier_1.$Vw)('MainThreadUrls'),
        MainThreadUriOpeners: (0, proxyIdentifier_1.$Vw)('MainThreadUriOpeners'),
        MainThreadProfileContentHandlers: (0, proxyIdentifier_1.$Vw)('MainThreadProfileContentHandlers'),
        MainThreadWorkspace: (0, proxyIdentifier_1.$Vw)('MainThreadWorkspace'),
        MainThreadFileSystem: (0, proxyIdentifier_1.$Vw)('MainThreadFileSystem'),
        MainThreadFileSystemEventService: (0, proxyIdentifier_1.$Vw)('MainThreadFileSystemEventService'),
        MainThreadExtensionService: (0, proxyIdentifier_1.$Vw)('MainThreadExtensionService'),
        MainThreadSCM: (0, proxyIdentifier_1.$Vw)('MainThreadSCM'),
        MainThreadSearch: (0, proxyIdentifier_1.$Vw)('MainThreadSearch'),
        MainThreadShare: (0, proxyIdentifier_1.$Vw)('MainThreadShare'),
        MainThreadTask: (0, proxyIdentifier_1.$Vw)('MainThreadTask'),
        MainThreadWindow: (0, proxyIdentifier_1.$Vw)('MainThreadWindow'),
        MainThreadLabelService: (0, proxyIdentifier_1.$Vw)('MainThreadLabelService'),
        MainThreadNotebook: (0, proxyIdentifier_1.$Vw)('MainThreadNotebook'),
        MainThreadNotebookDocuments: (0, proxyIdentifier_1.$Vw)('MainThreadNotebookDocumentsShape'),
        MainThreadNotebookEditors: (0, proxyIdentifier_1.$Vw)('MainThreadNotebookEditorsShape'),
        MainThreadNotebookKernels: (0, proxyIdentifier_1.$Vw)('MainThreadNotebookKernels'),
        MainThreadNotebookRenderers: (0, proxyIdentifier_1.$Vw)('MainThreadNotebookRenderers'),
        MainThreadInteractive: (0, proxyIdentifier_1.$Vw)('MainThreadInteractive'),
        MainThreadTheming: (0, proxyIdentifier_1.$Vw)('MainThreadTheming'),
        MainThreadTunnelService: (0, proxyIdentifier_1.$Vw)('MainThreadTunnelService'),
        MainThreadManagedSockets: (0, proxyIdentifier_1.$Vw)('MainThreadManagedSockets'),
        MainThreadTimeline: (0, proxyIdentifier_1.$Vw)('MainThreadTimeline'),
        MainThreadTesting: (0, proxyIdentifier_1.$Vw)('MainThreadTesting'),
        MainThreadLocalization: (0, proxyIdentifier_1.$Vw)('MainThreadLocalizationShape'),
        MainThreadAiRelatedInformation: (0, proxyIdentifier_1.$Vw)('MainThreadAiRelatedInformation'),
        MainThreadAiEmbeddingVector: (0, proxyIdentifier_1.$Vw)('MainThreadAiEmbeddingVector')
    };
    exports.$LN = {
        ExtHostCommands: (0, proxyIdentifier_1.$Vw)('ExtHostCommands'),
        ExtHostConfiguration: (0, proxyIdentifier_1.$Vw)('ExtHostConfiguration'),
        ExtHostDiagnostics: (0, proxyIdentifier_1.$Vw)('ExtHostDiagnostics'),
        ExtHostDebugService: (0, proxyIdentifier_1.$Vw)('ExtHostDebugService'),
        ExtHostDecorations: (0, proxyIdentifier_1.$Vw)('ExtHostDecorations'),
        ExtHostDocumentsAndEditors: (0, proxyIdentifier_1.$Vw)('ExtHostDocumentsAndEditors'),
        ExtHostDocuments: (0, proxyIdentifier_1.$Vw)('ExtHostDocuments'),
        ExtHostDocumentContentProviders: (0, proxyIdentifier_1.$Vw)('ExtHostDocumentContentProviders'),
        ExtHostDocumentSaveParticipant: (0, proxyIdentifier_1.$Vw)('ExtHostDocumentSaveParticipant'),
        ExtHostEditors: (0, proxyIdentifier_1.$Vw)('ExtHostEditors'),
        ExtHostTreeViews: (0, proxyIdentifier_1.$Vw)('ExtHostTreeViews'),
        ExtHostFileSystem: (0, proxyIdentifier_1.$Vw)('ExtHostFileSystem'),
        ExtHostFileSystemInfo: (0, proxyIdentifier_1.$Vw)('ExtHostFileSystemInfo'),
        ExtHostFileSystemEventService: (0, proxyIdentifier_1.$Vw)('ExtHostFileSystemEventService'),
        ExtHostLanguages: (0, proxyIdentifier_1.$Vw)('ExtHostLanguages'),
        ExtHostLanguageFeatures: (0, proxyIdentifier_1.$Vw)('ExtHostLanguageFeatures'),
        ExtHostQuickOpen: (0, proxyIdentifier_1.$Vw)('ExtHostQuickOpen'),
        ExtHostQuickDiff: (0, proxyIdentifier_1.$Vw)('ExtHostQuickDiff'),
        ExtHostStatusBar: (0, proxyIdentifier_1.$Vw)('ExtHostStatusBar'),
        ExtHostShare: (0, proxyIdentifier_1.$Vw)('ExtHostShare'),
        ExtHostExtensionService: (0, proxyIdentifier_1.$Vw)('ExtHostExtensionService'),
        ExtHostLogLevelServiceShape: (0, proxyIdentifier_1.$Vw)('ExtHostLogLevelServiceShape'),
        ExtHostTerminalService: (0, proxyIdentifier_1.$Vw)('ExtHostTerminalService'),
        ExtHostTerminalShellIntegration: (0, proxyIdentifier_1.$Vw)('ExtHostTerminalShellIntegration'),
        ExtHostSCM: (0, proxyIdentifier_1.$Vw)('ExtHostSCM'),
        ExtHostSearch: (0, proxyIdentifier_1.$Vw)('ExtHostSearch'),
        ExtHostTask: (0, proxyIdentifier_1.$Vw)('ExtHostTask'),
        ExtHostWorkspace: (0, proxyIdentifier_1.$Vw)('ExtHostWorkspace'),
        ExtHostWindow: (0, proxyIdentifier_1.$Vw)('ExtHostWindow'),
        ExtHostWebviews: (0, proxyIdentifier_1.$Vw)('ExtHostWebviews'),
        ExtHostWebviewPanels: (0, proxyIdentifier_1.$Vw)('ExtHostWebviewPanels'),
        ExtHostCustomEditors: (0, proxyIdentifier_1.$Vw)('ExtHostCustomEditors'),
        ExtHostWebviewViews: (0, proxyIdentifier_1.$Vw)('ExtHostWebviewViews'),
        ExtHostEditorInsets: (0, proxyIdentifier_1.$Vw)('ExtHostEditorInsets'),
        ExtHostEditorTabs: (0, proxyIdentifier_1.$Vw)('ExtHostEditorTabs'),
        ExtHostProgress: (0, proxyIdentifier_1.$Vw)('ExtHostProgress'),
        ExtHostComments: (0, proxyIdentifier_1.$Vw)('ExtHostComments'),
        ExtHostSecretState: (0, proxyIdentifier_1.$Vw)('ExtHostSecretState'),
        ExtHostStorage: (0, proxyIdentifier_1.$Vw)('ExtHostStorage'),
        ExtHostUrls: (0, proxyIdentifier_1.$Vw)('ExtHostUrls'),
        ExtHostUriOpeners: (0, proxyIdentifier_1.$Vw)('ExtHostUriOpeners'),
        ExtHostProfileContentHandlers: (0, proxyIdentifier_1.$Vw)('ExtHostProfileContentHandlers'),
        ExtHostOutputService: (0, proxyIdentifier_1.$Vw)('ExtHostOutputService'),
        ExtHostLabelService: (0, proxyIdentifier_1.$Vw)('ExtHostLabelService'),
        ExtHostNotebook: (0, proxyIdentifier_1.$Vw)('ExtHostNotebook'),
        ExtHostNotebookDocuments: (0, proxyIdentifier_1.$Vw)('ExtHostNotebookDocuments'),
        ExtHostNotebookEditors: (0, proxyIdentifier_1.$Vw)('ExtHostNotebookEditors'),
        ExtHostNotebookKernels: (0, proxyIdentifier_1.$Vw)('ExtHostNotebookKernels'),
        ExtHostNotebookRenderers: (0, proxyIdentifier_1.$Vw)('ExtHostNotebookRenderers'),
        ExtHostNotebookDocumentSaveParticipant: (0, proxyIdentifier_1.$Vw)('ExtHostNotebookDocumentSaveParticipant'),
        ExtHostInteractive: (0, proxyIdentifier_1.$Vw)('ExtHostInteractive'),
        ExtHostChatAgents2: (0, proxyIdentifier_1.$Vw)('ExtHostChatAgents'),
        ExtHostChatVariables: (0, proxyIdentifier_1.$Vw)('ExtHostChatVariables'),
        ExtHostLanguageModelTools: (0, proxyIdentifier_1.$Vw)('ExtHostChatSkills'),
        ExtHostChatProvider: (0, proxyIdentifier_1.$Vw)('ExtHostChatProvider'),
        ExtHostSpeech: (0, proxyIdentifier_1.$Vw)('ExtHostSpeech'),
        ExtHostEmbeddings: (0, proxyIdentifier_1.$Vw)('ExtHostEmbeddings'),
        ExtHostAiRelatedInformation: (0, proxyIdentifier_1.$Vw)('ExtHostAiRelatedInformation'),
        ExtHostAiEmbeddingVector: (0, proxyIdentifier_1.$Vw)('ExtHostAiEmbeddingVector'),
        ExtHostTheming: (0, proxyIdentifier_1.$Vw)('ExtHostTheming'),
        ExtHostTunnelService: (0, proxyIdentifier_1.$Vw)('ExtHostTunnelService'),
        ExtHostManagedSockets: (0, proxyIdentifier_1.$Vw)('ExtHostManagedSockets'),
        ExtHostAuthentication: (0, proxyIdentifier_1.$Vw)('ExtHostAuthentication'),
        ExtHostTimeline: (0, proxyIdentifier_1.$Vw)('ExtHostTimeline'),
        ExtHostTesting: (0, proxyIdentifier_1.$Vw)('ExtHostTesting'),
        ExtHostTelemetry: (0, proxyIdentifier_1.$Vw)('ExtHostTelemetry'),
        ExtHostLocalization: (0, proxyIdentifier_1.$Vw)('ExtHostLocalization')
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[84/*vs/workbench/api/common/extHostApiDeprecationService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,5/*vs/workbench/api/common/extHost.protocol*/,16/*vs/workbench/api/common/extHostRpcService*/]), function (require, exports, instantiation_1, log_1, extHostProtocol, extHostRpcService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$tpc = exports.$spc = exports.$rpc = void 0;
    extHostProtocol = __importStar(extHostProtocol);
    exports.$rpc = (0, instantiation_1.$Fi)('IExtHostApiDeprecationService');
    let $spc = class $spc {
        constructor(rpc, c) {
            this.c = c;
            this.a = new Set();
            this.b = rpc.getProxy(extHostProtocol.$KN.MainThreadTelemetry);
        }
        report(apiId, extension, migrationSuggestion) {
            const key = this.d(apiId, extension);
            if (this.a.has(key)) {
                return;
            }
            this.a.add(key);
            if (extension.isUnderDevelopment) {
                this.c.warn(`[Deprecation Warning] '${apiId}' is deprecated. ${migrationSuggestion}`);
            }
            this.b.$publicLog2('extHostDeprecatedApiUsage', {
                extensionId: extension.identifier.value,
                apiId: apiId,
            });
        }
        d(apiId, extension) {
            return `${apiId}-${extension.identifier.value}`;
        }
    };
    exports.$spc = $spc;
    exports.$spc = $spc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, log_1.$ak)
    ], $spc);
    exports.$tpc = Object.freeze(new class {
        report(_apiId, _extension, _warningMessage) {
            // noop
        }
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[211/*vs/workbench/api/common/extHostClipboard*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Gpc = void 0;
    class $Gpc {
        constructor(mainContext) {
            const proxy = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadClipboard);
            this.value = Object.freeze({
                readText() {
                    return proxy.$readText();
                },
                writeText(value) {
                    return proxy.$writeText(value);
                }
            });
        }
    }
    exports.$Gpc = $Gpc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[212/*vs/workbench/api/common/extHostConsoleForwarder*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/objects*/,5/*vs/workbench/api/common/extHost.protocol*/,26/*vs/workbench/api/common/extHostInitDataService*/,16/*vs/workbench/api/common/extHostRpcService*/]), function (require, exports, objects_1, extHost_protocol_1, extHostInitDataService_1, extHostRpcService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Crc = void 0;
    let $Crc = class $Crc {
        constructor(extHostRpc, initData) {
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadConsole);
            this.b = initData.consoleForward.includeStack;
            this.c = initData.consoleForward.logNative;
            // Pass console logging to the outside so that we have it in the main side if told so
            this.d('info', 'log');
            this.d('log', 'log');
            this.d('warn', 'warn');
            this.d('debug', 'debug');
            this.d('error', 'error');
        }
        /**
         * Wraps a console message so that it is transmitted to the renderer. If
         * native logging is turned on, the original console message will be written
         * as well. This is needed since the console methods are "magic" in V8 and
         * are the only methods that allow later introspection of logged variables.
         *
         * The wrapped property is not defined with `writable: false` to avoid
         * throwing errors, but rather a no-op setting. See https://github.com/microsoft/vscode-extension-telemetry/issues/88
         */
        d(method, severity) {
            const that = this;
            const original = console[method];
            Object.defineProperty(console, method, {
                set: () => { },
                get: () => function () {
                    that.e(method, severity, original, arguments);
                },
            });
        }
        e(method, severity, original, args) {
            this.a.$logExtensionHostMessage({
                type: '__$console',
                severity,
                arguments: safeStringifyArgumentsToArray(args, this.b)
            });
            if (this.c) {
                this.f(method, original, args);
            }
        }
    };
    exports.$Crc = $Crc;
    exports.$Crc = $Crc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ)
    ], $Crc);
    const MAX_LENGTH = 100000;
    /**
     * Prevent circular stringify and convert arguments to real array
     */
    function safeStringifyArgumentsToArray(args, includeStack) {
        const argsArray = [];
        // Massage some arguments with special treatment
        if (args.length) {
            for (let i = 0; i < args.length; i++) {
                let arg = args[i];
                // Any argument of type 'undefined' needs to be specially treated because
                // JSON.stringify will simply ignore those. We replace them with the string
                // 'undefined' which is not 100% right, but good enough to be logged to console
                if (typeof arg === 'undefined') {
                    arg = 'undefined';
                }
                // Any argument that is an Error will be changed to be just the error stack/message
                // itself because currently cannot serialize the error over entirely.
                else if (arg instanceof Error) {
                    const errorObj = arg;
                    if (errorObj.stack) {
                        arg = errorObj.stack;
                    }
                    else {
                        arg = errorObj.toString();
                    }
                }
                argsArray.push(arg);
            }
        }
        // Add the stack trace as payload if we are told so. We remove the message and the 2 top frames
        // to start the stacktrace where the console message was being written
        if (includeStack) {
            const stack = new Error().stack;
            if (stack) {
                argsArray.push({ __$stack: stack.split('\n').slice(3).join('\n') });
            }
        }
        try {
            const res = (0, objects_1.$jo)(argsArray);
            if (res.length > MAX_LENGTH) {
                return 'Output omitted for a large object that exceeds the limits';
            }
            return res;
        }
        catch (error) {
            return `Output omitted for an object that cannot be inspected ('${error.toString()}')`;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[213/*vs/workbench/api/common/extHostDialogs*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, uri_1, extHost_protocol_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Iqc = void 0;
    class $Iqc {
        constructor(mainContext) {
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadDialogs);
        }
        showOpenDialog(extension, options) {
            if (options?.allowUIResources) {
                (0, extensions_1.$gH)(extension, 'showLocal');
            }
            return this.a.$showOpenDialog(options).then(filepaths => {
                return filepaths ? filepaths.map(p => uri_1.URI.revive(p)) : undefined;
            });
        }
        showSaveDialog(options) {
            return this.a.$showSaveDialog(options).then(filepath => {
                return filepath ? uri_1.URI.revive(filepath) : undefined;
            });
        }
    }
    exports.$Iqc = $Iqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[214/*vs/workbench/api/common/extHostEmbedding*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, cancellation_1, event_1, lifecycle_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Lqc = void 0;
    class $Lqc {
        constructor(mainContext) {
            this.b = new Map();
            this.c = new event_1.$le();
            this.onDidChange = this.c.event;
            this.d = new Set();
            this.e = 0;
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadEmbeddings);
        }
        registerEmbeddingsProvider(_extension, embeddingsModel, provider) {
            if (this.d.has(embeddingsModel)) {
                throw new Error('An embeddings provider for this model is already registered');
            }
            const handle = this.e++;
            this.a.$registerEmbeddingProvider(handle, embeddingsModel);
            this.b.set(handle, { id: embeddingsModel, provider });
            return (0, lifecycle_1.$Sc)(() => {
                this.d.delete(embeddingsModel);
                this.a.$unregisterEmbeddingProvider(handle);
                this.b.delete(handle);
            });
        }
        async computeEmbeddings(embeddingsModel, input, token) {
            token ??= cancellation_1.CancellationToken.None;
            let returnSingle = false;
            if (typeof input === 'string') {
                input = [input];
                returnSingle = true;
            }
            const result = await this.a.$computeEmbeddings(embeddingsModel, input, token);
            if (result.length !== input.length) {
                throw new Error();
            }
            if (returnSingle) {
                if (result.length !== 1) {
                    throw new Error();
                }
                return result[0];
            }
            return result;
        }
        async $provideEmbeddings(handle, input, token) {
            const data = this.b.get(handle);
            if (!data) {
                return [];
            }
            const result = await data.provider.provideEmbeddings(input, token);
            if (!result) {
                return [];
            }
            return result;
        }
        get embeddingsModels() {
            return Array.from(this.d);
        }
        $acceptEmbeddingModels(models) {
            this.d = new Set(models);
            this.c.fire();
        }
    }
    exports.$Lqc = $Lqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[215/*vs/workbench/api/common/extHostLabelService*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, lifecycle_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$3qc = void 0;
    class $3qc {
        constructor(mainContext) {
            this.b = 0;
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadLabelService);
        }
        $registerResourceLabelFormatter(formatter) {
            const handle = this.b++;
            this.a.$registerResourceLabelFormatter(handle, formatter);
            return (0, lifecycle_1.$Sc)(() => {
                this.a.$unregisterResourceLabelFormatter(handle);
            });
        }
    }
    exports.$3qc = $3qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[85/*vs/workbench/api/common/extHostLocalizationService*/], __M([1/*require*/,0/*exports*/,20/*vs/base/common/platform*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,5/*vs/workbench/api/common/extHost.protocol*/,26/*vs/workbench/api/common/extHostInitDataService*/,16/*vs/workbench/api/common/extHostRpcService*/]), function (require, exports, platform_1, strings_1, uri_1, instantiation_1, log_1, extHost_protocol_1, extHostInitDataService_1, extHostRpcService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$mqc = exports.$lqc = void 0;
    let $lqc = class $lqc {
        constructor(initData, rpc, f) {
            this.f = f;
            this.d = new Map();
            this.a = rpc.getProxy(extHost_protocol_1.$KN.MainThreadLocalization);
            this.b = initData.environment.appLanguage;
            this.c = this.b === platform_1.$h;
        }
        getMessage(extensionId, details) {
            const { message, args, comment } = details;
            if (this.c) {
                return (0, strings_1.$ef)(message, (args ?? {}));
            }
            let key = message;
            if (comment && comment.length > 0) {
                key += `/${Array.isArray(comment) ? comment.join('') : comment}`;
            }
            const str = this.d.get(extensionId)?.contents[key];
            if (!str) {
                this.f.warn(`Using default string since no string found in i18n bundle that has the key: ${key}`);
            }
            return (0, strings_1.$ef)(str ?? message, (args ?? {}));
        }
        getBundle(extensionId) {
            return this.d.get(extensionId)?.contents;
        }
        getBundleUri(extensionId) {
            return this.d.get(extensionId)?.uri;
        }
        async initializeLocalizedMessages(extension) {
            if (this.c
                || (!extension.l10n && !extension.isBuiltin)) {
                return;
            }
            if (this.d.has(extension.identifier.value)) {
                return;
            }
            let contents;
            const bundleUri = await this.g(extension);
            if (!bundleUri) {
                this.f.error(`No bundle location found for extension ${extension.identifier.value}`);
                return;
            }
            try {
                const response = await this.a.$fetchBundleContents(bundleUri);
                const result = JSON.parse(response);
                // 'contents.bundle' is a well-known key in the language pack json file that contains the _code_ translations for the extension
                contents = extension.isBuiltin ? result.contents?.bundle : result;
            }
            catch (e) {
                this.f.error(`Failed to load translations for ${extension.identifier.value} from ${bundleUri}: ${e.message}`);
                return;
            }
            if (contents) {
                this.d.set(extension.identifier.value, {
                    contents,
                    uri: bundleUri
                });
            }
        }
        async g(extension) {
            if (extension.isBuiltin) {
                const uri = await this.a.$fetchBuiltInBundleUri(extension.identifier.value, this.b);
                return uri_1.URI.revive(uri);
            }
            return extension.l10n
                ? uri_1.URI.joinPath(extension.extensionLocation, extension.l10n, `bundle.l10n.${this.b}.json`)
                : undefined;
        }
    };
    exports.$lqc = $lqc;
    exports.$lqc = $lqc = __decorate([
        __param(0, extHostInitDataService_1.$AQ),
        __param(1, extHostRpcService_1.$kQ),
        __param(2, log_1.$ak)
    ], $lqc);
    exports.$mqc = (0, instantiation_1.$Fi)('IExtHostLocalizationService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[216/*vs/workbench/api/common/extHostLoggerService*/], __M([1/*require*/,0/*exports*/,11/*vs/platform/log/common/log*/,5/*vs/workbench/api/common/extHost.protocol*/,26/*vs/workbench/api/common/extHostInitDataService*/,16/*vs/workbench/api/common/extHostRpcService*/,2/*vs/base/common/uri*/,36/*vs/base/common/marshalling*/]), function (require, exports, log_1, extHost_protocol_1, extHostInitDataService_1, extHostRpcService_1, uri_1, marshalling_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Brc = void 0;
    let $Brc = class $Brc extends log_1.$lk {
        constructor(rpc, initData) {
            super(initData.logLevel, initData.logsLocation, initData.loggers.map(logger => (0, marshalling_1.$ci)(logger)));
            this.r = rpc.getProxy(extHost_protocol_1.$KN.MainThreadLogger);
        }
        $setLogLevel(logLevel, resource) {
            if (resource) {
                this.setLogLevel(uri_1.URI.revive(resource), logLevel);
            }
            else {
                this.setLogLevel(logLevel);
            }
        }
        setVisibility(resource, visibility) {
            super.setVisibility(resource, visibility);
            this.r.$setVisibility(resource, visibility);
        }
        s(resource, logLevel, options) {
            return new Logger(this.r, resource, logLevel, options);
        }
    };
    exports.$Brc = $Brc;
    exports.$Brc = $Brc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ)
    ], $Brc);
    class Logger extends log_1.$gk {
        constructor(r, s, logLevel, loggerOptions) {
            super(loggerOptions?.logLevel === 'always');
            this.r = r;
            this.s = s;
            this.m = false;
            this.n = [];
            this.setLevel(logLevel);
            this.r.$createLogger(s, loggerOptions)
                .then(() => {
                this.u(this.n);
                this.m = true;
            });
        }
        g(level, message) {
            const messages = [[level, message]];
            if (this.m) {
                this.u(messages);
            }
            else {
                this.n.push(...messages);
            }
        }
        u(messages) {
            this.r.$log(this.s, messages);
        }
        flush() {
            this.r.$flush(this.s);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[86/*vs/workbench/api/common/extHostManagedSockets*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,3/*vs/platform/instantiation/common/instantiation*/,4/*vs/base/common/lifecycle*/,16/*vs/workbench/api/common/extHostRpcService*/,22/*vs/base/common/buffer*/]), function (require, exports, extHost_protocol_1, instantiation_1, lifecycle_1, extHostRpcService_1, buffer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oqc = exports.$nqc = void 0;
    exports.$nqc = (0, instantiation_1.$Fi)('IExtHostManagedSockets');
    let $oqc = class $oqc {
        constructor(extHostRpc) {
            this.b = 0;
            this.c = null;
            this.d = new Map();
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadManagedSockets);
        }
        setFactory(socketFactoryId, makeConnection) {
            // Terminate all previous sockets
            for (const socket of this.d.values()) {
                // calling dispose() will lead to it removing itself from the map
                socket.dispose();
            }
            // Unregister previous factory
            if (this.c) {
                this.a.$unregisterSocketFactory(this.c.socketFactoryId);
            }
            this.c = new ManagedSocketFactory(socketFactoryId, makeConnection);
            this.a.$registerSocketFactory(this.c.socketFactoryId);
        }
        async $openRemoteSocket(socketFactoryId) {
            if (!this.c || this.c.socketFactoryId !== socketFactoryId) {
                throw new Error(`No socket factory with id ${socketFactoryId}`);
            }
            const id = (++this.b);
            const socket = await this.c.makeConnection();
            const disposable = new lifecycle_1.$Tc();
            this.d.set(id, new ManagedSocket(id, socket, disposable));
            disposable.add((0, lifecycle_1.$Sc)(() => this.d.delete(id)));
            disposable.add(socket.onDidEnd(() => {
                this.a.$onDidManagedSocketEnd(id);
                disposable.dispose();
            }));
            disposable.add(socket.onDidClose(e => {
                this.a.$onDidManagedSocketClose(id, e?.stack ?? e?.message);
                disposable.dispose();
            }));
            disposable.add(socket.onDidReceiveMessage(e => this.a.$onDidManagedSocketHaveData(id, buffer_1.$Ne.wrap(e))));
            return id;
        }
        $remoteSocketWrite(socketId, buffer) {
            this.d.get(socketId)?.actual.send(buffer.buffer);
        }
        $remoteSocketEnd(socketId) {
            const socket = this.d.get(socketId);
            if (socket) {
                socket.actual.end();
                socket.dispose();
            }
        }
        async $remoteSocketDrain(socketId) {
            await this.d.get(socketId)?.actual.drain?.();
        }
    };
    exports.$oqc = $oqc;
    exports.$oqc = $oqc = __decorate([
        __param(0, extHostRpcService_1.$kQ)
    ], $oqc);
    class ManagedSocketFactory {
        constructor(socketFactoryId, makeConnection) {
            this.socketFactoryId = socketFactoryId;
            this.makeConnection = makeConnection;
        }
    }
    class ManagedSocket extends lifecycle_1.$Uc {
        constructor(socketId, actual, disposer) {
            super();
            this.socketId = socketId;
            this.actual = actual;
            this.B(disposer);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[217/*vs/workbench/api/common/extHostMessageService*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,11/*vs/platform/log/common/log*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, extHost_protocol_1, log_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$6qc = void 0;
    function isMessageItem(item) {
        return item && item.title;
    }
    let $6qc = class $6qc {
        constructor(mainContext, b) {
            this.b = b;
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadMessageService);
        }
        showMessage(extension, severity, message, optionsOrFirstItem, rest) {
            const options = {
                source: { identifier: extension.identifier, label: extension.displayName || extension.name }
            };
            let items;
            if (typeof optionsOrFirstItem === 'string' || isMessageItem(optionsOrFirstItem)) {
                items = [optionsOrFirstItem, ...rest];
            }
            else {
                options.modal = optionsOrFirstItem?.modal;
                options.useCustom = optionsOrFirstItem?.useCustom;
                options.detail = optionsOrFirstItem?.detail;
                items = rest;
            }
            if (options.useCustom) {
                (0, extensions_1.$gH)(extension, 'resolvers');
            }
            const commands = [];
            let hasCloseAffordance = false;
            for (let handle = 0; handle < items.length; handle++) {
                const command = items[handle];
                if (typeof command === 'string') {
                    commands.push({ title: command, handle, isCloseAffordance: false });
                }
                else if (typeof command === 'object') {
                    const { title, isCloseAffordance } = command;
                    commands.push({ title, isCloseAffordance: !!isCloseAffordance, handle });
                    if (isCloseAffordance) {
                        if (hasCloseAffordance) {
                            this.b.warn(`[${extension.identifier}] Only one message item can have 'isCloseAffordance':`, command);
                        }
                        else {
                            hasCloseAffordance = true;
                        }
                    }
                }
                else {
                    this.b.warn(`[${extension.identifier}] Invalid message item:`, command);
                }
            }
            return this.a.$showMessage(severity, message, options, commands).then(handle => {
                if (typeof handle === 'number') {
                    return items[handle];
                }
                return undefined;
            });
        }
    };
    exports.$6qc = $6qc;
    exports.$6qc = $6qc = __decorate([
        __param(1, log_1.$ak)
    ], $6qc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[218/*vs/workbench/api/common/extHostProfileContentHandler*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,24/*vs/workbench/services/extensions/common/extensions*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, lifecycle_1, types_1, uri_1, extensions_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$crc = void 0;
    class $crc {
        constructor(mainContext) {
            this.b = new Map();
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadProfileContentHandlers);
        }
        registerProfileContentHandler(extension, id, handler) {
            (0, extensions_1.$gH)(extension, 'profileContentHandlers');
            if (this.b.has(id)) {
                throw new Error(`Handler with id '${id}' already registered`);
            }
            this.b.set(id, handler);
            this.a.$registerProfileContentHandler(id, handler.name, handler.description, extension.identifier.value);
            return (0, lifecycle_1.$Sc)(() => {
                this.b.delete(id);
                this.a.$unregisterProfileContentHandler(id);
            });
        }
        async $saveProfile(id, name, content, token) {
            const handler = this.b.get(id);
            if (!handler) {
                throw new Error(`Unknown handler with id: ${id}`);
            }
            return handler.saveProfile(name, content, token);
        }
        async $readProfile(id, idOrUri, token) {
            const handler = this.b.get(id);
            if (!handler) {
                throw new Error(`Unknown handler with id: ${id}`);
            }
            return handler.readProfile((0, types_1.$eg)(idOrUri) ? idOrUri : uri_1.URI.revive(idOrUri), token);
        }
    }
    exports.$crc = $crc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[87/*vs/workbench/api/common/extHostSecretState*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,6/*vs/base/common/event*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, extHost_protocol_1, event_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$jqc = exports.$iqc = void 0;
    class $iqc {
        constructor(mainContext) {
            this.b = new event_1.$le();
            this.onDidChangePassword = this.b.event;
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadSecretState);
        }
        async $onDidChangePassword(e) {
            this.b.fire(e);
        }
        get(extensionId, key) {
            return this.a.$getPassword(extensionId, key);
        }
        store(extensionId, key, value) {
            return this.a.$setPassword(extensionId, key, value);
        }
        delete(extensionId, key) {
            return this.a.$deletePassword(extensionId, key);
        }
    }
    exports.$iqc = $iqc;
    exports.$jqc = (0, instantiation_1.$Fi)('IExtHostSecretState');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[219/*vs/workbench/api/common/extHostSpeech*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/cancellation*/,4/*vs/base/common/lifecycle*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, cancellation_1, lifecycle_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$jrc = void 0;
    class $jrc {
        static { this.a = 1; }
        constructor(mainContext) {
            this.c = new Map();
            this.d = new Map();
            this.f = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadSpeech);
        }
        async $createSpeechToTextSession(handle, session, language) {
            const provider = this.c.get(handle);
            if (!provider) {
                return;
            }
            const disposables = new lifecycle_1.$Tc();
            const cts = new cancellation_1.$we();
            this.d.set(session, cts);
            const speechToTextSession = await provider.provideSpeechToTextSession(cts.token, language ? { language } : undefined);
            if (!speechToTextSession) {
                return;
            }
            disposables.add(speechToTextSession.onDidChange(e => {
                if (cts.token.isCancellationRequested) {
                    return;
                }
                this.b.$emitSpeechToTextEvent(session, e);
            }));
            disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));
        }
        async $cancelSpeechToTextSession(session) {
            this.d.get(session)?.dispose(true);
            this.d.delete(session);
        }
        async $createTextToSpeechSession(handle, session, language) {
            const provider = this.c.get(handle);
            if (!provider) {
                return;
            }
            const disposables = new lifecycle_1.$Tc();
            const cts = new cancellation_1.$we();
            this.d.set(session, cts);
            const textToSpeech = await provider.provideTextToSpeechSession(cts.token, language ? { language } : undefined);
            if (!textToSpeech) {
                return;
            }
            this.f.set(session, textToSpeech);
            disposables.add(textToSpeech.onDidChange(e => {
                if (cts.token.isCancellationRequested) {
                    return;
                }
                this.b.$emitTextToSpeechEvent(session, e);
            }));
            disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));
        }
        async $synthesizeSpeech(session, text) {
            this.f.get(session)?.synthesize(text);
        }
        async $cancelTextToSpeechSession(session) {
            this.d.get(session)?.dispose(true);
            this.d.delete(session);
            this.f.delete(session);
        }
        async $createKeywordRecognitionSession(handle, session) {
            const provider = this.c.get(handle);
            if (!provider) {
                return;
            }
            const disposables = new lifecycle_1.$Tc();
            const cts = new cancellation_1.$we();
            this.d.set(session, cts);
            const keywordRecognitionSession = await provider.provideKeywordRecognitionSession(cts.token);
            if (!keywordRecognitionSession) {
                return;
            }
            disposables.add(keywordRecognitionSession.onDidChange(e => {
                if (cts.token.isCancellationRequested) {
                    return;
                }
                this.b.$emitKeywordRecognitionEvent(session, e);
            }));
            disposables.add(cts.token.onCancellationRequested(() => disposables.dispose()));
        }
        async $cancelKeywordRecognitionSession(session) {
            this.d.get(session)?.dispose(true);
            this.d.delete(session);
        }
        registerProvider(extension, identifier, provider) {
            const handle = $jrc.a++;
            this.c.set(handle, provider);
            this.b.$registerProvider(handle, identifier, { extension, displayName: extension.value });
            return (0, lifecycle_1.$Sc)(() => {
                this.b.$unregisterProvider(handle);
                this.c.delete(handle);
            });
        }
    }
    exports.$jrc = $jrc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[88/*vs/workbench/api/common/extHostStorage*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,6/*vs/base/common/event*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, extHost_protocol_1, event_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$_pc = exports.$$pc = void 0;
    class $$pc {
        constructor(mainContext, c) {
            this.c = c;
            this.b = new event_1.$le();
            this.onDidChangeStorage = this.b.event;
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadStorage);
        }
        registerExtensionStorageKeysToSync(extension, keys) {
            this.a.$registerExtensionStorageKeysToSync(extension, keys);
        }
        async initializeExtensionStorage(shared, key, defaultValue) {
            const value = await this.a.$initializeExtensionStorage(shared, key);
            let parsedValue;
            if (value) {
                parsedValue = this.d(shared, key, value);
            }
            return parsedValue || defaultValue;
        }
        setValue(shared, key, value) {
            return this.a.$setValue(shared, key, value);
        }
        $acceptValue(shared, key, value) {
            const parsedValue = this.d(shared, key, value);
            if (parsedValue) {
                this.b.fire({ shared, key, value: parsedValue });
            }
        }
        d(shared, key, value) {
            try {
                return JSON.parse(value);
            }
            catch (error) {
                // Do not fail this call but log it for diagnostics
                // https://github.com/microsoft/vscode/issues/132777
                this.c.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${key}, global: ${shared}): ${error}`);
            }
            return undefined;
        }
    }
    exports.$$pc = $$pc;
    exports.$_pc = (0, instantiation_1.$Fi)('IExtHostStorage');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[220/*vs/workbench/api/common/extHostUriOpener*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,15/*vs/base/common/network*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, lifecycle_1, network_1, uri_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vrc = void 0;
    class $vrc {
        static { this.a = new Set([network_1.Schemas.http, network_1.Schemas.https]); }
        constructor(mainContext) {
            this.c = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadUriOpeners);
        }
        registerExternalUriOpener(extensionId, id, opener, metadata) {
            if (this.c.has(id)) {
                throw new Error(`Opener with id '${id}' already registered`);
            }
            const invalidScheme = metadata.schemes.find(scheme => !$vrc.a.has(scheme));
            if (invalidScheme) {
                throw new Error(`Scheme '${invalidScheme}' is not supported. Only http and https are currently supported.`);
            }
            this.c.set(id, opener);
            this.b.$registerUriOpener(id, metadata.schemes, extensionId, metadata.label);
            return (0, lifecycle_1.$Sc)(() => {
                this.c.delete(id);
                this.b.$unregisterUriOpener(id);
            });
        }
        async $canOpenUri(id, uriComponents, token) {
            const opener = this.c.get(id);
            if (!opener) {
                throw new Error(`Unknown opener with id: ${id}`);
            }
            const uri = uri_1.URI.revive(uriComponents);
            return opener.canOpenExternalUri(uri, token);
        }
        async $openUri(id, context, token) {
            const opener = this.c.get(id);
            if (!opener) {
                throw new Error(`Unknown opener id: '${id}'`);
            }
            return opener.openExternalUri(uri_1.URI.revive(context.resolvedUri), {
                sourceUri: uri_1.URI.revive(context.sourceUri)
            }, token);
        }
    }
    exports.$vrc = $vrc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[221/*vs/workbench/api/common/extHostUrls*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,2/*vs/base/common/uri*/,4/*vs/base/common/lifecycle*/,13/*vs/base/common/errors*/,18/*vs/platform/extensions/common/extensions*/]), function (require, exports, extHost_protocol_1, uri_1, lifecycle_1, errors_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$wrc = void 0;
    class $wrc {
        static { this.a = 0; }
        constructor(mainContext) {
            this.c = new extensions_1.$sn();
            this.d = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadUrls);
        }
        registerUriHandler(extension, handler) {
            const extensionId = extension.identifier;
            if (this.c.has(extensionId)) {
                throw new Error(`Protocol handler already registered for extension ${extensionId}`);
            }
            const handle = $wrc.a++;
            this.c.add(extensionId);
            this.d.set(handle, handler);
            this.b.$registerUriHandler(handle, extensionId, extension.displayName || extension.name);
            return (0, lifecycle_1.$Sc)(() => {
                this.c.delete(extensionId);
                this.d.delete(handle);
                this.b.$unregisterUriHandler(handle);
            });
        }
        $handleExternalUri(handle, uri) {
            const handler = this.d.get(handle);
            if (!handler) {
                return Promise.resolve(undefined);
            }
            try {
                handler.handleUri(uri_1.URI.revive(uri));
            }
            catch (err) {
                (0, errors_1.$Y)(err);
            }
            return Promise.resolve(undefined);
        }
        async createAppUri(uri) {
            return uri_1.URI.revive(await this.b.$createAppUri(uri));
        }
    }
    exports.$wrc = $wrc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[222/*vs/workbench/api/common/extHostWebviewMessaging*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, buffer_1, extHostProtocol) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ttb = $Ttb;
    exports.$Utb = $Utb;
    extHostProtocol = __importStar(extHostProtocol);
    class ArrayBufferSet {
        constructor() {
            this.buffers = [];
        }
        add(buffer) {
            let index = this.buffers.indexOf(buffer);
            if (index < 0) {
                index = this.buffers.length;
                this.buffers.push(buffer);
            }
            return index;
        }
    }
    function $Ttb(message, options) {
        if (options.serializeBuffersForPostMessage) {
            // Extract all ArrayBuffers from the message and replace them with references.
            const arrayBuffers = new ArrayBufferSet();
            const replacer = (_key, value) => {
                if (value instanceof ArrayBuffer) {
                    const index = arrayBuffers.add(value);
                    return {
                        $$vscode_array_buffer_reference$$: true,
                        index,
                    };
                }
                else if (ArrayBuffer.isView(value)) {
                    const type = getTypedArrayType(value);
                    if (type) {
                        const index = arrayBuffers.add(value.buffer);
                        return {
                            $$vscode_array_buffer_reference$$: true,
                            index,
                            view: {
                                type: type,
                                byteLength: value.byteLength,
                                byteOffset: value.byteOffset,
                            }
                        };
                    }
                }
                return value;
            };
            const serializedMessage = JSON.stringify(message, replacer);
            const buffers = arrayBuffers.buffers.map(arrayBuffer => {
                const bytes = new Uint8Array(arrayBuffer);
                return buffer_1.$Ne.wrap(bytes);
            });
            return { message: serializedMessage, buffers };
        }
        else {
            return { message: JSON.stringify(message), buffers: [] };
        }
    }
    function getTypedArrayType(value) {
        switch (value.constructor.name) {
            case 'Int8Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Int8Array;
            case 'Uint8Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Uint8Array;
            case 'Uint8ClampedArray': return extHostProtocol.WebviewMessageArrayBufferViewType.Uint8ClampedArray;
            case 'Int16Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Int16Array;
            case 'Uint16Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Uint16Array;
            case 'Int32Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Int32Array;
            case 'Uint32Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Uint32Array;
            case 'Float32Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Float32Array;
            case 'Float64Array': return extHostProtocol.WebviewMessageArrayBufferViewType.Float64Array;
            case 'BigInt64Array': return extHostProtocol.WebviewMessageArrayBufferViewType.BigInt64Array;
            case 'BigUint64Array': return extHostProtocol.WebviewMessageArrayBufferViewType.BigUint64Array;
        }
        return undefined;
    }
    function $Utb(jsonMessage, buffers) {
        const arrayBuffers = buffers.map(buffer => {
            const arrayBuffer = new ArrayBuffer(buffer.byteLength);
            const uint8Array = new Uint8Array(arrayBuffer);
            uint8Array.set(buffer.buffer);
            return arrayBuffer;
        });
        const reviver = !buffers.length ? undefined : (_key, value) => {
            if (value && typeof value === 'object' && value.$$vscode_array_buffer_reference$$) {
                const ref = value;
                const { index } = ref;
                const arrayBuffer = arrayBuffers[index];
                if (ref.view) {
                    switch (ref.view.type) {
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Int8Array: return new Int8Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Int8Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Uint8Array: return new Uint8Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Uint8ClampedArray: return new Uint8ClampedArray(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Int16Array: return new Int16Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Int16Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Uint16Array: return new Uint16Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Int32Array: return new Int32Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Int32Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Uint32Array: return new Uint32Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Float32Array: return new Float32Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Float32Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.Float64Array: return new Float64Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / Float64Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.BigInt64Array: return new BigInt64Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT);
                        case extHostProtocol.WebviewMessageArrayBufferViewType.BigUint64Array: return new BigUint64Array(arrayBuffer, ref.view.byteOffset, ref.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT);
                        default: throw new Error('Unknown array buffer view type');
                    }
                }
                return arrayBuffer;
            }
            return value;
        };
        const message = JSON.parse(jsonMessage, reviver);
        return { message, arrayBuffers };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[67/*vs/workbench/api/common/extHostWebview*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,15/*vs/base/common/network*/,25/*vs/base/common/objects*/,2/*vs/base/common/uri*/,175/*vs/platform/extensions/common/extensionValidator*/,222/*vs/workbench/api/common/extHostWebviewMessaging*/,82/*vs/workbench/contrib/webview/common/webview*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, event_1, lifecycle_1, network_1, objects, uri_1, extensionValidator_1, extHostWebviewMessaging_1, webview_1, extHostProtocol) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Xpc = exports.$Vpc = void 0;
    exports.$Wpc = $Wpc;
    exports.$Ypc = $Ypc;
    exports.$Zpc = $Zpc;
    objects = __importStar(objects);
    extHostProtocol = __importStar(extHostProtocol);
    class $Vpc {
        #handle;
        #proxy;
        #deprecationService;
        #remoteInfo;
        #workspace;
        #extension;
        #html;
        #options;
        #isDisposed;
        #hasCalledAsWebviewUri;
        #serializeBuffersForPostMessage;
        #shouldRewriteOldResourceUris;
        constructor(handle, proxy, options, remoteInfo, workspace, extension, deprecationService) {
            this.#html = '';
            this.#isDisposed = false;
            this.#hasCalledAsWebviewUri = false;
            /* internal */ this._onMessageEmitter = new event_1.$le();
            this.onDidReceiveMessage = this._onMessageEmitter.event;
            this.#onDidDisposeEmitter = new event_1.$le();
            /* internal */ this._onDidDispose = this.#onDidDisposeEmitter.event;
            this.#handle = handle;
            this.#proxy = proxy;
            this.#options = options;
            this.#remoteInfo = remoteInfo;
            this.#workspace = workspace;
            this.#extension = extension;
            this.#serializeBuffersForPostMessage = $Wpc(extension);
            this.#shouldRewriteOldResourceUris = shouldTryRewritingOldResourceUris(extension);
            this.#deprecationService = deprecationService;
        }
        #onDidDisposeEmitter;
        dispose() {
            this.#isDisposed = true;
            this.#onDidDisposeEmitter.fire();
            this.#onDidDisposeEmitter.dispose();
            this._onMessageEmitter.dispose();
        }
        asWebviewUri(resource) {
            this.#hasCalledAsWebviewUri = true;
            return (0, webview_1.$EDb)(resource, this.#remoteInfo);
        }
        get cspSource() {
            const extensionLocation = this.#extension.extensionLocation;
            if (extensionLocation.scheme === network_1.Schemas.https || extensionLocation.scheme === network_1.Schemas.http) {
                // The extension is being served up from a CDN.
                // Also include the CDN in the default csp.
                let extensionCspRule = extensionLocation.toString();
                if (!extensionCspRule.endsWith('/')) {
                    // Always treat the location as a directory so that we allow all content under it
                    extensionCspRule += '/';
                }
                return extensionCspRule + ' ' + webview_1.$DDb;
            }
            return webview_1.$DDb;
        }
        get html() {
            this.a();
            return this.#html;
        }
        set html(value) {
            this.a();
            if (this.#html !== value) {
                this.#html = value;
                if (this.#shouldRewriteOldResourceUris && !this.#hasCalledAsWebviewUri && /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(value)) {
                    this.#hasCalledAsWebviewUri = true;
                    this.#deprecationService.report('Webview vscode-resource: uris', this.#extension, `Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri`);
                }
                this.#proxy.$setHtml(this.#handle, this.b(value));
            }
        }
        get options() {
            this.a();
            return this.#options;
        }
        set options(newOptions) {
            this.a();
            if (!objects.$io(this.#options, newOptions)) {
                this.#proxy.$setOptions(this.#handle, $Zpc(this.#extension, this.#workspace, newOptions));
            }
            this.#options = newOptions;
        }
        async postMessage(message) {
            if (this.#isDisposed) {
                return false;
            }
            const serialized = (0, extHostWebviewMessaging_1.$Ttb)(message, { serializeBuffersForPostMessage: this.#serializeBuffersForPostMessage });
            return this.#proxy.$postMessage(this.#handle, serialized.message, ...serialized.buffers);
        }
        a() {
            if (this.#isDisposed) {
                throw new Error('Webview is disposed');
            }
        }
        b(value) {
            if (!this.#shouldRewriteOldResourceUris) {
                return value;
            }
            const isRemote = this.#extension.extensionLocation?.scheme === network_1.Schemas.vscodeRemote;
            const remoteAuthority = this.#extension.extensionLocation.scheme === network_1.Schemas.vscodeRemote ? this.#extension.extensionLocation.authority : undefined;
            return value
                .replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {
                const uri = uri_1.URI.from({
                    scheme: scheme || 'file',
                    path: decodeURIComponent(path),
                });
                const webviewUri = (0, webview_1.$EDb)(uri, { isRemote, authority: remoteAuthority }).toString();
                return `${startQuote}${webviewUri}${endQuote}`;
            })
                .replace(/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_match, startQuote, _1, scheme, path, endQuote) => {
                const uri = uri_1.URI.from({
                    scheme: scheme || 'file',
                    path: decodeURIComponent(path),
                });
                const webviewUri = (0, webview_1.$EDb)(uri, { isRemote, authority: remoteAuthority }).toString();
                return `${startQuote}${webviewUri}${endQuote}`;
            });
        }
    }
    exports.$Vpc = $Vpc;
    function $Wpc(extension) {
        try {
            const version = (0, extensionValidator_1.$2p)((0, extensionValidator_1.$1p)(extension.engines.vscode));
            return !!version && version.majorBase >= 1 && version.minorBase >= 57;
        }
        catch {
            return false;
        }
    }
    function shouldTryRewritingOldResourceUris(extension) {
        try {
            const version = (0, extensionValidator_1.$2p)((0, extensionValidator_1.$1p)(extension.engines.vscode));
            if (!version) {
                return false;
            }
            return version.majorBase < 1 || (version.majorBase === 1 && version.minorBase < 60);
        }
        catch {
            return false;
        }
    }
    class $Xpc extends lifecycle_1.$Uc {
        constructor(mainContext, c, f, g, h) {
            super();
            this.c = c;
            this.f = f;
            this.g = g;
            this.h = h;
            this.b = new Map();
            this.a = mainContext.getProxy(extHostProtocol.$KN.MainThreadWebviews);
        }
        dispose() {
            super.dispose();
            for (const webview of this.b.values()) {
                webview.dispose();
            }
            this.b.clear();
        }
        $onMessage(handle, jsonMessage, buffers) {
            const webview = this.j(handle);
            if (webview) {
                const { message } = (0, extHostWebviewMessaging_1.$Utb)(jsonMessage, buffers.value);
                webview._onMessageEmitter.fire(message);
            }
        }
        $onMissingCsp(_handle, extensionId) {
            this.g.warn(`${extensionId} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`);
        }
        createNewWebview(handle, options, extension) {
            const webview = new $Vpc(handle, this.a, reviveOptions(options), this.c, this.f, extension, this.h);
            this.b.set(handle, webview);
            const sub = webview._onDidDispose(() => {
                sub.dispose();
                this.deleteWebview(handle);
            });
            return webview;
        }
        deleteWebview(handle) {
            this.b.delete(handle);
        }
        j(handle) {
            return this.b.get(handle);
        }
    }
    exports.$Xpc = $Xpc;
    function $Ypc(extension) {
        return { id: extension.identifier, location: extension.extensionLocation };
    }
    function $Zpc(extension, workspace, options) {
        return {
            enableCommandUris: options.enableCommandUris,
            enableScripts: options.enableScripts,
            enableForms: options.enableForms,
            portMapping: options.portMapping,
            localResourceRoots: options.localResourceRoots || getDefaultLocalResourceRoots(extension, workspace)
        };
    }
    function reviveOptions(options) {
        return {
            enableCommandUris: options.enableCommandUris,
            enableScripts: options.enableScripts,
            enableForms: options.enableForms,
            portMapping: options.portMapping,
            localResourceRoots: options.localResourceRoots?.map(components => uri_1.URI.from(components)),
        };
    }
    function getDefaultLocalResourceRoots(extension, workspace) {
        return [
            ...(workspace?.getWorkspaceFolders() || []).map(x => x.uri),
            extension.extensionLocation,
        ];
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[121/*vs/workbench/api/common/extHostWindow*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,15/*vs/base/common/network*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, event_1, network_1, strings_1, uri_1, instantiation_1, extHostRpcService_1, extHost_protocol_1) {
    "use strict";
    var $yrc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$zrc = exports.$yrc = void 0;
    let $yrc = class $yrc {
        static { $yrc_1 = this; }
        static { this.a = {
            focused: true,
            active: true,
        }; }
        getState() {
            // todo@connor4312: this can be changed to just return this._state after proposed api is finalized
            const state = this.d;
            return {
                get focused() {
                    return state.focused;
                },
                get active() {
                    return state.active;
                },
            };
        }
        constructor(extHostRpc) {
            this.c = new event_1.$le();
            this.onDidChangeWindowState = this.c.event;
            this.d = $yrc_1.a;
            this.b = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadWindow);
            this.b.$getInitialState().then(({ isFocused, isActive }) => {
                this.onDidChangeWindowProperty('focused', isFocused);
                this.onDidChangeWindowProperty('active', isActive);
            });
        }
        $onDidChangeWindowFocus(value) {
            this.onDidChangeWindowProperty('focused', value);
        }
        $onDidChangeWindowActive(value) {
            this.onDidChangeWindowProperty('active', value);
        }
        onDidChangeWindowProperty(property, value) {
            if (value === this.d[property]) {
                return;
            }
            this.d = { ...this.d, [property]: value };
            this.c.fire(this.d);
        }
        openUri(stringOrUri, options) {
            let uriAsString;
            if (typeof stringOrUri === 'string') {
                uriAsString = stringOrUri;
                try {
                    stringOrUri = uri_1.URI.parse(stringOrUri);
                }
                catch (e) {
                    return Promise.reject(`Invalid uri - '${stringOrUri}'`);
                }
            }
            if ((0, strings_1.$cf)(stringOrUri.scheme)) {
                return Promise.reject('Invalid scheme - cannot be empty');
            }
            else if (stringOrUri.scheme === network_1.Schemas.command) {
                return Promise.reject(`Invalid scheme '${stringOrUri.scheme}'`);
            }
            return this.b.$openUri(stringOrUri, uriAsString, options);
        }
        async asExternalUri(uri, options) {
            if ((0, strings_1.$cf)(uri.scheme)) {
                return Promise.reject('Invalid scheme - cannot be empty');
            }
            const result = await this.b.$asExternalUri(uri, options);
            return uri_1.URI.from(result);
        }
    };
    exports.$yrc = $yrc;
    exports.$yrc = $yrc = $yrc_1 = __decorate([
        __param(0, extHostRpcService_1.$kQ)
    ], $yrc);
    exports.$zrc = (0, instantiation_1.$Fi)('IExtHostWindow');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[223/*vs/workbench/api/worker/extHostConsoleForwarder*/], __M([1/*require*/,0/*exports*/,212/*vs/workbench/api/common/extHostConsoleForwarder*/,26/*vs/workbench/api/common/extHostInitDataService*/,16/*vs/workbench/api/common/extHostRpcService*/]), function (require, exports, extHostConsoleForwarder_1, extHostInitDataService_1, extHostRpcService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ntc = void 0;
    let $Ntc = class $Ntc extends extHostConsoleForwarder_1.$Crc {
        constructor(extHostRpc, initData) {
            super(extHostRpc, initData);
        }
        f(_method, original, args) {
            original.apply(console, args);
        }
    };
    exports.$Ntc = $Ntc;
    exports.$Ntc = $Ntc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ)
    ], $Ntc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[224/*vs/workbench/services/extensions/common/rpcProtocol*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,22/*vs/base/common/buffer*/,21/*vs/base/common/cancellation*/,27/*vs/base/common/charCode*/,13/*vs/base/common/errors*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,37/*vs/base/common/marshallingIds*/,150/*vs/base/common/uriIpc*/,210/*vs/workbench/services/extensions/common/lazyPromise*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/]), function (require, exports, async_1, buffer_1, cancellation_1, charCode_1, errors, event_1, lifecycle_1, marshallingIds_1, uriIpc_1, lazyPromise_1, proxyIdentifier_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Udc = exports.ResponsiveState = exports.RequestInitiator = void 0;
    exports.$Sdc = $Sdc;
    exports.$Tdc = $Tdc;
    errors = __importStar(errors);
    function safeStringify(obj, replacer) {
        try {
            return JSON.stringify(obj, replacer);
        }
        catch (err) {
            return 'null';
        }
    }
    const refSymbolName = '$$ref$$';
    const undefinedRef = { [refSymbolName]: -1 };
    class StringifiedJsonWithBufferRefs {
        constructor(jsonString, referencedBuffers) {
            this.jsonString = jsonString;
            this.referencedBuffers = referencedBuffers;
        }
    }
    function $Sdc(obj, replacer = null, useSafeStringify = false) {
        const foundBuffers = [];
        const serialized = (useSafeStringify ? safeStringify : JSON.stringify)(obj, (key, value) => {
            if (typeof value === 'undefined') {
                return undefinedRef; // JSON.stringify normally converts 'undefined' to 'null'
            }
            else if (typeof value === 'object') {
                if (value instanceof buffer_1.$Ne) {
                    const bufferIndex = foundBuffers.push(value) - 1;
                    return { [refSymbolName]: bufferIndex };
                }
                if (replacer) {
                    return replacer(key, value);
                }
            }
            return value;
        });
        return {
            jsonString: serialized,
            referencedBuffers: foundBuffers
        };
    }
    function $Tdc(jsonString, buffers, uriTransformer) {
        return JSON.parse(jsonString, (_key, value) => {
            if (value) {
                const ref = value[refSymbolName];
                if (typeof ref === 'number') {
                    return buffers[ref];
                }
                if (uriTransformer && value.$mid === marshallingIds_1.MarshalledId.Uri) {
                    return uriTransformer.transformIncoming(value);
                }
            }
            return value;
        });
    }
    function stringify(obj, replacer) {
        return JSON.stringify(obj, replacer);
    }
    function createURIReplacer(transformer) {
        if (!transformer) {
            return null;
        }
        return (key, value) => {
            if (value && value.$mid === marshallingIds_1.MarshalledId.Uri) {
                return transformer.transformOutgoing(value);
            }
            return value;
        };
    }
    var RequestInitiator;
    (function (RequestInitiator) {
        RequestInitiator[RequestInitiator["LocalSide"] = 0] = "LocalSide";
        RequestInitiator[RequestInitiator["OtherSide"] = 1] = "OtherSide";
    })(RequestInitiator || (exports.RequestInitiator = RequestInitiator = {}));
    var ResponsiveState;
    (function (ResponsiveState) {
        ResponsiveState[ResponsiveState["Responsive"] = 0] = "Responsive";
        ResponsiveState[ResponsiveState["Unresponsive"] = 1] = "Unresponsive";
    })(ResponsiveState || (exports.ResponsiveState = ResponsiveState = {}));
    const noop = () => { };
    const _RPCProtocolSymbol = Symbol.for('rpcProtocol');
    const _RPCProxySymbol = Symbol.for('rpcProxy');
    class $Udc extends lifecycle_1.$Uc {
        static { _a = _RPCProtocolSymbol; }
        static { this.a = 3 * 1000; } // 3s
        constructor(protocol, logger = null, transformer = null) {
            super();
            this[_a] = true;
            this.b = this.B(new event_1.$le());
            this.onDidChangeResponsiveState = this.b.event;
            this.c = protocol;
            this.f = logger;
            this.g = transformer;
            this.h = createURIReplacer(this.g);
            this.j = false;
            this.m = [];
            this.s = [];
            for (let i = 0, len = proxyIdentifier_1.$Uw.count; i < len; i++) {
                this.m[i] = null;
                this.s[i] = null;
            }
            this.t = 0;
            this.u = Object.create(null);
            this.w = {};
            this.y = ResponsiveState.Responsive;
            this.z = 0;
            this.C = 0;
            this.D = this.B(new async_1.$Rh(() => this.H(), 1000));
            this.B(this.c.onMessage((msg) => this.L(msg)));
        }
        dispose() {
            this.j = true;
            // Release all outstanding promises with a canceled error
            Object.keys(this.w).forEach((msgId) => {
                const pending = this.w[msgId];
                delete this.w[msgId];
                pending.resolveErr(errors.$5());
            });
            super.dispose();
        }
        drain() {
            if (typeof this.c.drain === 'function') {
                return this.c.drain();
            }
            return Promise.resolve();
        }
        F(req) {
            if (this.z === 0) {
                // Since this is the first request we are sending in a while,
                // mark this moment as the start for the countdown to unresponsive time
                this.C = Date.now() + $Udc.a;
            }
            this.z++;
            if (!this.D.isScheduled()) {
                this.D.schedule();
            }
        }
        G(req) {
            // The next possible unresponsive time is now + delta.
            this.C = Date.now() + $Udc.a;
            this.z--;
            if (this.z === 0) {
                // No more need to check for unresponsive
                this.D.cancel();
            }
            // The ext host is responsive!
            this.I(ResponsiveState.Responsive);
        }
        H() {
            if (this.z === 0) {
                // Not waiting for anything => cannot say if it is responsive or not
                return;
            }
            if (Date.now() > this.C) {
                // Unresponsive!!
                this.I(ResponsiveState.Unresponsive);
            }
            else {
                // Not (yet) unresponsive, be sure to check again soon
                this.D.schedule();
            }
        }
        I(newResponsiveState) {
            if (this.y === newResponsiveState) {
                // no change
                return;
            }
            this.y = newResponsiveState;
            this.b.fire(this.y);
        }
        get responsiveState() {
            return this.y;
        }
        transformIncomingURIs(obj) {
            if (!this.g) {
                return obj;
            }
            return (0, uriIpc_1.$Pn)(obj, this.g);
        }
        getProxy(identifier) {
            const { nid: rpcId, sid } = identifier;
            if (!this.s[rpcId]) {
                this.s[rpcId] = this.J(rpcId, sid);
            }
            return this.s[rpcId];
        }
        J(rpcId, debugName) {
            const handler = {
                get: (target, name) => {
                    if (typeof name === 'string' && !target[name] && name.charCodeAt(0) === charCode_1.CharCode.DollarSign) {
                        target[name] = (...myArgs) => {
                            return this.U(rpcId, name, myArgs);
                        };
                    }
                    if (name === _RPCProxySymbol) {
                        return debugName;
                    }
                    return target[name];
                }
            };
            return new Proxy(Object.create(null), handler);
        }
        set(identifier, value) {
            this.m[identifier.nid] = value;
            return value;
        }
        assertRegistered(identifiers) {
            for (let i = 0, len = identifiers.length; i < len; i++) {
                const identifier = identifiers[i];
                if (!this.m[identifier.nid]) {
                    throw new Error(`Missing proxy instance ${identifier.sid}`);
                }
            }
        }
        L(rawmsg) {
            if (this.j) {
                return;
            }
            const msgLength = rawmsg.byteLength;
            const buff = MessageBuffer.read(rawmsg, 0);
            const messageType = buff.readUInt8();
            const req = buff.readUInt32();
            switch (messageType) {
                case MessageType.RequestJSONArgs:
                case MessageType.RequestJSONArgsWithCancellation: {
                    let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);
                    if (this.g) {
                        args = (0, uriIpc_1.$Pn)(args, this.g);
                    }
                    this.M(msgLength, req, rpcId, method, args, (messageType === MessageType.RequestJSONArgsWithCancellation));
                    break;
                }
                case MessageType.RequestMixedArgs:
                case MessageType.RequestMixedArgsWithCancellation: {
                    let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);
                    if (this.g) {
                        args = (0, uriIpc_1.$Pn)(args, this.g);
                    }
                    this.M(msgLength, req, rpcId, method, args, (messageType === MessageType.RequestMixedArgsWithCancellation));
                    break;
                }
                case MessageType.Acknowledged: {
                    this.f?.logIncoming(msgLength, req, RequestInitiator.LocalSide, `ack`);
                    this.G(req);
                    break;
                }
                case MessageType.Cancel: {
                    this.N(msgLength, req);
                    break;
                }
                case MessageType.ReplyOKEmpty: {
                    this.O(msgLength, req, undefined);
                    break;
                }
                case MessageType.ReplyOKJSON: {
                    let value = MessageIO.deserializeReplyOKJSON(buff);
                    if (this.g) {
                        value = (0, uriIpc_1.$Pn)(value, this.g);
                    }
                    this.O(msgLength, req, value);
                    break;
                }
                case MessageType.ReplyOKJSONWithBuffers: {
                    const value = MessageIO.deserializeReplyOKJSONWithBuffers(buff, this.g);
                    this.O(msgLength, req, value);
                    break;
                }
                case MessageType.ReplyOKVSBuffer: {
                    const value = MessageIO.deserializeReplyOKVSBuffer(buff);
                    this.O(msgLength, req, value);
                    break;
                }
                case MessageType.ReplyErrError: {
                    let err = MessageIO.deserializeReplyErrError(buff);
                    if (this.g) {
                        err = (0, uriIpc_1.$Pn)(err, this.g);
                    }
                    this.P(msgLength, req, err);
                    break;
                }
                case MessageType.ReplyErrEmpty: {
                    this.P(msgLength, req, undefined);
                    break;
                }
                default:
                    console.error(`received unexpected message`);
                    console.error(rawmsg);
            }
        }
        M(msgLength, req, rpcId, method, args, usesCancellationToken) {
            this.f?.logIncoming(msgLength, req, RequestInitiator.OtherSide, `receiveRequest ${(0, proxyIdentifier_1.$Ww)(rpcId)}.${method}(`, args);
            const callId = String(req);
            let promise;
            let cancel;
            if (usesCancellationToken) {
                const cancellationTokenSource = new cancellation_1.$we();
                args.push(cancellationTokenSource.token);
                promise = this.Q(rpcId, method, args);
                cancel = () => cancellationTokenSource.cancel();
            }
            else {
                // cannot be cancelled
                promise = this.Q(rpcId, method, args);
                cancel = noop;
            }
            this.u[callId] = cancel;
            // Acknowledge the request
            const msg = MessageIO.serializeAcknowledged(req);
            this.f?.logOutgoing(msg.byteLength, req, RequestInitiator.OtherSide, `ack`);
            this.c.send(msg);
            promise.then((r) => {
                delete this.u[callId];
                const msg = MessageIO.serializeReplyOK(req, r, this.h);
                this.f?.logOutgoing(msg.byteLength, req, RequestInitiator.OtherSide, `reply:`, r);
                this.c.send(msg);
            }, (err) => {
                delete this.u[callId];
                const msg = MessageIO.serializeReplyErr(req, err);
                this.f?.logOutgoing(msg.byteLength, req, RequestInitiator.OtherSide, `replyErr:`, err);
                this.c.send(msg);
            });
        }
        N(msgLength, req) {
            this.f?.logIncoming(msgLength, req, RequestInitiator.OtherSide, `receiveCancel`);
            const callId = String(req);
            this.u[callId]?.();
        }
        O(msgLength, req, value) {
            this.f?.logIncoming(msgLength, req, RequestInitiator.LocalSide, `receiveReply:`, value);
            const callId = String(req);
            if (!this.w.hasOwnProperty(callId)) {
                return;
            }
            const pendingReply = this.w[callId];
            delete this.w[callId];
            pendingReply.resolveOk(value);
        }
        P(msgLength, req, value) {
            this.f?.logIncoming(msgLength, req, RequestInitiator.LocalSide, `receiveReplyErr:`, value);
            const callId = String(req);
            if (!this.w.hasOwnProperty(callId)) {
                return;
            }
            const pendingReply = this.w[callId];
            delete this.w[callId];
            let err = undefined;
            if (value) {
                if (value.$isError) {
                    err = new Error();
                    err.name = value.name;
                    err.message = value.message;
                    err.stack = value.stack;
                }
                else {
                    err = value;
                }
            }
            pendingReply.resolveErr(err);
        }
        Q(rpcId, methodName, args) {
            try {
                return Promise.resolve(this.S(rpcId, methodName, args));
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        S(rpcId, methodName, args) {
            const actor = this.m[rpcId];
            if (!actor) {
                throw new Error('Unknown actor ' + (0, proxyIdentifier_1.$Ww)(rpcId));
            }
            const method = actor[methodName];
            if (typeof method !== 'function') {
                throw new Error('Unknown method ' + methodName + ' on actor ' + (0, proxyIdentifier_1.$Ww)(rpcId));
            }
            return method.apply(actor, args);
        }
        U(rpcId, methodName, args) {
            if (this.j) {
                return new lazyPromise_1.$Rdc();
            }
            let cancellationToken = null;
            if (args.length > 0 && cancellation_1.CancellationToken.isCancellationToken(args[args.length - 1])) {
                cancellationToken = args.pop();
            }
            if (cancellationToken && cancellationToken.isCancellationRequested) {
                // No need to do anything...
                return Promise.reject(errors.$5());
            }
            const serializedRequestArguments = MessageIO.serializeRequestArguments(args, this.h);
            const req = ++this.t;
            const callId = String(req);
            const result = new lazyPromise_1.$Qdc();
            const disposable = new lifecycle_1.$Tc();
            if (cancellationToken) {
                disposable.add(cancellationToken.onCancellationRequested(() => {
                    const msg = MessageIO.serializeCancel(req);
                    this.f?.logOutgoing(msg.byteLength, req, RequestInitiator.LocalSide, `cancel`);
                    this.c.send(MessageIO.serializeCancel(req));
                }));
            }
            this.w[callId] = new PendingRPCReply(result, disposable);
            this.F(req);
            const msg = MessageIO.serializeRequest(req, rpcId, methodName, serializedRequestArguments, !!cancellationToken);
            this.f?.logOutgoing(msg.byteLength, req, RequestInitiator.LocalSide, `request: ${(0, proxyIdentifier_1.$Ww)(rpcId)}.${methodName}(`, args);
            this.c.send(msg);
            return result;
        }
    }
    exports.$Udc = $Udc;
    class PendingRPCReply {
        constructor(a, b) {
            this.a = a;
            this.b = b;
        }
        resolveOk(value) {
            this.a.resolveOk(value);
            this.b.dispose();
        }
        resolveErr(err) {
            this.a.resolveErr(err);
            this.b.dispose();
        }
    }
    class MessageBuffer {
        static alloc(type, req, messageSize) {
            const result = new MessageBuffer(buffer_1.$Ne.alloc(messageSize + 1 /* type */ + 4 /* req */), 0);
            result.writeUInt8(type);
            result.writeUInt32(req);
            return result;
        }
        static read(buff, offset) {
            return new MessageBuffer(buff, offset);
        }
        get buffer() {
            return this.a;
        }
        constructor(buff, offset) {
            this.a = buff;
            this.b = offset;
        }
        static sizeUInt8() {
            return 1;
        }
        static { this.sizeUInt32 = 4; }
        writeUInt8(n) {
            this.a.writeUInt8(n, this.b);
            this.b += 1;
        }
        readUInt8() {
            const n = this.a.readUInt8(this.b);
            this.b += 1;
            return n;
        }
        writeUInt32(n) {
            this.a.writeUInt32BE(n, this.b);
            this.b += 4;
        }
        readUInt32() {
            const n = this.a.readUInt32BE(this.b);
            this.b += 4;
            return n;
        }
        static sizeShortString(str) {
            return 1 /* string length */ + str.byteLength /* actual string */;
        }
        writeShortString(str) {
            this.a.writeUInt8(str.byteLength, this.b);
            this.b += 1;
            this.a.set(str, this.b);
            this.b += str.byteLength;
        }
        readShortString() {
            const strByteLength = this.a.readUInt8(this.b);
            this.b += 1;
            const strBuff = this.a.slice(this.b, this.b + strByteLength);
            const str = strBuff.toString();
            this.b += strByteLength;
            return str;
        }
        static sizeLongString(str) {
            return 4 /* string length */ + str.byteLength /* actual string */;
        }
        writeLongString(str) {
            this.a.writeUInt32BE(str.byteLength, this.b);
            this.b += 4;
            this.a.set(str, this.b);
            this.b += str.byteLength;
        }
        readLongString() {
            const strByteLength = this.a.readUInt32BE(this.b);
            this.b += 4;
            const strBuff = this.a.slice(this.b, this.b + strByteLength);
            const str = strBuff.toString();
            this.b += strByteLength;
            return str;
        }
        writeBuffer(buff) {
            this.a.writeUInt32BE(buff.byteLength, this.b);
            this.b += 4;
            this.a.set(buff, this.b);
            this.b += buff.byteLength;
        }
        static sizeVSBuffer(buff) {
            return 4 /* buffer length */ + buff.byteLength /* actual buffer */;
        }
        writeVSBuffer(buff) {
            this.a.writeUInt32BE(buff.byteLength, this.b);
            this.b += 4;
            this.a.set(buff, this.b);
            this.b += buff.byteLength;
        }
        readVSBuffer() {
            const buffLength = this.a.readUInt32BE(this.b);
            this.b += 4;
            const buff = this.a.slice(this.b, this.b + buffLength);
            this.b += buffLength;
            return buff;
        }
        static sizeMixedArray(arr) {
            let size = 0;
            size += 1; // arr length
            for (let i = 0, len = arr.length; i < len; i++) {
                const el = arr[i];
                size += 1; // arg type
                switch (el.type) {
                    case ArgType.String:
                        size += this.sizeLongString(el.value);
                        break;
                    case ArgType.VSBuffer:
                        size += this.sizeVSBuffer(el.value);
                        break;
                    case ArgType.SerializedObjectWithBuffers:
                        size += this.sizeUInt32; // buffer count
                        size += this.sizeLongString(el.value);
                        for (let i = 0; i < el.buffers.length; ++i) {
                            size += this.sizeVSBuffer(el.buffers[i]);
                        }
                        break;
                    case ArgType.Undefined:
                        // empty...
                        break;
                }
            }
            return size;
        }
        writeMixedArray(arr) {
            this.a.writeUInt8(arr.length, this.b);
            this.b += 1;
            for (let i = 0, len = arr.length; i < len; i++) {
                const el = arr[i];
                switch (el.type) {
                    case ArgType.String:
                        this.writeUInt8(ArgType.String);
                        this.writeLongString(el.value);
                        break;
                    case ArgType.VSBuffer:
                        this.writeUInt8(ArgType.VSBuffer);
                        this.writeVSBuffer(el.value);
                        break;
                    case ArgType.SerializedObjectWithBuffers:
                        this.writeUInt8(ArgType.SerializedObjectWithBuffers);
                        this.writeUInt32(el.buffers.length);
                        this.writeLongString(el.value);
                        for (let i = 0; i < el.buffers.length; ++i) {
                            this.writeBuffer(el.buffers[i]);
                        }
                        break;
                    case ArgType.Undefined:
                        this.writeUInt8(ArgType.Undefined);
                        break;
                }
            }
        }
        readMixedArray() {
            const arrLen = this.a.readUInt8(this.b);
            this.b += 1;
            const arr = new Array(arrLen);
            for (let i = 0; i < arrLen; i++) {
                const argType = this.readUInt8();
                switch (argType) {
                    case ArgType.String:
                        arr[i] = this.readLongString();
                        break;
                    case ArgType.VSBuffer:
                        arr[i] = this.readVSBuffer();
                        break;
                    case ArgType.SerializedObjectWithBuffers: {
                        const bufferCount = this.readUInt32();
                        const jsonString = this.readLongString();
                        const buffers = [];
                        for (let i = 0; i < bufferCount; ++i) {
                            buffers.push(this.readVSBuffer());
                        }
                        arr[i] = new proxyIdentifier_1.$Xw($Tdc(jsonString, buffers, null));
                        break;
                    }
                    case ArgType.Undefined:
                        arr[i] = undefined;
                        break;
                }
            }
            return arr;
        }
    }
    var SerializedRequestArgumentType;
    (function (SerializedRequestArgumentType) {
        SerializedRequestArgumentType[SerializedRequestArgumentType["Simple"] = 0] = "Simple";
        SerializedRequestArgumentType[SerializedRequestArgumentType["Mixed"] = 1] = "Mixed";
    })(SerializedRequestArgumentType || (SerializedRequestArgumentType = {}));
    class MessageIO {
        static a(arr) {
            for (let i = 0, len = arr.length; i < len; i++) {
                if (arr[i] instanceof buffer_1.$Ne) {
                    return true;
                }
                if (arr[i] instanceof proxyIdentifier_1.$Xw) {
                    return true;
                }
                if (typeof arr[i] === 'undefined') {
                    return true;
                }
            }
            return false;
        }
        static serializeRequestArguments(args, replacer) {
            if (this.a(args)) {
                const massagedArgs = [];
                for (let i = 0, len = args.length; i < len; i++) {
                    const arg = args[i];
                    if (arg instanceof buffer_1.$Ne) {
                        massagedArgs[i] = { type: ArgType.VSBuffer, value: arg };
                    }
                    else if (typeof arg === 'undefined') {
                        massagedArgs[i] = { type: ArgType.Undefined };
                    }
                    else if (arg instanceof proxyIdentifier_1.$Xw) {
                        const { jsonString, referencedBuffers } = $Sdc(arg.value, replacer);
                        massagedArgs[i] = { type: ArgType.SerializedObjectWithBuffers, value: buffer_1.$Ne.fromString(jsonString), buffers: referencedBuffers };
                    }
                    else {
                        massagedArgs[i] = { type: ArgType.String, value: buffer_1.$Ne.fromString(stringify(arg, replacer)) };
                    }
                }
                return {
                    type: SerializedRequestArgumentType.Mixed,
                    args: massagedArgs,
                };
            }
            return {
                type: SerializedRequestArgumentType.Simple,
                args: stringify(args, replacer)
            };
        }
        static serializeRequest(req, rpcId, method, serializedArgs, usesCancellationToken) {
            switch (serializedArgs.type) {
                case SerializedRequestArgumentType.Simple:
                    return this.b(req, rpcId, method, serializedArgs.args, usesCancellationToken);
                case SerializedRequestArgumentType.Mixed:
                    return this.c(req, rpcId, method, serializedArgs.args, usesCancellationToken);
            }
        }
        static b(req, rpcId, method, args, usesCancellationToken) {
            const methodBuff = buffer_1.$Ne.fromString(method);
            const argsBuff = buffer_1.$Ne.fromString(args);
            let len = 0;
            len += MessageBuffer.sizeUInt8();
            len += MessageBuffer.sizeShortString(methodBuff);
            len += MessageBuffer.sizeLongString(argsBuff);
            const result = MessageBuffer.alloc(usesCancellationToken ? MessageType.RequestJSONArgsWithCancellation : MessageType.RequestJSONArgs, req, len);
            result.writeUInt8(rpcId);
            result.writeShortString(methodBuff);
            result.writeLongString(argsBuff);
            return result.buffer;
        }
        static deserializeRequestJSONArgs(buff) {
            const rpcId = buff.readUInt8();
            const method = buff.readShortString();
            const args = buff.readLongString();
            return {
                rpcId: rpcId,
                method: method,
                args: JSON.parse(args)
            };
        }
        static c(req, rpcId, method, args, usesCancellationToken) {
            const methodBuff = buffer_1.$Ne.fromString(method);
            let len = 0;
            len += MessageBuffer.sizeUInt8();
            len += MessageBuffer.sizeShortString(methodBuff);
            len += MessageBuffer.sizeMixedArray(args);
            const result = MessageBuffer.alloc(usesCancellationToken ? MessageType.RequestMixedArgsWithCancellation : MessageType.RequestMixedArgs, req, len);
            result.writeUInt8(rpcId);
            result.writeShortString(methodBuff);
            result.writeMixedArray(args);
            return result.buffer;
        }
        static deserializeRequestMixedArgs(buff) {
            const rpcId = buff.readUInt8();
            const method = buff.readShortString();
            const rawargs = buff.readMixedArray();
            const args = new Array(rawargs.length);
            for (let i = 0, len = rawargs.length; i < len; i++) {
                const rawarg = rawargs[i];
                if (typeof rawarg === 'string') {
                    args[i] = JSON.parse(rawarg);
                }
                else {
                    args[i] = rawarg;
                }
            }
            return {
                rpcId: rpcId,
                method: method,
                args: args
            };
        }
        static serializeAcknowledged(req) {
            return MessageBuffer.alloc(MessageType.Acknowledged, req, 0).buffer;
        }
        static serializeCancel(req) {
            return MessageBuffer.alloc(MessageType.Cancel, req, 0).buffer;
        }
        static serializeReplyOK(req, res, replacer) {
            if (typeof res === 'undefined') {
                return this.d(req);
            }
            else if (res instanceof buffer_1.$Ne) {
                return this.e(req, res);
            }
            else if (res instanceof proxyIdentifier_1.$Xw) {
                const { jsonString, referencedBuffers } = $Sdc(res.value, replacer, true);
                return this.g(req, jsonString, referencedBuffers);
            }
            else {
                return this.f(req, safeStringify(res, replacer));
            }
        }
        static d(req) {
            return MessageBuffer.alloc(MessageType.ReplyOKEmpty, req, 0).buffer;
        }
        static e(req, res) {
            let len = 0;
            len += MessageBuffer.sizeVSBuffer(res);
            const result = MessageBuffer.alloc(MessageType.ReplyOKVSBuffer, req, len);
            result.writeVSBuffer(res);
            return result.buffer;
        }
        static deserializeReplyOKVSBuffer(buff) {
            return buff.readVSBuffer();
        }
        static f(req, res) {
            const resBuff = buffer_1.$Ne.fromString(res);
            let len = 0;
            len += MessageBuffer.sizeLongString(resBuff);
            const result = MessageBuffer.alloc(MessageType.ReplyOKJSON, req, len);
            result.writeLongString(resBuff);
            return result.buffer;
        }
        static g(req, res, buffers) {
            const resBuff = buffer_1.$Ne.fromString(res);
            let len = 0;
            len += MessageBuffer.sizeUInt32; // buffer count
            len += MessageBuffer.sizeLongString(resBuff);
            for (const buffer of buffers) {
                len += MessageBuffer.sizeVSBuffer(buffer);
            }
            const result = MessageBuffer.alloc(MessageType.ReplyOKJSONWithBuffers, req, len);
            result.writeUInt32(buffers.length);
            result.writeLongString(resBuff);
            for (const buffer of buffers) {
                result.writeBuffer(buffer);
            }
            return result.buffer;
        }
        static deserializeReplyOKJSON(buff) {
            const res = buff.readLongString();
            return JSON.parse(res);
        }
        static deserializeReplyOKJSONWithBuffers(buff, uriTransformer) {
            const bufferCount = buff.readUInt32();
            const res = buff.readLongString();
            const buffers = [];
            for (let i = 0; i < bufferCount; ++i) {
                buffers.push(buff.readVSBuffer());
            }
            return new proxyIdentifier_1.$Xw($Tdc(res, buffers, uriTransformer));
        }
        static serializeReplyErr(req, err) {
            const errStr = (err ? safeStringify(errors.$1(err), null) : undefined);
            if (typeof errStr !== 'string') {
                return this.h(req);
            }
            const errBuff = buffer_1.$Ne.fromString(errStr);
            let len = 0;
            len += MessageBuffer.sizeLongString(errBuff);
            const result = MessageBuffer.alloc(MessageType.ReplyErrError, req, len);
            result.writeLongString(errBuff);
            return result.buffer;
        }
        static deserializeReplyErrError(buff) {
            const err = buff.readLongString();
            return JSON.parse(err);
        }
        static h(req) {
            return MessageBuffer.alloc(MessageType.ReplyErrEmpty, req, 0).buffer;
        }
    }
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["RequestJSONArgs"] = 1] = "RequestJSONArgs";
        MessageType[MessageType["RequestJSONArgsWithCancellation"] = 2] = "RequestJSONArgsWithCancellation";
        MessageType[MessageType["RequestMixedArgs"] = 3] = "RequestMixedArgs";
        MessageType[MessageType["RequestMixedArgsWithCancellation"] = 4] = "RequestMixedArgsWithCancellation";
        MessageType[MessageType["Acknowledged"] = 5] = "Acknowledged";
        MessageType[MessageType["Cancel"] = 6] = "Cancel";
        MessageType[MessageType["ReplyOKEmpty"] = 7] = "ReplyOKEmpty";
        MessageType[MessageType["ReplyOKVSBuffer"] = 8] = "ReplyOKVSBuffer";
        MessageType[MessageType["ReplyOKJSON"] = 9] = "ReplyOKJSON";
        MessageType[MessageType["ReplyOKJSONWithBuffers"] = 10] = "ReplyOKJSONWithBuffers";
        MessageType[MessageType["ReplyErrError"] = 11] = "ReplyErrError";
        MessageType[MessageType["ReplyErrEmpty"] = 12] = "ReplyErrEmpty";
    })(MessageType || (MessageType = {}));
    var ArgType;
    (function (ArgType) {
        ArgType[ArgType["String"] = 1] = "String";
        ArgType[ArgType["VSBuffer"] = 2] = "VSBuffer";
        ArgType[ArgType["SerializedObjectWithBuffers"] = 3] = "SerializedObjectWithBuffers";
        ArgType[ArgType["Undefined"] = 4] = "Undefined";
    })(ArgType || (ArgType = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[225/*vs/workbench/services/extensions/worker/polyfillNestedWorker*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ptc = void 0;
    const _bootstrapFnSource = (function _bootstrapFn(workerUrl) {
        const listener = (event) => {
            // uninstall handler
            globalThis.removeEventListener('message', listener);
            // get data
            const port = event.data;
            // postMessage
            // onmessage
            Object.defineProperties(globalThis, {
                'postMessage': {
                    value(data, transferOrOptions) {
                        port.postMessage(data, transferOrOptions);
                    }
                },
                'onmessage': {
                    get() {
                        return port.onmessage;
                    },
                    set(value) {
                        port.onmessage = value;
                    }
                }
                // todo onerror
            });
            port.addEventListener('message', msg => {
                globalThis.dispatchEvent(new MessageEvent('message', { data: msg.data, ports: msg.ports ? [...msg.ports] : undefined }));
            });
            port.start();
            // fake recursively nested worker
            globalThis.Worker = class {
                constructor() { throw new TypeError('Nested workers from within nested worker are NOT supported.'); }
            };
            // load module
            importScripts(workerUrl);
        };
        globalThis.addEventListener('message', listener);
    }).toString();
    class $Ptc extends EventTarget {
        constructor(nativePostMessage, stringOrUrl, options) {
            super();
            this.onmessage = null;
            this.onmessageerror = null;
            this.onerror = null;
            // create bootstrap script
            const bootstrap = `((${_bootstrapFnSource})('${stringOrUrl}'))`;
            const blob = new Blob([bootstrap], { type: 'application/javascript' });
            const blobUrl = URL.createObjectURL(blob);
            const channel = new MessageChannel();
            const id = blobUrl; // works because blob url is unique, needs ID pool otherwise
            const msg = {
                type: '_newWorker',
                id,
                port: channel.port2,
                url: blobUrl,
                options,
            };
            nativePostMessage(msg, [channel.port2]);
            // worker-impl: functions
            this.postMessage = channel.port1.postMessage.bind(channel.port1);
            this.terminate = () => {
                const msg = {
                    type: '_terminateWorker',
                    id
                };
                nativePostMessage(msg);
                URL.revokeObjectURL(blobUrl);
                channel.port1.close();
                channel.port2.close();
            };
            // worker-impl: events
            Object.defineProperties(this, {
                'onmessage': {
                    get() {
                        return channel.port1.onmessage;
                    },
                    set(value) {
                        channel.port1.onmessage = value;
                    }
                },
                'onmessageerror': {
                    get() {
                        return channel.port1.onmessageerror;
                    },
                    set(value) {
                        channel.port1.onmessageerror = value;
                    }
                },
                // todo onerror
            });
            channel.port1.addEventListener('messageerror', evt => {
                const msgEvent = new MessageEvent('messageerror', { data: evt.data });
                this.dispatchEvent(msgEvent);
            });
            channel.port1.addEventListener('message', evt => {
                const msgEvent = new MessageEvent('message', { data: evt.data });
                this.dispatchEvent(msgEvent);
            });
            channel.port1.start();
        }
    }
    exports.$Ptc = $Ptc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[226/*vs/workbench/services/notebook/common/notebookDocumentService*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,28/*vs/base/common/map*/,15/*vs/base/common/network*/,60/*vs/platform/instantiation/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, buffer_1, map_1, network_1, extensions_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$uL = exports.$rL = void 0;
    exports.$sL = $sL;
    exports.$tL = $tL;
    exports.$rL = (0, instantiation_1.$Fi)('notebookDocumentService');
    const _lengths = ['W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f'];
    const _padRegexp = new RegExp(`^[${_lengths.join('')}]+`);
    const _radix = 7;
    function $sL(cell) {
        if (cell.scheme !== network_1.Schemas.vscodeNotebookCell) {
            return undefined;
        }
        const idx = cell.fragment.indexOf('s');
        if (idx < 0) {
            return undefined;
        }
        const handle = parseInt(cell.fragment.substring(0, idx).replace(_padRegexp, ''), _radix);
        const _scheme = (0, buffer_1.$7e)(cell.fragment.substring(idx + 1)).toString();
        if (isNaN(handle)) {
            return undefined;
        }
        return {
            handle,
            notebook: cell.with({ scheme: _scheme, fragment: null })
        };
    }
    function $tL(notebook, handle) {
        const s = handle.toString(_radix);
        const p = s.length < _lengths.length ? _lengths[s.length - 1] : 'z';
        const fragment = `${p}${s}s${(0, buffer_1.$8e)(buffer_1.$Ne.fromString(notebook.scheme), true, true)}`;
        return notebook.with({ scheme: network_1.Schemas.vscodeNotebookCell, fragment });
    }
    class $uL {
        constructor() {
            this.a = new map_1.$Ac();
        }
        getNotebook(uri) {
            if (uri.scheme === network_1.Schemas.vscodeNotebookCell) {
                const cellUri = $sL(uri);
                if (cellUri) {
                    const document = this.a.get(cellUri.notebook);
                    if (document) {
                        return document;
                    }
                }
            }
            return this.a.get(uri);
        }
        addNotebookDocument(document) {
            this.a.set(document.uri, document);
        }
        removeNotebookDocument(document) {
            this.a.delete(document.uri);
        }
    }
    exports.$uL = $uL;
    (0, extensions_1.$Rs)(exports.$rL, $uL, extensions_1.InstantiationType.Delayed);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[89/*vs/workbench/contrib/notebook/common/notebookCommon*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,41/*vs/base/common/glob*/,40/*vs/base/common/iterator*/,72/*vs/base/common/mime*/,15/*vs/base/common/network*/,19/*vs/base/common/path*/,20/*vs/base/common/platform*/,31/*vs/platform/contextkey/common/contextkey*/,226/*vs/workbench/services/notebook/common/notebookDocumentService*/]), function (require, exports, buffer_1, glob, iterator_1, mime_1, network_1, path_1, platform_1, contextkey_1, notebookDocumentService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$OL = exports.$LL = exports.CellStatusbarAlignment = exports.$KL = exports.NotebookFindScopeType = exports.NotebookEditorPriority = exports.$HL = exports.$GL = exports.$EL = exports.CellUri = exports.CellEditType = exports.SelectionStateType = exports.NotebookCellsChangeType = exports.RendererMessagingSpec = exports.NotebookRendererMatch = exports.NotebookExecutionState = exports.NotebookCellExecutionState = exports.NotebookRunState = exports.$DL = exports.$CL = exports.$BL = exports.$AL = exports.CellKind = exports.$zL = exports.$yL = exports.$xL = exports.$wL = exports.$vL = void 0;
    exports.$FL = $FL;
    exports.$IL = $IL;
    exports.$JL = $JL;
    exports.$ML = $ML;
    exports.$NL = $NL;
    glob = __importStar(glob);
    exports.$vL = 'workbench.editor.notebook';
    exports.$wL = 'workbench.editor.notebookTextDiffEditor';
    exports.$xL = 'workbench.editor.interactive';
    exports.$yL = 'workbench.editor.repl';
    exports.$zL = 'replNotebook.input.execute';
    var CellKind;
    (function (CellKind) {
        CellKind[CellKind["Markup"] = 1] = "Markup";
        CellKind[CellKind["Code"] = 2] = "Code";
    })(CellKind || (exports.CellKind = CellKind = {}));
    exports.$AL = [
        'application/json',
        'application/javascript',
        'text/html',
        'image/svg+xml',
        mime_1.$$s.latex,
        mime_1.$$s.markdown,
        'image/png',
        'image/jpeg',
        mime_1.$$s.text
    ];
    exports.$BL = [
        mime_1.$$s.latex,
        mime_1.$$s.markdown,
        'application/json',
        'text/html',
        'image/svg+xml',
        'image/png',
        'image/jpeg',
        mime_1.$$s.text,
    ];
    /**
     * A mapping of extension IDs who contain renderers, to notebook ids who they
     * should be treated as the same in the renderer selection logic. This is used
     * to prefer the 1st party Jupyter renderers even though they're in a separate
     * extension, for instance. See #136247.
     */
    exports.$CL = new Map([
        ['ms-toolsai.jupyter', new Set(['jupyter-notebook', 'interactive'])],
        ['ms-toolsai.jupyter-renderers', new Set(['jupyter-notebook', 'interactive'])],
    ]);
    exports.$DL = '_notAvailable';
    var NotebookRunState;
    (function (NotebookRunState) {
        NotebookRunState[NotebookRunState["Running"] = 1] = "Running";
        NotebookRunState[NotebookRunState["Idle"] = 2] = "Idle";
    })(NotebookRunState || (exports.NotebookRunState = NotebookRunState = {}));
    var NotebookCellExecutionState;
    (function (NotebookCellExecutionState) {
        NotebookCellExecutionState[NotebookCellExecutionState["Unconfirmed"] = 1] = "Unconfirmed";
        NotebookCellExecutionState[NotebookCellExecutionState["Pending"] = 2] = "Pending";
        NotebookCellExecutionState[NotebookCellExecutionState["Executing"] = 3] = "Executing";
    })(NotebookCellExecutionState || (exports.NotebookCellExecutionState = NotebookCellExecutionState = {}));
    var NotebookExecutionState;
    (function (NotebookExecutionState) {
        NotebookExecutionState[NotebookExecutionState["Unconfirmed"] = 1] = "Unconfirmed";
        NotebookExecutionState[NotebookExecutionState["Pending"] = 2] = "Pending";
        NotebookExecutionState[NotebookExecutionState["Executing"] = 3] = "Executing";
    })(NotebookExecutionState || (exports.NotebookExecutionState = NotebookExecutionState = {}));
    /** Note: enum values are used for sorting */
    var NotebookRendererMatch;
    (function (NotebookRendererMatch) {
        /** Renderer has a hard dependency on an available kernel */
        NotebookRendererMatch[NotebookRendererMatch["WithHardKernelDependency"] = 0] = "WithHardKernelDependency";
        /** Renderer works better with an available kernel */
        NotebookRendererMatch[NotebookRendererMatch["WithOptionalKernelDependency"] = 1] = "WithOptionalKernelDependency";
        /** Renderer is kernel-agnostic */
        NotebookRendererMatch[NotebookRendererMatch["Pure"] = 2] = "Pure";
        /** Renderer is for a different mimeType or has a hard dependency which is unsatisfied */
        NotebookRendererMatch[NotebookRendererMatch["Never"] = 3] = "Never";
    })(NotebookRendererMatch || (exports.NotebookRendererMatch = NotebookRendererMatch = {}));
    /**
     * Renderer messaging requirement. While this allows for 'optional' messaging,
     * VS Code effectively treats it the same as true right now. "Partial
     * activation" of extensions is a very tricky problem, which could allow
     * solving this. But for now, optional is mostly only honored for aznb.
     */
    var RendererMessagingSpec;
    (function (RendererMessagingSpec) {
        RendererMessagingSpec["Always"] = "always";
        RendererMessagingSpec["Never"] = "never";
        RendererMessagingSpec["Optional"] = "optional";
    })(RendererMessagingSpec || (exports.RendererMessagingSpec = RendererMessagingSpec = {}));
    var NotebookCellsChangeType;
    (function (NotebookCellsChangeType) {
        NotebookCellsChangeType[NotebookCellsChangeType["ModelChange"] = 1] = "ModelChange";
        NotebookCellsChangeType[NotebookCellsChangeType["Move"] = 2] = "Move";
        NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellLanguage"] = 5] = "ChangeCellLanguage";
        NotebookCellsChangeType[NotebookCellsChangeType["Initialize"] = 6] = "Initialize";
        NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellMetadata"] = 7] = "ChangeCellMetadata";
        NotebookCellsChangeType[NotebookCellsChangeType["Output"] = 8] = "Output";
        NotebookCellsChangeType[NotebookCellsChangeType["OutputItem"] = 9] = "OutputItem";
        NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellContent"] = 10] = "ChangeCellContent";
        NotebookCellsChangeType[NotebookCellsChangeType["ChangeDocumentMetadata"] = 11] = "ChangeDocumentMetadata";
        NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellInternalMetadata"] = 12] = "ChangeCellInternalMetadata";
        NotebookCellsChangeType[NotebookCellsChangeType["ChangeCellMime"] = 13] = "ChangeCellMime";
        NotebookCellsChangeType[NotebookCellsChangeType["Unknown"] = 100] = "Unknown";
    })(NotebookCellsChangeType || (exports.NotebookCellsChangeType = NotebookCellsChangeType = {}));
    var SelectionStateType;
    (function (SelectionStateType) {
        SelectionStateType[SelectionStateType["Handle"] = 0] = "Handle";
        SelectionStateType[SelectionStateType["Index"] = 1] = "Index";
    })(SelectionStateType || (exports.SelectionStateType = SelectionStateType = {}));
    var CellEditType;
    (function (CellEditType) {
        CellEditType[CellEditType["Replace"] = 1] = "Replace";
        CellEditType[CellEditType["Output"] = 2] = "Output";
        CellEditType[CellEditType["Metadata"] = 3] = "Metadata";
        CellEditType[CellEditType["CellLanguage"] = 4] = "CellLanguage";
        CellEditType[CellEditType["DocumentMetadata"] = 5] = "DocumentMetadata";
        CellEditType[CellEditType["Move"] = 6] = "Move";
        CellEditType[CellEditType["OutputItems"] = 7] = "OutputItems";
        CellEditType[CellEditType["PartialMetadata"] = 8] = "PartialMetadata";
        CellEditType[CellEditType["PartialInternalMetadata"] = 9] = "PartialInternalMetadata";
    })(CellEditType || (exports.CellEditType = CellEditType = {}));
    var CellUri;
    (function (CellUri) {
        CellUri.scheme = network_1.Schemas.vscodeNotebookCell;
        function generate(notebook, handle) {
            return (0, notebookDocumentService_1.$tL)(notebook, handle);
        }
        CellUri.generate = generate;
        function parse(cell) {
            return (0, notebookDocumentService_1.$sL)(cell);
        }
        CellUri.parse = parse;
        function generateCellOutputUri(notebook, outputId) {
            return notebook.with({
                scheme: network_1.Schemas.vscodeNotebookCellOutput,
                fragment: `op${outputId ?? ''},${notebook.scheme !== network_1.Schemas.file ? notebook.scheme : ''}`
            });
        }
        CellUri.generateCellOutputUri = generateCellOutputUri;
        function parseCellOutputUri(uri) {
            if (uri.scheme !== network_1.Schemas.vscodeNotebookCellOutput) {
                return;
            }
            const match = /^op([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?\,(.*)$/i.exec(uri.fragment);
            if (!match) {
                return undefined;
            }
            const outputId = (match[1] && match[1] !== '') ? match[1] : undefined;
            const scheme = match[2];
            return {
                outputId,
                notebook: uri.with({
                    scheme: scheme || network_1.Schemas.file,
                    fragment: null
                })
            };
        }
        CellUri.parseCellOutputUri = parseCellOutputUri;
        function generateCellPropertyUri(notebook, handle, scheme) {
            return CellUri.generate(notebook, handle).with({ scheme: scheme });
        }
        CellUri.generateCellPropertyUri = generateCellPropertyUri;
        function parseCellPropertyUri(uri, propertyScheme) {
            if (uri.scheme !== propertyScheme) {
                return undefined;
            }
            return CellUri.parse(uri.with({ scheme: CellUri.scheme }));
        }
        CellUri.parseCellPropertyUri = parseCellPropertyUri;
    })(CellUri || (exports.CellUri = CellUri = {}));
    const normalizeSlashes = (str) => platform_1.$j ? str.replace(/\//g, '\\') : str;
    class $EL {
        constructor(initialValue = [], e = exports.$AL) {
            this.e = e;
            this.d = [...new Set(initialValue)].map(pattern => ({
                pattern,
                matches: glob.$Ak(normalizeSlashes(pattern))
            }));
        }
        /**
         * Returns a sorted array of the input mimetypes.
         */
        sort(mimetypes) {
            const remaining = new Map(iterator_1.Iterable.map(mimetypes, m => [m, normalizeSlashes(m)]));
            let sorted = [];
            for (const { matches } of this.d) {
                for (const [original, normalized] of remaining) {
                    if (matches(normalized)) {
                        sorted.push(original);
                        remaining.delete(original);
                        break;
                    }
                }
            }
            if (remaining.size) {
                sorted = sorted.concat([...remaining.keys()].sort((a, b) => this.e.indexOf(a) - this.e.indexOf(b)));
            }
            return sorted;
        }
        /**
         * Records that the user selected the given mimetype over the other
         * possible mimetypes, prioritizing it for future reference.
         */
        prioritize(chosenMimetype, otherMimetypes) {
            const chosenIndex = this.f(chosenMimetype);
            if (chosenIndex === -1) {
                // always first, nothing more to do
                this.d.unshift({ pattern: chosenMimetype, matches: glob.$Ak(normalizeSlashes(chosenMimetype)) });
                return;
            }
            // Get the other mimetypes that are before the chosenMimetype. Then, move
            // them after it, retaining order.
            const uniqueIndicies = new Set(otherMimetypes.map(m => this.f(m, chosenIndex)));
            uniqueIndicies.delete(-1);
            const otherIndices = Array.from(uniqueIndicies).sort();
            this.d.splice(chosenIndex + 1, 0, ...otherIndices.map(i => this.d[i]));
            for (let oi = otherIndices.length - 1; oi >= 0; oi--) {
                this.d.splice(otherIndices[oi], 1);
            }
        }
        /**
         * Gets an array of in-order mimetype preferences.
         */
        toArray() {
            return this.d.map(o => o.pattern);
        }
        f(mimeType, maxIndex = this.d.length) {
            const normalized = normalizeSlashes(mimeType);
            for (let i = 0; i < maxIndex; i++) {
                if (this.d[i].matches(normalized)) {
                    return i;
                }
            }
            return -1;
        }
    }
    exports.$EL = $EL;
    function $FL(before, after, contains, equal = (a, b) => a === b) {
        const result = [];
        function pushSplice(start, deleteCount, toInsert) {
            if (deleteCount === 0 && toInsert.length === 0) {
                return;
            }
            const latest = result[result.length - 1];
            if (latest && latest.start + latest.deleteCount === start) {
                latest.deleteCount += deleteCount;
                latest.toInsert.push(...toInsert);
            }
            else {
                result.push({ start, deleteCount, toInsert });
            }
        }
        let beforeIdx = 0;
        let afterIdx = 0;
        while (true) {
            if (beforeIdx === before.length) {
                pushSplice(beforeIdx, 0, after.slice(afterIdx));
                break;
            }
            if (afterIdx === after.length) {
                pushSplice(beforeIdx, before.length - beforeIdx, []);
                break;
            }
            const beforeElement = before[beforeIdx];
            const afterElement = after[afterIdx];
            if (equal(beforeElement, afterElement)) {
                // equal
                beforeIdx += 1;
                afterIdx += 1;
                continue;
            }
            if (contains(afterElement)) {
                // `afterElement` exists before, which means some elements before `afterElement` are deleted
                pushSplice(beforeIdx, 1, []);
                beforeIdx += 1;
            }
            else {
                // `afterElement` added
                pushSplice(beforeIdx, 0, [afterElement]);
                afterIdx += 1;
            }
        }
        return result;
    }
    exports.$GL = new contextkey_1.$Wj('notebookEditorCursorAtBoundary', 'none');
    exports.$HL = new contextkey_1.$Wj('notebookEditorCursorAtLineBoundary', 'none');
    var NotebookEditorPriority;
    (function (NotebookEditorPriority) {
        NotebookEditorPriority["default"] = "default";
        NotebookEditorPriority["option"] = "option";
    })(NotebookEditorPriority || (exports.NotebookEditorPriority = NotebookEditorPriority = {}));
    var NotebookFindScopeType;
    (function (NotebookFindScopeType) {
        NotebookFindScopeType["Cells"] = "cells";
        NotebookFindScopeType["Text"] = "text";
        NotebookFindScopeType["None"] = "none";
    })(NotebookFindScopeType || (exports.NotebookFindScopeType = NotebookFindScopeType = {}));
    //TODO@rebornix test
    function $IL(filenamePattern) {
        const arg = filenamePattern;
        if ((typeof arg.include === 'string' || glob.$Bk(arg.include))
            && (typeof arg.exclude === 'string' || glob.$Bk(arg.exclude))) {
            return true;
        }
        return false;
    }
    function $JL(filter, viewType, resource) {
        if (Array.isArray(filter.viewType) && filter.viewType.indexOf(viewType) >= 0) {
            return true;
        }
        if (filter.viewType === viewType) {
            return true;
        }
        if (filter.filenamePattern) {
            const filenamePattern = $IL(filter.filenamePattern) ? filter.filenamePattern.include : filter.filenamePattern;
            const excludeFilenamePattern = $IL(filter.filenamePattern) ? filter.filenamePattern.exclude : undefined;
            if (glob.$zk(filenamePattern, (0, path_1.$nc)(resource.fsPath).toLowerCase())) {
                if (excludeFilenamePattern) {
                    if (glob.$zk(excludeFilenamePattern, (0, path_1.$nc)(resource.fsPath).toLowerCase())) {
                        // should exclude
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
    exports.$KL = {
        displayOrder: 'notebook.displayOrder',
        cellToolbarLocation: 'notebook.cellToolbarLocation',
        cellToolbarVisibility: 'notebook.cellToolbarVisibility',
        showCellStatusBar: 'notebook.showCellStatusBar',
        textDiffEditorPreview: 'notebook.diff.enablePreview',
        diffOverviewRuler: 'notebook.diff.overviewRuler',
        experimentalInsertToolbarAlignment: 'notebook.experimental.insertToolbarAlignment',
        compactView: 'notebook.compactView',
        focusIndicator: 'notebook.cellFocusIndicator',
        insertToolbarLocation: 'notebook.insertToolbarLocation',
        globalToolbar: 'notebook.globalToolbar',
        stickyScrollEnabled: 'notebook.stickyScroll.enabled',
        stickyScrollMode: 'notebook.stickyScroll.mode',
        undoRedoPerCell: 'notebook.undoRedoPerCell',
        consolidatedOutputButton: 'notebook.consolidatedOutputButton',
        showFoldingControls: 'notebook.showFoldingControls',
        dragAndDropEnabled: 'notebook.dragAndDropEnabled',
        cellEditorOptionsCustomizations: 'notebook.editorOptionsCustomizations',
        consolidatedRunButton: 'notebook.consolidatedRunButton',
        openGettingStarted: 'notebook.experimental.openGettingStarted',
        globalToolbarShowLabel: 'notebook.globalToolbarShowLabel',
        markupFontSize: 'notebook.markup.fontSize',
        markdownLineHeight: 'notebook.markdown.lineHeight',
        interactiveWindowCollapseCodeCells: 'interactiveWindow.collapseCellInputCode',
        outputScrollingDeprecated: 'notebook.experimental.outputScrolling',
        outputScrolling: 'notebook.output.scrolling',
        textOutputLineLimit: 'notebook.output.textLineLimit',
        LinkifyOutputFilePaths: 'notebook.output.linkifyFilePaths',
        minimalErrorRendering: 'notebook.output.minimalErrorRendering',
        formatOnSave: 'notebook.formatOnSave.enabled',
        insertFinalNewline: 'notebook.insertFinalNewline',
        defaultFormatter: 'notebook.defaultFormatter',
        formatOnCellExecution: 'notebook.formatOnCellExecution',
        codeActionsOnSave: 'notebook.codeActionsOnSave',
        outputWordWrap: 'notebook.output.wordWrap',
        outputLineHeightDeprecated: 'notebook.outputLineHeight',
        outputLineHeight: 'notebook.output.lineHeight',
        outputFontSizeDeprecated: 'notebook.outputFontSize',
        outputFontSize: 'notebook.output.fontSize',
        outputFontFamilyDeprecated: 'notebook.outputFontFamily',
        outputFontFamily: 'notebook.output.fontFamily',
        findFilters: 'notebook.find.filters',
        logging: 'notebook.logging',
        confirmDeleteRunningCell: 'notebook.confirmDeleteRunningCell',
        remoteSaving: 'notebook.experimental.remoteSave',
        gotoSymbolsAllSymbols: 'notebook.gotoSymbols.showAllSymbols',
        outlineShowMarkdownHeadersOnly: 'notebook.outline.showMarkdownHeadersOnly',
        outlineShowCodeCells: 'notebook.outline.showCodeCells',
        outlineShowCodeCellSymbols: 'notebook.outline.showCodeCellSymbols',
        breadcrumbsShowCodeCells: 'notebook.breadcrumbs.showCodeCells',
        scrollToRevealCell: 'notebook.scrolling.revealNextCellOnExecute',
        cellChat: 'notebook.experimental.cellChat',
        cellGenerate: 'notebook.experimental.generate',
        notebookVariablesView: 'notebook.experimental.variablesView',
        InteractiveWindowPromptToSave: 'interactiveWindow.promptToSaveOnClose',
        cellFailureDiagnostics: 'notebook.cellFailureDiagnostics',
        outputBackupSizeLimit: 'notebook.backup.sizeLimit',
    };
    var CellStatusbarAlignment;
    (function (CellStatusbarAlignment) {
        CellStatusbarAlignment[CellStatusbarAlignment["Left"] = 1] = "Left";
        CellStatusbarAlignment[CellStatusbarAlignment["Right"] = 2] = "Right";
    })(CellStatusbarAlignment || (exports.CellStatusbarAlignment = CellStatusbarAlignment = {}));
    class $LL {
        static { this.d = 'notebook/'; }
        static create(viewType) {
            return `${$LL.d}${viewType}`;
        }
        static parse(candidate) {
            if (candidate.startsWith($LL.d)) {
                return candidate.substring($LL.d.length);
            }
            return undefined;
        }
    }
    exports.$LL = $LL;
    /**
     * Whether the provided mime type is a text stream like `stdout`, `stderr`.
     */
    function $ML(mimeType) {
        return ['application/vnd.code.notebook.stdout', 'application/vnd.code.notebook.stderr'].includes(mimeType);
    }
    const textDecoder = new TextDecoder();
    /**
     * Given a stream of individual stdout outputs, this function will return the compressed lines, escaping some of the common terminal escape codes.
     * E.g. some terminal escape codes would result in the previous line getting cleared, such if we had 3 lines and
     * last line contained such a code, then the result string would be just the first two lines.
     * @returns a single VSBuffer with the concatenated and compressed data, and whether any compression was done.
     */
    function $NL(outputs) {
        const buffers = [];
        let startAppending = false;
        // Pick the first set of outputs with the same mime type.
        for (const output of outputs) {
            if ((buffers.length === 0 || startAppending)) {
                buffers.push(output);
                startAppending = true;
            }
        }
        let didCompression = compressStreamBuffer(buffers);
        const concatenated = buffer_1.$Ne.concat(buffers.map(buffer => buffer_1.$Ne.wrap(buffer)));
        const data = formatStreamText(concatenated);
        didCompression = didCompression || data.byteLength !== concatenated.byteLength;
        return { data, didCompression };
    }
    exports.$OL = `${String.fromCharCode(27)}[A`;
    const MOVE_CURSOR_1_LINE_COMMAND_BYTES = exports.$OL.split('').map(c => c.charCodeAt(0));
    const LINE_FEED = 10;
    function compressStreamBuffer(streams) {
        let didCompress = false;
        streams.forEach((stream, index) => {
            if (index === 0 || stream.length < exports.$OL.length) {
                return;
            }
            const previousStream = streams[index - 1];
            // Remove the previous line if required.
            const command = stream.subarray(0, exports.$OL.length);
            if (command[0] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[0] && command[1] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[1] && command[2] === MOVE_CURSOR_1_LINE_COMMAND_BYTES[2]) {
                const lastIndexOfLineFeed = previousStream.lastIndexOf(LINE_FEED);
                if (lastIndexOfLineFeed === -1) {
                    return;
                }
                didCompress = true;
                streams[index - 1] = previousStream.subarray(0, lastIndexOfLineFeed);
                streams[index] = stream.subarray(exports.$OL.length);
            }
        });
        return didCompress;
    }
    /**
     * Took this from jupyter/notebook
     * https://github.com/jupyter/notebook/blob/b8b66332e2023e83d2ee04f83d8814f567e01a4e/notebook/static/base/js/utils.js
     * Remove characters that are overridden by backspace characters
     */
    function fixBackspace(txt) {
        let tmp = txt;
        do {
            txt = tmp;
            // Cancel out anything-but-newline followed by backspace
            tmp = txt.replace(/[^\n]\x08/gm, '');
        } while (tmp.length < txt.length);
        return txt;
    }
    /**
     * Remove chunks that should be overridden by the effect of carriage return characters
     * From https://github.com/jupyter/notebook/blob/master/notebook/static/base/js/utils.js
     */
    function fixCarriageReturn(txt) {
        txt = txt.replace(/\r+\n/gm, '\n'); // \r followed by \n --> newline
        while (txt.search(/\r[^$]/g) > -1) {
            const base = txt.match(/^(.*)\r+/m)[1];
            let insert = txt.match(/\r+(.*)$/m)[1];
            insert = insert + base.slice(insert.length, base.length);
            txt = txt.replace(/\r+.*$/m, '\r').replace(/^.*\r/m, insert);
        }
        return txt;
    }
    const BACKSPACE_CHARACTER = '\b'.charCodeAt(0);
    const CARRIAGE_RETURN_CHARACTER = '\r'.charCodeAt(0);
    function formatStreamText(buffer) {
        // We have special handling for backspace and carriage return characters.
        // Don't unnecessary decode the bytes if we don't need to perform any processing.
        if (!buffer.buffer.includes(BACKSPACE_CHARACTER) && !buffer.buffer.includes(CARRIAGE_RETURN_CHARACTER)) {
            return buffer;
        }
        // Do the same thing jupyter is doing
        return buffer_1.$Ne.fromString(fixCarriageReturn(fixBackspace(textDecoder.decode(buffer.buffer))));
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






define(__m[7/*vs/workbench/api/common/extHostTypes*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,13/*vs/base/common/errors*/,59/*vs/base/common/htmlContent*/,28/*vs/base/common/map*/,72/*vs/base/common/mime*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,38/*vs/base/common/uuid*/,18/*vs/platform/extensions/common/extensions*/,29/*vs/platform/files/common/files*/,109/*vs/platform/remote/common/remoteAuthorityResolver*/,89/*vs/workbench/contrib/notebook/common/notebookCommon*/]), function (require, exports, arrays_1, errors_1, htmlContent_1, map_1, mime_1, strings_1, types_1, uri_1, uuid_1, extensions_1, files_1, remoteAuthorityResolver_1, notebookCommon_1) {
    "use strict";
    var $MN_1, $NN_1, $ON_1, $PN_1, $VN_1, $WN_1, $ZN_1, $1N_1, $8N_1, $9N_1, $$N_1, $eO_1, $xO_1, $BO_1, $CO_1, $6O_1, $qP_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineEditTriggerKind = exports.$_P = exports.KeywordRecognitionStatus = exports.TextToSpeechStatus = exports.SpeechToTextStatus = exports.RelatedInformationType = exports.$$P = exports.$0P = exports.$9P = exports.$8P = exports.$7P = exports.$6P = exports.$5P = exports.$4P = exports.LanguageModelChatMessageRole = exports.$3P = exports.$2P = exports.ChatResponseReferencePartStatusKind = exports.ChatLocation = exports.$1P = exports.$ZP = exports.$YP = exports.$XP = exports.$WP = exports.$VP = exports.$UP = exports.$TP = exports.$SP = exports.$RP = exports.$QP = exports.$PP = exports.$OP = exports.$NP = exports.$MP = exports.ChatResultFeedbackKind = exports.InteractiveEditorResponseFeedbackKind = exports.$LP = exports.ChatVariableLevel = exports.ChatCopyKind = exports.InteractiveSessionVoteDirection = exports.$KP = exports.$JP = exports.$IP = exports.$HP = exports.$GP = exports.$FP = exports.$EP = exports.$DP = exports.$CP = exports.$BP = exports.$AP = exports.$zP = exports.PortAutoForwardAction = exports.WorkspaceTrustState = exports.ExternalUriOpenerPriority = exports.$yP = exports.$xP = exports.$wP = exports.$vP = exports.$tP = exports.$sP = exports.$rP = exports.$qP = exports.$pP = exports.TestRunProfileKind = exports.TestResultState = exports.$oP = exports.$nP = exports.StandardTokenType = exports.ExtensionRuntime = exports.ExtensionMode = exports.$mP = exports.NotebookVariablesRequestKind = exports.$lP = exports.$kP = exports.NotebookControllerAffinity2 = exports.NotebookControllerAffinity = exports.$jP = exports.NotebookEditorRevealType = exports.NotebookCellStatusBarAlignment = exports.NotebookCellExecutionState = exports.NotebookCellKind = exports.$iP = exports.$hP = exports.$gP = exports.$fP = exports.$eP = exports.ColorThemeKind = exports.$dP = exports.$cP = exports.ExtensionKind = exports.InputBoxValidationSeverity = exports.QuickPickItemKind = exports.$bP = exports.QuickInputButtonLocation = exports.$aP = exports.DebugConsoleMode = exports.$_O = exports.$$O = exports.$0O = exports.$9O = exports.$8O = exports.CommentThreadFocus = exports.CommentThreadApplicability = exports.CommentThreadState = exports.CommentState = exports.CommentMode = exports.CommentThreadCollapsibleState = exports.FoldingRangeKind = exports.$7O = exports.$6O = exports.FileChangeType = exports.$5O = exports.NewSymbolNameTriggerKind = exports.NewSymbolNameTag = exports.$4O = exports.$3O = exports.$2O = exports.$1O = exports.InlineCompletionTriggerKind = exports.$ZO = exports.$YO = exports.$XO = exports.$WO = exports.$VO = exports.$UO = exports.$TO = exports.$SO = exports.$RO = exports.$QO = exports.$PO = exports.$NO = exports.ConfigurationTarget = exports.$MO = exports.$LO = exports.$KO = exports.$JO = exports.DocumentPasteTriggerKind = exports.$IO = exports.$HO = exports.$GO = exports.$FO = exports.$EO = exports.$DO = exports.TreeItemCheckboxState = exports.TreeItemCollapsibleState = exports.$CO = exports.ViewBadge = exports.ProgressLocation = exports.$BO = exports.$AO = exports.TaskScope = exports.ShellQuoting = exports.$zO = exports.$yO = exports.$xO = exports.TaskPanelKind = exports.TaskRevealKind = exports.$wO = exports.TerminalLocation = exports.$vO = exports.$uO = exports.$tO = exports.TerminalShellExecutionCommandLineConfidence = exports.TerminalExitReason = exports.SourceControlInputBoxValidationType = exports.ColorFormat = exports.$sO = exports.$rO = exports.$qO = exports.$pO = exports.SyntaxTokenType = exports.DecorationRangeBehavior = exports.TextDocumentChangeReason = exports.TextEditorSelectionChangeKind = exports.TextEditorRevealType = exports.TextDocumentSaveReason = exports.TextEditorLineNumbersStyle = exports.StatusBarAlignment = exports.ViewColumn = exports.PartialAcceptTriggerKind = exports.$nO = exports.$mO = exports.$lO = exports.$kO = exports.CompletionItemTag = exports.CompletionItemKind = exports.CompletionTriggerKind = exports.$jO = exports.$iO = exports.InlayHintKind = exports.SignatureHelpTriggerKind = exports.$hO = exports.$gO = exports.$fO = exports.$eO = exports.$dO = exports.LanguageStatusSeverity = exports.$cO = exports.$bO = exports.$aO = exports.$_N = exports.$$N = exports.$0N = exports.CodeActionTriggerKind = exports.$9N = exports.$8N = exports.SymbolTag = exports.SymbolKind = exports.$7N = exports.$6N = exports.DocumentHighlightKind = exports.HoverVerbosityAction = exports.$5N = exports.$4N = exports.$3N = exports.$2N = exports.$1N = exports.DiagnosticSeverity = exports.DiagnosticTag = exports.$ZN = exports.$YN = exports.FileEditType = exports.$XN = exports.$WN = exports.$VN = exports.EnvironmentVariableMutatorType = exports.EndOfLine = exports.$UN = exports.$TN = exports.$SN = exports.$PN = exports.$ON = exports.$NN = exports.$MN = exports.TerminalQuickFixType = exports.TerminalOutputAnchor = void 0;
    exports.$QN = $QN;
    exports.$RN = $RN;
    exports.$oO = $oO;
    exports.$OO = $OO;
    exports.$uP = $uP;
    /**
     * @deprecated
     *
     * This utility ensures that old JS code that uses functions for classes still works. Existing usages cannot be removed
     * but new ones must not be added
     * */
    function es5ClassCompat(target) {
        const interceptFunctions = {
            apply: function (...args) {
                if (args.length === 0) {
                    return Reflect.construct(target, []);
                }
                else {
                    const argsList = args.length === 1 ? [] : args[1];
                    return Reflect.construct(target, argsList, args[0].constructor);
                }
            },
            call: function (...args) {
                if (args.length === 0) {
                    return Reflect.construct(target, []);
                }
                else {
                    const [thisArg, ...restArgs] = args;
                    return Reflect.construct(target, restArgs, thisArg.constructor);
                }
            }
        };
        return Object.assign(target, interceptFunctions);
    }
    var TerminalOutputAnchor;
    (function (TerminalOutputAnchor) {
        TerminalOutputAnchor[TerminalOutputAnchor["Top"] = 0] = "Top";
        TerminalOutputAnchor[TerminalOutputAnchor["Bottom"] = 1] = "Bottom";
    })(TerminalOutputAnchor || (exports.TerminalOutputAnchor = TerminalOutputAnchor = {}));
    var TerminalQuickFixType;
    (function (TerminalQuickFixType) {
        TerminalQuickFixType[TerminalQuickFixType["TerminalCommand"] = 0] = "TerminalCommand";
        TerminalQuickFixType[TerminalQuickFixType["Opener"] = 1] = "Opener";
        TerminalQuickFixType[TerminalQuickFixType["Command"] = 3] = "Command";
    })(TerminalQuickFixType || (exports.TerminalQuickFixType = TerminalQuickFixType = {}));
    let $MN = $MN_1 = class $MN {
        static from(...inDisposables) {
            let disposables = inDisposables;
            return new $MN_1(function () {
                if (disposables) {
                    for (const disposable of disposables) {
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            });
        }
        #callOnDispose;
        constructor(callOnDispose) {
            this.#callOnDispose = callOnDispose;
        }
        dispose() {
            if (typeof this.#callOnDispose === 'function') {
                this.#callOnDispose();
                this.#callOnDispose = undefined;
            }
        }
    };
    exports.$MN = $MN;
    exports.$MN = $MN = $MN_1 = __decorate([
        es5ClassCompat
    ], $MN);
    let $NN = $NN_1 = class $NN {
        static Min(...positions) {
            if (positions.length === 0) {
                throw new TypeError();
            }
            let result = positions[0];
            for (let i = 1; i < positions.length; i++) {
                const p = positions[i];
                if (p.isBefore(result)) {
                    result = p;
                }
            }
            return result;
        }
        static Max(...positions) {
            if (positions.length === 0) {
                throw new TypeError();
            }
            let result = positions[0];
            for (let i = 1; i < positions.length; i++) {
                const p = positions[i];
                if (p.isAfter(result)) {
                    result = p;
                }
            }
            return result;
        }
        static isPosition(other) {
            if (!other) {
                return false;
            }
            if (other instanceof $NN_1) {
                return true;
            }
            const { line, character } = other;
            if (typeof line === 'number' && typeof character === 'number') {
                return true;
            }
            return false;
        }
        static of(obj) {
            if (obj instanceof $NN_1) {
                return obj;
            }
            else if (this.isPosition(obj)) {
                return new $NN_1(obj.line, obj.character);
            }
            throw new Error('Invalid argument, is NOT a position-like object');
        }
        get line() {
            return this.c;
        }
        get character() {
            return this.e;
        }
        constructor(line, character) {
            if (line < 0) {
                throw (0, errors_1.$6)('line must be non-negative');
            }
            if (character < 0) {
                throw (0, errors_1.$6)('character must be non-negative');
            }
            this.c = line;
            this.e = character;
        }
        isBefore(other) {
            if (this.c < other.c) {
                return true;
            }
            if (other.c < this.c) {
                return false;
            }
            return this.e < other.e;
        }
        isBeforeOrEqual(other) {
            if (this.c < other.c) {
                return true;
            }
            if (other.c < this.c) {
                return false;
            }
            return this.e <= other.e;
        }
        isAfter(other) {
            return !this.isBeforeOrEqual(other);
        }
        isAfterOrEqual(other) {
            return !this.isBefore(other);
        }
        isEqual(other) {
            return this.c === other.c && this.e === other.e;
        }
        compareTo(other) {
            if (this.c < other.c) {
                return -1;
            }
            else if (this.c > other.line) {
                return 1;
            }
            else {
                // equal line
                if (this.e < other.e) {
                    return -1;
                }
                else if (this.e > other.e) {
                    return 1;
                }
                else {
                    // equal line and character
                    return 0;
                }
            }
        }
        translate(lineDeltaOrChange, characterDelta = 0) {
            if (lineDeltaOrChange === null || characterDelta === null) {
                throw (0, errors_1.$6)();
            }
            let lineDelta;
            if (typeof lineDeltaOrChange === 'undefined') {
                lineDelta = 0;
            }
            else if (typeof lineDeltaOrChange === 'number') {
                lineDelta = lineDeltaOrChange;
            }
            else {
                lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
                characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
            }
            if (lineDelta === 0 && characterDelta === 0) {
                return this;
            }
            return new $NN_1(this.line + lineDelta, this.character + characterDelta);
        }
        with(lineOrChange, character = this.character) {
            if (lineOrChange === null || character === null) {
                throw (0, errors_1.$6)();
            }
            let line;
            if (typeof lineOrChange === 'undefined') {
                line = this.line;
            }
            else if (typeof lineOrChange === 'number') {
                line = lineOrChange;
            }
            else {
                line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
                character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
            }
            if (line === this.line && character === this.character) {
                return this;
            }
            return new $NN_1(line, character);
        }
        toJSON() {
            return { line: this.line, character: this.character };
        }
        [Symbol.for('debug.description')]() {
            return `(${this.line}:${this.character})`;
        }
    };
    exports.$NN = $NN;
    exports.$NN = $NN = $NN_1 = __decorate([
        es5ClassCompat
    ], $NN);
    let $ON = $ON_1 = class $ON {
        static isRange(thing) {
            if (thing instanceof $ON_1) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return $NN.isPosition(thing.start)
                && $NN.isPosition(thing.end);
        }
        static of(obj) {
            if (obj instanceof $ON_1) {
                return obj;
            }
            if (this.isRange(obj)) {
                return new $ON_1(obj.start, obj.end);
            }
            throw new Error('Invalid argument, is NOT a range-like object');
        }
        get start() {
            return this.c;
        }
        get end() {
            return this.e;
        }
        constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
            let start;
            let end;
            if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
                start = new $NN(startLineOrStart, startColumnOrEnd);
                end = new $NN(endLine, endColumn);
            }
            else if ($NN.isPosition(startLineOrStart) && $NN.isPosition(startColumnOrEnd)) {
                start = $NN.of(startLineOrStart);
                end = $NN.of(startColumnOrEnd);
            }
            if (!start || !end) {
                throw new Error('Invalid arguments');
            }
            if (start.isBefore(end)) {
                this.c = start;
                this.e = end;
            }
            else {
                this.c = end;
                this.e = start;
            }
        }
        contains(positionOrRange) {
            if ($ON_1.isRange(positionOrRange)) {
                return this.contains(positionOrRange.start)
                    && this.contains(positionOrRange.end);
            }
            else if ($NN.isPosition(positionOrRange)) {
                if ($NN.of(positionOrRange).isBefore(this.c)) {
                    return false;
                }
                if (this.e.isBefore(positionOrRange)) {
                    return false;
                }
                return true;
            }
            return false;
        }
        isEqual(other) {
            return this.c.isEqual(other.c) && this.e.isEqual(other.e);
        }
        intersection(other) {
            const start = $NN.Max(other.start, this.c);
            const end = $NN.Min(other.end, this.e);
            if (start.isAfter(end)) {
                // this happens when there is no overlap:
                // |-----|
                //          |----|
                return undefined;
            }
            return new $ON_1(start, end);
        }
        union(other) {
            if (this.contains(other)) {
                return this;
            }
            else if (other.contains(this)) {
                return other;
            }
            const start = $NN.Min(other.start, this.c);
            const end = $NN.Max(other.end, this.end);
            return new $ON_1(start, end);
        }
        get isEmpty() {
            return this.c.isEqual(this.e);
        }
        get isSingleLine() {
            return this.c.line === this.e.line;
        }
        with(startOrChange, end = this.end) {
            if (startOrChange === null || end === null) {
                throw (0, errors_1.$6)();
            }
            let start;
            if (!startOrChange) {
                start = this.start;
            }
            else if ($NN.isPosition(startOrChange)) {
                start = startOrChange;
            }
            else {
                start = startOrChange.start || this.start;
                end = startOrChange.end || this.end;
            }
            if (start.isEqual(this.c) && end.isEqual(this.end)) {
                return this;
            }
            return new $ON_1(start, end);
        }
        toJSON() {
            return [this.start, this.end];
        }
        [Symbol.for('debug.description')]() {
            return $QN(this);
        }
    };
    exports.$ON = $ON;
    exports.$ON = $ON = $ON_1 = __decorate([
        es5ClassCompat
    ], $ON);
    let $PN = $PN_1 = class $PN extends $ON {
        static isSelection(thing) {
            if (thing instanceof $PN_1) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return $ON.isRange(thing)
                && $NN.isPosition(thing.anchor)
                && $NN.isPosition(thing.active)
                && typeof thing.isReversed === 'boolean';
        }
        get anchor() {
            return this.f;
        }
        get active() {
            return this.g;
        }
        constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
            let anchor;
            let active;
            if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
                anchor = new $NN(anchorLineOrAnchor, anchorColumnOrActive);
                active = new $NN(activeLine, activeColumn);
            }
            else if ($NN.isPosition(anchorLineOrAnchor) && $NN.isPosition(anchorColumnOrActive)) {
                anchor = $NN.of(anchorLineOrAnchor);
                active = $NN.of(anchorColumnOrActive);
            }
            if (!anchor || !active) {
                throw new Error('Invalid arguments');
            }
            super(anchor, active);
            this.f = anchor;
            this.g = active;
        }
        get isReversed() {
            return this.f === this.e;
        }
        toJSON() {
            return {
                start: this.start,
                end: this.end,
                active: this.active,
                anchor: this.anchor
            };
        }
        [Symbol.for('debug.description')]() {
            return $RN(this);
        }
    };
    exports.$PN = $PN;
    exports.$PN = $PN = $PN_1 = __decorate([
        es5ClassCompat
    ], $PN);
    function $QN(range) {
        return range.isEmpty
            ? `[${range.start.line}:${range.start.character})`
            : `[${range.start.line}:${range.start.character} -> ${range.end.line}:${range.end.character})`;
    }
    function $RN(selection) {
        let rangeStr = $QN(selection);
        if (!selection.isEmpty) {
            if (selection.active.isEqual(selection.start)) {
                rangeStr = `|${rangeStr}`;
            }
            else {
                rangeStr = `${rangeStr}|`;
            }
        }
        return rangeStr;
    }
    const validateConnectionToken = (connectionToken) => {
        if (typeof connectionToken !== 'string' || connectionToken.length === 0 || !/^[0-9A-Za-z_\-]+$/.test(connectionToken)) {
            throw (0, errors_1.$6)('connectionToken');
        }
    };
    class $SN {
        static isResolvedAuthority(resolvedAuthority) {
            return resolvedAuthority
                && typeof resolvedAuthority === 'object'
                && typeof resolvedAuthority.host === 'string'
                && typeof resolvedAuthority.port === 'number'
                && (resolvedAuthority.connectionToken === undefined || typeof resolvedAuthority.connectionToken === 'string');
        }
        constructor(host, port, connectionToken) {
            if (typeof host !== 'string' || host.length === 0) {
                throw (0, errors_1.$6)('host');
            }
            if (typeof port !== 'number' || port === 0 || Math.round(port) !== port) {
                throw (0, errors_1.$6)('port');
            }
            if (typeof connectionToken !== 'undefined') {
                validateConnectionToken(connectionToken);
            }
            this.host = host;
            this.port = Math.round(port);
            this.connectionToken = connectionToken;
        }
    }
    exports.$SN = $SN;
    class $TN {
        static isManagedResolvedAuthority(resolvedAuthority) {
            return resolvedAuthority
                && typeof resolvedAuthority === 'object'
                && typeof resolvedAuthority.makeConnection === 'function'
                && (resolvedAuthority.connectionToken === undefined || typeof resolvedAuthority.connectionToken === 'string');
        }
        constructor(makeConnection, connectionToken) {
            this.makeConnection = makeConnection;
            this.connectionToken = connectionToken;
            if (typeof connectionToken !== 'undefined') {
                validateConnectionToken(connectionToken);
            }
        }
    }
    exports.$TN = $TN;
    class $UN extends Error {
        static NotAvailable(message, handled) {
            return new $UN(message, remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.NotAvailable, handled);
        }
        static TemporarilyNotAvailable(message) {
            return new $UN(message, remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable);
        }
        constructor(message, code = remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.Unknown, detail) {
            super(message);
            this._message = message;
            this._code = code;
            this._detail = detail;
            // workaround when extending builtin objects and when compiling to ES5, see:
            // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
            Object.setPrototypeOf(this, $UN.prototype);
        }
    }
    exports.$UN = $UN;
    var EndOfLine;
    (function (EndOfLine) {
        EndOfLine[EndOfLine["LF"] = 1] = "LF";
        EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
    })(EndOfLine || (exports.EndOfLine = EndOfLine = {}));
    var EnvironmentVariableMutatorType;
    (function (EnvironmentVariableMutatorType) {
        EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Replace"] = 1] = "Replace";
        EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Append"] = 2] = "Append";
        EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Prepend"] = 3] = "Prepend";
    })(EnvironmentVariableMutatorType || (exports.EnvironmentVariableMutatorType = EnvironmentVariableMutatorType = {}));
    let $VN = $VN_1 = class $VN {
        static isTextEdit(thing) {
            if (thing instanceof $VN_1) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return $ON.isRange(thing)
                && typeof thing.newText === 'string';
        }
        static replace(range, newText) {
            return new $VN_1(range, newText);
        }
        static insert(position, newText) {
            return $VN_1.replace(new $ON(position, position), newText);
        }
        static delete(range) {
            return $VN_1.replace(range, '');
        }
        static setEndOfLine(eol) {
            const ret = new $VN_1(new $ON(new $NN(0, 0), new $NN(0, 0)), '');
            ret.newEol = eol;
            return ret;
        }
        get range() {
            return this.c;
        }
        set range(value) {
            if (value && !$ON.isRange(value)) {
                throw (0, errors_1.$6)('range');
            }
            this.c = value;
        }
        get newText() {
            return this.e || '';
        }
        set newText(value) {
            if (value && typeof value !== 'string') {
                throw (0, errors_1.$6)('newText');
            }
            this.e = value;
        }
        get newEol() {
            return this.f;
        }
        set newEol(value) {
            if (value && typeof value !== 'number') {
                throw (0, errors_1.$6)('newEol');
            }
            this.f = value;
        }
        constructor(range, newText) {
            this.c = range;
            this.e = newText;
        }
        toJSON() {
            return {
                range: this.range,
                newText: this.newText,
                newEol: this.f
            };
        }
    };
    exports.$VN = $VN;
    exports.$VN = $VN = $VN_1 = __decorate([
        es5ClassCompat
    ], $VN);
    let $WN = $WN_1 = class $WN {
        static isNotebookCellEdit(thing) {
            if (thing instanceof $WN_1) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return $eP.isNotebookRange(thing)
                && Array.isArray(thing.newCells);
        }
        static replaceCells(range, newCells) {
            return new $WN_1(range, newCells);
        }
        static insertCells(index, newCells) {
            return new $WN_1(new $eP(index, index), newCells);
        }
        static deleteCells(range) {
            return new $WN_1(range, []);
        }
        static updateCellMetadata(index, newMetadata) {
            const edit = new $WN_1(new $eP(index, index), []);
            edit.newCellMetadata = newMetadata;
            return edit;
        }
        static updateNotebookMetadata(newMetadata) {
            const edit = new $WN_1(new $eP(0, 0), []);
            edit.newNotebookMetadata = newMetadata;
            return edit;
        }
        constructor(range, newCells) {
            this.range = range;
            this.newCells = newCells;
        }
    };
    exports.$WN = $WN;
    exports.$WN = $WN = $WN_1 = __decorate([
        es5ClassCompat
    ], $WN);
    class $XN {
        static isSnippetTextEdit(thing) {
            if (thing instanceof $XN) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return $ON.isRange(thing.range)
                && $ZN.isSnippetString(thing.snippet);
        }
        static replace(range, snippet) {
            return new $XN(range, snippet);
        }
        static insert(position, snippet) {
            return $XN.replace(new $ON(position, position), snippet);
        }
        constructor(range, snippet) {
            this.range = range;
            this.snippet = snippet;
        }
    }
    exports.$XN = $XN;
    var FileEditType;
    (function (FileEditType) {
        FileEditType[FileEditType["File"] = 1] = "File";
        FileEditType[FileEditType["Text"] = 2] = "Text";
        FileEditType[FileEditType["Cell"] = 3] = "Cell";
        FileEditType[FileEditType["CellReplace"] = 5] = "CellReplace";
        FileEditType[FileEditType["Snippet"] = 6] = "Snippet";
    })(FileEditType || (exports.FileEditType = FileEditType = {}));
    let $YN = class $YN {
        constructor() {
            this.c = [];
        }
        _allEntries() {
            return this.c;
        }
        // --- file
        renameFile(from, to, options, metadata) {
            this.c.push({ _type: FileEditType.File, from, to, options, metadata });
        }
        createFile(uri, options, metadata) {
            this.c.push({ _type: FileEditType.File, from: undefined, to: uri, options, metadata });
        }
        deleteFile(uri, options, metadata) {
            this.c.push({ _type: FileEditType.File, from: uri, to: undefined, options, metadata });
        }
        // --- notebook
        e(uri, value, metadata) {
            this.c.push({ _type: FileEditType.Cell, metadata, uri, edit: { editType: notebookCommon_1.CellEditType.DocumentMetadata, metadata: value }, notebookMetadata: value });
        }
        f(uri, startOrRange, cellData, metadata) {
            const start = startOrRange.start;
            const end = startOrRange.end;
            if (start !== end || cellData.length > 0) {
                this.c.push({ _type: FileEditType.CellReplace, uri, index: start, count: end - start, cells: cellData, metadata });
            }
        }
        g(uri, index, cellMetadata, metadata) {
            this.c.push({ _type: FileEditType.Cell, metadata, uri, edit: { editType: notebookCommon_1.CellEditType.Metadata, index, metadata: cellMetadata } });
        }
        // --- text
        replace(uri, range, newText, metadata) {
            this.c.push({ _type: FileEditType.Text, uri, edit: new $VN(range, newText), metadata });
        }
        insert(resource, position, newText, metadata) {
            this.replace(resource, new $ON(position, position), newText, metadata);
        }
        delete(resource, range, metadata) {
            this.replace(resource, range, '', metadata);
        }
        // --- text (Maplike)
        has(uri) {
            return this.c.some(edit => edit._type === FileEditType.Text && edit.uri.toString() === uri.toString());
        }
        set(uri, edits) {
            if (!edits) {
                // remove all text, snippet, or notebook edits for `uri`
                for (let i = 0; i < this.c.length; i++) {
                    const element = this.c[i];
                    switch (element._type) {
                        case FileEditType.Text:
                        case FileEditType.Snippet:
                        case FileEditType.Cell:
                        case FileEditType.CellReplace:
                            if (element.uri.toString() === uri.toString()) {
                                this.c[i] = undefined; // will be coalesced down below
                            }
                            break;
                    }
                }
                (0, arrays_1.$Hb)(this.c);
            }
            else {
                // append edit to the end
                for (const editOrTuple of edits) {
                    if (!editOrTuple) {
                        continue;
                    }
                    let edit;
                    let metadata;
                    if (Array.isArray(editOrTuple)) {
                        edit = editOrTuple[0];
                        metadata = editOrTuple[1];
                    }
                    else {
                        edit = editOrTuple;
                    }
                    if ($WN.isNotebookCellEdit(edit)) {
                        if (edit.newCellMetadata) {
                            this.g(uri, edit.range.start, edit.newCellMetadata, metadata);
                        }
                        else if (edit.newNotebookMetadata) {
                            this.e(uri, edit.newNotebookMetadata, metadata);
                        }
                        else {
                            this.f(uri, edit.range, edit.newCells, metadata);
                        }
                    }
                    else if ($XN.isSnippetTextEdit(edit)) {
                        this.c.push({ _type: FileEditType.Snippet, uri, range: edit.range, edit: edit.snippet, metadata });
                    }
                    else {
                        this.c.push({ _type: FileEditType.Text, uri, edit, metadata });
                    }
                }
            }
        }
        get(uri) {
            const res = [];
            for (const candidate of this.c) {
                if (candidate._type === FileEditType.Text && candidate.uri.toString() === uri.toString()) {
                    res.push(candidate.edit);
                }
            }
            return res;
        }
        entries() {
            const textEdits = new map_1.$Ac();
            for (const candidate of this.c) {
                if (candidate._type === FileEditType.Text) {
                    let textEdit = textEdits.get(candidate.uri);
                    if (!textEdit) {
                        textEdit = [candidate.uri, []];
                        textEdits.set(candidate.uri, textEdit);
                    }
                    textEdit[1].push(candidate.edit);
                }
            }
            return [...textEdits.values()];
        }
        get size() {
            return this.entries().length;
        }
        toJSON() {
            return this.entries();
        }
    };
    exports.$YN = $YN;
    exports.$YN = $YN = __decorate([
        es5ClassCompat
    ], $YN);
    let $ZN = $ZN_1 = class $ZN {
        static isSnippetString(thing) {
            if (thing instanceof $ZN_1) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.value === 'string';
        }
        static c(value) {
            return value.replace(/\$|}|\\/g, '\\$&');
        }
        constructor(value) {
            this.e = 1;
            this.value = value || '';
        }
        appendText(string) {
            this.value += $ZN_1.c(string);
            return this;
        }
        appendTabstop(number = this.e++) {
            this.value += '$';
            this.value += number;
            return this;
        }
        appendPlaceholder(value, number = this.e++) {
            if (typeof value === 'function') {
                const nested = new $ZN_1();
                nested.e = this.e;
                value(nested);
                this.e = nested.e;
                value = nested.value;
            }
            else {
                value = $ZN_1.c(value);
            }
            this.value += '${';
            this.value += number;
            this.value += ':';
            this.value += value;
            this.value += '}';
            return this;
        }
        appendChoice(values, number = this.e++) {
            const value = values.map(s => s.replaceAll(/[|\\,]/g, '\\$&')).join(',');
            this.value += '${';
            this.value += number;
            this.value += '|';
            this.value += value;
            this.value += '|}';
            return this;
        }
        appendVariable(name, defaultValue) {
            if (typeof defaultValue === 'function') {
                const nested = new $ZN_1();
                nested.e = this.e;
                defaultValue(nested);
                this.e = nested.e;
                defaultValue = nested.value;
            }
            else if (typeof defaultValue === 'string') {
                defaultValue = defaultValue.replace(/\$|}/g, '\\$&'); // CodeQL [SM02383] I do not want to escape backslashes here
            }
            this.value += '${';
            this.value += name;
            if (defaultValue) {
                this.value += ':';
                this.value += defaultValue;
            }
            this.value += '}';
            return this;
        }
    };
    exports.$ZN = $ZN;
    exports.$ZN = $ZN = $ZN_1 = __decorate([
        es5ClassCompat
    ], $ZN);
    var DiagnosticTag;
    (function (DiagnosticTag) {
        DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
        DiagnosticTag[DiagnosticTag["Deprecated"] = 2] = "Deprecated";
    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
        DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
        DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
        DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
    let $1N = $1N_1 = class $1N {
        static isLocation(thing) {
            if (thing instanceof $1N_1) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return $ON.isRange(thing.range)
                && uri_1.URI.isUri(thing.uri);
        }
        constructor(uri, rangeOrPosition) {
            this.uri = uri;
            if (!rangeOrPosition) {
                //that's OK
            }
            else if ($ON.isRange(rangeOrPosition)) {
                this.range = $ON.of(rangeOrPosition);
            }
            else if ($NN.isPosition(rangeOrPosition)) {
                this.range = new $ON(rangeOrPosition, rangeOrPosition);
            }
            else {
                throw new Error('Illegal argument');
            }
        }
        toJSON() {
            return {
                uri: this.uri,
                range: this.range
            };
        }
    };
    exports.$1N = $1N;
    exports.$1N = $1N = $1N_1 = __decorate([
        es5ClassCompat
    ], $1N);
    let $2N = class $2N {
        static is(thing) {
            if (!thing) {
                return false;
            }
            return typeof thing.message === 'string'
                && thing.location
                && $ON.isRange(thing.location.range)
                && uri_1.URI.isUri(thing.location.uri);
        }
        constructor(location, message) {
            this.location = location;
            this.message = message;
        }
        static isEqual(a, b) {
            if (a === b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            return a.message === b.message
                && a.location.range.isEqual(b.location.range)
                && a.location.uri.toString() === b.location.uri.toString();
        }
    };
    exports.$2N = $2N;
    exports.$2N = $2N = __decorate([
        es5ClassCompat
    ], $2N);
    let $3N = class $3N {
        constructor(range, message, severity = DiagnosticSeverity.Error) {
            if (!$ON.isRange(range)) {
                throw new TypeError('range must be set');
            }
            if (!message) {
                throw new TypeError('message must be set');
            }
            this.range = range;
            this.message = message;
            this.severity = severity;
        }
        toJSON() {
            return {
                severity: DiagnosticSeverity[this.severity],
                message: this.message,
                range: this.range,
                source: this.source,
                code: this.code,
            };
        }
        static isEqual(a, b) {
            if (a === b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            return a.message === b.message
                && a.severity === b.severity
                && a.code === b.code
                && a.severity === b.severity
                && a.source === b.source
                && a.range.isEqual(b.range)
                && (0, arrays_1.$tb)(a.tags, b.tags)
                && (0, arrays_1.$tb)(a.relatedInformation, b.relatedInformation, $2N.isEqual);
        }
    };
    exports.$3N = $3N;
    exports.$3N = $3N = __decorate([
        es5ClassCompat
    ], $3N);
    let $4N = class $4N {
        constructor(contents, range) {
            if (!contents) {
                throw new Error('Illegal argument, contents must be defined');
            }
            if (Array.isArray(contents)) {
                this.contents = contents;
            }
            else {
                this.contents = [contents];
            }
            this.range = range;
        }
    };
    exports.$4N = $4N;
    exports.$4N = $4N = __decorate([
        es5ClassCompat
    ], $4N);
    let $5N = class $5N extends $4N {
        constructor(contents, range, canIncreaseVerbosity, canDecreaseVerbosity) {
            super(contents, range);
            this.canIncreaseVerbosity = canIncreaseVerbosity;
            this.canDecreaseVerbosity = canDecreaseVerbosity;
        }
    };
    exports.$5N = $5N;
    exports.$5N = $5N = __decorate([
        es5ClassCompat
    ], $5N);
    var HoverVerbosityAction;
    (function (HoverVerbosityAction) {
        HoverVerbosityAction[HoverVerbosityAction["Increase"] = 0] = "Increase";
        HoverVerbosityAction[HoverVerbosityAction["Decrease"] = 1] = "Decrease";
    })(HoverVerbosityAction || (exports.HoverVerbosityAction = HoverVerbosityAction = {}));
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));
    let $6N = class $6N {
        constructor(range, kind = DocumentHighlightKind.Text) {
            this.range = range;
            this.kind = kind;
        }
        toJSON() {
            return {
                range: this.range,
                kind: DocumentHighlightKind[this.kind]
            };
        }
    };
    exports.$6N = $6N;
    exports.$6N = $6N = __decorate([
        es5ClassCompat
    ], $6N);
    let $7N = class $7N {
        constructor(uri, highlights) {
            this.uri = uri;
            this.highlights = highlights;
        }
        toJSON() {
            return {
                uri: this.uri,
                highlights: this.highlights.map(h => h.toJSON())
            };
        }
    };
    exports.$7N = $7N;
    exports.$7N = $7N = __decorate([
        es5ClassCompat
    ], $7N);
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
    var SymbolTag;
    (function (SymbolTag) {
        SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
    let $8N = $8N_1 = class $8N {
        static validate(candidate) {
            if (!candidate.name) {
                throw new Error('name must not be falsy');
            }
        }
        constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {
            this.name = name;
            this.kind = kind;
            this.containerName = containerName;
            if (typeof rangeOrContainer === 'string') {
                this.containerName = rangeOrContainer;
            }
            if (locationOrUri instanceof $1N) {
                this.location = locationOrUri;
            }
            else if (rangeOrContainer instanceof $ON) {
                this.location = new $1N(locationOrUri, rangeOrContainer);
            }
            $8N_1.validate(this);
        }
        toJSON() {
            return {
                name: this.name,
                kind: SymbolKind[this.kind],
                location: this.location,
                containerName: this.containerName
            };
        }
    };
    exports.$8N = $8N;
    exports.$8N = $8N = $8N_1 = __decorate([
        es5ClassCompat
    ], $8N);
    let $9N = $9N_1 = class $9N {
        static validate(candidate) {
            if (!candidate.name) {
                throw new Error('name must not be falsy');
            }
            if (!candidate.range.contains(candidate.selectionRange)) {
                throw new Error('selectionRange must be contained in fullRange');
            }
            candidate.children?.forEach($9N_1.validate);
        }
        constructor(name, detail, kind, range, selectionRange) {
            this.name = name;
            this.detail = detail;
            this.kind = kind;
            this.range = range;
            this.selectionRange = selectionRange;
            this.children = [];
            $9N_1.validate(this);
        }
    };
    exports.$9N = $9N;
    exports.$9N = $9N = $9N_1 = __decorate([
        es5ClassCompat
    ], $9N);
    var CodeActionTriggerKind;
    (function (CodeActionTriggerKind) {
        CodeActionTriggerKind[CodeActionTriggerKind["Invoke"] = 1] = "Invoke";
        CodeActionTriggerKind[CodeActionTriggerKind["Automatic"] = 2] = "Automatic";
    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
    let $0N = class $0N {
        constructor(title, kind) {
            this.title = title;
            this.kind = kind;
        }
    };
    exports.$0N = $0N;
    exports.$0N = $0N = __decorate([
        es5ClassCompat
    ], $0N);
    let $$N = class $$N {
        static { $$N_1 = this; }
        static { this.c = '.'; }
        constructor(value) {
            this.value = value;
        }
        append(parts) {
            return new $$N_1(this.value ? this.value + $$N_1.c + parts : parts);
        }
        intersects(other) {
            return this.contains(other) || other.contains(this);
        }
        contains(other) {
            return this.value === other.value || other.value.startsWith(this.value + $$N_1.c);
        }
    };
    exports.$$N = $$N;
    exports.$$N = $$N = $$N_1 = __decorate([
        es5ClassCompat
    ], $$N);
    $$N.Empty = new $$N('');
    $$N.QuickFix = $$N.Empty.append('quickfix');
    $$N.Refactor = $$N.Empty.append('refactor');
    $$N.RefactorExtract = $$N.Refactor.append('extract');
    $$N.RefactorInline = $$N.Refactor.append('inline');
    $$N.RefactorMove = $$N.Refactor.append('move');
    $$N.RefactorRewrite = $$N.Refactor.append('rewrite');
    $$N.Source = $$N.Empty.append('source');
    $$N.SourceOrganizeImports = $$N.Source.append('organizeImports');
    $$N.SourceFixAll = $$N.Source.append('fixAll');
    $$N.Notebook = $$N.Empty.append('notebook');
    let $_N = class $_N {
        constructor(range, parent) {
            this.range = range;
            this.parent = parent;
            if (parent && !parent.range.contains(this.range)) {
                throw new Error('Invalid argument: parent must contain this range');
            }
        }
    };
    exports.$_N = $_N;
    exports.$_N = $_N = __decorate([
        es5ClassCompat
    ], $_N);
    class $aO {
        constructor(kind, name, detail, uri, range, selectionRange) {
            this.kind = kind;
            this.name = name;
            this.detail = detail;
            this.uri = uri;
            this.range = range;
            this.selectionRange = selectionRange;
        }
    }
    exports.$aO = $aO;
    class $bO {
        constructor(item, fromRanges) {
            this.fromRanges = fromRanges;
            this.from = item;
        }
    }
    exports.$bO = $bO;
    class $cO {
        constructor(item, fromRanges) {
            this.fromRanges = fromRanges;
            this.to = item;
        }
    }
    exports.$cO = $cO;
    var LanguageStatusSeverity;
    (function (LanguageStatusSeverity) {
        LanguageStatusSeverity[LanguageStatusSeverity["Information"] = 0] = "Information";
        LanguageStatusSeverity[LanguageStatusSeverity["Warning"] = 1] = "Warning";
        LanguageStatusSeverity[LanguageStatusSeverity["Error"] = 2] = "Error";
    })(LanguageStatusSeverity || (exports.LanguageStatusSeverity = LanguageStatusSeverity = {}));
    let $dO = class $dO {
        constructor(range, command) {
            this.range = range;
            this.command = command;
        }
        get isResolved() {
            return !!this.command;
        }
    };
    exports.$dO = $dO;
    exports.$dO = $dO = __decorate([
        es5ClassCompat
    ], $dO);
    let $eO = $eO_1 = class $eO {
        #delegate;
        static isMarkdownString(thing) {
            if (thing instanceof $eO_1) {
                return true;
            }
            return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && (thing.value !== undefined);
        }
        constructor(value, supportThemeIcons = false) {
            this.#delegate = new htmlContent_1.$4k(value, { supportThemeIcons });
        }
        get value() {
            return this.#delegate.value;
        }
        set value(value) {
            this.#delegate.value = value;
        }
        get isTrusted() {
            return this.#delegate.isTrusted;
        }
        set isTrusted(value) {
            this.#delegate.isTrusted = value;
        }
        get supportThemeIcons() {
            return this.#delegate.supportThemeIcons;
        }
        set supportThemeIcons(value) {
            this.#delegate.supportThemeIcons = value;
        }
        get supportHtml() {
            return this.#delegate.supportHtml;
        }
        set supportHtml(value) {
            this.#delegate.supportHtml = value;
        }
        get baseUri() {
            return this.#delegate.baseUri;
        }
        set baseUri(value) {
            this.#delegate.baseUri = value;
        }
        appendText(value) {
            this.#delegate.appendText(value);
            return this;
        }
        appendMarkdown(value) {
            this.#delegate.appendMarkdown(value);
            return this;
        }
        appendCodeblock(value, language) {
            this.#delegate.appendCodeblock(language ?? '', value);
            return this;
        }
    };
    exports.$eO = $eO;
    exports.$eO = $eO = $eO_1 = __decorate([
        es5ClassCompat
    ], $eO);
    let $fO = class $fO {
        constructor(label, documentation) {
            this.label = label;
            this.documentation = documentation;
        }
    };
    exports.$fO = $fO;
    exports.$fO = $fO = __decorate([
        es5ClassCompat
    ], $fO);
    let $gO = class $gO {
        constructor(label, documentation) {
            this.label = label;
            this.documentation = documentation;
            this.parameters = [];
        }
    };
    exports.$gO = $gO;
    exports.$gO = $gO = __decorate([
        es5ClassCompat
    ], $gO);
    let $hO = class $hO {
        constructor() {
            this.activeSignature = 0;
            this.activeParameter = 0;
            this.signatures = [];
        }
    };
    exports.$hO = $hO;
    exports.$hO = $hO = __decorate([
        es5ClassCompat
    ], $hO);
    var SignatureHelpTriggerKind;
    (function (SignatureHelpTriggerKind) {
        SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
    })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var InlayHintKind;
    (function (InlayHintKind) {
        InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
        InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
    let $iO = class $iO {
        constructor(value) {
            this.value = value;
        }
    };
    exports.$iO = $iO;
    exports.$iO = $iO = __decorate([
        es5ClassCompat
    ], $iO);
    let $jO = class $jO {
        constructor(position, label, kind) {
            this.position = position;
            this.label = label;
            this.kind = kind;
        }
    };
    exports.$jO = $jO;
    exports.$jO = $jO = __decorate([
        es5ClassCompat
    ], $jO);
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
    })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
        CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
        CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
        CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
        CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
        CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
        CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
        CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
        CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
        CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
    var CompletionItemTag;
    (function (CompletionItemTag) {
        CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));
    let $kO = class $kO {
        constructor(label, kind) {
            this.label = label;
            this.kind = kind;
        }
        toJSON() {
            return {
                label: this.label,
                kind: this.kind && CompletionItemKind[this.kind],
                detail: this.detail,
                documentation: this.documentation,
                sortText: this.sortText,
                filterText: this.filterText,
                preselect: this.preselect,
                insertText: this.insertText,
                textEdit: this.textEdit
            };
        }
    };
    exports.$kO = $kO;
    exports.$kO = $kO = __decorate([
        es5ClassCompat
    ], $kO);
    let $lO = class $lO {
        constructor(items = [], isIncomplete = false) {
            this.items = items;
            this.isIncomplete = isIncomplete;
        }
    };
    exports.$lO = $lO;
    exports.$lO = $lO = __decorate([
        es5ClassCompat
    ], $lO);
    let $mO = class $mO {
        constructor(insertText, range, command) {
            this.insertText = insertText;
            this.range = range;
            this.command = command;
        }
    };
    exports.$mO = $mO;
    exports.$mO = $mO = __decorate([
        es5ClassCompat
    ], $mO);
    let $nO = class $nO {
        constructor(items) {
            this.commands = undefined;
            this.suppressSuggestions = undefined;
            this.items = items;
        }
    };
    exports.$nO = $nO;
    exports.$nO = $nO = __decorate([
        es5ClassCompat
    ], $nO);
    var PartialAcceptTriggerKind;
    (function (PartialAcceptTriggerKind) {
        PartialAcceptTriggerKind[PartialAcceptTriggerKind["Unknown"] = 0] = "Unknown";
        PartialAcceptTriggerKind[PartialAcceptTriggerKind["Word"] = 1] = "Word";
        PartialAcceptTriggerKind[PartialAcceptTriggerKind["Line"] = 2] = "Line";
        PartialAcceptTriggerKind[PartialAcceptTriggerKind["Suggest"] = 3] = "Suggest";
    })(PartialAcceptTriggerKind || (exports.PartialAcceptTriggerKind = PartialAcceptTriggerKind = {}));
    var ViewColumn;
    (function (ViewColumn) {
        ViewColumn[ViewColumn["Active"] = -1] = "Active";
        ViewColumn[ViewColumn["Beside"] = -2] = "Beside";
        ViewColumn[ViewColumn["One"] = 1] = "One";
        ViewColumn[ViewColumn["Two"] = 2] = "Two";
        ViewColumn[ViewColumn["Three"] = 3] = "Three";
        ViewColumn[ViewColumn["Four"] = 4] = "Four";
        ViewColumn[ViewColumn["Five"] = 5] = "Five";
        ViewColumn[ViewColumn["Six"] = 6] = "Six";
        ViewColumn[ViewColumn["Seven"] = 7] = "Seven";
        ViewColumn[ViewColumn["Eight"] = 8] = "Eight";
        ViewColumn[ViewColumn["Nine"] = 9] = "Nine";
    })(ViewColumn || (exports.ViewColumn = ViewColumn = {}));
    var StatusBarAlignment;
    (function (StatusBarAlignment) {
        StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
        StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
    })(StatusBarAlignment || (exports.StatusBarAlignment = StatusBarAlignment = {}));
    function $oO(extension, id) {
        return `${extensions_1.$rn.toKey(extension)}.${id}`;
    }
    var TextEditorLineNumbersStyle;
    (function (TextEditorLineNumbersStyle) {
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Interval"] = 3] = "Interval";
    })(TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = TextEditorLineNumbersStyle = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
        TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
        TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
    })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType || (exports.TextEditorRevealType = TextEditorRevealType = {}));
    var TextEditorSelectionChangeKind;
    (function (TextEditorSelectionChangeKind) {
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
    })(TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = TextEditorSelectionChangeKind = {}));
    var TextDocumentChangeReason;
    (function (TextDocumentChangeReason) {
        TextDocumentChangeReason[TextDocumentChangeReason["Undo"] = 1] = "Undo";
        TextDocumentChangeReason[TextDocumentChangeReason["Redo"] = 2] = "Redo";
    })(TextDocumentChangeReason || (exports.TextDocumentChangeReason = TextDocumentChangeReason = {}));
    /**
     * These values match very carefully the values of `TrackedRangeStickiness`
     */
    var DecorationRangeBehavior;
    (function (DecorationRangeBehavior) {
        /**
         * TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
        /**
         * TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingAfter
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
    })(DecorationRangeBehavior || (exports.DecorationRangeBehavior = DecorationRangeBehavior = {}));
    (function (TextEditorSelectionChangeKind) {
        function fromValue(s) {
            switch (s) {
                case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
                case 'mouse': return TextEditorSelectionChangeKind.Mouse;
                case 'api': return TextEditorSelectionChangeKind.Command;
            }
            return undefined;
        }
        TextEditorSelectionChangeKind.fromValue = fromValue;
    })(TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = TextEditorSelectionChangeKind = {}));
    var SyntaxTokenType;
    (function (SyntaxTokenType) {
        SyntaxTokenType[SyntaxTokenType["Other"] = 0] = "Other";
        SyntaxTokenType[SyntaxTokenType["Comment"] = 1] = "Comment";
        SyntaxTokenType[SyntaxTokenType["String"] = 2] = "String";
        SyntaxTokenType[SyntaxTokenType["RegEx"] = 3] = "RegEx";
    })(SyntaxTokenType || (exports.SyntaxTokenType = SyntaxTokenType = {}));
    (function (SyntaxTokenType) {
        function toString(v) {
            switch (v) {
                case SyntaxTokenType.Other: return 'other';
                case SyntaxTokenType.Comment: return 'comment';
                case SyntaxTokenType.String: return 'string';
                case SyntaxTokenType.RegEx: return 'regex';
            }
            return 'other';
        }
        SyntaxTokenType.toString = toString;
    })(SyntaxTokenType || (exports.SyntaxTokenType = SyntaxTokenType = {}));
    let $pO = class $pO {
        constructor(range, target) {
            if (target && !(uri_1.URI.isUri(target))) {
                throw (0, errors_1.$6)('target');
            }
            if (!$ON.isRange(range) || range.isEmpty) {
                throw (0, errors_1.$6)('range');
            }
            this.range = range;
            this.target = target;
        }
    };
    exports.$pO = $pO;
    exports.$pO = $pO = __decorate([
        es5ClassCompat
    ], $pO);
    let $qO = class $qO {
        constructor(red, green, blue, alpha) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = alpha;
        }
    };
    exports.$qO = $qO;
    exports.$qO = $qO = __decorate([
        es5ClassCompat
    ], $qO);
    let $rO = class $rO {
        constructor(range, color) {
            if (color && !(color instanceof $qO)) {
                throw (0, errors_1.$6)('color');
            }
            if (!$ON.isRange(range) || range.isEmpty) {
                throw (0, errors_1.$6)('range');
            }
            this.range = range;
            this.color = color;
        }
    };
    exports.$rO = $rO;
    exports.$rO = $rO = __decorate([
        es5ClassCompat
    ], $rO);
    let $sO = class $sO {
        constructor(label) {
            if (!label || typeof label !== 'string') {
                throw (0, errors_1.$6)('label');
            }
            this.label = label;
        }
    };
    exports.$sO = $sO;
    exports.$sO = $sO = __decorate([
        es5ClassCompat
    ], $sO);
    var ColorFormat;
    (function (ColorFormat) {
        ColorFormat[ColorFormat["RGB"] = 0] = "RGB";
        ColorFormat[ColorFormat["HEX"] = 1] = "HEX";
        ColorFormat[ColorFormat["HSL"] = 2] = "HSL";
    })(ColorFormat || (exports.ColorFormat = ColorFormat = {}));
    var SourceControlInputBoxValidationType;
    (function (SourceControlInputBoxValidationType) {
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Error"] = 0] = "Error";
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Warning"] = 1] = "Warning";
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Information"] = 2] = "Information";
    })(SourceControlInputBoxValidationType || (exports.SourceControlInputBoxValidationType = SourceControlInputBoxValidationType = {}));
    var TerminalExitReason;
    (function (TerminalExitReason) {
        TerminalExitReason[TerminalExitReason["Unknown"] = 0] = "Unknown";
        TerminalExitReason[TerminalExitReason["Shutdown"] = 1] = "Shutdown";
        TerminalExitReason[TerminalExitReason["Process"] = 2] = "Process";
        TerminalExitReason[TerminalExitReason["User"] = 3] = "User";
        TerminalExitReason[TerminalExitReason["Extension"] = 4] = "Extension";
    })(TerminalExitReason || (exports.TerminalExitReason = TerminalExitReason = {}));
    var TerminalShellExecutionCommandLineConfidence;
    (function (TerminalShellExecutionCommandLineConfidence) {
        TerminalShellExecutionCommandLineConfidence[TerminalShellExecutionCommandLineConfidence["Low"] = 0] = "Low";
        TerminalShellExecutionCommandLineConfidence[TerminalShellExecutionCommandLineConfidence["Medium"] = 1] = "Medium";
        TerminalShellExecutionCommandLineConfidence[TerminalShellExecutionCommandLineConfidence["High"] = 2] = "High";
    })(TerminalShellExecutionCommandLineConfidence || (exports.TerminalShellExecutionCommandLineConfidence = TerminalShellExecutionCommandLineConfidence = {}));
    class $tO {
        constructor(startIndex, length, tooltip) {
            this.startIndex = startIndex;
            this.length = length;
            this.tooltip = tooltip;
            if (typeof startIndex !== 'number' || startIndex < 0) {
                throw (0, errors_1.$6)('startIndex');
            }
            if (typeof length !== 'number' || length < 1) {
                throw (0, errors_1.$6)('length');
            }
            if (tooltip !== undefined && typeof tooltip !== 'string') {
                throw (0, errors_1.$6)('tooltip');
            }
        }
    }
    exports.$tO = $tO;
    class $uO {
        constructor(uri) {
            this.uri = uri;
        }
    }
    exports.$uO = $uO;
    class $vO {
        constructor(terminalCommand) {
            this.terminalCommand = terminalCommand;
        }
    }
    exports.$vO = $vO;
    var TerminalLocation;
    (function (TerminalLocation) {
        TerminalLocation[TerminalLocation["Panel"] = 1] = "Panel";
        TerminalLocation[TerminalLocation["Editor"] = 2] = "Editor";
    })(TerminalLocation || (exports.TerminalLocation = TerminalLocation = {}));
    class $wO {
        constructor(options) {
            this.options = options;
            if (typeof options !== 'object') {
                throw (0, errors_1.$6)('options');
            }
        }
    }
    exports.$wO = $wO;
    var TaskRevealKind;
    (function (TaskRevealKind) {
        TaskRevealKind[TaskRevealKind["Always"] = 1] = "Always";
        TaskRevealKind[TaskRevealKind["Silent"] = 2] = "Silent";
        TaskRevealKind[TaskRevealKind["Never"] = 3] = "Never";
    })(TaskRevealKind || (exports.TaskRevealKind = TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        TaskPanelKind[TaskPanelKind["Shared"] = 1] = "Shared";
        TaskPanelKind[TaskPanelKind["Dedicated"] = 2] = "Dedicated";
        TaskPanelKind[TaskPanelKind["New"] = 3] = "New";
    })(TaskPanelKind || (exports.TaskPanelKind = TaskPanelKind = {}));
    let $xO = class $xO {
        static { $xO_1 = this; }
        static { this.Clean = new $xO_1('clean', 'Clean'); }
        static { this.Build = new $xO_1('build', 'Build'); }
        static { this.Rebuild = new $xO_1('rebuild', 'Rebuild'); }
        static { this.Test = new $xO_1('test', 'Test'); }
        static from(value) {
            switch (value) {
                case 'clean':
                    return $xO_1.Clean;
                case 'build':
                    return $xO_1.Build;
                case 'rebuild':
                    return $xO_1.Rebuild;
                case 'test':
                    return $xO_1.Test;
                default:
                    return undefined;
            }
        }
        constructor(id, label) {
            this.label = label;
            if (typeof id !== 'string') {
                throw (0, errors_1.$6)('name');
            }
            if (typeof label !== 'string') {
                throw (0, errors_1.$6)('name');
            }
            this.c = id;
        }
        get id() {
            return this.c;
        }
    };
    exports.$xO = $xO;
    exports.$xO = $xO = $xO_1 = __decorate([
        es5ClassCompat
    ], $xO);
    function computeTaskExecutionId(values) {
        let id = '';
        for (let i = 0; i < values.length; i++) {
            id += values[i].replace(/,/g, ',,') + ',';
        }
        return id;
    }
    let $yO = class $yO {
        constructor(process, varg1, varg2) {
            if (typeof process !== 'string') {
                throw (0, errors_1.$6)('process');
            }
            this.e = [];
            this.c = process;
            if (varg1 !== undefined) {
                if (Array.isArray(varg1)) {
                    this.e = varg1;
                    this.f = varg2;
                }
                else {
                    this.f = varg1;
                }
            }
        }
        get process() {
            return this.c;
        }
        set process(value) {
            if (typeof value !== 'string') {
                throw (0, errors_1.$6)('process');
            }
            this.c = value;
        }
        get args() {
            return this.e;
        }
        set args(value) {
            if (!Array.isArray(value)) {
                value = [];
            }
            this.e = value;
        }
        get options() {
            return this.f;
        }
        set options(value) {
            this.f = value;
        }
        computeId() {
            const props = [];
            props.push('process');
            if (this.c !== undefined) {
                props.push(this.c);
            }
            if (this.e && this.e.length > 0) {
                for (const arg of this.e) {
                    props.push(arg);
                }
            }
            return computeTaskExecutionId(props);
        }
    };
    exports.$yO = $yO;
    exports.$yO = $yO = __decorate([
        es5ClassCompat
    ], $yO);
    let $zO = class $zO {
        constructor(arg0, arg1, arg2) {
            this.f = [];
            if (Array.isArray(arg1)) {
                if (!arg0) {
                    throw (0, errors_1.$6)('command can\'t be undefined or null');
                }
                if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {
                    throw (0, errors_1.$6)('command');
                }
                this.e = arg0;
                this.f = arg1;
                this.g = arg2;
            }
            else {
                if (typeof arg0 !== 'string') {
                    throw (0, errors_1.$6)('commandLine');
                }
                this.c = arg0;
                this.g = arg1;
            }
        }
        get commandLine() {
            return this.c;
        }
        set commandLine(value) {
            if (typeof value !== 'string') {
                throw (0, errors_1.$6)('commandLine');
            }
            this.c = value;
        }
        get command() {
            return this.e ? this.e : '';
        }
        set command(value) {
            if (typeof value !== 'string' && typeof value.value !== 'string') {
                throw (0, errors_1.$6)('command');
            }
            this.e = value;
        }
        get args() {
            return this.f;
        }
        set args(value) {
            this.f = value || [];
        }
        get options() {
            return this.g;
        }
        set options(value) {
            this.g = value;
        }
        computeId() {
            const props = [];
            props.push('shell');
            if (this.c !== undefined) {
                props.push(this.c);
            }
            if (this.e !== undefined) {
                props.push(typeof this.e === 'string' ? this.e : this.e.value);
            }
            if (this.f && this.f.length > 0) {
                for (const arg of this.f) {
                    props.push(typeof arg === 'string' ? arg : arg.value);
                }
            }
            return computeTaskExecutionId(props);
        }
    };
    exports.$zO = $zO;
    exports.$zO = $zO = __decorate([
        es5ClassCompat
    ], $zO);
    var ShellQuoting;
    (function (ShellQuoting) {
        ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
        ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
        ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
    })(ShellQuoting || (exports.ShellQuoting = ShellQuoting = {}));
    var TaskScope;
    (function (TaskScope) {
        TaskScope[TaskScope["Global"] = 1] = "Global";
        TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
    })(TaskScope || (exports.TaskScope = TaskScope = {}));
    class $AO {
        constructor(callback) {
            this.c = callback;
        }
        computeId() {
            return 'customExecution' + (0, uuid_1.$2g)();
        }
        set callback(value) {
            this.c = value;
        }
        get callback() {
            return this.c;
        }
    }
    exports.$AO = $AO;
    let $BO = class $BO {
        static { $BO_1 = this; }
        static { this.c = 'customExecution'; }
        static { this.e = 'process'; }
        static { this.f = 'shell'; }
        static { this.g = '$empty'; }
        constructor(definition, arg2, arg3, arg4, arg5, arg6) {
            this.k = false;
            this.l = this.definition = definition;
            let problemMatchers;
            if (typeof arg2 === 'string') {
                this.o = this.name = arg2;
                this.w = this.source = arg3;
                this.execution = arg4;
                problemMatchers = arg5;
                this.k = true;
            }
            else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {
                this.target = arg2;
                this.o = this.name = arg3;
                this.w = this.source = arg4;
                this.execution = arg5;
                problemMatchers = arg6;
            }
            else {
                this.target = arg2;
                this.o = this.name = arg3;
                this.w = this.source = arg4;
                this.execution = arg5;
                problemMatchers = arg6;
            }
            if (typeof problemMatchers === 'string') {
                this.r = [problemMatchers];
                this.t = true;
            }
            else if (Array.isArray(problemMatchers)) {
                this.r = problemMatchers;
                this.t = true;
            }
            else {
                this.r = [];
                this.t = false;
            }
            this.u = false;
            this.y = Object.create(null);
            this.z = Object.create(null);
        }
        get _id() {
            return this.j;
        }
        set _id(value) {
            this.j = value;
        }
        get _deprecated() {
            return this.k;
        }
        B() {
            if (this.j === undefined) {
                return;
            }
            this.j = undefined;
            this.m = undefined;
            this.C();
        }
        C() {
            if (this.q instanceof $yO) {
                this.l = {
                    type: $BO_1.e,
                    id: this.q.computeId()
                };
            }
            else if (this.q instanceof $zO) {
                this.l = {
                    type: $BO_1.f,
                    id: this.q.computeId()
                };
            }
            else if (this.q instanceof $AO) {
                this.l = {
                    type: $BO_1.c,
                    id: this.q.computeId()
                };
            }
            else {
                this.l = {
                    type: $BO_1.g,
                    id: (0, uuid_1.$2g)()
                };
            }
        }
        get definition() {
            return this.l;
        }
        set definition(value) {
            if (value === undefined || value === null) {
                throw (0, errors_1.$6)('Kind can\'t be undefined or null');
            }
            this.B();
            this.l = value;
        }
        get scope() {
            return this.m;
        }
        set target(value) {
            this.B();
            this.m = value;
        }
        get name() {
            return this.o;
        }
        set name(value) {
            if (typeof value !== 'string') {
                throw (0, errors_1.$6)('name');
            }
            this.B();
            this.o = value;
        }
        get execution() {
            return this.q;
        }
        set execution(value) {
            if (value === null) {
                value = undefined;
            }
            this.B();
            this.q = value;
            const type = this.l.type;
            if ($BO_1.g === type || $BO_1.e === type || $BO_1.f === type || $BO_1.c === type) {
                this.C();
            }
        }
        get problemMatchers() {
            return this.r;
        }
        set problemMatchers(value) {
            if (!Array.isArray(value)) {
                this.B();
                this.r = [];
                this.t = false;
                return;
            }
            else {
                this.B();
                this.r = value;
                this.t = true;
            }
        }
        get hasDefinedMatchers() {
            return this.t;
        }
        get isBackground() {
            return this.u;
        }
        set isBackground(value) {
            if (value !== true && value !== false) {
                value = false;
            }
            this.B();
            this.u = value;
        }
        get source() {
            return this.w;
        }
        set source(value) {
            if (typeof value !== 'string' || value.length === 0) {
                throw (0, errors_1.$6)('source must be a string of length > 0');
            }
            this.B();
            this.w = value;
        }
        get group() {
            return this.x;
        }
        set group(value) {
            if (value === null) {
                value = undefined;
            }
            this.B();
            this.x = value;
        }
        get detail() {
            return this.A;
        }
        set detail(value) {
            if (value === null) {
                value = undefined;
            }
            this.A = value;
        }
        get presentationOptions() {
            return this.y;
        }
        set presentationOptions(value) {
            if (value === null || value === undefined) {
                value = Object.create(null);
            }
            this.B();
            this.y = value;
        }
        get runOptions() {
            return this.z;
        }
        set runOptions(value) {
            if (value === null || value === undefined) {
                value = Object.create(null);
            }
            this.B();
            this.z = value;
        }
    };
    exports.$BO = $BO;
    exports.$BO = $BO = $BO_1 = __decorate([
        es5ClassCompat
    ], $BO);
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
        ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
    })(ProgressLocation || (exports.ProgressLocation = ProgressLocation = {}));
    var ViewBadge;
    (function (ViewBadge) {
        function isViewBadge(thing) {
            const viewBadgeThing = thing;
            if (!(0, types_1.$ig)(viewBadgeThing.value)) {
                console.log('INVALID view badge, invalid value', viewBadgeThing.value);
                return false;
            }
            if (viewBadgeThing.tooltip && !(0, types_1.$eg)(viewBadgeThing.tooltip)) {
                console.log('INVALID view badge, invalid tooltip', viewBadgeThing.tooltip);
                return false;
            }
            return true;
        }
        ViewBadge.isViewBadge = isViewBadge;
    })(ViewBadge || (exports.ViewBadge = ViewBadge = {}));
    let $CO = $CO_1 = class $CO {
        static isTreeItem(thing, extension) {
            const treeItemThing = thing;
            if (treeItemThing.checkboxState !== undefined) {
                const checkbox = (0, types_1.$ig)(treeItemThing.checkboxState) ? treeItemThing.checkboxState :
                    (0, types_1.$gg)(treeItemThing.checkboxState) && (0, types_1.$ig)(treeItemThing.checkboxState.state) ? treeItemThing.checkboxState.state : undefined;
                const tooltip = !(0, types_1.$ig)(treeItemThing.checkboxState) && (0, types_1.$gg)(treeItemThing.checkboxState) ? treeItemThing.checkboxState.tooltip : undefined;
                if (checkbox === undefined || (checkbox !== TreeItemCheckboxState.Checked && checkbox !== TreeItemCheckboxState.Unchecked) || (tooltip !== undefined && !(0, types_1.$eg)(tooltip))) {
                    console.log('INVALID tree item, invalid checkboxState', treeItemThing.checkboxState);
                    return false;
                }
            }
            if (thing instanceof $CO_1) {
                return true;
            }
            if (treeItemThing.label !== undefined && !(0, types_1.$eg)(treeItemThing.label) && !(treeItemThing.label?.label)) {
                console.log('INVALID tree item, invalid label', treeItemThing.label);
                return false;
            }
            if ((treeItemThing.id !== undefined) && !(0, types_1.$eg)(treeItemThing.id)) {
                console.log('INVALID tree item, invalid id', treeItemThing.id);
                return false;
            }
            if ((treeItemThing.iconPath !== undefined) && !(0, types_1.$eg)(treeItemThing.iconPath) && !uri_1.URI.isUri(treeItemThing.iconPath) && (!treeItemThing.iconPath || !(0, types_1.$eg)(treeItemThing.iconPath.id))) {
                const asLightAndDarkThing = treeItemThing.iconPath;
                if (!asLightAndDarkThing || (!(0, types_1.$eg)(asLightAndDarkThing.light) && !uri_1.URI.isUri(asLightAndDarkThing.light) && !(0, types_1.$eg)(asLightAndDarkThing.dark) && !uri_1.URI.isUri(asLightAndDarkThing.dark))) {
                    console.log('INVALID tree item, invalid iconPath', treeItemThing.iconPath);
                    return false;
                }
            }
            if ((treeItemThing.description !== undefined) && !(0, types_1.$eg)(treeItemThing.description) && (typeof treeItemThing.description !== 'boolean')) {
                console.log('INVALID tree item, invalid description', treeItemThing.description);
                return false;
            }
            if ((treeItemThing.resourceUri !== undefined) && !uri_1.URI.isUri(treeItemThing.resourceUri)) {
                console.log('INVALID tree item, invalid resourceUri', treeItemThing.resourceUri);
                return false;
            }
            if ((treeItemThing.tooltip !== undefined) && !(0, types_1.$eg)(treeItemThing.tooltip) && !(treeItemThing.tooltip instanceof $eO)) {
                console.log('INVALID tree item, invalid tooltip', treeItemThing.tooltip);
                return false;
            }
            if ((treeItemThing.command !== undefined) && !treeItemThing.command.command) {
                console.log('INVALID tree item, invalid command', treeItemThing.command);
                return false;
            }
            if ((treeItemThing.collapsibleState !== undefined) && (treeItemThing.collapsibleState < TreeItemCollapsibleState.None) && (treeItemThing.collapsibleState > TreeItemCollapsibleState.Expanded)) {
                console.log('INVALID tree item, invalid collapsibleState', treeItemThing.collapsibleState);
                return false;
            }
            if ((treeItemThing.contextValue !== undefined) && !(0, types_1.$eg)(treeItemThing.contextValue)) {
                console.log('INVALID tree item, invalid contextValue', treeItemThing.contextValue);
                return false;
            }
            if ((treeItemThing.accessibilityInformation !== undefined) && !treeItemThing.accessibilityInformation?.label) {
                console.log('INVALID tree item, invalid accessibilityInformation', treeItemThing.accessibilityInformation);
                return false;
            }
            return true;
        }
        constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {
            this.collapsibleState = collapsibleState;
            if (uri_1.URI.isUri(arg1)) {
                this.resourceUri = arg1;
            }
            else {
                this.label = arg1;
            }
        }
    };
    exports.$CO = $CO;
    exports.$CO = $CO = $CO_1 = __decorate([
        es5ClassCompat
    ], $CO);
    var TreeItemCollapsibleState;
    (function (TreeItemCollapsibleState) {
        TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = TreeItemCollapsibleState = {}));
    var TreeItemCheckboxState;
    (function (TreeItemCheckboxState) {
        TreeItemCheckboxState[TreeItemCheckboxState["Unchecked"] = 0] = "Unchecked";
        TreeItemCheckboxState[TreeItemCheckboxState["Checked"] = 1] = "Checked";
    })(TreeItemCheckboxState || (exports.TreeItemCheckboxState = TreeItemCheckboxState = {}));
    let $DO = class $DO {
        async asString() {
            return typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
        }
        asFile() {
            return undefined;
        }
        constructor(value) {
            this.value = value;
        }
    };
    exports.$DO = $DO;
    exports.$DO = $DO = __decorate([
        es5ClassCompat
    ], $DO);
    /**
     * A data transfer item that has been created by VS Code instead of by a extension.
     *
     * Intentionally not exported to extensions.
     */
    class $EO extends $DO {
    }
    exports.$EO = $EO;
    /**
     * A data transfer item for a file.
     *
     * Intentionally not exported to extensions as only we can create these.
     */
    class $FO extends $EO {
        #file;
        constructor(file) {
            super('');
            this.#file = file;
        }
        asFile() {
            return this.#file;
        }
    }
    exports.$FO = $FO;
    /**
     * Intentionally not exported to extensions
     */
    class $GO {
        constructor(name, uri, itemId, getData) {
            this.name = name;
            this.uri = uri;
            this._itemId = itemId;
            this.c = getData;
        }
        data() {
            return this.c();
        }
    }
    exports.$GO = $GO;
    let $HO = class $HO {
        #items = new Map();
        constructor(init) {
            for (const [mime, item] of init ?? []) {
                const existing = this.#items.get(this.#normalizeMime(mime));
                if (existing) {
                    existing.push(item);
                }
                else {
                    this.#items.set(this.#normalizeMime(mime), [item]);
                }
            }
        }
        get(mimeType) {
            return this.#items.get(this.#normalizeMime(mimeType))?.[0];
        }
        set(mimeType, value) {
            // This intentionally overwrites all entries for a given mimetype.
            // This is similar to how the DOM DataTransfer type works
            this.#items.set(this.#normalizeMime(mimeType), [value]);
        }
        forEach(callbackfn, thisArg) {
            for (const [mime, items] of this.#items) {
                for (const item of items) {
                    callbackfn.call(thisArg, item, mime, this);
                }
            }
        }
        *[Symbol.iterator]() {
            for (const [mime, items] of this.#items) {
                for (const item of items) {
                    yield [mime, item];
                }
            }
        }
        #normalizeMime(mimeType) {
            return mimeType.toLowerCase();
        }
    };
    exports.$HO = $HO;
    exports.$HO = $HO = __decorate([
        es5ClassCompat
    ], $HO);
    let $IO = class $IO {
        constructor(insertText, title, kind) {
            this.insertText = insertText;
            this.title = title;
            this.kind = kind;
        }
    };
    exports.$IO = $IO;
    exports.$IO = $IO = __decorate([
        es5ClassCompat
    ], $IO);
    var DocumentPasteTriggerKind;
    (function (DocumentPasteTriggerKind) {
        DocumentPasteTriggerKind[DocumentPasteTriggerKind["Automatic"] = 0] = "Automatic";
        DocumentPasteTriggerKind[DocumentPasteTriggerKind["PasteAs"] = 1] = "PasteAs";
    })(DocumentPasteTriggerKind || (exports.DocumentPasteTriggerKind = DocumentPasteTriggerKind = {}));
    class $JO {
        static { this.c = '.'; }
        constructor(value) {
            this.value = value;
        }
        append(...parts) {
            return new $JO((this.value ? [this.value, ...parts] : parts).join($JO.c));
        }
        intersects(other) {
            return this.contains(other) || other.contains(this);
        }
        contains(other) {
            return this.value === other.value || other.value.startsWith(this.value + $JO.c);
        }
    }
    exports.$JO = $JO;
    $JO.Empty = new $JO('');
    class $KO {
        constructor(insertText, title, kind) {
            this.title = title;
            this.insertText = insertText;
            this.kind = kind;
        }
    }
    exports.$KO = $KO;
    let $LO = class $LO {
        constructor(id, color) {
            this.id = id;
            this.color = color;
        }
        static isThemeIcon(thing) {
            if (typeof thing.id !== 'string') {
                console.log('INVALID ThemeIcon, invalid id', thing.id);
                return false;
            }
            return true;
        }
    };
    exports.$LO = $LO;
    exports.$LO = $LO = __decorate([
        es5ClassCompat
    ], $LO);
    $LO.File = new $LO('file');
    $LO.Folder = new $LO('folder');
    let $MO = class $MO {
        constructor(id) {
            this.id = id;
        }
    };
    exports.$MO = $MO;
    exports.$MO = $MO = __decorate([
        es5ClassCompat
    ], $MO);
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
        ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
        ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
    })(ConfigurationTarget || (exports.ConfigurationTarget = ConfigurationTarget = {}));
    let $NO = class $NO {
        get base() {
            return this.c;
        }
        set base(base) {
            this.c = base;
            this.e = uri_1.URI.file(base);
        }
        get baseUri() {
            return this.e;
        }
        set baseUri(baseUri) {
            this.e = baseUri;
            this.c = baseUri.fsPath;
        }
        constructor(base, pattern) {
            if (typeof base !== 'string') {
                if (!base || !uri_1.URI.isUri(base) && !uri_1.URI.isUri(base.uri)) {
                    throw (0, errors_1.$6)('base');
                }
            }
            if (typeof pattern !== 'string') {
                throw (0, errors_1.$6)('pattern');
            }
            if (typeof base === 'string') {
                this.baseUri = uri_1.URI.file(base);
            }
            else if (uri_1.URI.isUri(base)) {
                this.baseUri = base;
            }
            else {
                this.baseUri = base.uri;
            }
            this.pattern = pattern;
        }
        toJSON() {
            return {
                pattern: this.pattern,
                base: this.base,
                baseUri: this.baseUri.toJSON()
            };
        }
    };
    exports.$NO = $NO;
    exports.$NO = $NO = __decorate([
        es5ClassCompat
    ], $NO);
    const breakpointIds = new WeakMap();
    /**
     * We want to be able to construct Breakpoints internally that have a particular id, but we don't want extensions to be
     * able to do this with the exposed Breakpoint classes in extension API.
     * We also want "instanceof" to work with debug.breakpoints and the exposed breakpoint classes.
     * And private members will be renamed in the built js, so casting to any and setting a private member is not safe.
     * So, we store internal breakpoint IDs in a WeakMap. This function must be called after constructing a Breakpoint
     * with a known id.
     */
    function $OO(bp, id) {
        breakpointIds.set(bp, id);
    }
    let $PO = class $PO {
        constructor(enabled, condition, hitCondition, logMessage, mode) {
            this.enabled = typeof enabled === 'boolean' ? enabled : true;
            if (typeof condition === 'string') {
                this.condition = condition;
            }
            if (typeof hitCondition === 'string') {
                this.hitCondition = hitCondition;
            }
            if (typeof logMessage === 'string') {
                this.logMessage = logMessage;
            }
            if (typeof mode === 'string') {
                this.mode = mode;
            }
        }
        get id() {
            if (!this.c) {
                this.c = breakpointIds.get(this) ?? (0, uuid_1.$2g)();
            }
            return this.c;
        }
    };
    exports.$PO = $PO;
    exports.$PO = $PO = __decorate([
        es5ClassCompat
    ], $PO);
    let $QO = class $QO extends $PO {
        constructor(location, enabled, condition, hitCondition, logMessage, mode) {
            super(enabled, condition, hitCondition, logMessage, mode);
            if (location === null) {
                throw (0, errors_1.$6)('location');
            }
            this.location = location;
        }
    };
    exports.$QO = $QO;
    exports.$QO = $QO = __decorate([
        es5ClassCompat
    ], $QO);
    let $RO = class $RO extends $PO {
        constructor(functionName, enabled, condition, hitCondition, logMessage, mode) {
            super(enabled, condition, hitCondition, logMessage, mode);
            this.functionName = functionName;
        }
    };
    exports.$RO = $RO;
    exports.$RO = $RO = __decorate([
        es5ClassCompat
    ], $RO);
    let $SO = class $SO extends $PO {
        constructor(label, dataId, canPersist, enabled, condition, hitCondition, logMessage, mode) {
            super(enabled, condition, hitCondition, logMessage, mode);
            if (!dataId) {
                throw (0, errors_1.$6)('dataId');
            }
            this.label = label;
            this.dataId = dataId;
            this.canPersist = canPersist;
        }
    };
    exports.$SO = $SO;
    exports.$SO = $SO = __decorate([
        es5ClassCompat
    ], $SO);
    let $TO = class $TO {
        constructor(command, args, options) {
            this.command = command;
            this.args = args || [];
            this.options = options;
        }
    };
    exports.$TO = $TO;
    exports.$TO = $TO = __decorate([
        es5ClassCompat
    ], $TO);
    let $UO = class $UO {
        constructor(port, host) {
            this.port = port;
            this.host = host;
        }
    };
    exports.$UO = $UO;
    exports.$UO = $UO = __decorate([
        es5ClassCompat
    ], $UO);
    let $VO = class $VO {
        constructor(path) {
            this.path = path;
        }
    };
    exports.$VO = $VO;
    exports.$VO = $VO = __decorate([
        es5ClassCompat
    ], $VO);
    let $WO = class $WO {
        constructor(impl) {
            this.implementation = impl;
        }
    };
    exports.$WO = $WO;
    exports.$WO = $WO = __decorate([
        es5ClassCompat
    ], $WO);
    class $XO {
        constructor(session, threadId, frameId) {
            this.session = session;
            this.threadId = threadId;
            this.frameId = frameId;
        }
    }
    exports.$XO = $XO;
    class $YO {
        constructor(session, threadId) {
            this.session = session;
            this.threadId = threadId;
        }
    }
    exports.$YO = $YO;
    let $ZO = class $ZO {
        constructor(range, expression) {
            this.range = range;
            this.expression = expression;
        }
    };
    exports.$ZO = $ZO;
    exports.$ZO = $ZO = __decorate([
        es5ClassCompat
    ], $ZO);
    var InlineCompletionTriggerKind;
    (function (InlineCompletionTriggerKind) {
        InlineCompletionTriggerKind[InlineCompletionTriggerKind["Invoke"] = 0] = "Invoke";
        InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 1] = "Automatic";
    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
    let $1O = class $1O {
        constructor(range, text) {
            this.range = range;
            this.text = text;
        }
    };
    exports.$1O = $1O;
    exports.$1O = $1O = __decorate([
        es5ClassCompat
    ], $1O);
    let $2O = class $2O {
        constructor(range, variableName, caseSensitiveLookup = true) {
            this.range = range;
            this.variableName = variableName;
            this.caseSensitiveLookup = caseSensitiveLookup;
        }
    };
    exports.$2O = $2O;
    exports.$2O = $2O = __decorate([
        es5ClassCompat
    ], $2O);
    let $3O = class $3O {
        constructor(range, expression) {
            this.range = range;
            this.expression = expression;
        }
    };
    exports.$3O = $3O;
    exports.$3O = $3O = __decorate([
        es5ClassCompat
    ], $3O);
    let $4O = class $4O {
        constructor(frameId, range) {
            this.frameId = frameId;
            this.stoppedLocation = range;
        }
    };
    exports.$4O = $4O;
    exports.$4O = $4O = __decorate([
        es5ClassCompat
    ], $4O);
    var NewSymbolNameTag;
    (function (NewSymbolNameTag) {
        NewSymbolNameTag[NewSymbolNameTag["AIGenerated"] = 1] = "AIGenerated";
    })(NewSymbolNameTag || (exports.NewSymbolNameTag = NewSymbolNameTag = {}));
    var NewSymbolNameTriggerKind;
    (function (NewSymbolNameTriggerKind) {
        NewSymbolNameTriggerKind[NewSymbolNameTriggerKind["Invoke"] = 0] = "Invoke";
        NewSymbolNameTriggerKind[NewSymbolNameTriggerKind["Automatic"] = 1] = "Automatic";
    })(NewSymbolNameTriggerKind || (exports.NewSymbolNameTriggerKind = NewSymbolNameTriggerKind = {}));
    class $5O {
        constructor(newSymbolName, tags) {
            this.newSymbolName = newSymbolName;
            this.tags = tags;
        }
    }
    exports.$5O = $5O;
    //#region file api
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["Changed"] = 1] = "Changed";
        FileChangeType[FileChangeType["Created"] = 2] = "Created";
        FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
    })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
    let $6O = $6O_1 = class $6O extends Error {
        static FileExists(messageOrUri) {
            return new $6O_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileExists, $6O_1.FileExists);
        }
        static FileNotFound(messageOrUri) {
            return new $6O_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileNotFound, $6O_1.FileNotFound);
        }
        static FileNotADirectory(messageOrUri) {
            return new $6O_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileNotADirectory, $6O_1.FileNotADirectory);
        }
        static FileIsADirectory(messageOrUri) {
            return new $6O_1(messageOrUri, files_1.FileSystemProviderErrorCode.FileIsADirectory, $6O_1.FileIsADirectory);
        }
        static NoPermissions(messageOrUri) {
            return new $6O_1(messageOrUri, files_1.FileSystemProviderErrorCode.NoPermissions, $6O_1.NoPermissions);
        }
        static Unavailable(messageOrUri) {
            return new $6O_1(messageOrUri, files_1.FileSystemProviderErrorCode.Unavailable, $6O_1.Unavailable);
        }
        constructor(uriOrMessage, code = files_1.FileSystemProviderErrorCode.Unknown, terminator) {
            super(uri_1.URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage);
            this.code = terminator?.name ?? 'Unknown';
            // mark the error as file system provider error so that
            // we can extract the error code on the receiving side
            (0, files_1.$pl)(this, code);
            // workaround when extending builtin objects and when compiling to ES5, see:
            // https://github.com/microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
            Object.setPrototypeOf(this, $6O_1.prototype);
            if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {
                // nice stack traces
                Error.captureStackTrace(this, terminator);
            }
        }
    };
    exports.$6O = $6O;
    exports.$6O = $6O = $6O_1 = __decorate([
        es5ClassCompat
    ], $6O);
    //#endregion
    //#region folding api
    let $7O = class $7O {
        constructor(start, end, kind) {
            this.start = start;
            this.end = end;
            this.kind = kind;
        }
    };
    exports.$7O = $7O;
    exports.$7O = $7O = __decorate([
        es5ClassCompat
    ], $7O);
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
        FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
        FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));
    //#endregion
    //#region Comment
    var CommentThreadCollapsibleState;
    (function (CommentThreadCollapsibleState) {
        /**
         * Determines an item is collapsed
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
        /**
         * Determines an item is expanded
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
    })(CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = CommentThreadCollapsibleState = {}));
    var CommentMode;
    (function (CommentMode) {
        CommentMode[CommentMode["Editing"] = 0] = "Editing";
        CommentMode[CommentMode["Preview"] = 1] = "Preview";
    })(CommentMode || (exports.CommentMode = CommentMode = {}));
    var CommentState;
    (function (CommentState) {
        CommentState[CommentState["Published"] = 0] = "Published";
        CommentState[CommentState["Draft"] = 1] = "Draft";
    })(CommentState || (exports.CommentState = CommentState = {}));
    var CommentThreadState;
    (function (CommentThreadState) {
        CommentThreadState[CommentThreadState["Unresolved"] = 0] = "Unresolved";
        CommentThreadState[CommentThreadState["Resolved"] = 1] = "Resolved";
    })(CommentThreadState || (exports.CommentThreadState = CommentThreadState = {}));
    var CommentThreadApplicability;
    (function (CommentThreadApplicability) {
        CommentThreadApplicability[CommentThreadApplicability["Current"] = 0] = "Current";
        CommentThreadApplicability[CommentThreadApplicability["Outdated"] = 1] = "Outdated";
    })(CommentThreadApplicability || (exports.CommentThreadApplicability = CommentThreadApplicability = {}));
    var CommentThreadFocus;
    (function (CommentThreadFocus) {
        CommentThreadFocus[CommentThreadFocus["Reply"] = 1] = "Reply";
        CommentThreadFocus[CommentThreadFocus["Comment"] = 2] = "Comment";
    })(CommentThreadFocus || (exports.CommentThreadFocus = CommentThreadFocus = {}));
    //#endregion
    //#region Semantic Coloring
    class $8O {
        constructor(tokenTypes, tokenModifiers = []) {
            this.tokenTypes = tokenTypes;
            this.tokenModifiers = tokenModifiers;
        }
    }
    exports.$8O = $8O;
    function isStrArrayOrUndefined(arg) {
        return ((typeof arg === 'undefined') || (0, types_1.$fg)(arg));
    }
    class $9O {
        constructor(legend) {
            this.c = 0;
            this.e = 0;
            this.f = true;
            this.g = [];
            this.j = 0;
            this.k = new Map();
            this.l = new Map();
            this.m = false;
            if (legend) {
                this.m = true;
                for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
                    this.k.set(legend.tokenTypes[i], i);
                }
                for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
                    this.l.set(legend.tokenModifiers[i], i);
                }
            }
        }
        push(arg0, arg1, arg2, arg3, arg4) {
            if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {
                if (typeof arg4 === 'undefined') {
                    arg4 = 0;
                }
                // 1st overload
                return this.q(arg0, arg1, arg2, arg3, arg4);
            }
            if ($ON.isRange(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {
                // 2nd overload
                return this.o(arg0, arg1, arg2);
            }
            throw (0, errors_1.$6)();
        }
        o(range, tokenType, tokenModifiers) {
            if (!this.m) {
                throw new Error('Legend must be provided in constructor');
            }
            if (range.start.line !== range.end.line) {
                throw new Error('`range` cannot span multiple lines');
            }
            if (!this.k.has(tokenType)) {
                throw new Error('`tokenType` is not in the provided legend');
            }
            const line = range.start.line;
            const char = range.start.character;
            const length = range.end.character - range.start.character;
            const nTokenType = this.k.get(tokenType);
            let nTokenModifiers = 0;
            if (tokenModifiers) {
                for (const tokenModifier of tokenModifiers) {
                    if (!this.l.has(tokenModifier)) {
                        throw new Error('`tokenModifier` is not in the provided legend');
                    }
                    const nTokenModifier = this.l.get(tokenModifier);
                    nTokenModifiers |= (1 << nTokenModifier) >>> 0;
                }
            }
            this.q(line, char, length, nTokenType, nTokenModifiers);
        }
        q(line, char, length, tokenType, tokenModifiers) {
            if (this.f && (line < this.c || (line === this.c && char < this.e))) {
                // push calls were ordered and are no longer ordered
                this.f = false;
                // Remove delta encoding from data
                const tokenCount = (this.g.length / 5) | 0;
                let prevLine = 0;
                let prevChar = 0;
                for (let i = 0; i < tokenCount; i++) {
                    let line = this.g[5 * i];
                    let char = this.g[5 * i + 1];
                    if (line === 0) {
                        // on the same line as previous token
                        line = prevLine;
                        char += prevChar;
                    }
                    else {
                        // on a different line than previous token
                        line += prevLine;
                    }
                    this.g[5 * i] = line;
                    this.g[5 * i + 1] = char;
                    prevLine = line;
                    prevChar = char;
                }
            }
            let pushLine = line;
            let pushChar = char;
            if (this.f && this.j > 0) {
                pushLine -= this.c;
                if (pushLine === 0) {
                    pushChar -= this.e;
                }
            }
            this.g[this.j++] = pushLine;
            this.g[this.j++] = pushChar;
            this.g[this.j++] = length;
            this.g[this.j++] = tokenType;
            this.g[this.j++] = tokenModifiers;
            this.c = line;
            this.e = char;
        }
        static r(data) {
            const pos = [];
            const tokenCount = (data.length / 5) | 0;
            for (let i = 0; i < tokenCount; i++) {
                pos[i] = i;
            }
            pos.sort((a, b) => {
                const aLine = data[5 * a];
                const bLine = data[5 * b];
                if (aLine === bLine) {
                    const aChar = data[5 * a + 1];
                    const bChar = data[5 * b + 1];
                    return aChar - bChar;
                }
                return aLine - bLine;
            });
            const result = new Uint32Array(data.length);
            let prevLine = 0;
            let prevChar = 0;
            for (let i = 0; i < tokenCount; i++) {
                const srcOffset = 5 * pos[i];
                const line = data[srcOffset + 0];
                const char = data[srcOffset + 1];
                const length = data[srcOffset + 2];
                const tokenType = data[srcOffset + 3];
                const tokenModifiers = data[srcOffset + 4];
                const pushLine = line - prevLine;
                const pushChar = (pushLine === 0 ? char - prevChar : char);
                const dstOffset = 5 * i;
                result[dstOffset + 0] = pushLine;
                result[dstOffset + 1] = pushChar;
                result[dstOffset + 2] = length;
                result[dstOffset + 3] = tokenType;
                result[dstOffset + 4] = tokenModifiers;
                prevLine = line;
                prevChar = char;
            }
            return result;
        }
        build(resultId) {
            if (!this.f) {
                return new $0O($9O.r(this.g), resultId);
            }
            return new $0O(new Uint32Array(this.g), resultId);
        }
    }
    exports.$9O = $9O;
    class $0O {
        constructor(data, resultId) {
            this.resultId = resultId;
            this.data = data;
        }
    }
    exports.$0O = $0O;
    class $$O {
        constructor(start, deleteCount, data) {
            this.start = start;
            this.deleteCount = deleteCount;
            this.data = data;
        }
    }
    exports.$$O = $$O;
    class $_O {
        constructor(edits, resultId) {
            this.resultId = resultId;
            this.edits = edits;
        }
    }
    exports.$_O = $_O;
    //#endregion
    //#region debug
    var DebugConsoleMode;
    (function (DebugConsoleMode) {
        /**
         * Debug session should have a separate debug console.
         */
        DebugConsoleMode[DebugConsoleMode["Separate"] = 0] = "Separate";
        /**
         * Debug session should share debug console with its parent session.
         * This value has no effect for sessions which do not have a parent session.
         */
        DebugConsoleMode[DebugConsoleMode["MergeWithParent"] = 1] = "MergeWithParent";
    })(DebugConsoleMode || (exports.DebugConsoleMode = DebugConsoleMode = {}));
    class $aP {
        constructor(name) {
            this.name = name;
        }
    }
    exports.$aP = $aP;
    //#endregion
    var QuickInputButtonLocation;
    (function (QuickInputButtonLocation) {
        QuickInputButtonLocation[QuickInputButtonLocation["Title"] = 1] = "Title";
        QuickInputButtonLocation[QuickInputButtonLocation["Inline"] = 2] = "Inline";
    })(QuickInputButtonLocation || (exports.QuickInputButtonLocation = QuickInputButtonLocation = {}));
    let $bP = class $bP {
        static { this.Back = { iconPath: new $LO('arrow-left') }; }
        constructor() { }
    };
    exports.$bP = $bP;
    exports.$bP = $bP = __decorate([
        es5ClassCompat
    ], $bP);
    var QuickPickItemKind;
    (function (QuickPickItemKind) {
        QuickPickItemKind[QuickPickItemKind["Separator"] = -1] = "Separator";
        QuickPickItemKind[QuickPickItemKind["Default"] = 0] = "Default";
    })(QuickPickItemKind || (exports.QuickPickItemKind = QuickPickItemKind = {}));
    var InputBoxValidationSeverity;
    (function (InputBoxValidationSeverity) {
        InputBoxValidationSeverity[InputBoxValidationSeverity["Info"] = 1] = "Info";
        InputBoxValidationSeverity[InputBoxValidationSeverity["Warning"] = 2] = "Warning";
        InputBoxValidationSeverity[InputBoxValidationSeverity["Error"] = 3] = "Error";
    })(InputBoxValidationSeverity || (exports.InputBoxValidationSeverity = InputBoxValidationSeverity = {}));
    var ExtensionKind;
    (function (ExtensionKind) {
        ExtensionKind[ExtensionKind["UI"] = 1] = "UI";
        ExtensionKind[ExtensionKind["Workspace"] = 2] = "Workspace";
    })(ExtensionKind || (exports.ExtensionKind = ExtensionKind = {}));
    class $cP {
        static validate(d) {
            if (typeof d.badge === 'string') {
                let len = (0, strings_1.$Pf)(d.badge, 0);
                if (len < d.badge.length) {
                    len += (0, strings_1.$Pf)(d.badge, len);
                }
                if (d.badge.length > len) {
                    throw new Error(`The 'badge'-property must be undefined or a short character`);
                }
            }
            else if (d.badge) {
                if (!$LO.isThemeIcon(d.badge)) {
                    throw new Error(`The 'badge'-property is not a valid ThemeIcon`);
                }
            }
            if (!d.color && !d.badge && !d.tooltip) {
                throw new Error(`The decoration is empty`);
            }
            return true;
        }
        constructor(badge, tooltip, color) {
            this.badge = badge;
            this.tooltip = tooltip;
            this.color = color;
        }
    }
    exports.$cP = $cP;
    //#region Theming
    let $dP = class $dP {
        constructor(kind) {
            this.kind = kind;
        }
    };
    exports.$dP = $dP;
    exports.$dP = $dP = __decorate([
        es5ClassCompat
    ], $dP);
    var ColorThemeKind;
    (function (ColorThemeKind) {
        ColorThemeKind[ColorThemeKind["Light"] = 1] = "Light";
        ColorThemeKind[ColorThemeKind["Dark"] = 2] = "Dark";
        ColorThemeKind[ColorThemeKind["HighContrast"] = 3] = "HighContrast";
        ColorThemeKind[ColorThemeKind["HighContrastLight"] = 4] = "HighContrastLight";
    })(ColorThemeKind || (exports.ColorThemeKind = ColorThemeKind = {}));
    //#endregion Theming
    //#region Notebook
    class $eP {
        static isNotebookRange(thing) {
            if (thing instanceof $eP) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.start === 'number'
                && typeof thing.end === 'number';
        }
        get start() {
            return this.c;
        }
        get end() {
            return this.e;
        }
        get isEmpty() {
            return this.c === this.e;
        }
        constructor(start, end) {
            if (start < 0) {
                throw (0, errors_1.$6)('start must be positive');
            }
            if (end < 0) {
                throw (0, errors_1.$6)('end must be positive');
            }
            if (start <= end) {
                this.c = start;
                this.e = end;
            }
            else {
                this.c = end;
                this.e = start;
            }
        }
        with(change) {
            let start = this.c;
            let end = this.e;
            if (change.start !== undefined) {
                start = change.start;
            }
            if (change.end !== undefined) {
                end = change.end;
            }
            if (start === this.c && end === this.e) {
                return this;
            }
            return new $eP(start, end);
        }
    }
    exports.$eP = $eP;
    class $fP {
        static validate(data) {
            if (typeof data.kind !== 'number') {
                throw new Error('NotebookCellData MUST have \'kind\' property');
            }
            if (typeof data.value !== 'string') {
                throw new Error('NotebookCellData MUST have \'value\' property');
            }
            if (typeof data.languageId !== 'string') {
                throw new Error('NotebookCellData MUST have \'languageId\' property');
            }
        }
        static isNotebookCellDataArray(value) {
            return Array.isArray(value) && value.every(elem => $fP.isNotebookCellData(elem));
        }
        static isNotebookCellData(value) {
            // return value instanceof NotebookCellData;
            return true;
        }
        constructor(kind, value, languageId, mime, outputs, metadata, executionSummary) {
            this.kind = kind;
            this.value = value;
            this.languageId = languageId;
            this.mime = mime;
            this.outputs = outputs ?? [];
            this.metadata = metadata;
            this.executionSummary = executionSummary;
            $fP.validate(this);
        }
    }
    exports.$fP = $fP;
    class $gP {
        constructor(cells) {
            this.cells = cells;
        }
    }
    exports.$gP = $gP;
    class $hP {
        static isNotebookCellOutputItem(obj) {
            if (obj instanceof $hP) {
                return true;
            }
            if (!obj) {
                return false;
            }
            return typeof obj.mime === 'string'
                && obj.data instanceof Uint8Array;
        }
        static error(err) {
            const obj = {
                name: err.name,
                message: err.message,
                stack: err.stack
            };
            return $hP.json(obj, 'application/vnd.code.notebook.error');
        }
        static stdout(value) {
            return $hP.text(value, 'application/vnd.code.notebook.stdout');
        }
        static stderr(value) {
            return $hP.text(value, 'application/vnd.code.notebook.stderr');
        }
        static bytes(value, mime = 'application/octet-stream') {
            return new $hP(value, mime);
        }
        static #encoder = new TextEncoder();
        static text(value, mime = mime_1.$$s.text) {
            const bytes = $hP.#encoder.encode(String(value));
            return new $hP(bytes, mime);
        }
        static json(value, mime = 'text/x-json') {
            const rawStr = JSON.stringify(value, undefined, '\t');
            return $hP.text(rawStr, mime);
        }
        constructor(data, mime) {
            this.data = data;
            this.mime = mime;
            const mimeNormalized = (0, mime_1.$ct)(mime, true);
            if (!mimeNormalized) {
                throw new Error(`INVALID mime type: ${mime}. Must be in the format "type/subtype[;optionalparameter]"`);
            }
            this.mime = mimeNormalized;
        }
    }
    exports.$hP = $hP;
    class $iP {
        static isNotebookCellOutput(candidate) {
            if (candidate instanceof $iP) {
                return true;
            }
            if (!candidate || typeof candidate !== 'object') {
                return false;
            }
            return typeof candidate.id === 'string' && Array.isArray(candidate.items);
        }
        static ensureUniqueMimeTypes(items, warn = false) {
            const seen = new Set();
            const removeIdx = new Set();
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const normalMime = (0, mime_1.$ct)(item.mime);
                // We can have multiple text stream mime types in the same output.
                if (!seen.has(normalMime) || (0, notebookCommon_1.$ML)(normalMime)) {
                    seen.add(normalMime);
                    continue;
                }
                // duplicated mime types... first has won
                removeIdx.add(i);
                if (warn) {
                    console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);
                }
            }
            if (removeIdx.size === 0) {
                return items;
            }
            return items.filter((_item, index) => !removeIdx.has(index));
        }
        constructor(items, idOrMetadata, metadata) {
            this.items = $iP.ensureUniqueMimeTypes(items, true);
            if (typeof idOrMetadata === 'string') {
                this.id = idOrMetadata;
                this.metadata = metadata;
            }
            else {
                this.id = (0, uuid_1.$2g)();
                this.metadata = idOrMetadata ?? metadata;
            }
        }
    }
    exports.$iP = $iP;
    var NotebookCellKind;
    (function (NotebookCellKind) {
        NotebookCellKind[NotebookCellKind["Markup"] = 1] = "Markup";
        NotebookCellKind[NotebookCellKind["Code"] = 2] = "Code";
    })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
    var NotebookCellExecutionState;
    (function (NotebookCellExecutionState) {
        NotebookCellExecutionState[NotebookCellExecutionState["Idle"] = 1] = "Idle";
        NotebookCellExecutionState[NotebookCellExecutionState["Pending"] = 2] = "Pending";
        NotebookCellExecutionState[NotebookCellExecutionState["Executing"] = 3] = "Executing";
    })(NotebookCellExecutionState || (exports.NotebookCellExecutionState = NotebookCellExecutionState = {}));
    var NotebookCellStatusBarAlignment;
    (function (NotebookCellStatusBarAlignment) {
        NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment["Left"] = 1] = "Left";
        NotebookCellStatusBarAlignment[NotebookCellStatusBarAlignment["Right"] = 2] = "Right";
    })(NotebookCellStatusBarAlignment || (exports.NotebookCellStatusBarAlignment = NotebookCellStatusBarAlignment = {}));
    var NotebookEditorRevealType;
    (function (NotebookEditorRevealType) {
        NotebookEditorRevealType[NotebookEditorRevealType["Default"] = 0] = "Default";
        NotebookEditorRevealType[NotebookEditorRevealType["InCenter"] = 1] = "InCenter";
        NotebookEditorRevealType[NotebookEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        NotebookEditorRevealType[NotebookEditorRevealType["AtTop"] = 3] = "AtTop";
    })(NotebookEditorRevealType || (exports.NotebookEditorRevealType = NotebookEditorRevealType = {}));
    class $jP {
        constructor(text, alignment) {
            this.text = text;
            this.alignment = alignment;
        }
    }
    exports.$jP = $jP;
    var NotebookControllerAffinity;
    (function (NotebookControllerAffinity) {
        NotebookControllerAffinity[NotebookControllerAffinity["Default"] = 1] = "Default";
        NotebookControllerAffinity[NotebookControllerAffinity["Preferred"] = 2] = "Preferred";
    })(NotebookControllerAffinity || (exports.NotebookControllerAffinity = NotebookControllerAffinity = {}));
    var NotebookControllerAffinity2;
    (function (NotebookControllerAffinity2) {
        NotebookControllerAffinity2[NotebookControllerAffinity2["Default"] = 1] = "Default";
        NotebookControllerAffinity2[NotebookControllerAffinity2["Preferred"] = 2] = "Preferred";
        NotebookControllerAffinity2[NotebookControllerAffinity2["Hidden"] = -1] = "Hidden";
    })(NotebookControllerAffinity2 || (exports.NotebookControllerAffinity2 = NotebookControllerAffinity2 = {}));
    class $kP {
        constructor(uri, provides = []) {
            this.uri = uri;
            this.provides = (0, arrays_1.$1b)(provides);
        }
    }
    exports.$kP = $kP;
    class $lP {
        constructor(label) {
            this.label = label;
        }
    }
    exports.$lP = $lP;
    var NotebookVariablesRequestKind;
    (function (NotebookVariablesRequestKind) {
        NotebookVariablesRequestKind[NotebookVariablesRequestKind["Named"] = 1] = "Named";
        NotebookVariablesRequestKind[NotebookVariablesRequestKind["Indexed"] = 2] = "Indexed";
    })(NotebookVariablesRequestKind || (exports.NotebookVariablesRequestKind = NotebookVariablesRequestKind = {}));
    //#endregion
    //#region Timeline
    let $mP = class $mP {
        constructor(label, timestamp) {
            this.label = label;
            this.timestamp = timestamp;
        }
    };
    exports.$mP = $mP;
    exports.$mP = $mP = __decorate([
        es5ClassCompat
    ], $mP);
    //#endregion Timeline
    //#region ExtensionContext
    var ExtensionMode;
    (function (ExtensionMode) {
        /**
         * The extension is installed normally (for example, from the marketplace
         * or VSIX) in VS Code.
         */
        ExtensionMode[ExtensionMode["Production"] = 1] = "Production";
        /**
         * The extension is running from an `--extensionDevelopmentPath` provided
         * when launching VS Code.
         */
        ExtensionMode[ExtensionMode["Development"] = 2] = "Development";
        /**
         * The extension is running from an `--extensionDevelopmentPath` and
         * the extension host is running unit tests.
         */
        ExtensionMode[ExtensionMode["Test"] = 3] = "Test";
    })(ExtensionMode || (exports.ExtensionMode = ExtensionMode = {}));
    var ExtensionRuntime;
    (function (ExtensionRuntime) {
        /**
         * The extension is running in a NodeJS extension host. Runtime access to NodeJS APIs is available.
         */
        ExtensionRuntime[ExtensionRuntime["Node"] = 1] = "Node";
        /**
         * The extension is running in a Webworker extension host. Runtime access is limited to Webworker APIs.
         */
        ExtensionRuntime[ExtensionRuntime["Webworker"] = 2] = "Webworker";
    })(ExtensionRuntime || (exports.ExtensionRuntime = ExtensionRuntime = {}));
    //#endregion ExtensionContext
    var StandardTokenType;
    (function (StandardTokenType) {
        StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
        StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
        StandardTokenType[StandardTokenType["String"] = 2] = "String";
        StandardTokenType[StandardTokenType["RegEx"] = 3] = "RegEx";
    })(StandardTokenType || (exports.StandardTokenType = StandardTokenType = {}));
    class $nP {
        constructor(ranges, wordPattern) {
            this.ranges = ranges;
            this.wordPattern = wordPattern;
        }
    }
    exports.$nP = $nP;
    //#region ports
    class $oP {
        constructor(autoForwardAction) {
            this.c = autoForwardAction;
        }
        get autoForwardAction() {
            return this.c;
        }
    }
    exports.$oP = $oP;
    //#endregion ports
    //#region Testing
    var TestResultState;
    (function (TestResultState) {
        TestResultState[TestResultState["Queued"] = 1] = "Queued";
        TestResultState[TestResultState["Running"] = 2] = "Running";
        TestResultState[TestResultState["Passed"] = 3] = "Passed";
        TestResultState[TestResultState["Failed"] = 4] = "Failed";
        TestResultState[TestResultState["Skipped"] = 5] = "Skipped";
        TestResultState[TestResultState["Errored"] = 6] = "Errored";
    })(TestResultState || (exports.TestResultState = TestResultState = {}));
    var TestRunProfileKind;
    (function (TestRunProfileKind) {
        TestRunProfileKind[TestRunProfileKind["Run"] = 1] = "Run";
        TestRunProfileKind[TestRunProfileKind["Debug"] = 2] = "Debug";
        TestRunProfileKind[TestRunProfileKind["Coverage"] = 3] = "Coverage";
    })(TestRunProfileKind || (exports.TestRunProfileKind = TestRunProfileKind = {}));
    let $pP = class $pP {
        constructor(include = undefined, exclude = undefined, profile = undefined, continuous = false, preserveFocus = true) {
            this.include = include;
            this.exclude = exclude;
            this.profile = profile;
            this.continuous = continuous;
            this.preserveFocus = preserveFocus;
        }
    };
    exports.$pP = $pP;
    exports.$pP = $pP = __decorate([
        es5ClassCompat
    ], $pP);
    let $qP = $qP_1 = class $qP {
        static diff(message, expected, actual) {
            const msg = new $qP_1(message);
            msg.expectedOutput = expected;
            msg.actualOutput = actual;
            return msg;
        }
        constructor(message) {
            this.message = message;
        }
    };
    exports.$qP = $qP;
    exports.$qP = $qP = $qP_1 = __decorate([
        es5ClassCompat
    ], $qP);
    let $rP = class $rP {
        constructor(id) {
            this.id = id;
        }
    };
    exports.$rP = $rP;
    exports.$rP = $rP = __decorate([
        es5ClassCompat
    ], $rP);
    class $sP {
        /**
         * @param label The name of the stack frame
         * @param file The file URI of the stack frame
         * @param position The position of the stack frame within the file
         */
        constructor(label, file, position) {
            this.label = label;
            this.file = file;
            this.position = position;
        }
    }
    exports.$sP = $sP;
    //#endregion
    //#region Test Coverage
    class $tP {
        constructor(covered, total) {
            this.covered = covered;
            this.total = total;
            $uP(this);
        }
    }
    exports.$tP = $tP;
    function $uP(cc) {
        if (!cc) {
            return;
        }
        if (cc.covered > cc.total) {
            throw new Error(`The total number of covered items (${cc.covered}) cannot be greater than the total (${cc.total})`);
        }
        if (cc.total < 0) {
            throw new Error(`The number of covered items (${cc.total}) cannot be negative`);
        }
    }
    class $vP {
        static fromDetails(uri, details) {
            const statements = new $tP(0, 0);
            const branches = new $tP(0, 0);
            const decl = new $tP(0, 0);
            for (const detail of details) {
                if ('branches' in detail) {
                    statements.total += 1;
                    statements.covered += detail.executed ? 1 : 0;
                    for (const branch of detail.branches) {
                        branches.total += 1;
                        branches.covered += branch.executed ? 1 : 0;
                    }
                }
                else {
                    decl.total += 1;
                    decl.covered += detail.executed ? 1 : 0;
                }
            }
            const coverage = new $vP(uri, statements, branches.total > 0 ? branches : undefined, decl.total > 0 ? decl : undefined);
            coverage.detailedCoverage = details;
            return coverage;
        }
        constructor(uri, statementCoverage, branchCoverage, declarationCoverage, fromTests = []) {
            this.uri = uri;
            this.statementCoverage = statementCoverage;
            this.branchCoverage = branchCoverage;
            this.declarationCoverage = declarationCoverage;
            this.fromTests = fromTests;
        }
    }
    exports.$vP = $vP;
    class $wP {
        // back compat until finalization:
        get executionCount() { return +this.executed; }
        set executionCount(n) { this.executed = n; }
        constructor(executed, location, branches = []) {
            this.executed = executed;
            this.location = location;
            this.branches = branches;
        }
    }
    exports.$wP = $wP;
    class $xP {
        // back compat until finalization:
        get executionCount() { return +this.executed; }
        set executionCount(n) { this.executed = n; }
        constructor(executed, location, label) {
            this.executed = executed;
            this.location = location;
            this.label = label;
        }
    }
    exports.$xP = $xP;
    class $yP {
        // back compat until finalization:
        get executionCount() { return +this.executed; }
        set executionCount(n) { this.executed = n; }
        constructor(name, executed, location) {
            this.name = name;
            this.executed = executed;
            this.location = location;
        }
    }
    exports.$yP = $yP;
    //#endregion
    var ExternalUriOpenerPriority;
    (function (ExternalUriOpenerPriority) {
        ExternalUriOpenerPriority[ExternalUriOpenerPriority["None"] = 0] = "None";
        ExternalUriOpenerPriority[ExternalUriOpenerPriority["Option"] = 1] = "Option";
        ExternalUriOpenerPriority[ExternalUriOpenerPriority["Default"] = 2] = "Default";
        ExternalUriOpenerPriority[ExternalUriOpenerPriority["Preferred"] = 3] = "Preferred";
    })(ExternalUriOpenerPriority || (exports.ExternalUriOpenerPriority = ExternalUriOpenerPriority = {}));
    var WorkspaceTrustState;
    (function (WorkspaceTrustState) {
        WorkspaceTrustState[WorkspaceTrustState["Untrusted"] = 0] = "Untrusted";
        WorkspaceTrustState[WorkspaceTrustState["Trusted"] = 1] = "Trusted";
        WorkspaceTrustState[WorkspaceTrustState["Unspecified"] = 2] = "Unspecified";
    })(WorkspaceTrustState || (exports.WorkspaceTrustState = WorkspaceTrustState = {}));
    var PortAutoForwardAction;
    (function (PortAutoForwardAction) {
        PortAutoForwardAction[PortAutoForwardAction["Notify"] = 1] = "Notify";
        PortAutoForwardAction[PortAutoForwardAction["OpenBrowser"] = 2] = "OpenBrowser";
        PortAutoForwardAction[PortAutoForwardAction["OpenPreview"] = 3] = "OpenPreview";
        PortAutoForwardAction[PortAutoForwardAction["Silent"] = 4] = "Silent";
        PortAutoForwardAction[PortAutoForwardAction["Ignore"] = 5] = "Ignore";
        PortAutoForwardAction[PortAutoForwardAction["OpenBrowserOnce"] = 6] = "OpenBrowserOnce";
    })(PortAutoForwardAction || (exports.PortAutoForwardAction = PortAutoForwardAction = {}));
    class $zP {
        constructor(kind, name, detail, uri, range, selectionRange) {
            this.kind = kind;
            this.name = name;
            this.detail = detail;
            this.uri = uri;
            this.range = range;
            this.selectionRange = selectionRange;
        }
    }
    exports.$zP = $zP;
    //#region Tab Inputs
    class $AP {
        constructor(uri) {
            this.uri = uri;
        }
    }
    exports.$AP = $AP;
    class $BP {
        constructor(original, modified) {
            this.original = original;
            this.modified = modified;
        }
    }
    exports.$BP = $BP;
    class $CP {
        constructor(base, input1, input2, result) {
            this.base = base;
            this.input1 = input1;
            this.input2 = input2;
            this.result = result;
        }
    }
    exports.$CP = $CP;
    class $DP {
        constructor(uri, viewType) {
            this.uri = uri;
            this.viewType = viewType;
        }
    }
    exports.$DP = $DP;
    class $EP {
        constructor(viewType) {
            this.viewType = viewType;
        }
    }
    exports.$EP = $EP;
    class $FP {
        constructor(uri, notebookType) {
            this.uri = uri;
            this.notebookType = notebookType;
        }
    }
    exports.$FP = $FP;
    class $GP {
        constructor(original, modified, notebookType) {
            this.original = original;
            this.modified = modified;
            this.notebookType = notebookType;
        }
    }
    exports.$GP = $GP;
    class $HP {
        constructor() { }
    }
    exports.$HP = $HP;
    class $IP {
        constructor(uri, inputBoxUri) {
            this.uri = uri;
            this.inputBoxUri = inputBoxUri;
        }
    }
    exports.$IP = $IP;
    class $JP {
        constructor() { }
    }
    exports.$JP = $JP;
    class $KP {
        constructor(textDiffs) {
            this.textDiffs = textDiffs;
        }
    }
    exports.$KP = $KP;
    //#endregion
    //#region Chat
    var InteractiveSessionVoteDirection;
    (function (InteractiveSessionVoteDirection) {
        InteractiveSessionVoteDirection[InteractiveSessionVoteDirection["Down"] = 0] = "Down";
        InteractiveSessionVoteDirection[InteractiveSessionVoteDirection["Up"] = 1] = "Up";
    })(InteractiveSessionVoteDirection || (exports.InteractiveSessionVoteDirection = InteractiveSessionVoteDirection = {}));
    var ChatCopyKind;
    (function (ChatCopyKind) {
        ChatCopyKind[ChatCopyKind["Action"] = 1] = "Action";
        ChatCopyKind[ChatCopyKind["Toolbar"] = 2] = "Toolbar";
    })(ChatCopyKind || (exports.ChatCopyKind = ChatCopyKind = {}));
    var ChatVariableLevel;
    (function (ChatVariableLevel) {
        ChatVariableLevel[ChatVariableLevel["Short"] = 1] = "Short";
        ChatVariableLevel[ChatVariableLevel["Medium"] = 2] = "Medium";
        ChatVariableLevel[ChatVariableLevel["Full"] = 3] = "Full";
    })(ChatVariableLevel || (exports.ChatVariableLevel = ChatVariableLevel = {}));
    class $LP {
        constructor(id, label, values) {
            this.id = id;
            this.label = label;
            this.values = values;
        }
    }
    exports.$LP = $LP;
    //#endregion
    //#region Interactive Editor
    var InteractiveEditorResponseFeedbackKind;
    (function (InteractiveEditorResponseFeedbackKind) {
        InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind["Unhelpful"] = 0] = "Unhelpful";
        InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind["Helpful"] = 1] = "Helpful";
        InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind["Undone"] = 2] = "Undone";
        InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind["Accepted"] = 3] = "Accepted";
        InteractiveEditorResponseFeedbackKind[InteractiveEditorResponseFeedbackKind["Bug"] = 4] = "Bug";
    })(InteractiveEditorResponseFeedbackKind || (exports.InteractiveEditorResponseFeedbackKind = InteractiveEditorResponseFeedbackKind = {}));
    var ChatResultFeedbackKind;
    (function (ChatResultFeedbackKind) {
        ChatResultFeedbackKind[ChatResultFeedbackKind["Unhelpful"] = 0] = "Unhelpful";
        ChatResultFeedbackKind[ChatResultFeedbackKind["Helpful"] = 1] = "Helpful";
    })(ChatResultFeedbackKind || (exports.ChatResultFeedbackKind = ChatResultFeedbackKind = {}));
    class $MP {
        constructor(value) {
            if (typeof value !== 'string' && value.isTrusted === true) {
                throw new Error('The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.');
            }
            this.value = typeof value === 'string' ? new $eO(value) : value;
        }
    }
    exports.$MP = $MP;
    /**
     * TODO if 'vulnerabilities' is finalized, this should be merged with the base ChatResponseMarkdownPart. I just don't see how to do that while keeping
     * vulnerabilities in a seperate API proposal in a clean way.
     */
    class $NP {
        constructor(value, vulnerabilities) {
            if (typeof value !== 'string' && value.isTrusted === true) {
                throw new Error('The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.');
            }
            this.value = typeof value === 'string' ? new $eO(value) : value;
            this.vulnerabilities = vulnerabilities;
        }
    }
    exports.$NP = $NP;
    class $OP {
        constructor(participant, command) {
            this.participant = participant;
            this.command = command;
        }
    }
    exports.$OP = $OP;
    class $PP {
        constructor(title, message, data, buttons) {
            this.title = title;
            this.message = message;
            this.data = data;
            this.buttons = buttons;
        }
    }
    exports.$PP = $PP;
    class $QP {
        constructor(value, baseUri) {
            this.value = value;
            this.baseUri = baseUri;
        }
    }
    exports.$QP = $QP;
    class $RP {
        constructor(value, title) {
            this.value = value;
            this.title = title;
        }
    }
    exports.$RP = $RP;
    class $SP {
        constructor(value) {
            this.value = value;
        }
    }
    exports.$SP = $SP;
    class $TP {
        constructor(value, task) {
            this.value = value;
            this.task = task;
        }
    }
    exports.$TP = $TP;
    class $UP {
        constructor(value) {
            if (typeof value !== 'string' && value.isTrusted === true) {
                throw new Error('The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.');
            }
            this.value = typeof value === 'string' ? new $eO(value) : value;
        }
    }
    exports.$UP = $UP;
    class $VP {
        constructor(value) {
            this.value = value;
        }
    }
    exports.$VP = $VP;
    class $WP {
        constructor(value, iconPath, options) {
            this.value = value;
            this.iconPath = iconPath;
            this.options = options;
        }
    }
    exports.$WP = $WP;
    class $XP {
        constructor(value, license, snippet) {
            this.value = value;
            this.license = license;
            this.snippet = snippet;
        }
    }
    exports.$XP = $XP;
    class $YP {
        constructor(uri, edits) {
            this.uri = uri;
            this.edits = Array.isArray(edits) ? edits : [edits];
        }
    }
    exports.$YP = $YP;
    class $ZP {
        constructor(prompt, command, references, participant) {
            this.prompt = prompt;
            this.command = command;
            this.references = references;
            this.participant = participant;
        }
    }
    exports.$ZP = $ZP;
    class $1P {
        constructor(response, result, participant, command) {
            this.response = response;
            this.result = result;
            this.participant = participant;
            this.command = command;
        }
    }
    exports.$1P = $1P;
    var ChatLocation;
    (function (ChatLocation) {
        ChatLocation[ChatLocation["Panel"] = 1] = "Panel";
        ChatLocation[ChatLocation["Terminal"] = 2] = "Terminal";
        ChatLocation[ChatLocation["Notebook"] = 3] = "Notebook";
        ChatLocation[ChatLocation["Editor"] = 4] = "Editor";
    })(ChatLocation || (exports.ChatLocation = ChatLocation = {}));
    var ChatResponseReferencePartStatusKind;
    (function (ChatResponseReferencePartStatusKind) {
        ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind["Complete"] = 1] = "Complete";
        ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind["Partial"] = 2] = "Partial";
        ChatResponseReferencePartStatusKind[ChatResponseReferencePartStatusKind["Omitted"] = 3] = "Omitted";
    })(ChatResponseReferencePartStatusKind || (exports.ChatResponseReferencePartStatusKind = ChatResponseReferencePartStatusKind = {}));
    class $2P {
        constructor(document, selection, wholeRange) {
            this.document = document;
            this.selection = selection;
            this.wholeRange = wholeRange;
        }
    }
    exports.$2P = $2P;
    class $3P {
        constructor(cell) {
            this.cell = cell;
        }
    }
    exports.$3P = $3P;
    var LanguageModelChatMessageRole;
    (function (LanguageModelChatMessageRole) {
        LanguageModelChatMessageRole[LanguageModelChatMessageRole["User"] = 1] = "User";
        LanguageModelChatMessageRole[LanguageModelChatMessageRole["Assistant"] = 2] = "Assistant";
        LanguageModelChatMessageRole[LanguageModelChatMessageRole["System"] = 3] = "System";
    })(LanguageModelChatMessageRole || (exports.LanguageModelChatMessageRole = LanguageModelChatMessageRole = {}));
    class $4P {
        constructor(name, content, isError) {
            this.name = name;
            this.content = content;
            this.isError = isError ?? false;
        }
    }
    exports.$4P = $4P;
    class $5P {
        static User(content, name) {
            const value = new $5P(LanguageModelChatMessageRole.User, typeof content === 'string' ? content : '', name);
            value.content2 = content;
            return value;
        }
        static Assistant(content, name) {
            return new $5P(LanguageModelChatMessageRole.Assistant, content, name);
        }
        constructor(role, content, name) {
            this.role = role;
            this.content = content;
            this.content2 = content;
            this.name = name;
        }
    }
    exports.$5P = $5P;
    class $6P {
        constructor(name, parameters) {
            this.name = name;
            this.parameters = parameters;
        }
    }
    exports.$6P = $6P;
    class $7P {
        constructor(value) {
            this.value = value;
        }
    }
    exports.$7P = $7P;
    /**
     * @deprecated
     */
    class $8P {
        constructor(content) {
            this.content = content;
        }
    }
    exports.$8P = $8P;
    /**
     * @deprecated
     */
    class $9P {
        constructor(content, name) {
            this.content = content;
            this.name = name;
        }
    }
    exports.$9P = $9P;
    /**
     * @deprecated
     */
    class $0P {
        constructor(content, name) {
            this.content = content;
            this.name = name;
        }
    }
    exports.$0P = $0P;
    class $$P extends Error {
        static NotFound(message) {
            return new $$P(message, $$P.NotFound.name);
        }
        static NoPermissions(message) {
            return new $$P(message, $$P.NoPermissions.name);
        }
        static Blocked(message) {
            return new $$P(message, $$P.Blocked.name);
        }
        constructor(message, code, cause) {
            super(message, { cause });
            this.name = 'LanguageModelError';
            this.code = code ?? '';
        }
    }
    exports.$$P = $$P;
    //#endregion
    //#region ai
    var RelatedInformationType;
    (function (RelatedInformationType) {
        RelatedInformationType[RelatedInformationType["SymbolInformation"] = 1] = "SymbolInformation";
        RelatedInformationType[RelatedInformationType["CommandInformation"] = 2] = "CommandInformation";
        RelatedInformationType[RelatedInformationType["SearchInformation"] = 3] = "SearchInformation";
        RelatedInformationType[RelatedInformationType["SettingInformation"] = 4] = "SettingInformation";
    })(RelatedInformationType || (exports.RelatedInformationType = RelatedInformationType = {}));
    //#endregion
    //#region Speech
    var SpeechToTextStatus;
    (function (SpeechToTextStatus) {
        SpeechToTextStatus[SpeechToTextStatus["Started"] = 1] = "Started";
        SpeechToTextStatus[SpeechToTextStatus["Recognizing"] = 2] = "Recognizing";
        SpeechToTextStatus[SpeechToTextStatus["Recognized"] = 3] = "Recognized";
        SpeechToTextStatus[SpeechToTextStatus["Stopped"] = 4] = "Stopped";
        SpeechToTextStatus[SpeechToTextStatus["Error"] = 5] = "Error";
    })(SpeechToTextStatus || (exports.SpeechToTextStatus = SpeechToTextStatus = {}));
    var TextToSpeechStatus;
    (function (TextToSpeechStatus) {
        TextToSpeechStatus[TextToSpeechStatus["Started"] = 1] = "Started";
        TextToSpeechStatus[TextToSpeechStatus["Stopped"] = 2] = "Stopped";
        TextToSpeechStatus[TextToSpeechStatus["Error"] = 3] = "Error";
    })(TextToSpeechStatus || (exports.TextToSpeechStatus = TextToSpeechStatus = {}));
    var KeywordRecognitionStatus;
    (function (KeywordRecognitionStatus) {
        KeywordRecognitionStatus[KeywordRecognitionStatus["Recognized"] = 1] = "Recognized";
        KeywordRecognitionStatus[KeywordRecognitionStatus["Stopped"] = 2] = "Stopped";
    })(KeywordRecognitionStatus || (exports.KeywordRecognitionStatus = KeywordRecognitionStatus = {}));
    //#endregion
    //#region InlineEdit
    class $_P {
        constructor(text, range) {
            this.text = text;
            this.range = range;
        }
    }
    exports.$_P = $_P;
    var InlineEditTriggerKind;
    (function (InlineEditTriggerKind) {
        InlineEditTriggerKind[InlineEditTriggerKind["Invoke"] = 0] = "Invoke";
        InlineEditTriggerKind[InlineEditTriggerKind["Automatic"] = 1] = "Automatic";
    })(InlineEditTriggerKind || (exports.InlineEditTriggerKind = InlineEditTriggerKind = {}));
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[227/*vs/workbench/api/common/extHostAiRelatedInformation*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, extHost_protocol_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$qpc = void 0;
    class $qpc {
        constructor(mainContext) {
            this.a = new Map();
            this.b = 0;
            this.c = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadAiRelatedInformation);
        }
        async $provideAiRelatedInformation(handle, query, token) {
            if (this.a.size === 0) {
                throw new Error('No related information providers registered');
            }
            const provider = this.a.get(handle);
            if (!provider) {
                throw new Error('related information provider not found');
            }
            const result = await provider.provideRelatedInformation(query, token) ?? [];
            return result;
        }
        getRelatedInformation(extension, query, types) {
            return this.c.$getAiRelatedInformation(query, types);
        }
        registerRelatedInformationProvider(extension, type, provider) {
            const handle = this.b;
            this.b++;
            this.a.set(handle, provider);
            this.c.$registerAiRelatedInformationProvider(handle, type);
            return new extHostTypes_1.$MN(() => {
                this.c.$unregisterAiRelatedInformationProvider(handle);
                this.a.delete(handle);
            });
        }
    }
    exports.$qpc = $qpc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[90/*vs/workbench/api/common/extHostAuthentication*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/,18/*vs/platform/extensions/common/extensions*/,117/*vs/workbench/services/authentication/common/authentication*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/]), function (require, exports, event_1, extHost_protocol_1, extHostTypes_1, extensions_1, authentication_1, instantiation_1, extHostRpcService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Cpc = exports.$Bpc = void 0;
    exports.$Bpc = (0, instantiation_1.$Fi)('IExtHostAuthentication');
    let $Cpc = class $Cpc {
        constructor(extHostRpc) {
            this.b = new Map();
            this.c = new event_1.$le();
            this.onDidChangeSessions = this.c.event;
            this.d = new TaskSingler();
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadAuthentication);
        }
        async getSession(requestingExtension, providerId, scopes, options = {}) {
            const extensionId = extensions_1.$rn.toKey(requestingExtension.identifier);
            const sortedScopes = [...scopes].sort().join(' ');
            return await this.d.getOrCreate(`${extensionId} ${providerId} ${sortedScopes}`, async () => {
                await this.a.$ensureProvider(providerId);
                const extensionName = requestingExtension.displayName || requestingExtension.name;
                return this.a.$getSession(providerId, scopes, extensionId, extensionName, options);
            });
        }
        async getAccounts(providerId) {
            await this.a.$ensureProvider(providerId);
            return await this.a.$getAccounts(providerId);
        }
        async removeSession(providerId, sessionId) {
            const providerData = this.b.get(providerId);
            if (!providerData) {
                return this.a.$removeSession(providerId, sessionId);
            }
            return providerData.provider.removeSession(sessionId);
        }
        registerAuthenticationProvider(id, label, provider, options) {
            if (this.b.get(id)) {
                throw new Error(`An authentication provider with id '${id}' is already registered.`);
            }
            this.b.set(id, { label, provider, options: options ?? { supportsMultipleAccounts: false } });
            const listener = provider.onDidChangeSessions(e => this.a.$sendDidChangeSessions(id, e));
            this.a.$registerAuthenticationProvider(id, label, options?.supportsMultipleAccounts ?? false);
            return new extHostTypes_1.$MN(() => {
                listener.dispose();
                this.b.delete(id);
                this.a.$unregisterAuthenticationProvider(id);
            });
        }
        async $createSession(providerId, scopes, options) {
            const providerData = this.b.get(providerId);
            if (providerData) {
                return await providerData.provider.createSession(scopes, options);
            }
            throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
        }
        async $removeSession(providerId, sessionId) {
            const providerData = this.b.get(providerId);
            if (providerData) {
                return await providerData.provider.removeSession(sessionId);
            }
            throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
        }
        async $getSessions(providerId, scopes, options) {
            const providerData = this.b.get(providerId);
            if (providerData) {
                return await providerData.provider.getSessions(scopes, options);
            }
            throw new Error(`Unable to find authentication provider with handle: ${providerId}`);
        }
        $onDidChangeAuthenticationSessions(id, label) {
            // Don't fire events for the internal auth providers
            if (!id.startsWith(authentication_1.$MM)) {
                this.c.fire({ provider: { id, label } });
            }
            return Promise.resolve();
        }
    };
    exports.$Cpc = $Cpc;
    exports.$Cpc = $Cpc = __decorate([
        __param(0, extHostRpcService_1.$kQ)
    ], $Cpc);
    class TaskSingler {
        constructor() {
            this.a = new Map();
        }
        getOrCreate(key, promiseFactory) {
            const inFlight = this.a.get(key);
            if (inFlight) {
                return inFlight;
            }
            const promise = promiseFactory().finally(() => this.a.delete(key));
            this.a.set(key, promise);
            return promise;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[122/*vs/workbench/api/common/extHostDecorations*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/,11/*vs/platform/log/common/log*/,17/*vs/base/common/arrays*/,12/*vs/base/common/strings*/,19/*vs/base/common/path*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, uri_1, extHost_protocol_1, extHostTypes_1, instantiation_1, extHostRpcService_1, log_1, arrays_1, strings_1, path_1, extensions_1) {
    "use strict";
    var $Gqc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Hqc = exports.$Gqc = void 0;
    let $Gqc = class $Gqc {
        static { $Gqc_1 = this; }
        static { this.c = 0; }
        static { this.d = 250; }
        constructor(extHostRpc, h) {
            this.h = h;
            this.f = new Map();
            this.g = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadDecorations);
        }
        registerFileDecorationProvider(provider, extensionDescription) {
            const handle = $Gqc_1.c++;
            this.f.set(handle, { provider, extensionDescription });
            this.g.$registerDecorationProvider(handle, extensionDescription.identifier.value);
            const listener = provider.onDidChangeFileDecorations && provider.onDidChangeFileDecorations(e => {
                if (!e) {
                    this.g.$onDidChange(handle, null);
                    return;
                }
                const array = (0, arrays_1.$1b)(e);
                if (array.length <= $Gqc_1.d) {
                    this.g.$onDidChange(handle, array);
                    return;
                }
                // too many resources per event. pick one resource per folder, starting
                // with parent folders
                this.h.warn('[Decorations] CAPPING events from decorations provider', extensionDescription.identifier.value, array.length);
                const mapped = array.map(uri => ({ uri, rank: (0, strings_1.$if)(uri.path, '/') }));
                const groups = (0, arrays_1.$yb)(mapped, (a, b) => a.rank - b.rank || (0, strings_1.$yf)(a.uri.path, b.uri.path));
                const picked = [];
                outer: for (const uris of groups) {
                    let lastDirname;
                    for (const obj of uris) {
                        const myDirname = (0, path_1.$mc)(obj.uri.path);
                        if (lastDirname !== myDirname) {
                            lastDirname = myDirname;
                            if (picked.push(obj.uri) >= $Gqc_1.d) {
                                break outer;
                            }
                        }
                    }
                }
                this.g.$onDidChange(handle, picked);
            });
            return new extHostTypes_1.$MN(() => {
                listener?.dispose();
                this.g.$unregisterDecorationProvider(handle);
                this.f.delete(handle);
            });
        }
        async $provideDecorations(handle, requests, token) {
            if (!this.f.has(handle)) {
                // might have been unregistered in the meantime
                return Object.create(null);
            }
            const result = Object.create(null);
            const { provider, extensionDescription: extensionId } = this.f.get(handle);
            await Promise.all(requests.map(async (request) => {
                try {
                    const { uri, id } = request;
                    const data = await Promise.resolve(provider.provideFileDecoration(uri_1.URI.revive(uri), token));
                    if (!data) {
                        return;
                    }
                    try {
                        extHostTypes_1.$cP.validate(data);
                        if (data.badge && typeof data.badge !== 'string') {
                            (0, extensions_1.$gH)(extensionId, 'codiconDecoration');
                        }
                        result[id] = [data.propagate, data.tooltip, data.badge, data.color];
                    }
                    catch (e) {
                        this.h.warn(`INVALID decoration from extension '${extensionId.identifier.value}': ${e}`);
                    }
                }
                catch (err) {
                    this.h.error(err);
                }
            }));
            return result;
        }
    };
    exports.$Gqc = $Gqc;
    exports.$Gqc = $Gqc = $Gqc_1 = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, log_1.$ak)
    ], $Gqc);
    exports.$Hqc = (0, instantiation_1.$Fi)('IExtHostDecorations');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[228/*vs/workbench/api/common/extHostDocumentContentProviders*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,2/*vs/base/common/uri*/,7/*vs/workbench/api/common/extHostTypes*/,5/*vs/workbench/api/common/extHost.protocol*/,15/*vs/base/common/network*/,21/*vs/base/common/cancellation*/,12/*vs/base/common/strings*/]), function (require, exports, errors_1, uri_1, extHostTypes_1, extHost_protocol_1, network_1, cancellation_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Jqc = void 0;
    class $Jqc {
        static { this.a = 0; }
        constructor(mainContext, d, e) {
            this.d = d;
            this.e = e;
            this.b = new Map();
            this.c = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadDocumentContentProviders);
        }
        registerTextDocumentContentProvider(scheme, provider) {
            // todo@remote
            // check with scheme from fs-providers!
            if (Object.keys(network_1.Schemas).indexOf(scheme) >= 0) {
                throw new Error(`scheme '${scheme}' already registered`);
            }
            const handle = $Jqc.a++;
            this.b.set(handle, provider);
            this.c.$registerTextContentProvider(handle, scheme);
            let subscription;
            if (typeof provider.onDidChange === 'function') {
                let lastEvent;
                subscription = provider.onDidChange(async (uri) => {
                    if (uri.scheme !== scheme) {
                        this.e.warn(`Provider for scheme '${scheme}' is firing event for schema '${uri.scheme}' which will be IGNORED`);
                        return;
                    }
                    if (!this.d.getDocument(uri)) {
                        // ignore event if document isn't open
                        return;
                    }
                    if (lastEvent) {
                        await lastEvent;
                    }
                    const thisEvent = this.$provideTextDocumentContent(handle, uri)
                        .then(async (value) => {
                        if (!value && typeof value !== 'string') {
                            return;
                        }
                        const document = this.d.getDocument(uri);
                        if (!document) {
                            // disposed in the meantime
                            return;
                        }
                        // create lines and compare
                        const lines = (0, strings_1.$sf)(value);
                        // broadcast event when content changed
                        if (!document.equalLines(lines)) {
                            return this.c.$onVirtualDocumentChange(uri, value);
                        }
                    })
                        .catch(errors_1.$Y)
                        .finally(() => {
                        if (lastEvent === thisEvent) {
                            lastEvent = undefined;
                        }
                    });
                    lastEvent = thisEvent;
                });
            }
            return new extHostTypes_1.$MN(() => {
                if (this.b.delete(handle)) {
                    this.c.$unregisterTextContentProvider(handle);
                }
                if (subscription) {
                    subscription.dispose();
                    subscription = undefined;
                }
            });
        }
        $provideTextDocumentContent(handle, uri) {
            const provider = this.b.get(handle);
            if (!provider) {
                return Promise.reject(new Error(`unsupported uri-scheme: ${uri.scheme}`));
            }
            return Promise.resolve(provider.provideTextDocumentContent(uri_1.URI.revive(uri), cancellation_1.CancellationToken.None));
        }
    }
    exports.$Jqc = $Jqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[123/*vs/workbench/api/common/extHostDocumentData*/], __M([1/*require*/,0/*exports*/,61/*vs/base/common/assert*/,15/*vs/base/common/network*/,12/*vs/base/common/strings*/,284/*vs/editor/common/model/mirrorTextModel*/,169/*vs/editor/common/core/wordHelper*/,7/*vs/workbench/api/common/extHostTypes*/,17/*vs/base/common/arrays*/]), function (require, exports, assert_1, network_1, strings_1, mirrorTextModel_1, wordHelper_1, extHostTypes_1, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oQ = exports.$nQ = void 0;
    exports.$mQ = $mQ;
    const _languageId2WordDefinition = new Map();
    function $mQ(languageId, wordDefinition) {
        if (!wordDefinition) {
            _languageId2WordDefinition.delete(languageId);
        }
        else {
            _languageId2WordDefinition.set(languageId, wordDefinition);
        }
    }
    function getWordDefinitionFor(languageId) {
        return _languageId2WordDefinition.get(languageId);
    }
    class $nQ extends mirrorTextModel_1.$pw {
        constructor(c, uri, lines, eol, versionId, m, q) {
            super(uri, lines, eol, versionId);
            this.c = c;
            this.m = m;
            this.q = q;
            this.b = false;
        }
        // eslint-disable-next-line local/code-must-use-super-dispose
        dispose() {
            // we don't really dispose documents but let
            // extensions still read from them. some
            // operations, live saving, will now error tho
            (0, assert_1.ok)(!this.b);
            this.b = true;
            this.q = false;
        }
        equalLines(lines) {
            return (0, arrays_1.$tb)(this.f, lines);
        }
        get document() {
            if (!this.a) {
                const that = this;
                this.a = {
                    get uri() { return that.d; },
                    get fileName() { return that.d.fsPath; },
                    get isUntitled() { return that.d.scheme === network_1.Schemas.untitled; },
                    get languageId() { return that.m; },
                    get version() { return that.h; },
                    get isClosed() { return that.b; },
                    get isDirty() { return that.q; },
                    save() { return that.r(); },
                    getText(range) { return range ? that.s(range) : that.getText(); },
                    get eol() { return that.g === '\n' ? extHostTypes_1.EndOfLine.LF : extHostTypes_1.EndOfLine.CRLF; },
                    get lineCount() { return that.f.length; },
                    lineAt(lineOrPos) { return that.t(lineOrPos); },
                    offsetAt(pos) { return that.u(pos); },
                    positionAt(offset) { return that.v(offset); },
                    validateRange(ran) { return that.w(ran); },
                    validatePosition(pos) { return that.x(pos); },
                    getWordRangeAtPosition(pos, regexp) { return that.y(pos, regexp); },
                    [Symbol.for('debug.description')]() {
                        return `TextDocument(${that.d.toString()})`;
                    }
                };
            }
            return Object.freeze(this.a);
        }
        _acceptLanguageId(newLanguageId) {
            (0, assert_1.ok)(!this.b);
            this.m = newLanguageId;
        }
        _acceptIsDirty(isDirty) {
            (0, assert_1.ok)(!this.b);
            this.q = isDirty;
        }
        r() {
            if (this.b) {
                return Promise.reject(new Error('Document has been closed'));
            }
            return this.c.$trySaveDocument(this.d);
        }
        s(_range) {
            const range = this.w(_range);
            if (range.isEmpty) {
                return '';
            }
            if (range.isSingleLine) {
                return this.f[range.start.line].substring(range.start.character, range.end.character);
            }
            const lineEnding = this.g, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
            resultLines.push(this.f[startLineIndex].substring(range.start.character));
            for (let i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this.f[i]);
            }
            resultLines.push(this.f[endLineIndex].substring(0, range.end.character));
            return resultLines.join(lineEnding);
        }
        t(lineOrPosition) {
            let line;
            if (lineOrPosition instanceof extHostTypes_1.$NN) {
                line = lineOrPosition.line;
            }
            else if (typeof lineOrPosition === 'number') {
                line = lineOrPosition;
            }
            if (typeof line !== 'number' || line < 0 || line >= this.f.length || Math.floor(line) !== line) {
                throw new Error('Illegal value for `line`');
            }
            return new $oQ(line, this.f[line], line === this.f.length - 1);
        }
        u(position) {
            position = this.x(position);
            this.l();
            return this.j.getPrefixSum(position.line - 1) + position.character;
        }
        v(offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this.l();
            const out = this.j.getIndexOf(offset);
            const lineLength = this.f[out.index].length;
            // Ensure we return a valid position
            return new extHostTypes_1.$NN(out.index, Math.min(out.remainder, lineLength));
        }
        // ---- range math
        w(range) {
            if (!(range instanceof extHostTypes_1.$ON)) {
                throw new Error('Invalid argument');
            }
            const start = this.x(range.start);
            const end = this.x(range.end);
            if (start === range.start && end === range.end) {
                return range;
            }
            return new extHostTypes_1.$ON(start.line, start.character, end.line, end.character);
        }
        x(position) {
            if (!(position instanceof extHostTypes_1.$NN)) {
                throw new Error('Invalid argument');
            }
            if (this.f.length === 0) {
                return position.with(0, 0);
            }
            let { line, character } = position;
            let hasChanged = false;
            if (line < 0) {
                line = 0;
                character = 0;
                hasChanged = true;
            }
            else if (line >= this.f.length) {
                line = this.f.length - 1;
                character = this.f[line].length;
                hasChanged = true;
            }
            else {
                const maxCharacter = this.f[line].length;
                if (character < 0) {
                    character = 0;
                    hasChanged = true;
                }
                else if (character > maxCharacter) {
                    character = maxCharacter;
                    hasChanged = true;
                }
            }
            if (!hasChanged) {
                return position;
            }
            return new extHostTypes_1.$NN(line, character);
        }
        y(_position, regexp) {
            const position = this.x(_position);
            if (!regexp) {
                // use default when custom-regexp isn't provided
                regexp = getWordDefinitionFor(this.m);
            }
            else if ((0, strings_1.$rf)(regexp)) {
                // use default when custom-regexp is bad
                throw new Error(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);
            }
            const wordAtText = (0, wordHelper_1.$qt)(position.character + 1, (0, wordHelper_1.$ot)(regexp), this.f[position.line], 0);
            if (wordAtText) {
                return new extHostTypes_1.$ON(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
            }
            return undefined;
        }
    }
    exports.$nQ = $nQ;
    class $oQ {
        constructor(line, text, isLastLine) {
            this.a = line;
            this.b = text;
            this.c = isLastLine;
        }
        get lineNumber() {
            return this.a;
        }
        get text() {
            return this.b;
        }
        get range() {
            return new extHostTypes_1.$ON(this.a, 0, this.a, this.b.length);
        }
        get rangeIncludingLineBreak() {
            if (this.c) {
                return this.range;
            }
            return new extHostTypes_1.$ON(this.a, 0, this.a + 1, 0);
        }
        get firstNonWhitespaceCharacterIndex() {
            //TODO@api, rename to 'leadingWhitespaceLength'
            return /^(\s*)/.exec(this.b)[1].length;
        }
        get isEmptyOrWhitespace() {
            return this.firstNonWhitespaceCharacterIndex === this.b.length;
        }
    }
    exports.$oQ = $oQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[229/*vs/workbench/api/common/extHostEmbeddingVector*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, extHost_protocol_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Mqc = void 0;
    class $Mqc {
        constructor(mainContext) {
            this.a = new Map();
            this.b = 0;
            this.c = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadAiEmbeddingVector);
        }
        async $provideAiEmbeddingVector(handle, strings, token) {
            if (this.a.size === 0) {
                throw new Error('No embedding vector providers registered');
            }
            const provider = this.a.get(handle);
            if (!provider) {
                throw new Error('Embedding vector provider not found');
            }
            const result = await provider.provideEmbeddingVector(strings, token);
            if (!result) {
                throw new Error('Embedding vector provider returned undefined');
            }
            return result;
        }
        registerEmbeddingVectorProvider(extension, model, provider) {
            const handle = this.b;
            this.b++;
            this.a.set(handle, provider);
            this.c.$registerAiEmbeddingVectorProvider(model, handle);
            return new extHostTypes_1.$MN(() => {
                this.c.$unregisterAiEmbeddingVectorProvider(handle);
                this.a.delete(handle);
            });
        }
    }
    exports.$Mqc = $Mqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[68/*vs/workbench/api/common/extHostFileSystemConsumer*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,29/*vs/platform/files/common/files*/,7/*vs/workbench/api/common/extHostTypes*/,22/*vs/base/common/buffer*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/,50/*vs/workbench/api/common/extHostFileSystemInfo*/,4/*vs/base/common/lifecycle*/,10/*vs/base/common/async*/,23/*vs/base/common/resources*/,15/*vs/base/common/network*/]), function (require, exports, extHost_protocol_1, files, extHostTypes_1, buffer_1, instantiation_1, extHostRpcService_1, extHostFileSystemInfo_1, lifecycle_1, async_1, resources_1, network_1) {
    "use strict";
    var $Rpc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Spc = exports.$Rpc = void 0;
    files = __importStar(files);
    let $Rpc = $Rpc_1 = class $Rpc {
        constructor(extHostRpc, fileSystemInfo) {
            this.b = new Map();
            this.c = new async_1.$Oh();
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadFileSystem);
            const that = this;
            this.value = Object.freeze({
                async stat(uri) {
                    try {
                        let stat;
                        const provider = that.b.get(uri.scheme);
                        if (provider) {
                            // use shortcut
                            await that.a.$ensureActivation(uri.scheme);
                            stat = await provider.impl.stat(uri);
                        }
                        else {
                            stat = await that.a.$stat(uri);
                        }
                        return {
                            type: stat.type,
                            ctime: stat.ctime,
                            mtime: stat.mtime,
                            size: stat.size,
                            permissions: stat.permissions === files.FilePermission.Readonly ? 1 : undefined
                        };
                    }
                    catch (err) {
                        $Rpc_1.e(err);
                    }
                },
                async readDirectory(uri) {
                    try {
                        const provider = that.b.get(uri.scheme);
                        if (provider) {
                            // use shortcut
                            await that.a.$ensureActivation(uri.scheme);
                            return (await provider.impl.readDirectory(uri)).slice(); // safe-copy
                        }
                        else {
                            return await that.a.$readdir(uri);
                        }
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                async createDirectory(uri) {
                    try {
                        const provider = that.b.get(uri.scheme);
                        if (provider && !provider.isReadonly) {
                            // use shortcut
                            await that.a.$ensureActivation(uri.scheme);
                            return await that.d(provider.impl, provider.extUri, uri);
                        }
                        else {
                            return await that.a.$mkdir(uri);
                        }
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                async readFile(uri) {
                    try {
                        const provider = that.b.get(uri.scheme);
                        if (provider) {
                            // use shortcut
                            await that.a.$ensureActivation(uri.scheme);
                            return (await provider.impl.readFile(uri)).slice(); // safe-copy
                        }
                        else {
                            const buff = await that.a.$readFile(uri);
                            return buff.buffer;
                        }
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                async writeFile(uri, content) {
                    try {
                        const provider = that.b.get(uri.scheme);
                        if (provider && !provider.isReadonly) {
                            // use shortcut
                            await that.a.$ensureActivation(uri.scheme);
                            await that.d(provider.impl, provider.extUri, provider.extUri.dirname(uri));
                            return await that.c.queueFor(uri, () => Promise.resolve(provider.impl.writeFile(uri, content, { create: true, overwrite: true })));
                        }
                        else {
                            return await that.a.$writeFile(uri, buffer_1.$Ne.wrap(content));
                        }
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                async delete(uri, options) {
                    try {
                        const provider = that.b.get(uri.scheme);
                        if (provider && !provider.isReadonly && !options?.useTrash /* no shortcut: use trash */) {
                            // use shortcut
                            await that.a.$ensureActivation(uri.scheme);
                            return await provider.impl.delete(uri, { recursive: false, ...options });
                        }
                        else {
                            return await that.a.$delete(uri, { recursive: false, useTrash: false, atomic: false, ...options });
                        }
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                async rename(oldUri, newUri, options) {
                    try {
                        // no shortcut: potentially involves different schemes, does mkdirp
                        return await that.a.$rename(oldUri, newUri, { ...{ overwrite: false }, ...options });
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                async copy(source, destination, options) {
                    try {
                        // no shortcut: potentially involves different schemes, does mkdirp
                        return await that.a.$copy(source, destination, { ...{ overwrite: false }, ...options });
                    }
                    catch (err) {
                        return $Rpc_1.e(err);
                    }
                },
                isWritableFileSystem(scheme) {
                    const capabilities = fileSystemInfo.getCapabilities(scheme);
                    if (typeof capabilities === 'number') {
                        return !(capabilities & files.FileSystemProviderCapabilities.Readonly);
                    }
                    return undefined;
                }
            });
        }
        async d(provider, providerExtUri, directory) {
            const directoriesToCreate = [];
            while (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {
                try {
                    const stat = await provider.stat(directory);
                    if ((stat.type & files.FileType.Directory) === 0) {
                        throw extHostTypes_1.$6O.FileExists(`Unable to create folder '${directory.scheme === network_1.Schemas.file ? directory.fsPath : directory.toString(true)}' that already exists but is not a directory`);
                    }
                    break; // we have hit a directory that exists -> good
                }
                catch (error) {
                    if (files.$ql(error) !== files.FileSystemProviderErrorCode.FileNotFound) {
                        throw error;
                    }
                    // further go up and remember to create this directory
                    directoriesToCreate.push(providerExtUri.basename(directory));
                    directory = providerExtUri.dirname(directory);
                }
            }
            for (let i = directoriesToCreate.length - 1; i >= 0; i--) {
                directory = providerExtUri.joinPath(directory, directoriesToCreate[i]);
                try {
                    await provider.createDirectory(directory);
                }
                catch (error) {
                    if (files.$ql(error) !== files.FileSystemProviderErrorCode.FileExists) {
                        // For mkdirp() we tolerate that the mkdir() call fails
                        // in case the folder already exists. This follows node.js
                        // own implementation of fs.mkdir({ recursive: true }) and
                        // reduces the chances of race conditions leading to errors
                        // if multiple calls try to create the same folders
                        // As such, we only throw an error here if it is other than
                        // the fact that the file already exists.
                        // (see also https://github.com/microsoft/vscode/issues/89834)
                        throw error;
                    }
                }
            }
        }
        static e(err) {
            // desired error type
            if (err instanceof extHostTypes_1.$6O) {
                throw err;
            }
            // file system provider error
            if (err instanceof files.$ml) {
                switch (err.code) {
                    case files.FileSystemProviderErrorCode.FileExists: throw extHostTypes_1.$6O.FileExists(err.message);
                    case files.FileSystemProviderErrorCode.FileNotFound: throw extHostTypes_1.$6O.FileNotFound(err.message);
                    case files.FileSystemProviderErrorCode.FileNotADirectory: throw extHostTypes_1.$6O.FileNotADirectory(err.message);
                    case files.FileSystemProviderErrorCode.FileIsADirectory: throw extHostTypes_1.$6O.FileIsADirectory(err.message);
                    case files.FileSystemProviderErrorCode.NoPermissions: throw extHostTypes_1.$6O.NoPermissions(err.message);
                    case files.FileSystemProviderErrorCode.Unavailable: throw extHostTypes_1.$6O.Unavailable(err.message);
                    default: throw new extHostTypes_1.$6O(err.message, err.name);
                }
            }
            // generic error
            if (!(err instanceof Error)) {
                throw new extHostTypes_1.$6O(String(err));
            }
            // no provider (unknown scheme) error
            if (err.name === 'ENOPRO' || err.message.includes('ENOPRO')) {
                throw extHostTypes_1.$6O.Unavailable(err.message);
            }
            // file system error
            switch (err.name) {
                case files.FileSystemProviderErrorCode.FileExists: throw extHostTypes_1.$6O.FileExists(err.message);
                case files.FileSystemProviderErrorCode.FileNotFound: throw extHostTypes_1.$6O.FileNotFound(err.message);
                case files.FileSystemProviderErrorCode.FileNotADirectory: throw extHostTypes_1.$6O.FileNotADirectory(err.message);
                case files.FileSystemProviderErrorCode.FileIsADirectory: throw extHostTypes_1.$6O.FileIsADirectory(err.message);
                case files.FileSystemProviderErrorCode.NoPermissions: throw extHostTypes_1.$6O.NoPermissions(err.message);
                case files.FileSystemProviderErrorCode.Unavailable: throw extHostTypes_1.$6O.Unavailable(err.message);
                default: throw new extHostTypes_1.$6O(err.message, err.name);
            }
        }
        // ---
        addFileSystemProvider(scheme, provider, options) {
            this.b.set(scheme, { impl: provider, extUri: options?.isCaseSensitive ? resources_1.$9g : resources_1.$$g, isReadonly: !!options?.isReadonly });
            return (0, lifecycle_1.$Sc)(() => this.b.delete(scheme));
        }
        getFileSystemProviderExtUri(scheme) {
            return this.b.get(scheme)?.extUri ?? resources_1.$9g;
        }
    };
    exports.$Rpc = $Rpc;
    exports.$Rpc = $Rpc = $Rpc_1 = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostFileSystemInfo_1.$vpc)
    ], $Rpc);
    exports.$Spc = (0, instantiation_1.$Fi)('IExtHostConsumerFileSystem');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[91/*vs/workbench/api/common/extHostStoragePaths*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,26/*vs/workbench/api/common/extHostInitDataService*/,11/*vs/platform/log/common/log*/,68/*vs/workbench/api/common/extHostFileSystemConsumer*/,2/*vs/base/common/uri*/]), function (require, exports, instantiation_1, extHostInitDataService_1, log_1, extHostFileSystemConsumer_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Upc = exports.$Tpc = void 0;
    exports.$Tpc = (0, instantiation_1.$Fi)('IExtensionStoragePaths');
    let $Upc = class $Upc {
        constructor(initData, d, f) {
            this.d = d;
            this.f = f;
            this.a = initData.workspace ?? undefined;
            this.b = initData.environment;
            this.whenReady = this.h().then(value => this.c = value);
        }
        async g(storageName) {
            return uri_1.URI.joinPath(this.b.workspaceStorageHome, storageName);
        }
        async h() {
            if (!this.a) {
                return Promise.resolve(undefined);
            }
            const storageName = this.a.id;
            const storageUri = await this.g(storageName);
            try {
                await this.f.value.stat(storageUri);
                this.d.trace('[ExtHostStorage] storage dir already exists', storageUri);
                return storageUri;
            }
            catch {
                // doesn't exist, that's OK
            }
            try {
                this.d.trace('[ExtHostStorage] creating dir and metadata-file', storageUri);
                await this.f.value.createDirectory(storageUri);
                await this.f.value.writeFile(uri_1.URI.joinPath(storageUri, 'meta.json'), new TextEncoder().encode(JSON.stringify({
                    id: this.a.id,
                    configuration: uri_1.URI.revive(this.a.configuration)?.toString(),
                    name: this.a.name
                }, undefined, 2)));
                return storageUri;
            }
            catch (e) {
                this.d.error('[ExtHostStorage]', e);
                return undefined;
            }
        }
        workspaceValue(extension) {
            if (this.c) {
                return uri_1.URI.joinPath(this.c, extension.identifier.value);
            }
            return undefined;
        }
        globalValue(extension) {
            return uri_1.URI.joinPath(this.b.globalStorageHome, extension.identifier.value.toLowerCase());
        }
        onWillDeactivateAll() {
        }
    };
    exports.$Upc = $Upc;
    exports.$Upc = $Upc = __decorate([
        __param(0, extHostInitDataService_1.$AQ),
        __param(1, log_1.$ak),
        __param(2, extHostFileSystemConsumer_1.$Spc)
    ], $Upc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[230/*vs/workbench/api/common/extHostTheming*/], __M([1/*require*/,0/*exports*/,7/*vs/workbench/api/common/extHostTypes*/,16/*vs/workbench/api/common/extHostRpcService*/,6/*vs/base/common/event*/]), function (require, exports, extHostTypes_1, extHostRpcService_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$rrc = void 0;
    let $rrc = class $rrc {
        constructor(_extHostRpc) {
            this.a = new extHostTypes_1.$dP(extHostTypes_1.ColorThemeKind.Dark);
            this.b = new event_1.$le();
        }
        get activeColorTheme() {
            return this.a;
        }
        $onColorThemeChange(type) {
            let kind;
            switch (type) {
                case 'light':
                    kind = extHostTypes_1.ColorThemeKind.Light;
                    break;
                case 'hcDark':
                    kind = extHostTypes_1.ColorThemeKind.HighContrast;
                    break;
                case 'hcLight':
                    kind = extHostTypes_1.ColorThemeKind.HighContrastLight;
                    break;
                default:
                    kind = extHostTypes_1.ColorThemeKind.Dark;
            }
            this.a = new extHostTypes_1.$dP(kind);
            this.b.fire(this.a);
        }
        get onDidChangeActiveColorTheme() {
            return this.b.event;
        }
    };
    exports.$rrc = $rrc;
    exports.$rrc = $rrc = __decorate([
        __param(0, extHostRpcService_1.$kQ)
    ], $rrc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[92/*vs/workbench/api/common/extHostTunnelService*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,9/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,183/*vs/platform/tunnel/common/tunnel*/,5/*vs/workbench/api/common/extHost.protocol*/,26/*vs/workbench/api/common/extHostInitDataService*/,16/*vs/workbench/api/common/extHostRpcService*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, cancellation_1, event_1, lifecycle_1, nls, instantiation_1, log_1, tunnel_1, extHost_protocol_1, extHostInitDataService_1, extHostRpcService_1, types) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$hGb = exports.$gGb = exports.TunnelDtoConverter = void 0;
    nls = __importStar(nls);
    types = __importStar(types);
    class ExtensionTunnel extends tunnel_1.$Ow {
    }
    var TunnelDtoConverter;
    (function (TunnelDtoConverter) {
        function fromApiTunnel(tunnel) {
            return {
                remoteAddress: tunnel.remoteAddress,
                localAddress: tunnel.localAddress,
                public: !!tunnel.public,
                privacy: tunnel.privacy ?? (tunnel.public ? tunnel_1.TunnelPrivacyId.Public : tunnel_1.TunnelPrivacyId.Private),
                protocol: tunnel.protocol
            };
        }
        TunnelDtoConverter.fromApiTunnel = fromApiTunnel;
        function fromServiceTunnel(tunnel) {
            return {
                remoteAddress: {
                    host: tunnel.tunnelRemoteHost,
                    port: tunnel.tunnelRemotePort
                },
                localAddress: tunnel.localAddress,
                public: tunnel.privacy !== tunnel_1.TunnelPrivacyId.ConstantPrivate && tunnel.privacy !== tunnel_1.TunnelPrivacyId.ConstantPrivate,
                privacy: tunnel.privacy,
                protocol: tunnel.protocol
            };
        }
        TunnelDtoConverter.fromServiceTunnel = fromServiceTunnel;
    })(TunnelDtoConverter || (exports.TunnelDtoConverter = TunnelDtoConverter = {}));
    exports.$gGb = (0, instantiation_1.$Fi)('IExtHostTunnelService');
    let $hGb = class $hGb extends lifecycle_1.$Uc {
        constructor(extHostRpc, initData, s) {
            super();
            this.s = s;
            this.f = () => { return Promise.resolve(true); };
            this.g = new Map();
            this.h = new event_1.$le();
            this.onDidChangeTunnels = this.h.event;
            this.n = 0;
            this.r = new Map();
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadTunnelService);
        }
        async openTunnel(extension, forward) {
            this.s.trace(`ForwardedPorts: (ExtHostTunnelService) ${extension.identifier.value} called openTunnel API for ${forward.remoteAddress.host}:${forward.remoteAddress.port}.`);
            const tunnel = await this.a.$openTunnel(forward, extension.displayName);
            if (tunnel) {
                const disposableTunnel = new ExtensionTunnel(tunnel.remoteAddress, tunnel.localAddress, () => {
                    return this.a.$closeTunnel(tunnel.remoteAddress);
                });
                this.B(disposableTunnel);
                return disposableTunnel;
            }
            return undefined;
        }
        async getTunnels() {
            return this.a.$getTunnels();
        }
        u() {
            return this.n++;
        }
        registerPortsAttributesProvider(portSelector, provider) {
            if (portSelector.portRange === undefined && portSelector.commandPattern === undefined) {
                this.s.error('PortAttributesProvider must specify either a portRange or a commandPattern');
            }
            const providerHandle = this.u();
            this.r.set(providerHandle, { selector: portSelector, provider });
            this.a.$registerPortsAttributesProvider(portSelector, providerHandle);
            return new types.$MN(() => {
                this.r.delete(providerHandle);
                this.a.$unregisterPortsAttributesProvider(providerHandle);
            });
        }
        async $providePortAttributes(handles, ports, pid, commandLine, cancellationToken) {
            const providedAttributes = [];
            for (const handle of handles) {
                const provider = this.r.get(handle);
                if (!provider) {
                    return [];
                }
                providedAttributes.push(...(await Promise.all(ports.map(async (port) => {
                    let providedAttributes;
                    try {
                        providedAttributes = await provider.provider.providePortAttributes({ port, pid, commandLine }, cancellationToken);
                    }
                    catch (e) {
                        // Call with old signature for breaking API change
                        providedAttributes = await provider.provider.providePortAttributes(port, pid, commandLine, cancellationToken);
                    }
                    return { providedAttributes, port };
                }))));
            }
            const allAttributes = providedAttributes.filter(attribute => !!attribute.providedAttributes);
            return (allAttributes.length > 0) ? allAttributes.map(attributes => {
                return {
                    autoForwardAction: attributes.providedAttributes.autoForwardAction,
                    port: attributes.port
                };
            }) : [];
        }
        async $registerCandidateFinder(_enable) { }
        registerTunnelProvider(provider, information) {
            if (this.b) {
                throw new Error('A tunnel provider has already been registered. Only the first tunnel provider to be registered will be used.');
            }
            this.b = async (tunnelOptions, tunnelCreationOptions) => {
                const result = await provider.provideTunnel(tunnelOptions, tunnelCreationOptions, cancellation_1.CancellationToken.None);
                return result ?? undefined;
            };
            const tunnelFeatures = information.tunnelFeatures ? {
                elevation: !!information.tunnelFeatures?.elevation,
                privacyOptions: information.tunnelFeatures?.privacyOptions,
                protocol: information.tunnelFeatures.protocol === undefined ? true : information.tunnelFeatures.protocol,
            } : undefined;
            this.a.$setTunnelProvider(tunnelFeatures);
            return Promise.resolve((0, lifecycle_1.$Sc)(() => {
                this.b = undefined;
                this.a.$setTunnelProvider(undefined);
            }));
        }
        /**
         * Applies the tunnel metadata and factory found in the remote authority
         * resolver to the tunnel system.
         *
         * `managedRemoteAuthority` should be be passed if the resolver returned on.
         * If this is the case, the tunnel cannot be connected to via a websocket from
         * the share process, so a synethic tunnel factory is used as a default.
         */
        async setTunnelFactory(provider, managedRemoteAuthority) {
            // Do not wait for any of the proxy promises here.
            // It will delay startup and there is nothing that needs to be waited for.
            if (provider) {
                if (provider.candidatePortSource !== undefined) {
                    this.a.$setCandidatePortSource(provider.candidatePortSource);
                }
                if (provider.showCandidatePort) {
                    this.f = provider.showCandidatePort;
                    this.a.$setCandidateFilter();
                }
                const tunnelFactory = provider.tunnelFactory ?? (managedRemoteAuthority ? this.w(managedRemoteAuthority) : undefined);
                if (tunnelFactory) {
                    this.b = tunnelFactory;
                    let privacyOptions = provider.tunnelFeatures?.privacyOptions ?? [];
                    if (provider.tunnelFeatures?.public && (privacyOptions.length === 0)) {
                        privacyOptions = [
                            {
                                id: 'private',
                                label: nls.localize(11247, null),
                                themeIcon: 'lock'
                            },
                            {
                                id: 'public',
                                label: nls.localize(11248, null),
                                themeIcon: 'eye'
                            }
                        ];
                    }
                    const tunnelFeatures = provider.tunnelFeatures ? {
                        elevation: !!provider.tunnelFeatures?.elevation,
                        public: !!provider.tunnelFeatures?.public,
                        privacyOptions,
                        protocol: true
                    } : undefined;
                    this.a.$setTunnelProvider(tunnelFeatures);
                }
            }
            else {
                this.b = undefined;
            }
            return (0, lifecycle_1.$Sc)(() => {
                this.b = undefined;
            });
        }
        w(_authority) {
            return undefined; // may be overridden
        }
        async $closeTunnel(remote, silent) {
            if (this.g.has(remote.host)) {
                const hostMap = this.g.get(remote.host);
                if (hostMap.has(remote.port)) {
                    if (silent) {
                        hostMap.get(remote.port).disposeListener.dispose();
                    }
                    await hostMap.get(remote.port).tunnel.dispose();
                    hostMap.delete(remote.port);
                }
            }
        }
        async $onDidTunnelsChange() {
            this.h.fire();
        }
        async $forwardPort(tunnelOptions, tunnelCreationOptions) {
            if (this.b) {
                try {
                    this.s.trace('ForwardedPorts: (ExtHostTunnelService) Getting tunnel from provider.');
                    const providedPort = this.b(tunnelOptions, tunnelCreationOptions);
                    this.s.trace('ForwardedPorts: (ExtHostTunnelService) Got tunnel promise from provider.');
                    if (providedPort !== undefined) {
                        const tunnel = await providedPort;
                        this.s.trace('ForwardedPorts: (ExtHostTunnelService) Successfully awaited tunnel from provider.');
                        if (tunnel === undefined) {
                            this.s.error('ForwardedPorts: (ExtHostTunnelService) Resolved tunnel is undefined');
                            return undefined;
                        }
                        if (!this.g.has(tunnelOptions.remoteAddress.host)) {
                            this.g.set(tunnelOptions.remoteAddress.host, new Map());
                        }
                        const disposeListener = this.B(tunnel.onDidDispose(() => {
                            this.s.trace('ForwardedPorts: (ExtHostTunnelService) Extension fired tunnel\'s onDidDispose.');
                            return this.a.$closeTunnel(tunnel.remoteAddress);
                        }));
                        this.g.get(tunnelOptions.remoteAddress.host).set(tunnelOptions.remoteAddress.port, { tunnel, disposeListener });
                        return TunnelDtoConverter.fromApiTunnel(tunnel);
                    }
                    else {
                        this.s.trace('ForwardedPorts: (ExtHostTunnelService) Tunnel is undefined');
                    }
                }
                catch (e) {
                    this.s.trace('ForwardedPorts: (ExtHostTunnelService) tunnel provider error');
                    if (e instanceof Error) {
                        return e.message;
                    }
                }
            }
            return undefined;
        }
        async $applyCandidateFilter(candidates) {
            const filter = await Promise.all(candidates.map(candidate => this.f(candidate.host, candidate.port, candidate.detail ?? '')));
            const result = candidates.filter((candidate, index) => filter[index]);
            this.s.trace(`ForwardedPorts: (ExtHostTunnelService) filtered from ${candidates.map(port => port.port).join(', ')} to ${result.map(port => port.port).join(', ')}`);
            return result;
        }
    };
    exports.$hGb = $hGb;
    exports.$hGb = $hGb = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ),
        __param(2, log_1.$ak)
    ], $hGb);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[8/*vs/workbench/api/common/extHostTypeConverters*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,22/*vs/base/common/buffer*/,151/*vs/base/common/dataTransfer*/,231/*vs/base/common/functional*/,59/*vs/base/common/htmlContent*/,28/*vs/base/common/map*/,138/*vs/base/common/marked/marked*/,36/*vs/base/common/marshalling*/,72/*vs/base/common/mime*/,25/*vs/base/common/objects*/,144/*vs/base/common/prefixTree*/,23/*vs/base/common/resources*/,34/*vs/base/common/themables*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,105/*vs/editor/common/config/editorOptions*/,32/*vs/editor/common/core/range*/,159/*vs/editor/common/encodedTokenAttributes*/,93/*vs/editor/common/languages*/,52/*vs/editor/common/model*/,107/*vs/platform/markers/common/markers*/,76/*vs/platform/progress/common/progress*/,116/*vs/workbench/api/common/extHostTestingPrivateApi*/,114/*vs/workbench/common/editor*/,115/*vs/workbench/contrib/chat/common/chatAgents*/,207/*vs/workbench/contrib/chat/common/languageModels*/,80/*vs/workbench/contrib/debug/common/debug*/,89/*vs/workbench/contrib/notebook/common/notebookCommon*/,54/*vs/workbench/contrib/testing/common/testId*/,55/*vs/workbench/contrib/testing/common/testTypes*/,204/*vs/workbench/services/editor/common/editorService*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, arrays_1, buffer_1, dataTransfer_1, functional_1, htmlContent, map_1, marked_1, marshalling_1, mime_1, objects_1, prefixTree_1, resources_1, themables_1, types_1, uri_1, editorOptions_1, editorRange, encodedTokenAttributes, languages, model_1, markers_1, progress_1, extHostTestingPrivateApi_1, editor_1, chatAgents_1, chatProvider, debug_1, notebooks, testId_1, testTypes_1, editorService_1, types) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LanguageModelToolDescription = exports.DebugTreeItem = exports.PartialAcceptTriggerKind = exports.PartialAcceptInfo = exports.TerminalQuickFix = exports.ChatAgentUserActionEvent = exports.ChatAgentResult = exports.ChatAgentCompletionItem = exports.ChatAgentValueReference = exports.ChatLocation = exports.ChatAgentRequest = exports.ChatResponsePart = exports.ChatResponseCodeCitationPart = exports.ChatResponseReferencePart = exports.ChatResponseTextEditPart = exports.ChatResponseCommandButtonPart = exports.ChatTaskResult = exports.ChatTask = exports.ChatResponseWarningPart = exports.ChatResponseProgressPart = exports.ChatResponseAnchorPart = exports.ChatResponseFilesPart = exports.ChatResponseConfirmationPart = exports.ChatResponseDetectedParticipantPart = exports.ChatResponseMarkdownWithVulnerabilitiesPart = exports.ChatResponseMarkdownPart = exports.LanguageModelChatMessage = exports.LanguageModelChatMessageRole = exports.ChatFollowup = exports.DataTransfer = exports.DataTransferItem = exports.ViewBadge = exports.TypeHierarchyItem = exports.CodeActionTriggerKind = exports.TestCoverage = exports.TestResults = exports.TestItem = exports.TestTag = exports.TestMessage = exports.NotebookRendererScript = exports.NotebookDocumentContentOptions = exports.NotebookKernelSourceAction = exports.NotebookStatusBarItem = exports.NotebookExclusiveDocumentPattern = exports.NotebookCellOutput = exports.NotebookCellOutputItem = exports.NotebookCellData = exports.NotebookData = exports.NotebookCellKind = exports.NotebookCellExecutionState = exports.NotebookCellExecutionSummary = exports.NotebookRange = exports.MappedEditsContext = exports.LanguageSelector = exports.GlobPattern = exports.TextEditorOpenOptions = exports.FoldingRangeKind = exports.FoldingRange = exports.ProgressLocation = exports.EndOfLine = exports.TextEditorLineNumbersStyle = exports.TextDocumentSaveReason = exports.SelectionRange = exports.Color = exports.ColorPresentation = exports.DocumentLink = exports.InlayHintKind = exports.InlayHintLabelPart = exports.InlayHint = exports.SignatureHelp = exports.SignatureInformation = exports.ParameterInformation = exports.CompletionItem = exports.CompletionItemKind = exports.CompletionItemTag = exports.CompletionContext = exports.CompletionTriggerKind = exports.MultiDocumentHighlight = exports.DocumentHighlight = exports.InlineValueContext = exports.InlineValue = exports.EvaluatableExpression = exports.Hover = exports.DefinitionLink = exports.location = exports.CallHierarchyOutgoingCall = exports.CallHierarchyIncomingCall = exports.CallHierarchyItem = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolTag = exports.SymbolKind = exports.WorkspaceEdit = exports.TextEdit = exports.DecorationRenderOptions = exports.DecorationRangeBehavior = exports.ThemableDecorationRenderOptions = exports.ThemableDecorationAttachmentRenderOptions = exports.MarkdownString = exports.ViewColumn = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.Diagnostic = exports.DiagnosticTag = exports.DocumentSelector = exports.Position = exports.TokenType = exports.Location = exports.Range = exports.Selection = void 0;
    exports.$hQ = $hQ;
    exports.$iQ = $iQ;
    exports.$jQ = $jQ;
    htmlContent = __importStar(htmlContent);
    editorRange = __importStar(editorRange);
    encodedTokenAttributes = __importStar(encodedTokenAttributes);
    languages = __importStar(languages);
    chatProvider = __importStar(chatProvider);
    notebooks = __importStar(notebooks);
    types = __importStar(types);
    var Selection;
    (function (Selection) {
        function to(selection) {
            const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
            const start = new types.$NN(selectionStartLineNumber - 1, selectionStartColumn - 1);
            const end = new types.$NN(positionLineNumber - 1, positionColumn - 1);
            return new types.$PN(start, end);
        }
        Selection.to = to;
        function from(selection) {
            const { anchor, active } = selection;
            return {
                selectionStartLineNumber: anchor.line + 1,
                selectionStartColumn: anchor.character + 1,
                positionLineNumber: active.line + 1,
                positionColumn: active.character + 1
            };
        }
        Selection.from = from;
    })(Selection || (exports.Selection = Selection = {}));
    var Range;
    (function (Range) {
        function from(range) {
            if (!range) {
                return undefined;
            }
            const { start, end } = range;
            return {
                startLineNumber: start.line + 1,
                startColumn: start.character + 1,
                endLineNumber: end.line + 1,
                endColumn: end.character + 1
            };
        }
        Range.from = from;
        function to(range) {
            if (!range) {
                return undefined;
            }
            const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
            return new types.$ON(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
        }
        Range.to = to;
    })(Range || (exports.Range = Range = {}));
    var Location;
    (function (Location) {
        function from(location) {
            return {
                uri: location.uri,
                range: Range.from(location.range)
            };
        }
        Location.from = from;
        function to(location) {
            return new types.$1N(uri_1.URI.revive(location.uri), Range.to(location.range));
        }
        Location.to = to;
    })(Location || (exports.Location = Location = {}));
    var TokenType;
    (function (TokenType) {
        function to(type) {
            switch (type) {
                case encodedTokenAttributes.StandardTokenType.Comment: return types.StandardTokenType.Comment;
                case encodedTokenAttributes.StandardTokenType.Other: return types.StandardTokenType.Other;
                case encodedTokenAttributes.StandardTokenType.RegEx: return types.StandardTokenType.RegEx;
                case encodedTokenAttributes.StandardTokenType.String: return types.StandardTokenType.String;
            }
        }
        TokenType.to = to;
    })(TokenType || (exports.TokenType = TokenType = {}));
    var Position;
    (function (Position) {
        function to(position) {
            return new types.$NN(position.lineNumber - 1, position.column - 1);
        }
        Position.to = to;
        function from(position) {
            return { lineNumber: position.line + 1, column: position.character + 1 };
        }
        Position.from = from;
    })(Position || (exports.Position = Position = {}));
    var DocumentSelector;
    (function (DocumentSelector) {
        function from(value, uriTransformer, extension) {
            return (0, arrays_1.$Gb)((0, arrays_1.$1b)(value).map(sel => _doTransformDocumentSelector(sel, uriTransformer, extension)));
        }
        DocumentSelector.from = from;
        function _doTransformDocumentSelector(selector, uriTransformer, extension) {
            if (typeof selector === 'string') {
                return {
                    $serialized: true,
                    language: selector,
                    isBuiltin: extension?.isBuiltin,
                };
            }
            if (selector) {
                return {
                    $serialized: true,
                    language: selector.language,
                    scheme: _transformScheme(selector.scheme, uriTransformer),
                    pattern: GlobPattern.from(selector.pattern) ?? undefined,
                    exclusive: selector.exclusive,
                    notebookType: selector.notebookType,
                    isBuiltin: extension?.isBuiltin
                };
            }
            return undefined;
        }
        function _transformScheme(scheme, uriTransformer) {
            if (uriTransformer && typeof scheme === 'string') {
                return uriTransformer.transformOutgoingScheme(scheme);
            }
            return scheme;
        }
    })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
    var DiagnosticTag;
    (function (DiagnosticTag) {
        function from(value) {
            switch (value) {
                case types.DiagnosticTag.Unnecessary:
                    return markers_1.MarkerTag.Unnecessary;
                case types.DiagnosticTag.Deprecated:
                    return markers_1.MarkerTag.Deprecated;
            }
            return undefined;
        }
        DiagnosticTag.from = from;
        function to(value) {
            switch (value) {
                case markers_1.MarkerTag.Unnecessary:
                    return types.DiagnosticTag.Unnecessary;
                case markers_1.MarkerTag.Deprecated:
                    return types.DiagnosticTag.Deprecated;
                default:
                    return undefined;
            }
        }
        DiagnosticTag.to = to;
    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
    var Diagnostic;
    (function (Diagnostic) {
        function from(value) {
            let code;
            if (value.code) {
                if ((0, types_1.$eg)(value.code) || (0, types_1.$ig)(value.code)) {
                    code = String(value.code);
                }
                else {
                    code = {
                        value: String(value.code.value),
                        target: value.code.target,
                    };
                }
            }
            return {
                ...Range.from(value.range),
                message: value.message,
                source: value.source,
                code,
                severity: DiagnosticSeverity.from(value.severity),
                relatedInformation: value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation.from),
                tags: Array.isArray(value.tags) ? (0, arrays_1.$Gb)(value.tags.map(DiagnosticTag.from)) : undefined,
            };
        }
        Diagnostic.from = from;
        function to(value) {
            const res = new types.$3N(Range.to(value), value.message, DiagnosticSeverity.to(value.severity));
            res.source = value.source;
            res.code = (0, types_1.$eg)(value.code) ? value.code : value.code?.value;
            res.relatedInformation = value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation.to);
            res.tags = value.tags && (0, arrays_1.$Gb)(value.tags.map(DiagnosticTag.to));
            return res;
        }
        Diagnostic.to = to;
    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));
    var DiagnosticRelatedInformation;
    (function (DiagnosticRelatedInformation) {
        function from(value) {
            return {
                ...Range.from(value.location.range),
                message: value.message,
                resource: value.location.uri
            };
        }
        DiagnosticRelatedInformation.from = from;
        function to(value) {
            return new types.$2N(new types.$1N(value.resource, Range.to(value)), value.message);
        }
        DiagnosticRelatedInformation.to = to;
    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        function from(value) {
            switch (value) {
                case types.DiagnosticSeverity.Error:
                    return markers_1.MarkerSeverity.Error;
                case types.DiagnosticSeverity.Warning:
                    return markers_1.MarkerSeverity.Warning;
                case types.DiagnosticSeverity.Information:
                    return markers_1.MarkerSeverity.Info;
                case types.DiagnosticSeverity.Hint:
                    return markers_1.MarkerSeverity.Hint;
            }
            return markers_1.MarkerSeverity.Error;
        }
        DiagnosticSeverity.from = from;
        function to(value) {
            switch (value) {
                case markers_1.MarkerSeverity.Info:
                    return types.DiagnosticSeverity.Information;
                case markers_1.MarkerSeverity.Warning:
                    return types.DiagnosticSeverity.Warning;
                case markers_1.MarkerSeverity.Error:
                    return types.DiagnosticSeverity.Error;
                case markers_1.MarkerSeverity.Hint:
                    return types.DiagnosticSeverity.Hint;
                default:
                    return types.DiagnosticSeverity.Error;
            }
        }
        DiagnosticSeverity.to = to;
    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
    var ViewColumn;
    (function (ViewColumn) {
        function from(column) {
            if (typeof column === 'number' && column >= types.ViewColumn.One) {
                return column - 1; // adjust zero index (ViewColumn.ONE => 0)
            }
            if (column === types.ViewColumn.Beside) {
                return editorService_1.$zE;
            }
            return editorService_1.$yE; // default is always the active group
        }
        ViewColumn.from = from;
        function to(position) {
            if (typeof position === 'number' && position >= 0) {
                return position + 1; // adjust to index (ViewColumn.ONE => 1)
            }
            throw new Error(`invalid 'EditorGroupColumn'`);
        }
        ViewColumn.to = to;
    })(ViewColumn || (exports.ViewColumn = ViewColumn = {}));
    function isDecorationOptions(something) {
        return (typeof something.range !== 'undefined');
    }
    function $hQ(something) {
        if (something.length === 0) {
            return true;
        }
        return isDecorationOptions(something[0]) ? true : false;
    }
    var MarkdownString;
    (function (MarkdownString) {
        function fromMany(markup) {
            return markup.map(MarkdownString.from);
        }
        MarkdownString.fromMany = fromMany;
        function isCodeblock(thing) {
            return thing && typeof thing === 'object'
                && typeof thing.language === 'string'
                && typeof thing.value === 'string';
        }
        function from(markup) {
            let res;
            if (isCodeblock(markup)) {
                const { language, value } = markup;
                res = { value: '```' + language + '\n' + value + '\n```\n' };
            }
            else if (types.$eO.isMarkdownString(markup)) {
                res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, baseUri: markup.baseUri };
            }
            else if (typeof markup === 'string') {
                res = { value: markup };
            }
            else {
                res = { value: '' };
            }
            // extract uris into a separate object
            const resUris = Object.create(null);
            res.uris = resUris;
            const collectUri = (href) => {
                try {
                    let uri = uri_1.URI.parse(href, true);
                    uri = uri.with({ query: _uriMassage(uri.query, resUris) });
                    resUris[href] = uri;
                }
                catch (e) {
                    // ignore
                }
                return '';
            };
            const renderer = new marked_1.marked.Renderer();
            renderer.link = collectUri;
            renderer.image = href => typeof href === 'string' ? collectUri(htmlContent.$_k(href).href) : '';
            (0, marked_1.marked)(res.value, { renderer });
            return res;
        }
        MarkdownString.from = from;
        function _uriMassage(part, bucket) {
            if (!part) {
                return part;
            }
            let data;
            try {
                data = (0, marshalling_1.$bi)(part);
            }
            catch (e) {
                // ignore
            }
            if (!data) {
                return part;
            }
            let changed = false;
            data = (0, objects_1.$go)(data, value => {
                if (uri_1.URI.isUri(value)) {
                    const key = `__uri_${Math.random().toString(16).slice(2, 8)}`;
                    bucket[key] = value;
                    changed = true;
                    return key;
                }
                else {
                    return undefined;
                }
            });
            if (!changed) {
                return part;
            }
            return JSON.stringify(data);
        }
        function to(value) {
            const result = new types.$eO(value.value, value.supportThemeIcons);
            result.isTrusted = value.isTrusted;
            result.supportHtml = value.supportHtml;
            result.baseUri = value.baseUri ? uri_1.URI.from(value.baseUri) : undefined;
            return result;
        }
        MarkdownString.to = to;
        function fromStrict(value) {
            if (!value) {
                return undefined;
            }
            return typeof value === 'string' ? value : MarkdownString.from(value);
        }
        MarkdownString.fromStrict = fromStrict;
    })(MarkdownString || (exports.MarkdownString = MarkdownString = {}));
    function $iQ(ranges) {
        if ($hQ(ranges)) {
            return ranges.map((r) => {
                return {
                    range: Range.from(r.range),
                    hoverMessage: Array.isArray(r.hoverMessage)
                        ? MarkdownString.fromMany(r.hoverMessage)
                        : (r.hoverMessage ? MarkdownString.from(r.hoverMessage) : undefined),
                    renderOptions: /* URI vs Uri */ r.renderOptions
                };
            });
        }
        else {
            return ranges.map((r) => {
                return {
                    range: Range.from(r)
                };
            });
        }
    }
    function $jQ(value) {
        if (typeof value === 'undefined') {
            return value;
        }
        if (typeof value === 'string') {
            return uri_1.URI.file(value);
        }
        else {
            return value;
        }
    }
    var ThemableDecorationAttachmentRenderOptions;
    (function (ThemableDecorationAttachmentRenderOptions) {
        function from(options) {
            if (typeof options === 'undefined') {
                return options;
            }
            return {
                contentText: options.contentText,
                contentIconPath: options.contentIconPath ? $jQ(options.contentIconPath) : undefined,
                border: options.border,
                borderColor: options.borderColor,
                fontStyle: options.fontStyle,
                fontWeight: options.fontWeight,
                textDecoration: options.textDecoration,
                color: options.color,
                backgroundColor: options.backgroundColor,
                margin: options.margin,
                width: options.width,
                height: options.height,
            };
        }
        ThemableDecorationAttachmentRenderOptions.from = from;
    })(ThemableDecorationAttachmentRenderOptions || (exports.ThemableDecorationAttachmentRenderOptions = ThemableDecorationAttachmentRenderOptions = {}));
    var ThemableDecorationRenderOptions;
    (function (ThemableDecorationRenderOptions) {
        function from(options) {
            if (typeof options === 'undefined') {
                return options;
            }
            return {
                backgroundColor: options.backgroundColor,
                outline: options.outline,
                outlineColor: options.outlineColor,
                outlineStyle: options.outlineStyle,
                outlineWidth: options.outlineWidth,
                border: options.border,
                borderColor: options.borderColor,
                borderRadius: options.borderRadius,
                borderSpacing: options.borderSpacing,
                borderStyle: options.borderStyle,
                borderWidth: options.borderWidth,
                fontStyle: options.fontStyle,
                fontWeight: options.fontWeight,
                textDecoration: options.textDecoration,
                cursor: options.cursor,
                color: options.color,
                opacity: options.opacity,
                letterSpacing: options.letterSpacing,
                gutterIconPath: options.gutterIconPath ? $jQ(options.gutterIconPath) : undefined,
                gutterIconSize: options.gutterIconSize,
                overviewRulerColor: options.overviewRulerColor,
                before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
                after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
            };
        }
        ThemableDecorationRenderOptions.from = from;
    })(ThemableDecorationRenderOptions || (exports.ThemableDecorationRenderOptions = ThemableDecorationRenderOptions = {}));
    var DecorationRangeBehavior;
    (function (DecorationRangeBehavior) {
        function from(value) {
            if (typeof value === 'undefined') {
                return value;
            }
            switch (value) {
                case types.DecorationRangeBehavior.OpenOpen:
                    return model_1.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
                case types.DecorationRangeBehavior.ClosedClosed:
                    return model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
                case types.DecorationRangeBehavior.OpenClosed:
                    return model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore;
                case types.DecorationRangeBehavior.ClosedOpen:
                    return model_1.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
            }
        }
        DecorationRangeBehavior.from = from;
    })(DecorationRangeBehavior || (exports.DecorationRangeBehavior = DecorationRangeBehavior = {}));
    var DecorationRenderOptions;
    (function (DecorationRenderOptions) {
        function from(options) {
            return {
                isWholeLine: options.isWholeLine,
                rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior.from(options.rangeBehavior) : undefined,
                overviewRulerLane: options.overviewRulerLane,
                light: options.light ? ThemableDecorationRenderOptions.from(options.light) : undefined,
                dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : undefined,
                backgroundColor: options.backgroundColor,
                outline: options.outline,
                outlineColor: options.outlineColor,
                outlineStyle: options.outlineStyle,
                outlineWidth: options.outlineWidth,
                border: options.border,
                borderColor: options.borderColor,
                borderRadius: options.borderRadius,
                borderSpacing: options.borderSpacing,
                borderStyle: options.borderStyle,
                borderWidth: options.borderWidth,
                fontStyle: options.fontStyle,
                fontWeight: options.fontWeight,
                textDecoration: options.textDecoration,
                cursor: options.cursor,
                color: options.color,
                opacity: options.opacity,
                letterSpacing: options.letterSpacing,
                gutterIconPath: options.gutterIconPath ? $jQ(options.gutterIconPath) : undefined,
                gutterIconSize: options.gutterIconSize,
                overviewRulerColor: options.overviewRulerColor,
                before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
                after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
            };
        }
        DecorationRenderOptions.from = from;
    })(DecorationRenderOptions || (exports.DecorationRenderOptions = DecorationRenderOptions = {}));
    var TextEdit;
    (function (TextEdit) {
        function from(edit) {
            return {
                text: edit.newText,
                eol: edit.newEol && EndOfLine.from(edit.newEol),
                range: Range.from(edit.range)
            };
        }
        TextEdit.from = from;
        function to(edit) {
            const result = new types.$VN(Range.to(edit.range), edit.text);
            result.newEol = (typeof edit.eol === 'undefined' ? undefined : EndOfLine.to(edit.eol));
            return result;
        }
        TextEdit.to = to;
    })(TextEdit || (exports.TextEdit = TextEdit = {}));
    var WorkspaceEdit;
    (function (WorkspaceEdit) {
        function from(value, versionInfo) {
            const result = {
                edits: []
            };
            if (value instanceof types.$YN) {
                // collect all files that are to be created so that their version
                // information (in case they exist as text model already) can be ignored
                const toCreate = new map_1.$Bc();
                for (const entry of value._allEntries()) {
                    if (entry._type === types.FileEditType.File && uri_1.URI.isUri(entry.to) && entry.from === undefined) {
                        toCreate.add(entry.to);
                    }
                }
                for (const entry of value._allEntries()) {
                    if (entry._type === types.FileEditType.File) {
                        let contents;
                        if (entry.options?.contents) {
                            if (ArrayBuffer.isView(entry.options.contents)) {
                                contents = { type: 'base64', value: (0, buffer_1.$8e)(buffer_1.$Ne.wrap(entry.options.contents)) };
                            }
                            else {
                                contents = { type: 'dataTransferItem', id: entry.options.contents._itemId };
                            }
                        }
                        // file operation
                        result.edits.push({
                            oldResource: entry.from,
                            newResource: entry.to,
                            options: { ...entry.options, contents },
                            metadata: entry.metadata
                        });
                    }
                    else if (entry._type === types.FileEditType.Text) {
                        // text edits
                        result.edits.push({
                            resource: entry.uri,
                            textEdit: TextEdit.from(entry.edit),
                            versionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                            metadata: entry.metadata
                        });
                    }
                    else if (entry._type === types.FileEditType.Snippet) {
                        result.edits.push({
                            resource: entry.uri,
                            textEdit: {
                                range: Range.from(entry.range),
                                text: entry.edit.value,
                                insertAsSnippet: true
                            },
                            versionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                            metadata: entry.metadata
                        });
                    }
                    else if (entry._type === types.FileEditType.Cell) {
                        // cell edit
                        result.edits.push({
                            metadata: entry.metadata,
                            resource: entry.uri,
                            cellEdit: entry.edit,
                            notebookMetadata: entry.notebookMetadata,
                            notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri)
                        });
                    }
                    else if (entry._type === types.FileEditType.CellReplace) {
                        // cell replace
                        result.edits.push({
                            metadata: entry.metadata,
                            resource: entry.uri,
                            notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri),
                            cellEdit: {
                                editType: notebooks.CellEditType.Replace,
                                index: entry.index,
                                count: entry.count,
                                cells: entry.cells.map(NotebookCellData.from)
                            }
                        });
                    }
                }
            }
            return result;
        }
        WorkspaceEdit.from = from;
        function to(value) {
            const result = new types.$YN();
            const edits = new map_1.$Ac();
            for (const edit of value.edits) {
                if (edit.textEdit) {
                    const item = edit;
                    const uri = uri_1.URI.revive(item.resource);
                    const range = Range.to(item.textEdit.range);
                    const text = item.textEdit.text;
                    const isSnippet = item.textEdit.insertAsSnippet;
                    let editOrSnippetTest;
                    if (isSnippet) {
                        editOrSnippetTest = types.$XN.replace(range, new types.$ZN(text));
                    }
                    else {
                        editOrSnippetTest = types.$VN.replace(range, text);
                    }
                    const array = edits.get(uri);
                    if (!array) {
                        edits.set(uri, [editOrSnippetTest]);
                    }
                    else {
                        array.push(editOrSnippetTest);
                    }
                }
                else {
                    result.renameFile(uri_1.URI.revive(edit.oldResource), uri_1.URI.revive(edit.newResource), edit.options);
                }
            }
            for (const [uri, array] of edits) {
                result.set(uri, array);
            }
            return result;
        }
        WorkspaceEdit.to = to;
    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));
    var SymbolKind;
    (function (SymbolKind) {
        const _fromMapping = Object.create(null);
        _fromMapping[types.SymbolKind.File] = languages.SymbolKind.File;
        _fromMapping[types.SymbolKind.Module] = languages.SymbolKind.Module;
        _fromMapping[types.SymbolKind.Namespace] = languages.SymbolKind.Namespace;
        _fromMapping[types.SymbolKind.Package] = languages.SymbolKind.Package;
        _fromMapping[types.SymbolKind.Class] = languages.SymbolKind.Class;
        _fromMapping[types.SymbolKind.Method] = languages.SymbolKind.Method;
        _fromMapping[types.SymbolKind.Property] = languages.SymbolKind.Property;
        _fromMapping[types.SymbolKind.Field] = languages.SymbolKind.Field;
        _fromMapping[types.SymbolKind.Constructor] = languages.SymbolKind.Constructor;
        _fromMapping[types.SymbolKind.Enum] = languages.SymbolKind.Enum;
        _fromMapping[types.SymbolKind.Interface] = languages.SymbolKind.Interface;
        _fromMapping[types.SymbolKind.Function] = languages.SymbolKind.Function;
        _fromMapping[types.SymbolKind.Variable] = languages.SymbolKind.Variable;
        _fromMapping[types.SymbolKind.Constant] = languages.SymbolKind.Constant;
        _fromMapping[types.SymbolKind.String] = languages.SymbolKind.String;
        _fromMapping[types.SymbolKind.Number] = languages.SymbolKind.Number;
        _fromMapping[types.SymbolKind.Boolean] = languages.SymbolKind.Boolean;
        _fromMapping[types.SymbolKind.Array] = languages.SymbolKind.Array;
        _fromMapping[types.SymbolKind.Object] = languages.SymbolKind.Object;
        _fromMapping[types.SymbolKind.Key] = languages.SymbolKind.Key;
        _fromMapping[types.SymbolKind.Null] = languages.SymbolKind.Null;
        _fromMapping[types.SymbolKind.EnumMember] = languages.SymbolKind.EnumMember;
        _fromMapping[types.SymbolKind.Struct] = languages.SymbolKind.Struct;
        _fromMapping[types.SymbolKind.Event] = languages.SymbolKind.Event;
        _fromMapping[types.SymbolKind.Operator] = languages.SymbolKind.Operator;
        _fromMapping[types.SymbolKind.TypeParameter] = languages.SymbolKind.TypeParameter;
        function from(kind) {
            return typeof _fromMapping[kind] === 'number' ? _fromMapping[kind] : languages.SymbolKind.Property;
        }
        SymbolKind.from = from;
        function to(kind) {
            for (const k in _fromMapping) {
                if (_fromMapping[k] === kind) {
                    return Number(k);
                }
            }
            return types.SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
    var SymbolTag;
    (function (SymbolTag) {
        function from(kind) {
            switch (kind) {
                case types.SymbolTag.Deprecated: return languages.SymbolTag.Deprecated;
            }
        }
        SymbolTag.from = from;
        function to(kind) {
            switch (kind) {
                case languages.SymbolTag.Deprecated: return types.SymbolTag.Deprecated;
            }
        }
        SymbolTag.to = to;
    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
    var WorkspaceSymbol;
    (function (WorkspaceSymbol) {
        function from(info) {
            return {
                name: info.name,
                kind: SymbolKind.from(info.kind),
                tags: info.tags && info.tags.map(SymbolTag.from),
                containerName: info.containerName,
                location: location.from(info.location)
            };
        }
        WorkspaceSymbol.from = from;
        function to(info) {
            const result = new types.$8N(info.name, SymbolKind.to(info.kind), info.containerName, location.to(info.location));
            result.tags = info.tags && info.tags.map(SymbolTag.to);
            return result;
        }
        WorkspaceSymbol.to = to;
    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));
    var DocumentSymbol;
    (function (DocumentSymbol) {
        function from(info) {
            const result = {
                name: info.name || '!!MISSING: name!!',
                detail: info.detail,
                range: Range.from(info.range),
                selectionRange: Range.from(info.selectionRange),
                kind: SymbolKind.from(info.kind),
                tags: info.tags?.map(SymbolTag.from) ?? []
            };
            if (info.children) {
                result.children = info.children.map(from);
            }
            return result;
        }
        DocumentSymbol.from = from;
        function to(info) {
            const result = new types.$9N(info.name, info.detail, SymbolKind.to(info.kind), Range.to(info.range), Range.to(info.selectionRange));
            if ((0, arrays_1.$Kb)(info.tags)) {
                result.tags = info.tags.map(SymbolTag.to);
            }
            if (info.children) {
                result.children = info.children.map(to);
            }
            return result;
        }
        DocumentSymbol.to = to;
    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));
    var CallHierarchyItem;
    (function (CallHierarchyItem) {
        function to(item) {
            const result = new types.$aO(SymbolKind.to(item.kind), item.name, item.detail || '', uri_1.URI.revive(item.uri), Range.to(item.range), Range.to(item.selectionRange));
            result._sessionId = item._sessionId;
            result._itemId = item._itemId;
            return result;
        }
        CallHierarchyItem.to = to;
        function from(item, sessionId, itemId) {
            sessionId = sessionId ?? item._sessionId;
            itemId = itemId ?? item._itemId;
            if (sessionId === undefined || itemId === undefined) {
                throw new Error('invalid item');
            }
            return {
                _sessionId: sessionId,
                _itemId: itemId,
                name: item.name,
                detail: item.detail,
                kind: SymbolKind.from(item.kind),
                uri: item.uri,
                range: Range.from(item.range),
                selectionRange: Range.from(item.selectionRange),
                tags: item.tags?.map(SymbolTag.from)
            };
        }
        CallHierarchyItem.from = from;
    })(CallHierarchyItem || (exports.CallHierarchyItem = CallHierarchyItem = {}));
    var CallHierarchyIncomingCall;
    (function (CallHierarchyIncomingCall) {
        function to(item) {
            return new types.$bO(CallHierarchyItem.to(item.from), item.fromRanges.map(r => Range.to(r)));
        }
        CallHierarchyIncomingCall.to = to;
    })(CallHierarchyIncomingCall || (exports.CallHierarchyIncomingCall = CallHierarchyIncomingCall = {}));
    var CallHierarchyOutgoingCall;
    (function (CallHierarchyOutgoingCall) {
        function to(item) {
            return new types.$cO(CallHierarchyItem.to(item.to), item.fromRanges.map(r => Range.to(r)));
        }
        CallHierarchyOutgoingCall.to = to;
    })(CallHierarchyOutgoingCall || (exports.CallHierarchyOutgoingCall = CallHierarchyOutgoingCall = {}));
    var location;
    (function (location) {
        function from(value) {
            return {
                range: value.range && Range.from(value.range),
                uri: value.uri
            };
        }
        location.from = from;
        function to(value) {
            return new types.$1N(uri_1.URI.revive(value.uri), Range.to(value.range));
        }
        location.to = to;
    })(location || (exports.location = location = {}));
    var DefinitionLink;
    (function (DefinitionLink) {
        function from(value) {
            const definitionLink = value;
            const location = value;
            return {
                originSelectionRange: definitionLink.originSelectionRange
                    ? Range.from(definitionLink.originSelectionRange)
                    : undefined,
                uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,
                range: Range.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),
                targetSelectionRange: definitionLink.targetSelectionRange
                    ? Range.from(definitionLink.targetSelectionRange)
                    : undefined,
            };
        }
        DefinitionLink.from = from;
        function to(value) {
            return {
                targetUri: uri_1.URI.revive(value.uri),
                targetRange: Range.to(value.range),
                targetSelectionRange: value.targetSelectionRange
                    ? Range.to(value.targetSelectionRange)
                    : undefined,
                originSelectionRange: value.originSelectionRange
                    ? Range.to(value.originSelectionRange)
                    : undefined
            };
        }
        DefinitionLink.to = to;
    })(DefinitionLink || (exports.DefinitionLink = DefinitionLink = {}));
    var Hover;
    (function (Hover) {
        function from(hover) {
            const convertedHover = {
                range: Range.from(hover.range),
                contents: MarkdownString.fromMany(hover.contents),
                canIncreaseVerbosity: hover.canIncreaseVerbosity,
                canDecreaseVerbosity: hover.canDecreaseVerbosity,
            };
            return convertedHover;
        }
        Hover.from = from;
        function to(info) {
            const contents = info.contents.map(MarkdownString.to);
            const range = Range.to(info.range);
            const canIncreaseVerbosity = info.canIncreaseVerbosity;
            const canDecreaseVerbosity = info.canDecreaseVerbosity;
            return new types.$5N(contents, range, canIncreaseVerbosity, canDecreaseVerbosity);
        }
        Hover.to = to;
    })(Hover || (exports.Hover = Hover = {}));
    var EvaluatableExpression;
    (function (EvaluatableExpression) {
        function from(expression) {
            return {
                range: Range.from(expression.range),
                expression: expression.expression
            };
        }
        EvaluatableExpression.from = from;
        function to(info) {
            return new types.$ZO(Range.to(info.range), info.expression);
        }
        EvaluatableExpression.to = to;
    })(EvaluatableExpression || (exports.EvaluatableExpression = EvaluatableExpression = {}));
    var InlineValue;
    (function (InlineValue) {
        function from(inlineValue) {
            if (inlineValue instanceof types.$1O) {
                return {
                    type: 'text',
                    range: Range.from(inlineValue.range),
                    text: inlineValue.text
                };
            }
            else if (inlineValue instanceof types.$2O) {
                return {
                    type: 'variable',
                    range: Range.from(inlineValue.range),
                    variableName: inlineValue.variableName,
                    caseSensitiveLookup: inlineValue.caseSensitiveLookup
                };
            }
            else if (inlineValue instanceof types.$3O) {
                return {
                    type: 'expression',
                    range: Range.from(inlineValue.range),
                    expression: inlineValue.expression
                };
            }
            else {
                throw new Error(`Unknown 'InlineValue' type`);
            }
        }
        InlineValue.from = from;
        function to(inlineValue) {
            switch (inlineValue.type) {
                case 'text':
                    return {
                        range: Range.to(inlineValue.range),
                        text: inlineValue.text
                    };
                case 'variable':
                    return {
                        range: Range.to(inlineValue.range),
                        variableName: inlineValue.variableName,
                        caseSensitiveLookup: inlineValue.caseSensitiveLookup
                    };
                case 'expression':
                    return {
                        range: Range.to(inlineValue.range),
                        expression: inlineValue.expression
                    };
            }
        }
        InlineValue.to = to;
    })(InlineValue || (exports.InlineValue = InlineValue = {}));
    var InlineValueContext;
    (function (InlineValueContext) {
        function from(inlineValueContext) {
            return {
                frameId: inlineValueContext.frameId,
                stoppedLocation: Range.from(inlineValueContext.stoppedLocation)
            };
        }
        InlineValueContext.from = from;
        function to(inlineValueContext) {
            return new types.$4O(inlineValueContext.frameId, Range.to(inlineValueContext.stoppedLocation));
        }
        InlineValueContext.to = to;
    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));
    var DocumentHighlight;
    (function (DocumentHighlight) {
        function from(documentHighlight) {
            return {
                range: Range.from(documentHighlight.range),
                kind: documentHighlight.kind
            };
        }
        DocumentHighlight.from = from;
        function to(occurrence) {
            return new types.$6N(Range.to(occurrence.range), occurrence.kind);
        }
        DocumentHighlight.to = to;
    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));
    var MultiDocumentHighlight;
    (function (MultiDocumentHighlight) {
        function from(multiDocumentHighlight) {
            return {
                uri: multiDocumentHighlight.uri,
                highlights: multiDocumentHighlight.highlights.map(DocumentHighlight.from)
            };
        }
        MultiDocumentHighlight.from = from;
        function to(multiDocumentHighlight) {
            return new types.$7N(uri_1.URI.revive(multiDocumentHighlight.uri), multiDocumentHighlight.highlights.map(DocumentHighlight.to));
        }
        MultiDocumentHighlight.to = to;
    })(MultiDocumentHighlight || (exports.MultiDocumentHighlight = MultiDocumentHighlight = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        function to(kind) {
            switch (kind) {
                case languages.CompletionTriggerKind.TriggerCharacter:
                    return types.CompletionTriggerKind.TriggerCharacter;
                case languages.CompletionTriggerKind.TriggerForIncompleteCompletions:
                    return types.CompletionTriggerKind.TriggerForIncompleteCompletions;
                case languages.CompletionTriggerKind.Invoke:
                default:
                    return types.CompletionTriggerKind.Invoke;
            }
        }
        CompletionTriggerKind.to = to;
    })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionContext;
    (function (CompletionContext) {
        function to(context) {
            return {
                triggerKind: CompletionTriggerKind.to(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            };
        }
        CompletionContext.to = to;
    })(CompletionContext || (exports.CompletionContext = CompletionContext = {}));
    var CompletionItemTag;
    (function (CompletionItemTag) {
        function from(kind) {
            switch (kind) {
                case types.CompletionItemTag.Deprecated: return languages.CompletionItemTag.Deprecated;
            }
        }
        CompletionItemTag.from = from;
        function to(kind) {
            switch (kind) {
                case languages.CompletionItemTag.Deprecated: return types.CompletionItemTag.Deprecated;
            }
        }
        CompletionItemTag.to = to;
    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));
    var CompletionItemKind;
    (function (CompletionItemKind) {
        const _from = new Map([
            [types.CompletionItemKind.Method, languages.CompletionItemKind.Method],
            [types.CompletionItemKind.Function, languages.CompletionItemKind.Function],
            [types.CompletionItemKind.Constructor, languages.CompletionItemKind.Constructor],
            [types.CompletionItemKind.Field, languages.CompletionItemKind.Field],
            [types.CompletionItemKind.Variable, languages.CompletionItemKind.Variable],
            [types.CompletionItemKind.Class, languages.CompletionItemKind.Class],
            [types.CompletionItemKind.Interface, languages.CompletionItemKind.Interface],
            [types.CompletionItemKind.Struct, languages.CompletionItemKind.Struct],
            [types.CompletionItemKind.Module, languages.CompletionItemKind.Module],
            [types.CompletionItemKind.Property, languages.CompletionItemKind.Property],
            [types.CompletionItemKind.Unit, languages.CompletionItemKind.Unit],
            [types.CompletionItemKind.Value, languages.CompletionItemKind.Value],
            [types.CompletionItemKind.Constant, languages.CompletionItemKind.Constant],
            [types.CompletionItemKind.Enum, languages.CompletionItemKind.Enum],
            [types.CompletionItemKind.EnumMember, languages.CompletionItemKind.EnumMember],
            [types.CompletionItemKind.Keyword, languages.CompletionItemKind.Keyword],
            [types.CompletionItemKind.Snippet, languages.CompletionItemKind.Snippet],
            [types.CompletionItemKind.Text, languages.CompletionItemKind.Text],
            [types.CompletionItemKind.Color, languages.CompletionItemKind.Color],
            [types.CompletionItemKind.File, languages.CompletionItemKind.File],
            [types.CompletionItemKind.Reference, languages.CompletionItemKind.Reference],
            [types.CompletionItemKind.Folder, languages.CompletionItemKind.Folder],
            [types.CompletionItemKind.Event, languages.CompletionItemKind.Event],
            [types.CompletionItemKind.Operator, languages.CompletionItemKind.Operator],
            [types.CompletionItemKind.TypeParameter, languages.CompletionItemKind.TypeParameter],
            [types.CompletionItemKind.Issue, languages.CompletionItemKind.Issue],
            [types.CompletionItemKind.User, languages.CompletionItemKind.User],
        ]);
        function from(kind) {
            return _from.get(kind) ?? languages.CompletionItemKind.Property;
        }
        CompletionItemKind.from = from;
        const _to = new Map([
            [languages.CompletionItemKind.Method, types.CompletionItemKind.Method],
            [languages.CompletionItemKind.Function, types.CompletionItemKind.Function],
            [languages.CompletionItemKind.Constructor, types.CompletionItemKind.Constructor],
            [languages.CompletionItemKind.Field, types.CompletionItemKind.Field],
            [languages.CompletionItemKind.Variable, types.CompletionItemKind.Variable],
            [languages.CompletionItemKind.Class, types.CompletionItemKind.Class],
            [languages.CompletionItemKind.Interface, types.CompletionItemKind.Interface],
            [languages.CompletionItemKind.Struct, types.CompletionItemKind.Struct],
            [languages.CompletionItemKind.Module, types.CompletionItemKind.Module],
            [languages.CompletionItemKind.Property, types.CompletionItemKind.Property],
            [languages.CompletionItemKind.Unit, types.CompletionItemKind.Unit],
            [languages.CompletionItemKind.Value, types.CompletionItemKind.Value],
            [languages.CompletionItemKind.Constant, types.CompletionItemKind.Constant],
            [languages.CompletionItemKind.Enum, types.CompletionItemKind.Enum],
            [languages.CompletionItemKind.EnumMember, types.CompletionItemKind.EnumMember],
            [languages.CompletionItemKind.Keyword, types.CompletionItemKind.Keyword],
            [languages.CompletionItemKind.Snippet, types.CompletionItemKind.Snippet],
            [languages.CompletionItemKind.Text, types.CompletionItemKind.Text],
            [languages.CompletionItemKind.Color, types.CompletionItemKind.Color],
            [languages.CompletionItemKind.File, types.CompletionItemKind.File],
            [languages.CompletionItemKind.Reference, types.CompletionItemKind.Reference],
            [languages.CompletionItemKind.Folder, types.CompletionItemKind.Folder],
            [languages.CompletionItemKind.Event, types.CompletionItemKind.Event],
            [languages.CompletionItemKind.Operator, types.CompletionItemKind.Operator],
            [languages.CompletionItemKind.TypeParameter, types.CompletionItemKind.TypeParameter],
            [languages.CompletionItemKind.User, types.CompletionItemKind.User],
            [languages.CompletionItemKind.Issue, types.CompletionItemKind.Issue],
        ]);
        function to(kind) {
            return _to.get(kind) ?? types.CompletionItemKind.Property;
        }
        CompletionItemKind.to = to;
    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
    var CompletionItem;
    (function (CompletionItem) {
        function to(suggestion, converter) {
            const result = new types.$kO(suggestion.label);
            result.insertText = suggestion.insertText;
            result.kind = CompletionItemKind.to(suggestion.kind);
            result.tags = suggestion.tags?.map(CompletionItemTag.to);
            result.detail = suggestion.detail;
            result.documentation = htmlContent.$6k(suggestion.documentation) ? MarkdownString.to(suggestion.documentation) : suggestion.documentation;
            result.sortText = suggestion.sortText;
            result.filterText = suggestion.filterText;
            result.preselect = suggestion.preselect;
            result.commitCharacters = suggestion.commitCharacters;
            // range
            if (editorRange.$Ot.isIRange(suggestion.range)) {
                result.range = Range.to(suggestion.range);
            }
            else if (typeof suggestion.range === 'object') {
                result.range = { inserting: Range.to(suggestion.range.insert), replacing: Range.to(suggestion.range.replace) };
            }
            result.keepWhitespace = typeof suggestion.insertTextRules === 'undefined' ? false : Boolean(suggestion.insertTextRules & languages.CompletionItemInsertTextRule.KeepWhitespace);
            // 'insertText'-logic
            if (typeof suggestion.insertTextRules !== 'undefined' && suggestion.insertTextRules & languages.CompletionItemInsertTextRule.InsertAsSnippet) {
                result.insertText = new types.$ZN(suggestion.insertText);
            }
            else {
                result.insertText = suggestion.insertText;
                result.textEdit = result.range instanceof types.$ON ? new types.$VN(result.range, result.insertText) : undefined;
            }
            if (suggestion.additionalTextEdits && suggestion.additionalTextEdits.length > 0) {
                result.additionalTextEdits = suggestion.additionalTextEdits.map(e => TextEdit.to(e));
            }
            result.command = converter && suggestion.command ? converter.fromInternal(suggestion.command) : undefined;
            return result;
        }
        CompletionItem.to = to;
    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));
    var ParameterInformation;
    (function (ParameterInformation) {
        function from(info) {
            if (typeof info.label !== 'string' && !Array.isArray(info.label)) {
                throw new TypeError('Invalid label');
            }
            return {
                label: info.label,
                documentation: MarkdownString.fromStrict(info.documentation)
            };
        }
        ParameterInformation.from = from;
        function to(info) {
            return {
                label: info.label,
                documentation: htmlContent.$6k(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation
            };
        }
        ParameterInformation.to = to;
    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));
    var SignatureInformation;
    (function (SignatureInformation) {
        function from(info) {
            return {
                label: info.label,
                documentation: MarkdownString.fromStrict(info.documentation),
                parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation.from) : [],
                activeParameter: info.activeParameter,
            };
        }
        SignatureInformation.from = from;
        function to(info) {
            return {
                label: info.label,
                documentation: htmlContent.$6k(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation,
                parameters: Array.isArray(info.parameters) ? info.parameters.map(ParameterInformation.to) : [],
                activeParameter: info.activeParameter,
            };
        }
        SignatureInformation.to = to;
    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));
    var SignatureHelp;
    (function (SignatureHelp) {
        function from(help) {
            return {
                activeSignature: help.activeSignature,
                activeParameter: help.activeParameter,
                signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation.from) : [],
            };
        }
        SignatureHelp.from = from;
        function to(help) {
            return {
                activeSignature: help.activeSignature,
                activeParameter: help.activeParameter,
                signatures: Array.isArray(help.signatures) ? help.signatures.map(SignatureInformation.to) : [],
            };
        }
        SignatureHelp.to = to;
    })(SignatureHelp || (exports.SignatureHelp = SignatureHelp = {}));
    var InlayHint;
    (function (InlayHint) {
        function to(converter, hint) {
            const res = new types.$jO(Position.to(hint.position), typeof hint.label === 'string' ? hint.label : hint.label.map(InlayHintLabelPart.to.bind(undefined, converter)), hint.kind && InlayHintKind.to(hint.kind));
            res.textEdits = hint.textEdits && hint.textEdits.map(TextEdit.to);
            res.tooltip = htmlContent.$6k(hint.tooltip) ? MarkdownString.to(hint.tooltip) : hint.tooltip;
            res.paddingLeft = hint.paddingLeft;
            res.paddingRight = hint.paddingRight;
            return res;
        }
        InlayHint.to = to;
    })(InlayHint || (exports.InlayHint = InlayHint = {}));
    var InlayHintLabelPart;
    (function (InlayHintLabelPart) {
        function to(converter, part) {
            const result = new types.$iO(part.label);
            result.tooltip = htmlContent.$6k(part.tooltip)
                ? MarkdownString.to(part.tooltip)
                : part.tooltip;
            if (languages.Command.is(part.command)) {
                result.command = converter.fromInternal(part.command);
            }
            if (part.location) {
                result.location = location.to(part.location);
            }
            return result;
        }
        InlayHintLabelPart.to = to;
    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));
    var InlayHintKind;
    (function (InlayHintKind) {
        function from(kind) {
            return kind;
        }
        InlayHintKind.from = from;
        function to(kind) {
            return kind;
        }
        InlayHintKind.to = to;
    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
    var DocumentLink;
    (function (DocumentLink) {
        function from(link) {
            return {
                range: Range.from(link.range),
                url: link.target,
                tooltip: link.tooltip
            };
        }
        DocumentLink.from = from;
        function to(link) {
            let target = undefined;
            if (link.url) {
                try {
                    target = typeof link.url === 'string' ? uri_1.URI.parse(link.url, true) : uri_1.URI.revive(link.url);
                }
                catch (err) {
                    // ignore
                }
            }
            const result = new types.$pO(Range.to(link.range), target);
            result.tooltip = link.tooltip;
            return result;
        }
        DocumentLink.to = to;
    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));
    var ColorPresentation;
    (function (ColorPresentation) {
        function to(colorPresentation) {
            const cp = new types.$sO(colorPresentation.label);
            if (colorPresentation.textEdit) {
                cp.textEdit = TextEdit.to(colorPresentation.textEdit);
            }
            if (colorPresentation.additionalTextEdits) {
                cp.additionalTextEdits = colorPresentation.additionalTextEdits.map(value => TextEdit.to(value));
            }
            return cp;
        }
        ColorPresentation.to = to;
        function from(colorPresentation) {
            return {
                label: colorPresentation.label,
                textEdit: colorPresentation.textEdit ? TextEdit.from(colorPresentation.textEdit) : undefined,
                additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map(value => TextEdit.from(value)) : undefined
            };
        }
        ColorPresentation.from = from;
    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));
    var Color;
    (function (Color) {
        function to(c) {
            return new types.$qO(c[0], c[1], c[2], c[3]);
        }
        Color.to = to;
        function from(color) {
            return [color.red, color.green, color.blue, color.alpha];
        }
        Color.from = from;
    })(Color || (exports.Color = Color = {}));
    var SelectionRange;
    (function (SelectionRange) {
        function from(obj) {
            return { range: Range.from(obj.range) };
        }
        SelectionRange.from = from;
        function to(obj) {
            return new types.$_N(Range.to(obj.range));
        }
        SelectionRange.to = to;
    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        function to(reason) {
            switch (reason) {
                case editor_1.SaveReason.AUTO:
                    return types.TextDocumentSaveReason.AfterDelay;
                case editor_1.SaveReason.EXPLICIT:
                    return types.TextDocumentSaveReason.Manual;
                case editor_1.SaveReason.FOCUS_CHANGE:
                case editor_1.SaveReason.WINDOW_CHANGE:
                    return types.TextDocumentSaveReason.FocusOut;
            }
        }
        TextDocumentSaveReason.to = to;
    })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var TextEditorLineNumbersStyle;
    (function (TextEditorLineNumbersStyle) {
        function from(style) {
            switch (style) {
                case types.TextEditorLineNumbersStyle.Off:
                    return editorOptions_1.RenderLineNumbersType.Off;
                case types.TextEditorLineNumbersStyle.Relative:
                    return editorOptions_1.RenderLineNumbersType.Relative;
                case types.TextEditorLineNumbersStyle.Interval:
                    return editorOptions_1.RenderLineNumbersType.Interval;
                case types.TextEditorLineNumbersStyle.On:
                default:
                    return editorOptions_1.RenderLineNumbersType.On;
            }
        }
        TextEditorLineNumbersStyle.from = from;
        function to(style) {
            switch (style) {
                case editorOptions_1.RenderLineNumbersType.Off:
                    return types.TextEditorLineNumbersStyle.Off;
                case editorOptions_1.RenderLineNumbersType.Relative:
                    return types.TextEditorLineNumbersStyle.Relative;
                case editorOptions_1.RenderLineNumbersType.Interval:
                    return types.TextEditorLineNumbersStyle.Interval;
                case editorOptions_1.RenderLineNumbersType.On:
                default:
                    return types.TextEditorLineNumbersStyle.On;
            }
        }
        TextEditorLineNumbersStyle.to = to;
    })(TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = TextEditorLineNumbersStyle = {}));
    var EndOfLine;
    (function (EndOfLine) {
        function from(eol) {
            if (eol === types.EndOfLine.CRLF) {
                return model_1.EndOfLineSequence.CRLF;
            }
            else if (eol === types.EndOfLine.LF) {
                return model_1.EndOfLineSequence.LF;
            }
            return undefined;
        }
        EndOfLine.from = from;
        function to(eol) {
            if (eol === model_1.EndOfLineSequence.CRLF) {
                return types.EndOfLine.CRLF;
            }
            else if (eol === model_1.EndOfLineSequence.LF) {
                return types.EndOfLine.LF;
            }
            return undefined;
        }
        EndOfLine.to = to;
    })(EndOfLine || (exports.EndOfLine = EndOfLine = {}));
    var ProgressLocation;
    (function (ProgressLocation) {
        function from(loc) {
            if (typeof loc === 'object') {
                return loc.viewId;
            }
            switch (loc) {
                case types.ProgressLocation.SourceControl: return progress_1.ProgressLocation.Scm;
                case types.ProgressLocation.Window: return progress_1.ProgressLocation.Window;
                case types.ProgressLocation.Notification: return progress_1.ProgressLocation.Notification;
            }
            throw new Error(`Unknown 'ProgressLocation'`);
        }
        ProgressLocation.from = from;
    })(ProgressLocation || (exports.ProgressLocation = ProgressLocation = {}));
    var FoldingRange;
    (function (FoldingRange) {
        function from(r) {
            const range = { start: r.start + 1, end: r.end + 1 };
            if (r.kind) {
                range.kind = FoldingRangeKind.from(r.kind);
            }
            return range;
        }
        FoldingRange.from = from;
        function to(r) {
            const range = { start: r.start - 1, end: r.end - 1 };
            if (r.kind) {
                range.kind = FoldingRangeKind.to(r.kind);
            }
            return range;
        }
        FoldingRange.to = to;
    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        function from(kind) {
            if (kind) {
                switch (kind) {
                    case types.FoldingRangeKind.Comment:
                        return languages.$Pu.Comment;
                    case types.FoldingRangeKind.Imports:
                        return languages.$Pu.Imports;
                    case types.FoldingRangeKind.Region:
                        return languages.$Pu.Region;
                }
            }
            return undefined;
        }
        FoldingRangeKind.from = from;
        function to(kind) {
            if (kind) {
                switch (kind.value) {
                    case languages.$Pu.Comment.value:
                        return types.FoldingRangeKind.Comment;
                    case languages.$Pu.Imports.value:
                        return types.FoldingRangeKind.Imports;
                    case languages.$Pu.Region.value:
                        return types.FoldingRangeKind.Region;
                }
            }
            return undefined;
        }
        FoldingRangeKind.to = to;
    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));
    var TextEditorOpenOptions;
    (function (TextEditorOpenOptions) {
        function from(options) {
            if (options) {
                return {
                    pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,
                    inactive: options.background,
                    preserveFocus: options.preserveFocus,
                    selection: typeof options.selection === 'object' ? Range.from(options.selection) : undefined,
                    override: typeof options.override === 'boolean' ? editor_1.$5F.id : undefined
                };
            }
            return undefined;
        }
        TextEditorOpenOptions.from = from;
    })(TextEditorOpenOptions || (exports.TextEditorOpenOptions = TextEditorOpenOptions = {}));
    var GlobPattern;
    (function (GlobPattern) {
        function from(pattern) {
            if (pattern instanceof types.$NO) {
                return pattern.toJSON();
            }
            if (typeof pattern === 'string') {
                return pattern;
            }
            // This is slightly bogus because we declare this method to accept
            // `vscode.GlobPattern` which can be `vscode.RelativePattern` class,
            // but given we cannot enforce classes from our vscode.d.ts, we have
            // to probe for objects too
            // Refs: https://github.com/microsoft/vscode/issues/140771
            if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {
                return new types.$NO(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();
            }
            return pattern; // preserve `undefined` and `null`
        }
        GlobPattern.from = from;
        function isRelativePatternShape(obj) {
            const rp = obj;
            if (!rp) {
                return false;
            }
            return uri_1.URI.isUri(rp.baseUri) && typeof rp.pattern === 'string';
        }
        function isLegacyRelativePatternShape(obj) {
            // Before 1.64.x, `RelativePattern` did not have any `baseUri: Uri`
            // property. To preserve backwards compatibility with older extensions
            // we allow this old format when creating the `vscode.RelativePattern`.
            const rp = obj;
            if (!rp) {
                return false;
            }
            return typeof rp.base === 'string' && typeof rp.pattern === 'string';
        }
        function to(pattern) {
            if (typeof pattern === 'string') {
                return pattern;
            }
            return new types.$NO(uri_1.URI.revive(pattern.baseUri), pattern.pattern);
        }
        GlobPattern.to = to;
    })(GlobPattern || (exports.GlobPattern = GlobPattern = {}));
    var LanguageSelector;
    (function (LanguageSelector) {
        function from(selector) {
            if (!selector) {
                return undefined;
            }
            else if (Array.isArray(selector)) {
                return selector.map(from);
            }
            else if (typeof selector === 'string') {
                return selector;
            }
            else {
                const filter = selector; // TODO: microsoft/TypeScript#42768
                return {
                    language: filter.language,
                    scheme: filter.scheme,
                    pattern: GlobPattern.from(filter.pattern),
                    exclusive: filter.exclusive,
                    notebookType: filter.notebookType
                };
            }
        }
        LanguageSelector.from = from;
    })(LanguageSelector || (exports.LanguageSelector = LanguageSelector = {}));
    var MappedEditsContext;
    (function (MappedEditsContext) {
        function is(v) {
            return (!!v && typeof v === 'object' &&
                'documents' in v &&
                Array.isArray(v.documents) &&
                v.documents.every(subArr => Array.isArray(subArr) &&
                    subArr.every(docRef => docRef && typeof docRef === 'object' &&
                        'uri' in docRef && uri_1.URI.isUri(docRef.uri) &&
                        'version' in docRef && typeof docRef.version === 'number' &&
                        'ranges' in docRef && Array.isArray(docRef.ranges) && docRef.ranges.every((r) => r instanceof types.$ON))));
        }
        MappedEditsContext.is = is;
        function from(extContext) {
            return {
                documents: extContext.documents.map((subArray) => subArray.map((r) => ({
                    uri: uri_1.URI.from(r.uri),
                    version: r.version,
                    ranges: r.ranges.map((r) => Range.from(r)),
                }))),
            };
        }
        MappedEditsContext.from = from;
    })(MappedEditsContext || (exports.MappedEditsContext = MappedEditsContext = {}));
    var NotebookRange;
    (function (NotebookRange) {
        function from(range) {
            return { start: range.start, end: range.end };
        }
        NotebookRange.from = from;
        function to(range) {
            return new types.$eP(range.start, range.end);
        }
        NotebookRange.to = to;
    })(NotebookRange || (exports.NotebookRange = NotebookRange = {}));
    var NotebookCellExecutionSummary;
    (function (NotebookCellExecutionSummary) {
        function to(data) {
            return {
                timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,
                executionOrder: data.executionOrder,
                success: data.lastRunSuccess
            };
        }
        NotebookCellExecutionSummary.to = to;
        function from(data) {
            return {
                lastRunSuccess: data.success,
                runStartTime: data.timing?.startTime,
                runEndTime: data.timing?.endTime,
                executionOrder: data.executionOrder
            };
        }
        NotebookCellExecutionSummary.from = from;
    })(NotebookCellExecutionSummary || (exports.NotebookCellExecutionSummary = NotebookCellExecutionSummary = {}));
    var NotebookCellExecutionState;
    (function (NotebookCellExecutionState) {
        function to(state) {
            if (state === notebooks.NotebookCellExecutionState.Unconfirmed) {
                return types.NotebookCellExecutionState.Pending;
            }
            else if (state === notebooks.NotebookCellExecutionState.Pending) {
                // Since the (proposed) extension API doesn't have the distinction between Unconfirmed and Pending, we don't want to fire an update for Pending twice
                return undefined;
            }
            else if (state === notebooks.NotebookCellExecutionState.Executing) {
                return types.NotebookCellExecutionState.Executing;
            }
            else {
                throw new Error(`Unknown state: ${state}`);
            }
        }
        NotebookCellExecutionState.to = to;
    })(NotebookCellExecutionState || (exports.NotebookCellExecutionState = NotebookCellExecutionState = {}));
    var NotebookCellKind;
    (function (NotebookCellKind) {
        function from(data) {
            switch (data) {
                case types.NotebookCellKind.Markup:
                    return notebooks.CellKind.Markup;
                case types.NotebookCellKind.Code:
                default:
                    return notebooks.CellKind.Code;
            }
        }
        NotebookCellKind.from = from;
        function to(data) {
            switch (data) {
                case notebooks.CellKind.Markup:
                    return types.NotebookCellKind.Markup;
                case notebooks.CellKind.Code:
                default:
                    return types.NotebookCellKind.Code;
            }
        }
        NotebookCellKind.to = to;
    })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
    var NotebookData;
    (function (NotebookData) {
        function from(data) {
            const res = {
                metadata: data.metadata ?? Object.create(null),
                cells: [],
            };
            for (const cell of data.cells) {
                types.$fP.validate(cell);
                res.cells.push(NotebookCellData.from(cell));
            }
            return res;
        }
        NotebookData.from = from;
        function to(data) {
            const res = new types.$gP(data.cells.map(NotebookCellData.to));
            if (!(0, types_1.$rg)(data.metadata)) {
                res.metadata = data.metadata;
            }
            return res;
        }
        NotebookData.to = to;
    })(NotebookData || (exports.NotebookData = NotebookData = {}));
    var NotebookCellData;
    (function (NotebookCellData) {
        function from(data) {
            return {
                cellKind: NotebookCellKind.from(data.kind),
                language: data.languageId,
                mime: data.mime,
                source: data.value,
                metadata: data.metadata,
                internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),
                outputs: data.outputs ? data.outputs.map(NotebookCellOutput.from) : []
            };
        }
        NotebookCellData.from = from;
        function to(data) {
            return new types.$fP(NotebookCellKind.to(data.cellKind), data.source, data.language, data.mime, data.outputs ? data.outputs.map(NotebookCellOutput.to) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);
        }
        NotebookCellData.to = to;
    })(NotebookCellData || (exports.NotebookCellData = NotebookCellData = {}));
    var NotebookCellOutputItem;
    (function (NotebookCellOutputItem) {
        function from(item) {
            return {
                mime: item.mime,
                valueBytes: buffer_1.$Ne.wrap(item.data),
            };
        }
        NotebookCellOutputItem.from = from;
        function to(item) {
            return new types.$hP(item.valueBytes.buffer, item.mime);
        }
        NotebookCellOutputItem.to = to;
    })(NotebookCellOutputItem || (exports.NotebookCellOutputItem = NotebookCellOutputItem = {}));
    var NotebookCellOutput;
    (function (NotebookCellOutput) {
        function from(output) {
            return {
                outputId: output.id,
                items: output.items.map(NotebookCellOutputItem.from),
                metadata: output.metadata
            };
        }
        NotebookCellOutput.from = from;
        function to(output) {
            const items = output.items.map(NotebookCellOutputItem.to);
            return new types.$iP(items, output.outputId, output.metadata);
        }
        NotebookCellOutput.to = to;
    })(NotebookCellOutput || (exports.NotebookCellOutput = NotebookCellOutput = {}));
    var NotebookExclusiveDocumentPattern;
    (function (NotebookExclusiveDocumentPattern) {
        function from(pattern) {
            if (isExclusivePattern(pattern)) {
                return {
                    include: GlobPattern.from(pattern.include) ?? undefined,
                    exclude: GlobPattern.from(pattern.exclude) ?? undefined,
                };
            }
            return GlobPattern.from(pattern) ?? undefined;
        }
        NotebookExclusiveDocumentPattern.from = from;
        function to(pattern) {
            if (isExclusivePattern(pattern)) {
                return {
                    include: GlobPattern.to(pattern.include),
                    exclude: GlobPattern.to(pattern.exclude)
                };
            }
            return GlobPattern.to(pattern);
        }
        NotebookExclusiveDocumentPattern.to = to;
        function isExclusivePattern(obj) {
            const ep = obj;
            if (!ep) {
                return false;
            }
            return !(0, types_1.$ng)(ep.include) && !(0, types_1.$ng)(ep.exclude);
        }
    })(NotebookExclusiveDocumentPattern || (exports.NotebookExclusiveDocumentPattern = NotebookExclusiveDocumentPattern = {}));
    var NotebookStatusBarItem;
    (function (NotebookStatusBarItem) {
        function from(item, commandsConverter, disposables) {
            const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
            return {
                alignment: item.alignment === types.NotebookCellStatusBarAlignment.Left ? notebooks.CellStatusbarAlignment.Left : notebooks.CellStatusbarAlignment.Right,
                command: commandsConverter.toInternal(command, disposables), // TODO@roblou
                text: item.text,
                tooltip: item.tooltip,
                accessibilityInformation: item.accessibilityInformation,
                priority: item.priority
            };
        }
        NotebookStatusBarItem.from = from;
    })(NotebookStatusBarItem || (exports.NotebookStatusBarItem = NotebookStatusBarItem = {}));
    var NotebookKernelSourceAction;
    (function (NotebookKernelSourceAction) {
        function from(item, commandsConverter, disposables) {
            const command = typeof item.command === 'string' ? { title: '', command: item.command } : item.command;
            return {
                command: commandsConverter.toInternal(command, disposables),
                label: item.label,
                description: item.description,
                detail: item.detail,
                documentation: item.documentation
            };
        }
        NotebookKernelSourceAction.from = from;
    })(NotebookKernelSourceAction || (exports.NotebookKernelSourceAction = NotebookKernelSourceAction = {}));
    var NotebookDocumentContentOptions;
    (function (NotebookDocumentContentOptions) {
        function from(options) {
            return {
                transientOutputs: options?.transientOutputs ?? false,
                transientCellMetadata: options?.transientCellMetadata ?? {},
                transientDocumentMetadata: options?.transientDocumentMetadata ?? {},
                cellContentMetadata: options?.cellContentMetadata ?? {}
            };
        }
        NotebookDocumentContentOptions.from = from;
    })(NotebookDocumentContentOptions || (exports.NotebookDocumentContentOptions = NotebookDocumentContentOptions = {}));
    var NotebookRendererScript;
    (function (NotebookRendererScript) {
        function from(preload) {
            return {
                uri: preload.uri,
                provides: preload.provides
            };
        }
        NotebookRendererScript.from = from;
        function to(preload) {
            return new types.$kP(uri_1.URI.revive(preload.uri), preload.provides);
        }
        NotebookRendererScript.to = to;
    })(NotebookRendererScript || (exports.NotebookRendererScript = NotebookRendererScript = {}));
    var TestMessage;
    (function (TestMessage) {
        function from(message) {
            return {
                message: MarkdownString.fromStrict(message.message) || '',
                type: testTypes_1.TestMessageType.Error,
                expected: message.expectedOutput,
                actual: message.actualOutput,
                contextValue: message.contextValue,
                location: message.location && ({ range: Range.from(message.location.range), uri: message.location.uri }),
                stackTrace: message.stackTrace?.map(s => ({
                    label: s.label,
                    position: s.position && Position.from(s.position),
                    uri: s.file && uri_1.URI.revive(s.file).toJSON(),
                })),
            };
        }
        TestMessage.from = from;
        function to(item) {
            const message = new types.$qP(typeof item.message === 'string' ? item.message : MarkdownString.to(item.message));
            message.actualOutput = item.actual;
            message.expectedOutput = item.expected;
            message.contextValue = item.contextValue;
            message.location = item.location ? location.to(item.location) : undefined;
            return message;
        }
        TestMessage.to = to;
    })(TestMessage || (exports.TestMessage = TestMessage = {}));
    var TestTag;
    (function (TestTag) {
        TestTag.namespace = testTypes_1.$_I;
        TestTag.denamespace = testTypes_1.$aJ;
    })(TestTag || (exports.TestTag = TestTag = {}));
    var TestItem;
    (function (TestItem) {
        function from(item) {
            const ctrlId = (0, extHostTestingPrivateApi_1.$gQ)(item).controllerId;
            return {
                extId: testId_1.$7I.fromExtHostTestItem(item, ctrlId).toString(),
                label: item.label,
                uri: uri_1.URI.revive(item.uri),
                busy: item.busy,
                tags: item.tags.map(t => TestTag.namespace(ctrlId, t.id)),
                range: editorRange.$Ot.lift(Range.from(item.range)),
                description: item.description || null,
                sortText: item.sortText || null,
                error: item.error ? (MarkdownString.fromStrict(item.error) || null) : null,
            };
        }
        TestItem.from = from;
        function toPlain(item) {
            return {
                parent: undefined,
                error: undefined,
                id: testId_1.$7I.fromString(item.extId).localId,
                label: item.label,
                uri: uri_1.URI.revive(item.uri),
                tags: (item.tags || []).map(t => {
                    const { tagId } = TestTag.denamespace(t);
                    return new types.$rP(tagId);
                }),
                children: {
                    add: () => { },
                    delete: () => { },
                    forEach: () => { },
                    *[Symbol.iterator]() { },
                    get: () => undefined,
                    replace: () => { },
                    size: 0,
                },
                range: Range.to(item.range || undefined),
                canResolveChildren: false,
                busy: item.busy,
                description: item.description || undefined,
                sortText: item.sortText || undefined,
            };
        }
        TestItem.toPlain = toPlain;
    })(TestItem || (exports.TestItem = TestItem = {}));
    (function (TestTag) {
        function from(tag) {
            return { id: tag.id };
        }
        TestTag.from = from;
        function to(tag) {
            return new types.$rP(tag.id);
        }
        TestTag.to = to;
    })(TestTag || (exports.TestTag = TestTag = {}));
    var TestResults;
    (function (TestResults) {
        const convertTestResultItem = (node, parent) => {
            const item = node.value;
            if (!item) {
                return undefined; // should be unreachable
            }
            const snapshot = ({
                ...TestItem.toPlain(item.item),
                parent,
                taskStates: item.tasks.map(t => ({
                    state: t.state,
                    duration: t.duration,
                    messages: t.messages
                        .filter((m) => m.type === testTypes_1.TestMessageType.Error)
                        .map(TestMessage.to),
                })),
                children: [],
            });
            if (node.children) {
                for (const child of node.children.values()) {
                    const c = convertTestResultItem(child, snapshot);
                    if (c) {
                        snapshot.children.push(c);
                    }
                }
            }
            return snapshot;
        };
        function to(serialized) {
            const tree = new prefixTree_1.$6I();
            for (const item of serialized.items) {
                tree.insert(testId_1.$7I.fromString(item.item.extId).path, item);
            }
            // Get the first node with a value in each subtree of IDs.
            const queue = [tree.nodes];
            const roots = [];
            while (queue.length) {
                for (const node of queue.pop()) {
                    if (node.value) {
                        roots.push(node);
                    }
                    else if (node.children) {
                        queue.push(node.children.values());
                    }
                }
            }
            return {
                completedAt: serialized.completedAt,
                results: roots.map(r => convertTestResultItem(r)).filter(types_1.$mg),
            };
        }
        TestResults.to = to;
    })(TestResults || (exports.TestResults = TestResults = {}));
    var TestCoverage;
    (function (TestCoverage) {
        function fromCoverageCount(count) {
            return { covered: count.covered, total: count.total };
        }
        function fromLocation(location) {
            return 'line' in location ? Position.from(location) : Range.from(location);
        }
        function fromDetails(coverage) {
            if (typeof coverage.executed === 'number' && coverage.executed < 0) {
                throw new Error(`Invalid coverage count ${coverage.executed}`);
            }
            if ('branches' in coverage) {
                return {
                    count: coverage.executed,
                    location: fromLocation(coverage.location),
                    type: testTypes_1.DetailType.Statement,
                    branches: coverage.branches.length
                        ? coverage.branches.map(b => ({ count: b.executed, location: b.location && fromLocation(b.location), label: b.label }))
                        : undefined,
                };
            }
            else {
                return {
                    type: testTypes_1.DetailType.Declaration,
                    name: coverage.name,
                    count: coverage.executed,
                    location: fromLocation(coverage.location),
                };
            }
        }
        TestCoverage.fromDetails = fromDetails;
        function fromFile(controllerId, id, coverage) {
            types.$uP(coverage.statementCoverage);
            types.$uP(coverage.branchCoverage);
            types.$uP(coverage.declarationCoverage);
            return {
                id,
                uri: coverage.uri,
                statement: fromCoverageCount(coverage.statementCoverage),
                branch: coverage.branchCoverage && fromCoverageCount(coverage.branchCoverage),
                declaration: coverage.declarationCoverage && fromCoverageCount(coverage.declarationCoverage),
                testIds: coverage instanceof types.$vP && coverage.fromTests.length ?
                    coverage.fromTests.map(t => testId_1.$7I.fromExtHostTestItem(t, controllerId).toString()) : undefined,
            };
        }
        TestCoverage.fromFile = fromFile;
    })(TestCoverage || (exports.TestCoverage = TestCoverage = {}));
    var CodeActionTriggerKind;
    (function (CodeActionTriggerKind) {
        function to(value) {
            switch (value) {
                case languages.CodeActionTriggerType.Invoke:
                    return types.CodeActionTriggerKind.Invoke;
                case languages.CodeActionTriggerType.Auto:
                    return types.CodeActionTriggerKind.Automatic;
            }
        }
        CodeActionTriggerKind.to = to;
    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
    var TypeHierarchyItem;
    (function (TypeHierarchyItem) {
        function to(item) {
            const result = new types.$zP(SymbolKind.to(item.kind), item.name, item.detail || '', uri_1.URI.revive(item.uri), Range.to(item.range), Range.to(item.selectionRange));
            result._sessionId = item._sessionId;
            result._itemId = item._itemId;
            return result;
        }
        TypeHierarchyItem.to = to;
        function from(item, sessionId, itemId) {
            sessionId = sessionId ?? item._sessionId;
            itemId = itemId ?? item._itemId;
            if (sessionId === undefined || itemId === undefined) {
                throw new Error('invalid item');
            }
            return {
                _sessionId: sessionId,
                _itemId: itemId,
                kind: SymbolKind.from(item.kind),
                name: item.name,
                detail: item.detail ?? '',
                uri: item.uri,
                range: Range.from(item.range),
                selectionRange: Range.from(item.selectionRange),
                tags: item.tags?.map(SymbolTag.from)
            };
        }
        TypeHierarchyItem.from = from;
    })(TypeHierarchyItem || (exports.TypeHierarchyItem = TypeHierarchyItem = {}));
    var ViewBadge;
    (function (ViewBadge) {
        function from(badge) {
            if (!badge) {
                return undefined;
            }
            return {
                value: badge.value,
                tooltip: badge.tooltip
            };
        }
        ViewBadge.from = from;
    })(ViewBadge || (exports.ViewBadge = ViewBadge = {}));
    var DataTransferItem;
    (function (DataTransferItem) {
        function to(mime, item, resolveFileData) {
            const file = item.fileData;
            if (file) {
                return new types.$FO(new types.$GO(file.name, uri_1.URI.revive(file.uri), file.id, (0, functional_1.$cb)(() => resolveFileData(file.id))));
            }
            if (mime === mime_1.$$s.uriList && item.uriListData) {
                return new types.$EO(reviveUriList(item.uriListData));
            }
            return new types.$EO(item.asString);
        }
        DataTransferItem.to = to;
        async function from(mime, item) {
            const stringValue = await item.asString();
            if (mime === mime_1.$$s.uriList) {
                return {
                    asString: stringValue,
                    fileData: undefined,
                    uriListData: serializeUriList(stringValue),
                };
            }
            const fileValue = item.asFile();
            return {
                asString: stringValue,
                fileData: fileValue ? {
                    name: fileValue.name,
                    uri: fileValue.uri,
                    id: fileValue._itemId ?? fileValue.id,
                } : undefined,
            };
        }
        DataTransferItem.from = from;
        function serializeUriList(stringValue) {
            return dataTransfer_1.$tu.split(stringValue).map(part => {
                if (part.startsWith('#')) {
                    return part;
                }
                try {
                    return uri_1.URI.parse(part);
                }
                catch {
                    // noop
                }
                return part;
            });
        }
        function reviveUriList(parts) {
            return dataTransfer_1.$tu.create(parts.map(part => {
                return typeof part === 'string' ? part : uri_1.URI.revive(part);
            }));
        }
    })(DataTransferItem || (exports.DataTransferItem = DataTransferItem = {}));
    var DataTransfer;
    (function (DataTransfer) {
        function toDataTransfer(value, resolveFileData) {
            const init = value.items.map(([type, item]) => {
                return [type, DataTransferItem.to(type, item, resolveFileData)];
            });
            return new types.$HO(init);
        }
        DataTransfer.toDataTransfer = toDataTransfer;
        async function from(dataTransfer) {
            const newDTO = { items: [] };
            const promises = [];
            for (const [mime, value] of dataTransfer) {
                promises.push((async () => {
                    newDTO.items.push([mime, await DataTransferItem.from(mime, value)]);
                })());
            }
            await Promise.all(promises);
            return newDTO;
        }
        DataTransfer.from = from;
    })(DataTransfer || (exports.DataTransfer = DataTransfer = {}));
    var ChatFollowup;
    (function (ChatFollowup) {
        function from(followup, request) {
            return {
                kind: 'reply',
                agentId: followup.participant ?? request?.agentId ?? '',
                subCommand: followup.command ?? request?.command,
                message: followup.prompt,
                title: followup.label
            };
        }
        ChatFollowup.from = from;
        function to(followup) {
            return {
                prompt: followup.message,
                label: followup.title,
                participant: followup.agentId,
                command: followup.subCommand,
            };
        }
        ChatFollowup.to = to;
    })(ChatFollowup || (exports.ChatFollowup = ChatFollowup = {}));
    var LanguageModelChatMessageRole;
    (function (LanguageModelChatMessageRole) {
        function to(role) {
            switch (role) {
                case chatProvider.ChatMessageRole.System: return types.LanguageModelChatMessageRole.System;
                case chatProvider.ChatMessageRole.User: return types.LanguageModelChatMessageRole.User;
                case chatProvider.ChatMessageRole.Assistant: return types.LanguageModelChatMessageRole.Assistant;
            }
        }
        LanguageModelChatMessageRole.to = to;
        function from(role) {
            switch (role) {
                case types.LanguageModelChatMessageRole.System: return chatProvider.ChatMessageRole.System;
                case types.LanguageModelChatMessageRole.User: return chatProvider.ChatMessageRole.User;
                case types.LanguageModelChatMessageRole.Assistant: return chatProvider.ChatMessageRole.Assistant;
            }
            return chatProvider.ChatMessageRole.User;
        }
        LanguageModelChatMessageRole.from = from;
    })(LanguageModelChatMessageRole || (exports.LanguageModelChatMessageRole = LanguageModelChatMessageRole = {}));
    var LanguageModelChatMessage;
    (function (LanguageModelChatMessage) {
        function to(message) {
            let content = '';
            let content2;
            if (message.content.type === 'text') {
                content = message.content.value;
            }
            else {
                content2 = new types.$4P(message.content.name, message.content.value, message.content.isError);
            }
            const role = LanguageModelChatMessageRole.to(message.role);
            const result = new types.$5P(role, content, message.name);
            if (content2 !== undefined) {
                result.content2 = content2;
            }
            return result;
        }
        LanguageModelChatMessage.to = to;
        function from(message) {
            const role = LanguageModelChatMessageRole.from(message.role);
            const name = message.name;
            let content;
            if (message.content2 instanceof types.$4P) {
                content = {
                    type: 'function_result',
                    name: message.content2.name,
                    value: message.content2.content,
                    isError: message.content2.isError
                };
            }
            else {
                content = {
                    type: 'text',
                    value: message.content
                };
            }
            return {
                role,
                name,
                content
            };
        }
        LanguageModelChatMessage.from = from;
    })(LanguageModelChatMessage || (exports.LanguageModelChatMessage = LanguageModelChatMessage = {}));
    var ChatResponseMarkdownPart;
    (function (ChatResponseMarkdownPart) {
        function from(part) {
            return {
                kind: 'markdownContent',
                content: MarkdownString.from(part.value)
            };
        }
        ChatResponseMarkdownPart.from = from;
        function to(part) {
            return new types.$MP(MarkdownString.to(part.content));
        }
        ChatResponseMarkdownPart.to = to;
    })(ChatResponseMarkdownPart || (exports.ChatResponseMarkdownPart = ChatResponseMarkdownPart = {}));
    var ChatResponseMarkdownWithVulnerabilitiesPart;
    (function (ChatResponseMarkdownWithVulnerabilitiesPart) {
        function from(part) {
            return {
                kind: 'markdownVuln',
                content: MarkdownString.from(part.value),
                vulnerabilities: part.vulnerabilities,
            };
        }
        ChatResponseMarkdownWithVulnerabilitiesPart.from = from;
        function to(part) {
            return new types.$NP(MarkdownString.to(part.content), part.vulnerabilities);
        }
        ChatResponseMarkdownWithVulnerabilitiesPart.to = to;
    })(ChatResponseMarkdownWithVulnerabilitiesPart || (exports.ChatResponseMarkdownWithVulnerabilitiesPart = ChatResponseMarkdownWithVulnerabilitiesPart = {}));
    var ChatResponseDetectedParticipantPart;
    (function (ChatResponseDetectedParticipantPart) {
        function from(part) {
            return {
                kind: 'agentDetection',
                agentId: part.participant,
                command: part.command,
            };
        }
        ChatResponseDetectedParticipantPart.from = from;
        function to(part) {
            return new types.$OP(part.agentId, part.command);
        }
        ChatResponseDetectedParticipantPart.to = to;
    })(ChatResponseDetectedParticipantPart || (exports.ChatResponseDetectedParticipantPart = ChatResponseDetectedParticipantPart = {}));
    var ChatResponseConfirmationPart;
    (function (ChatResponseConfirmationPart) {
        function from(part) {
            return {
                kind: 'confirmation',
                title: part.title,
                message: part.message,
                data: part.data,
                buttons: part.buttons
            };
        }
        ChatResponseConfirmationPart.from = from;
    })(ChatResponseConfirmationPart || (exports.ChatResponseConfirmationPart = ChatResponseConfirmationPart = {}));
    var ChatResponseFilesPart;
    (function (ChatResponseFilesPart) {
        function from(part) {
            const { value, baseUri } = part;
            function convert(items, baseUri) {
                return items.map(item => {
                    const myUri = uri_1.URI.joinPath(baseUri, item.name);
                    return {
                        label: item.name,
                        uri: myUri,
                        children: item.children && convert(item.children, myUri)
                    };
                });
            }
            return {
                kind: 'treeData',
                treeData: {
                    label: (0, resources_1.$dh)(baseUri),
                    uri: baseUri,
                    children: convert(value, baseUri)
                }
            };
        }
        ChatResponseFilesPart.from = from;
        function to(part) {
            const treeData = (0, marshalling_1.$ci)(part.treeData);
            function convert(items) {
                return items.map(item => {
                    return {
                        name: item.label,
                        children: item.children && convert(item.children)
                    };
                });
            }
            const baseUri = treeData.uri;
            const items = treeData.children ? convert(treeData.children) : [];
            return new types.$QP(items, baseUri);
        }
        ChatResponseFilesPart.to = to;
    })(ChatResponseFilesPart || (exports.ChatResponseFilesPart = ChatResponseFilesPart = {}));
    var ChatResponseAnchorPart;
    (function (ChatResponseAnchorPart) {
        function from(part) {
            // Work around type-narrowing confusion between vscode.Uri and URI
            const isUri = (thing) => uri_1.URI.isUri(thing);
            return {
                kind: 'inlineReference',
                name: part.title,
                inlineReference: isUri(part.value) ? part.value : Location.from(part.value)
            };
        }
        ChatResponseAnchorPart.from = from;
        function to(part) {
            const value = (0, marshalling_1.$ci)(part);
            return new types.$RP(uri_1.URI.isUri(value.inlineReference) ? value.inlineReference : Location.to(value.inlineReference), part.name);
        }
        ChatResponseAnchorPart.to = to;
    })(ChatResponseAnchorPart || (exports.ChatResponseAnchorPart = ChatResponseAnchorPart = {}));
    var ChatResponseProgressPart;
    (function (ChatResponseProgressPart) {
        function from(part) {
            return {
                kind: 'progressMessage',
                content: MarkdownString.from(part.value)
            };
        }
        ChatResponseProgressPart.from = from;
        function to(part) {
            return new types.$SP(part.content.value);
        }
        ChatResponseProgressPart.to = to;
    })(ChatResponseProgressPart || (exports.ChatResponseProgressPart = ChatResponseProgressPart = {}));
    var ChatResponseWarningPart;
    (function (ChatResponseWarningPart) {
        function from(part) {
            return {
                kind: 'warning',
                content: MarkdownString.from(part.value)
            };
        }
        ChatResponseWarningPart.from = from;
        function to(part) {
            return new types.$UP(part.content.value);
        }
        ChatResponseWarningPart.to = to;
    })(ChatResponseWarningPart || (exports.ChatResponseWarningPart = ChatResponseWarningPart = {}));
    var ChatTask;
    (function (ChatTask) {
        function from(part) {
            return {
                kind: 'progressTask',
                content: MarkdownString.from(part.value),
            };
        }
        ChatTask.from = from;
    })(ChatTask || (exports.ChatTask = ChatTask = {}));
    var ChatTaskResult;
    (function (ChatTaskResult) {
        function from(part) {
            return {
                kind: 'progressTaskResult',
                content: typeof part === 'string' ? MarkdownString.from(part) : undefined
            };
        }
        ChatTaskResult.from = from;
    })(ChatTaskResult || (exports.ChatTaskResult = ChatTaskResult = {}));
    var ChatResponseCommandButtonPart;
    (function (ChatResponseCommandButtonPart) {
        function from(part, commandsConverter, commandDisposables) {
            // If the command isn't in the converter, then this session may have been restored, and the command args don't exist anymore
            const command = commandsConverter.toInternal(part.value, commandDisposables) ?? { command: part.value.command, title: part.value.title };
            return {
                kind: 'command',
                command
            };
        }
        ChatResponseCommandButtonPart.from = from;
        function to(part, commandsConverter) {
            // If the command isn't in the converter, then this session may have been restored, and the command args don't exist anymore
            return new types.$VP(commandsConverter.fromInternal(part.command) ?? { command: part.command.id, title: part.command.title });
        }
        ChatResponseCommandButtonPart.to = to;
    })(ChatResponseCommandButtonPart || (exports.ChatResponseCommandButtonPart = ChatResponseCommandButtonPart = {}));
    var ChatResponseTextEditPart;
    (function (ChatResponseTextEditPart) {
        function from(part) {
            return {
                kind: 'textEdit',
                uri: part.uri,
                edits: part.edits.map(e => TextEdit.from(e))
            };
        }
        ChatResponseTextEditPart.from = from;
        function to(part) {
            return new types.$YP(uri_1.URI.revive(part.uri), part.edits.map(e => TextEdit.to(e)));
        }
        ChatResponseTextEditPart.to = to;
    })(ChatResponseTextEditPart || (exports.ChatResponseTextEditPart = ChatResponseTextEditPart = {}));
    var ChatResponseReferencePart;
    (function (ChatResponseReferencePart) {
        function from(part) {
            const iconPath = themables_1.ThemeIcon.isThemeIcon(part.iconPath) ? part.iconPath
                : uri_1.URI.isUri(part.iconPath) ? { light: uri_1.URI.revive(part.iconPath) }
                    : (part.iconPath && 'light' in part.iconPath && 'dark' in part.iconPath && uri_1.URI.isUri(part.iconPath.light) && uri_1.URI.isUri(part.iconPath.dark) ? { light: uri_1.URI.revive(part.iconPath.light), dark: uri_1.URI.revive(part.iconPath.dark) }
                        : undefined);
            if ('variableName' in part.value) {
                return {
                    kind: 'reference',
                    reference: {
                        variableName: part.value.variableName,
                        value: uri_1.URI.isUri(part.value.value) || !part.value.value ?
                            part.value.value :
                            Location.from(part.value.value)
                    },
                    iconPath,
                    options: part.options
                };
            }
            return {
                kind: 'reference',
                reference: uri_1.URI.isUri(part.value) ?
                    part.value :
                    Location.from(part.value),
                iconPath,
                options: part.options
            };
        }
        ChatResponseReferencePart.from = from;
        function to(part) {
            const value = (0, marshalling_1.$ci)(part);
            const mapValue = (value) => uri_1.URI.isUri(value) ?
                value :
                Location.to(value);
            return new types.$WP('variableName' in value.reference ? {
                variableName: value.reference.variableName,
                value: value.reference.value && mapValue(value.reference.value)
            } :
                mapValue(value.reference)); // 'value' is extended with variableName
        }
        ChatResponseReferencePart.to = to;
    })(ChatResponseReferencePart || (exports.ChatResponseReferencePart = ChatResponseReferencePart = {}));
    var ChatResponseCodeCitationPart;
    (function (ChatResponseCodeCitationPart) {
        function from(part) {
            return {
                kind: 'codeCitation',
                value: part.value,
                license: part.license,
                snippet: part.snippet
            };
        }
        ChatResponseCodeCitationPart.from = from;
    })(ChatResponseCodeCitationPart || (exports.ChatResponseCodeCitationPart = ChatResponseCodeCitationPart = {}));
    var ChatResponsePart;
    (function (ChatResponsePart) {
        function from(part, commandsConverter, commandDisposables) {
            if (part instanceof types.$MP) {
                return ChatResponseMarkdownPart.from(part);
            }
            else if (part instanceof types.$RP) {
                return ChatResponseAnchorPart.from(part);
            }
            else if (part instanceof types.$WP) {
                return ChatResponseReferencePart.from(part);
            }
            else if (part instanceof types.$SP) {
                return ChatResponseProgressPart.from(part);
            }
            else if (part instanceof types.$QP) {
                return ChatResponseFilesPart.from(part);
            }
            else if (part instanceof types.$VP) {
                return ChatResponseCommandButtonPart.from(part, commandsConverter, commandDisposables);
            }
            else if (part instanceof types.$YP) {
                return ChatResponseTextEditPart.from(part);
            }
            else if (part instanceof types.$NP) {
                return ChatResponseMarkdownWithVulnerabilitiesPart.from(part);
            }
            else if (part instanceof types.$OP) {
                return ChatResponseDetectedParticipantPart.from(part);
            }
            else if (part instanceof types.$UP) {
                return ChatResponseWarningPart.from(part);
            }
            else if (part instanceof types.$PP) {
                return ChatResponseConfirmationPart.from(part);
            }
            else if (part instanceof types.$XP) {
                return ChatResponseCodeCitationPart.from(part);
            }
            return {
                kind: 'markdownContent',
                content: MarkdownString.from('')
            };
        }
        ChatResponsePart.from = from;
        function to(part, commandsConverter) {
            switch (part.kind) {
                case 'reference': return ChatResponseReferencePart.to(part);
                case 'markdownContent':
                case 'inlineReference':
                case 'progressMessage':
                case 'treeData':
                case 'command':
                    return toContent(part, commandsConverter);
            }
            return undefined;
        }
        ChatResponsePart.to = to;
        function toContent(part, commandsConverter) {
            switch (part.kind) {
                case 'markdownContent': return ChatResponseMarkdownPart.to(part);
                case 'inlineReference': return ChatResponseAnchorPart.to(part);
                case 'progressMessage': return undefined;
                case 'treeData': return ChatResponseFilesPart.to(part);
                case 'command': return ChatResponseCommandButtonPart.to(part, commandsConverter);
            }
            return undefined;
        }
        ChatResponsePart.toContent = toContent;
    })(ChatResponsePart || (exports.ChatResponsePart = ChatResponsePart = {}));
    var ChatAgentRequest;
    (function (ChatAgentRequest) {
        function to(request, location2) {
            const requestedTools = request.variables.variables.filter(v => v.isTool).map(tool => tool.id);
            const variablesWithoutTools = request.variables.variables.filter(v => !v.isTool);
            return {
                prompt: request.message,
                command: request.command,
                attempt: request.attempt ?? 0,
                enableCommandDetection: request.enableCommandDetection ?? true,
                references: variablesWithoutTools.map(ChatAgentValueReference.to),
                location: ChatLocation.to(request.location),
                acceptedConfirmationData: request.acceptedConfirmationData,
                rejectedConfirmationData: request.rejectedConfirmationData,
                location2,
                requestedTools
            };
        }
        ChatAgentRequest.to = to;
    })(ChatAgentRequest || (exports.ChatAgentRequest = ChatAgentRequest = {}));
    var ChatLocation;
    (function (ChatLocation) {
        function to(loc) {
            switch (loc) {
                case chatAgents_1.ChatAgentLocation.Notebook: return types.ChatLocation.Notebook;
                case chatAgents_1.ChatAgentLocation.Terminal: return types.ChatLocation.Terminal;
                case chatAgents_1.ChatAgentLocation.Panel: return types.ChatLocation.Panel;
                case chatAgents_1.ChatAgentLocation.Editor: return types.ChatLocation.Editor;
            }
        }
        ChatLocation.to = to;
        function from(loc) {
            switch (loc) {
                case types.ChatLocation.Notebook: return chatAgents_1.ChatAgentLocation.Notebook;
                case types.ChatLocation.Terminal: return chatAgents_1.ChatAgentLocation.Terminal;
                case types.ChatLocation.Panel: return chatAgents_1.ChatAgentLocation.Panel;
                case types.ChatLocation.Editor: return chatAgents_1.ChatAgentLocation.Editor;
            }
        }
        ChatLocation.from = from;
    })(ChatLocation || (exports.ChatLocation = ChatLocation = {}));
    var ChatAgentValueReference;
    (function (ChatAgentValueReference) {
        function to(variable) {
            const value = variable.value;
            if (!value) {
                throw new Error('Invalid value reference');
            }
            return {
                id: variable.id,
                name: variable.name,
                range: variable.range && [variable.range.start, variable.range.endExclusive],
                value: (0, uri_1.$vc)(value) ? uri_1.URI.revive(value) :
                    value && typeof value === 'object' && 'uri' in value && 'range' in value && (0, uri_1.$vc)(value.uri) ?
                        Location.to((0, marshalling_1.$ci)(value)) : value,
                modelDescription: variable.modelDescription
            };
        }
        ChatAgentValueReference.to = to;
    })(ChatAgentValueReference || (exports.ChatAgentValueReference = ChatAgentValueReference = {}));
    var ChatAgentCompletionItem;
    (function (ChatAgentCompletionItem) {
        function from(item, commandsConverter, disposables) {
            return {
                id: item.id,
                label: item.label,
                fullName: item.fullName,
                icon: item.icon?.id,
                value: item.values[0].value,
                insertText: item.insertText,
                detail: item.detail,
                documentation: item.documentation,
                command: commandsConverter.toInternal(item.command, disposables),
            };
        }
        ChatAgentCompletionItem.from = from;
    })(ChatAgentCompletionItem || (exports.ChatAgentCompletionItem = ChatAgentCompletionItem = {}));
    var ChatAgentResult;
    (function (ChatAgentResult) {
        function to(result) {
            return {
                errorDetails: result.errorDetails,
                metadata: result.metadata,
            };
        }
        ChatAgentResult.to = to;
    })(ChatAgentResult || (exports.ChatAgentResult = ChatAgentResult = {}));
    var ChatAgentUserActionEvent;
    (function (ChatAgentUserActionEvent) {
        function to(result, event, commandsConverter) {
            if (event.action.kind === 'vote') {
                // Is the "feedback" type
                return;
            }
            const ehResult = ChatAgentResult.to(result);
            if (event.action.kind === 'command') {
                const command = event.action.commandButton.command;
                const commandButton = {
                    command: commandsConverter.fromInternal(command) ?? { command: command.id, title: command.title },
                };
                const commandAction = { kind: 'command', commandButton };
                return { action: commandAction, result: ehResult };
            }
            else if (event.action.kind === 'followUp') {
                const followupAction = { kind: 'followUp', followup: ChatFollowup.to(event.action.followup) };
                return { action: followupAction, result: ehResult };
            }
            else if (event.action.kind === 'inlineChat') {
                return { action: { kind: 'editor', accepted: event.action.action === 'accepted' }, result: ehResult };
            }
            else {
                return { action: event.action, result: ehResult };
            }
        }
        ChatAgentUserActionEvent.to = to;
    })(ChatAgentUserActionEvent || (exports.ChatAgentUserActionEvent = ChatAgentUserActionEvent = {}));
    var TerminalQuickFix;
    (function (TerminalQuickFix) {
        function from(quickFix, converter, disposables) {
            if ('terminalCommand' in quickFix) {
                return { terminalCommand: quickFix.terminalCommand, shouldExecute: quickFix.shouldExecute };
            }
            if ('uri' in quickFix) {
                return { uri: quickFix.uri };
            }
            return converter.toInternal(quickFix, disposables);
        }
        TerminalQuickFix.from = from;
    })(TerminalQuickFix || (exports.TerminalQuickFix = TerminalQuickFix = {}));
    var PartialAcceptInfo;
    (function (PartialAcceptInfo) {
        function to(info) {
            return {
                kind: PartialAcceptTriggerKind.to(info.kind),
            };
        }
        PartialAcceptInfo.to = to;
    })(PartialAcceptInfo || (exports.PartialAcceptInfo = PartialAcceptInfo = {}));
    var PartialAcceptTriggerKind;
    (function (PartialAcceptTriggerKind) {
        function to(kind) {
            switch (kind) {
                case languages.PartialAcceptTriggerKind.Word:
                    return types.PartialAcceptTriggerKind.Word;
                case languages.PartialAcceptTriggerKind.Line:
                    return types.PartialAcceptTriggerKind.Line;
                case languages.PartialAcceptTriggerKind.Suggest:
                    return types.PartialAcceptTriggerKind.Suggest;
                default:
                    return types.PartialAcceptTriggerKind.Unknown;
            }
        }
        PartialAcceptTriggerKind.to = to;
    })(PartialAcceptTriggerKind || (exports.PartialAcceptTriggerKind = PartialAcceptTriggerKind = {}));
    var DebugTreeItem;
    (function (DebugTreeItem) {
        function from(item, id) {
            return {
                id,
                label: item.label,
                description: item.description,
                canEdit: item.canEdit,
                collapsibleState: (item.collapsibleState || debug_1.DebugTreeItemCollapsibleState.None),
                contextValue: item.contextValue,
            };
        }
        DebugTreeItem.from = from;
    })(DebugTreeItem || (exports.DebugTreeItem = DebugTreeItem = {}));
    var LanguageModelToolDescription;
    (function (LanguageModelToolDescription) {
        function to(item) {
            return {
                name: item.name,
                description: item.description,
                parametersSchema: item.parametersSchema,
            };
        }
        LanguageModelToolDescription.to = to;
    })(LanguageModelToolDescription || (exports.LanguageModelToolDescription = LanguageModelToolDescription = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[232/*vs/workbench/api/common/extHostBulkEdits*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,16/*vs/workbench/api/common/extHostRpcService*/,8/*vs/workbench/api/common/extHostTypeConverters*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/]), function (require, exports, extHost_protocol_1, extHostRpcService_1, extHostTypeConverters_1, proxyIdentifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Dpc = void 0;
    let $Dpc = class $Dpc {
        constructor(extHostRpc, extHostDocumentsAndEditors) {
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadBulkEdits);
            this.b = {
                getTextDocumentVersion: uri => extHostDocumentsAndEditors.getDocument(uri)?.version,
                getNotebookDocumentVersion: () => undefined
            };
        }
        applyWorkspaceEdit(edit, extension, metadata) {
            const dto = new proxyIdentifier_1.$Xw(extHostTypeConverters_1.WorkspaceEdit.from(edit, this.b));
            return this.a.$tryApplyWorkspaceEdit(dto, undefined, metadata?.isRefactoring ?? false);
        }
    };
    exports.$Dpc = $Dpc;
    exports.$Dpc = $Dpc = __decorate([
        __param(0, extHostRpcService_1.$kQ)
    ], $Dpc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[233/*vs/workbench/api/common/extHostChatAgents2*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,10/*vs/base/common/async*/,42/*vs/base/common/errorMessage*/,6/*vs/base/common/event*/,40/*vs/base/common/iterator*/,4/*vs/base/common/lifecycle*/,36/*vs/base/common/marshalling*/,69/*vs/base/common/stopwatch*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,18/*vs/platform/extensions/common/extensions*/,5/*vs/workbench/api/common/extHost.protocol*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,115/*vs/workbench/contrib/chat/common/chatAgents*/,194/*vs/workbench/contrib/chat/common/chatService*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, arrays_1, async_1, errorMessage_1, event_1, iterator_1, lifecycle_1, marshalling_1, stopwatch_1, types_1, uri_1, extensions_1, extHost_protocol_1, typeConvert, extHostTypes, chatAgents_1, chatService_1, extensions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Epc = void 0;
    typeConvert = __importStar(typeConvert);
    extHostTypes = __importStar(extHostTypes);
    class ChatAgentResponseStream {
        constructor(j, k, l, m, n) {
            this.j = j;
            this.k = k;
            this.l = l;
            this.m = m;
            this.n = n;
            this.b = stopwatch_1.$fe.create(false);
            this.c = false;
        }
        close() {
            this.c = true;
        }
        get timings() {
            return {
                firstProgress: this.d,
                totalElapsed: this.b.elapsed()
            };
        }
        get apiObject() {
            if (!this.g) {
                const that = this;
                this.b.reset();
                function throwIfDone(source) {
                    if (that.c) {
                        const err = new Error('Response stream has been closed');
                        Error.captureStackTrace(err, source);
                        throw err;
                    }
                }
                const _report = (progress, task) => {
                    // Measure the time to the first progress update with real markdown content
                    if (typeof this.d === 'undefined' && 'content' in progress) {
                        this.d = this.b.elapsed();
                    }
                    if (task) {
                        const progressReporterPromise = this.l.$handleProgressChunk(this.k.requestId, progress);
                        const progressReporter = {
                            report: (p) => {
                                progressReporterPromise?.then((handle) => {
                                    if (handle) {
                                        if (extHostTypes.$eO.isMarkdownString(p.value)) {
                                            this.l.$handleProgressChunk(this.k.requestId, typeConvert.ChatResponseWarningPart.from(p), handle);
                                        }
                                        else {
                                            this.l.$handleProgressChunk(this.k.requestId, typeConvert.ChatResponseReferencePart.from(p), handle);
                                        }
                                    }
                                });
                            }
                        };
                        Promise.all([progressReporterPromise, task?.(progressReporter)]).then(([handle, res]) => {
                            if (handle !== undefined && res !== undefined) {
                                this.l.$handleProgressChunk(this.k.requestId, typeConvert.ChatTaskResult.from(res), handle);
                            }
                        });
                    }
                    else {
                        this.l.$handleProgressChunk(this.k.requestId, progress);
                    }
                };
                this.g = {
                    markdown(value) {
                        throwIfDone(this.markdown);
                        const part = new extHostTypes.$MP(value);
                        const dto = typeConvert.ChatResponseMarkdownPart.from(part);
                        _report(dto);
                        return this;
                    },
                    markdownWithVulnerabilities(value, vulnerabilities) {
                        throwIfDone(this.markdown);
                        if (vulnerabilities) {
                            (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        }
                        const part = new extHostTypes.$NP(value, vulnerabilities);
                        const dto = typeConvert.ChatResponseMarkdownWithVulnerabilitiesPart.from(part);
                        _report(dto);
                        return this;
                    },
                    filetree(value, baseUri) {
                        throwIfDone(this.filetree);
                        const part = new extHostTypes.$QP(value, baseUri);
                        const dto = typeConvert.ChatResponseFilesPart.from(part);
                        _report(dto);
                        return this;
                    },
                    anchor(value, title) {
                        throwIfDone(this.anchor);
                        const part = new extHostTypes.$RP(value, title);
                        const dto = typeConvert.ChatResponseAnchorPart.from(part);
                        _report(dto);
                        return this;
                    },
                    button(value) {
                        throwIfDone(this.anchor);
                        const part = new extHostTypes.$VP(value);
                        const dto = typeConvert.ChatResponseCommandButtonPart.from(part, that.m, that.n);
                        _report(dto);
                        return this;
                    },
                    progress(value, task) {
                        throwIfDone(this.progress);
                        const part = new extHostTypes.$TP(value, task);
                        const dto = task ? typeConvert.ChatTask.from(part) : typeConvert.ChatResponseProgressPart.from(part);
                        _report(dto, task);
                        return this;
                    },
                    warning(value) {
                        throwIfDone(this.progress);
                        (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        const part = new extHostTypes.$UP(value);
                        const dto = typeConvert.ChatResponseWarningPart.from(part);
                        _report(dto);
                        return this;
                    },
                    reference(value, iconPath) {
                        return this.reference2(value, iconPath);
                    },
                    reference2(value, iconPath, options) {
                        throwIfDone(this.reference);
                        if ('variableName' in value) {
                            (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        }
                        if ('variableName' in value && !value.value) {
                            // The participant used this variable. Does that variable have any references to pull in?
                            const matchingVarData = that.k.variables.variables.find(v => v.name === value.variableName);
                            if (matchingVarData) {
                                let references;
                                if (matchingVarData.references?.length) {
                                    references = matchingVarData.references.map(r => ({
                                        kind: 'reference',
                                        reference: { variableName: value.variableName, value: r.reference }
                                    }));
                                }
                                else {
                                    // Participant sent a variableName reference but the variable produced no references. Show variable reference with no value
                                    const part = new extHostTypes.$WP(value, iconPath, options);
                                    const dto = typeConvert.ChatResponseReferencePart.from(part);
                                    references = [dto];
                                }
                                references.forEach(r => _report(r));
                                return this;
                            }
                            else {
                                // Something went wrong- that variable doesn't actually exist
                            }
                        }
                        else {
                            const part = new extHostTypes.$WP(value, iconPath, options);
                            const dto = typeConvert.ChatResponseReferencePart.from(part);
                            _report(dto);
                        }
                        return this;
                    },
                    codeCitation(value, license, snippet) {
                        throwIfDone(this.codeCitation);
                        (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        const part = new extHostTypes.$XP(value, license, snippet);
                        const dto = typeConvert.ChatResponseCodeCitationPart.from(part);
                        _report(dto);
                    },
                    textEdit(target, edits) {
                        throwIfDone(this.textEdit);
                        (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        const part = new extHostTypes.$YP(target, edits);
                        const dto = typeConvert.ChatResponseTextEditPart.from(part);
                        _report(dto);
                        return this;
                    },
                    detectedParticipant(participant, command) {
                        throwIfDone(this.detectedParticipant);
                        (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        const part = new extHostTypes.$OP(participant, command);
                        const dto = typeConvert.ChatResponseDetectedParticipantPart.from(part);
                        _report(dto);
                        return this;
                    },
                    confirmation(title, message, data, buttons) {
                        throwIfDone(this.confirmation);
                        (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        const part = new extHostTypes.$PP(title, message, data, buttons);
                        const dto = typeConvert.ChatResponseConfirmationPart.from(part);
                        _report(dto);
                        return this;
                    },
                    push(part) {
                        throwIfDone(this.push);
                        if (part instanceof extHostTypes.$YP ||
                            part instanceof extHostTypes.$NP ||
                            part instanceof extHostTypes.$OP ||
                            part instanceof extHostTypes.$UP ||
                            part instanceof extHostTypes.$PP ||
                            part instanceof extHostTypes.$XP) {
                            (0, extensions_2.$gH)(that.j, 'chatParticipantAdditions');
                        }
                        if (part instanceof extHostTypes.$WP) {
                            // Ensure variable reference values get fixed up
                            this.reference2(part.value, part.iconPath, part.options);
                        }
                        else {
                            const dto = typeConvert.ChatResponsePart.from(part, that.m, that.n);
                            _report(dto);
                        }
                        return this;
                    },
                };
            }
            return this.g;
        }
    }
    class $Epc extends lifecycle_1.$Uc {
        static { this.b = 0; }
        constructor(mainContext, n, s, t) {
            super();
            this.n = n;
            this.s = s;
            this.t = t;
            this.c = new Map();
            this.j = this.B(new lifecycle_1.$4c());
            this.m = this.B(new lifecycle_1.$4c());
            this.g = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadChatAgents2);
        }
        transferActiveChat(newWorkspace) {
            this.g.$transferActiveChatSession(newWorkspace);
        }
        createChatAgent(extension, id, handler) {
            const handle = $Epc.b++;
            const agent = new ExtHostChatAgent(extension, id, this.g, handle, handler);
            this.c.set(handle, agent);
            this.g.$registerAgent(handle, extension.identifier, id, {}, undefined);
            return agent.apiAgent;
        }
        createDynamicChatAgent(extension, id, dynamicProps, handler) {
            const handle = $Epc.b++;
            const agent = new ExtHostChatAgent(extension, id, this.g, handle, handler);
            this.c.set(handle, agent);
            this.g.$registerAgent(handle, extension.identifier, id, { isSticky: true }, dynamicProps);
            return agent.apiAgent;
        }
        async $invokeAgent(handle, requestDto, context, token) {
            const agent = this.c.get(handle);
            if (!agent) {
                throw new Error(`[CHAT](${handle}) CANNOT invoke agent because the agent is not registered`);
            }
            const request = (0, marshalling_1.$ci)(requestDto);
            // Init session disposables
            let sessionDisposables = this.j.get(request.sessionId);
            if (!sessionDisposables) {
                sessionDisposables = new lifecycle_1.$Tc();
                this.j.set(request.sessionId, sessionDisposables);
            }
            const stream = new ChatAgentResponseStream(agent.extension, request, this.g, this.s.converter, sessionDisposables);
            try {
                const convertedHistory = await this.u(request.agentId, context);
                // in-place converting for location-data
                let location2;
                if (request.locationData?.type === chatAgents_1.ChatAgentLocation.Editor) {
                    // editor data
                    const document = this.t.getDocument(request.locationData.document);
                    location2 = new extHostTypes.$2P(document, typeConvert.Selection.to(request.locationData.selection), typeConvert.Range.to(request.locationData.wholeRange));
                }
                else if (request.locationData?.type === chatAgents_1.ChatAgentLocation.Notebook) {
                    // notebook data
                    const cell = this.t.getDocument(request.locationData.sessionInputUri);
                    location2 = new extHostTypes.$3P(cell);
                }
                else if (request.locationData?.type === chatAgents_1.ChatAgentLocation.Terminal) {
                    // TBD
                }
                const task = agent.invoke(typeConvert.ChatAgentRequest.to(request, location2), { history: convertedHistory }, stream.apiObject, token);
                return await (0, async_1.$th)(Promise.resolve(task).then((result) => {
                    if (result?.metadata) {
                        try {
                            JSON.stringify(result.metadata);
                        }
                        catch (err) {
                            const msg = `result.metadata MUST be JSON.stringify-able. Got error: ${err.message}`;
                            this.n.error(`[${agent.extension.identifier.value}] [@${agent.id}] ${msg}`, agent.extension);
                            return { errorDetails: { message: msg }, timings: stream.timings };
                        }
                    }
                    let errorDetails;
                    if (result?.errorDetails) {
                        errorDetails = {
                            ...result.errorDetails,
                            responseIsIncomplete: true
                        };
                    }
                    if (errorDetails?.responseIsRedacted) {
                        (0, extensions_2.$gH)(agent.extension, 'chatParticipantPrivate');
                    }
                    return { errorDetails, timings: stream.timings, metadata: result?.metadata };
                }), token);
            }
            catch (e) {
                this.n.error(e, agent.extension);
                if (e instanceof extHostTypes.$$P && e.cause) {
                    e = e.cause;
                }
                return { errorDetails: { message: (0, errorMessage_1.$qj)(e), responseIsIncomplete: true } };
            }
            finally {
                stream.close();
            }
        }
        async u(agentId, context) {
            const res = [];
            for (const h of context.history) {
                const ehResult = typeConvert.ChatAgentResult.to(h.result);
                const result = agentId === h.request.agentId ?
                    ehResult :
                    { ...ehResult, metadata: undefined };
                // REQUEST turn
                const varsWithoutTools = h.request.variables.variables
                    .filter(v => !v.isTool)
                    .map(typeConvert.ChatAgentValueReference.to);
                res.push(new extHostTypes.$ZP(h.request.message, h.request.command, varsWithoutTools, h.request.agentId));
                // RESPONSE turn
                const parts = (0, arrays_1.$Gb)(h.response.map(r => typeConvert.ChatResponsePart.toContent(r, this.s.converter)));
                res.push(new extHostTypes.$1P(parts, result, h.request.agentId, h.request.command));
            }
            return res;
        }
        $releaseSession(sessionId) {
            this.j.deleteAndDispose(sessionId);
        }
        async $provideFollowups(requestDto, handle, result, context, token) {
            const agent = this.c.get(handle);
            if (!agent) {
                return Promise.resolve([]);
            }
            const request = (0, marshalling_1.$ci)(requestDto);
            const convertedHistory = await this.u(agent.id, context);
            const ehResult = typeConvert.ChatAgentResult.to(result);
            return (await agent.provideFollowups(ehResult, { history: convertedHistory }, token))
                .filter(f => {
                // The followup must refer to a participant that exists from the same extension
                const isValid = !f.participant || iterator_1.Iterable.some(this.c.values(), a => a.id === f.participant && extensions_1.$rn.equals(a.extension.identifier, agent.extension.identifier));
                if (!isValid) {
                    this.n.warn(`[@${agent.id}] ChatFollowup refers to an unknown participant: ${f.participant}`);
                }
                return isValid;
            })
                .map(f => typeConvert.ChatFollowup.from(f, request));
        }
        $acceptFeedback(handle, result, vote, reportIssue) {
            const agent = this.c.get(handle);
            if (!agent) {
                return;
            }
            const ehResult = typeConvert.ChatAgentResult.to(result);
            let kind;
            switch (vote) {
                case chatService_1.ChatAgentVoteDirection.Down:
                    kind = extHostTypes.ChatResultFeedbackKind.Unhelpful;
                    break;
                case chatService_1.ChatAgentVoteDirection.Up:
                    kind = extHostTypes.ChatResultFeedbackKind.Helpful;
                    break;
            }
            agent.acceptFeedback(reportIssue ?
                Object.freeze({ result: ehResult, kind, reportIssue }) :
                Object.freeze({ result: ehResult, kind }));
        }
        $acceptAction(handle, result, event) {
            const agent = this.c.get(handle);
            if (!agent) {
                return;
            }
            if (event.action.kind === 'vote') {
                // handled by $acceptFeedback
                return;
            }
            const ehAction = typeConvert.ChatAgentUserActionEvent.to(result, event, this.s.converter);
            if (ehAction) {
                agent.acceptAction(Object.freeze(ehAction));
            }
        }
        async $invokeCompletionProvider(handle, query, token) {
            const agent = this.c.get(handle);
            if (!agent) {
                return [];
            }
            let disposables = this.m.get(handle);
            if (disposables) {
                // Clear any disposables from the last invocation of this completion provider
                disposables.clear();
            }
            else {
                disposables = new lifecycle_1.$Tc();
                this.m.set(handle, disposables);
            }
            const items = await agent.invokeCompletionProvider(query, token);
            return items.map((i) => typeConvert.ChatAgentCompletionItem.from(i, this.s.converter, disposables));
        }
        async $provideWelcomeMessage(handle, location, token) {
            const agent = this.c.get(handle);
            if (!agent) {
                return;
            }
            return await agent.provideWelcomeMessage(typeConvert.ChatLocation.to(location), token);
        }
        async $provideSampleQuestions(handle, location, token) {
            const agent = this.c.get(handle);
            if (!agent) {
                return;
            }
            return (await agent.provideSampleQuestions(typeConvert.ChatLocation.to(location), token))
                .map(f => typeConvert.ChatFollowup.from(f, undefined));
        }
    }
    exports.$Epc = $Epc;
    class ExtHostChatAgent {
        constructor(extension, id, w, x, y) {
            this.extension = extension;
            this.id = id;
            this.w = w;
            this.x = x;
            this.y = y;
            this.m = new event_1.$le();
            this.n = new event_1.$le();
        }
        acceptFeedback(feedback) {
            this.m.fire(feedback);
        }
        acceptAction(event) {
            this.n.fire(event);
        }
        async invokeCompletionProvider(query, token) {
            if (!this.q) {
                return [];
            }
            return await this.q.provider.provideCompletionItems(query, token) ?? [];
        }
        async provideFollowups(result, context, token) {
            if (!this.b) {
                return [];
            }
            const followups = await this.b.provideFollowups(result, context, token);
            if (!followups) {
                return [];
            }
            return followups
                // Filter out "command followups" from older providers
                .filter(f => !(f && 'commandId' in f))
                // Filter out followups from older providers before 'message' changed to 'prompt'
                .filter(f => !(f && 'message' in f));
        }
        async provideWelcomeMessage(location, token) {
            if (!this.s) {
                return [];
            }
            const content = await this.s.provideWelcomeMessage(location, token);
            if (!content) {
                return [];
            }
            return content.map(item => {
                if (typeof item === 'string') {
                    return item;
                }
                else {
                    return typeConvert.MarkdownString.from(item);
                }
            });
        }
        async provideSampleQuestions(location, token) {
            if (!this.s || !this.s.provideSampleQuestions) {
                return [];
            }
            const content = await this.s.provideSampleQuestions(location, token);
            if (!content) {
                return [];
            }
            return content;
        }
        get apiAgent() {
            let disposed = false;
            let updateScheduled = false;
            const updateMetadataSoon = () => {
                if (disposed) {
                    return;
                }
                if (updateScheduled) {
                    return;
                }
                updateScheduled = true;
                queueMicrotask(() => {
                    this.w.$updateAgent(this.x, {
                        icon: !this.c ? undefined :
                            this.c instanceof uri_1.URI ? this.c :
                                'light' in this.c ? this.c.light :
                                    undefined,
                        iconDark: !this.c ? undefined :
                            'dark' in this.c ? this.c.dark :
                                undefined,
                        themeIcon: this.c instanceof extHostTypes.$LO ? this.c : undefined,
                        hasFollowups: this.b !== undefined,
                        isSecondary: this.l,
                        helpTextPrefix: (!this.g || typeof this.g === 'string') ? this.g : typeConvert.MarkdownString.from(this.g),
                        helpTextVariablesPrefix: (!this.j || typeof this.j === 'string') ? this.j : typeConvert.MarkdownString.from(this.j),
                        helpTextPostfix: (!this.k || typeof this.k === 'string') ? this.k : typeConvert.MarkdownString.from(this.k),
                        supportIssueReporting: this.o,
                        requester: this.t,
                        supportsSlowVariables: this.u,
                    });
                    updateScheduled = false;
                });
            };
            const that = this;
            return {
                get id() {
                    return that.id;
                },
                get iconPath() {
                    return that.c;
                },
                set iconPath(v) {
                    that.c = v;
                    updateMetadataSoon();
                },
                get requestHandler() {
                    return that.y;
                },
                set requestHandler(v) {
                    (0, types_1.$og)(typeof v === 'function', 'Invalid request handler');
                    that.y = v;
                },
                get followupProvider() {
                    return that.b;
                },
                set followupProvider(v) {
                    that.b = v;
                    updateMetadataSoon();
                },
                get isDefault() {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    return that.d;
                },
                set isDefault(v) {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    that.d = v;
                    updateMetadataSoon();
                },
                get helpTextPrefix() {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    return that.g;
                },
                set helpTextPrefix(v) {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    that.g = v;
                    updateMetadataSoon();
                },
                get helpTextVariablesPrefix() {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    return that.j;
                },
                set helpTextVariablesPrefix(v) {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    that.j = v;
                    updateMetadataSoon();
                },
                get helpTextPostfix() {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    return that.k;
                },
                set helpTextPostfix(v) {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    that.k = v;
                    updateMetadataSoon();
                },
                get isSecondary() {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    return that.l;
                },
                set isSecondary(v) {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    that.l = v;
                    updateMetadataSoon();
                },
                get supportIssueReporting() {
                    (0, extensions_2.$gH)(that.extension, 'chatParticipantPrivate');
                    return that.o;
                },
                set supportIssueReporting(v) {
                    (0, extensions_2.$gH)(that.extension, 'chatParticipantPrivate');
                    that.o = v;
                    updateMetadataSoon();
                },
                get onDidReceiveFeedback() {
                    return that.m.event;
                },
                set participantVariableProvider(v) {
                    (0, extensions_2.$gH)(that.extension, 'chatParticipantAdditions');
                    that.q = v;
                    if (v) {
                        if (!v.triggerCharacters.length) {
                            throw new Error('triggerCharacters are required');
                        }
                        that.w.$registerAgentCompletionsProvider(that.x, that.id, v.triggerCharacters);
                    }
                    else {
                        that.w.$unregisterAgentCompletionsProvider(that.x, that.id);
                    }
                },
                get participantVariableProvider() {
                    (0, extensions_2.$gH)(that.extension, 'chatParticipantAdditions');
                    return that.q;
                },
                set welcomeMessageProvider(v) {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    that.s = v;
                    updateMetadataSoon();
                },
                get welcomeMessageProvider() {
                    (0, extensions_2.$gH)(that.extension, 'defaultChatParticipant');
                    return that.s;
                },
                onDidPerformAction: !(0, extensions_2.$fH)(this.extension, 'chatParticipantAdditions')
                    ? undefined
                    : this.n.event,
                set requester(v) {
                    that.t = v;
                    updateMetadataSoon();
                },
                get requester() {
                    return that.t;
                },
                set supportsSlowReferences(v) {
                    (0, extensions_2.$gH)(that.extension, 'chatParticipantPrivate');
                    that.u = v;
                    updateMetadataSoon();
                },
                get supportsSlowReferences() {
                    (0, extensions_2.$gH)(that.extension, 'chatParticipantPrivate');
                    return that.u;
                },
                dispose() {
                    disposed = true;
                    that.b = undefined;
                    that.m.dispose();
                    that.w.$unregisterAgent(that.x);
                },
            };
        }
        invoke(request, context, response, token) {
            return this.y(request, context, response, token);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[234/*vs/workbench/api/common/extHostChatVariables*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,4/*vs/base/common/lifecycle*/,34/*vs/base/common/themables*/,5/*vs/workbench/api/common/extHost.protocol*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, errors_1, lifecycle_1, themables_1, extHost_protocol_1, typeConvert, extHostTypes, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Fpc = void 0;
    typeConvert = __importStar(typeConvert);
    extHostTypes = __importStar(extHostTypes);
    class $Fpc {
        static { this.a = 0; }
        constructor(mainContext) {
            this.b = new Map();
            this.c = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadChatVariables);
        }
        async $resolveVariable(handle, requestId, messageText, token) {
            const item = this.b.get(handle);
            if (!item) {
                return undefined;
            }
            try {
                if (item.resolver.resolve2) {
                    (0, extensions_1.$gH)(item.extension, 'chatParticipantAdditions');
                    const stream = new ChatVariableResolverResponseStream(requestId, this.c);
                    const value = await item.resolver.resolve2(item.data.name, { prompt: messageText }, stream.apiObject, token);
                    // Temp, ignoring other returned values to convert the array into a single value
                    if (value && value[0]) {
                        return value[0].value;
                    }
                }
                else {
                    const value = await item.resolver.resolve(item.data.name, { prompt: messageText }, token);
                    if (value && value[0]) {
                        return value[0].value;
                    }
                }
            }
            catch (err) {
                (0, errors_1.$Z)(err);
            }
            return undefined;
        }
        registerVariableResolver(extension, id, name, userDescription, modelDescription, isSlow, resolver, fullName, themeIconId) {
            const handle = $Fpc.a++;
            const icon = themeIconId ? themables_1.ThemeIcon.fromId(themeIconId) : undefined;
            this.b.set(handle, { extension, data: { id, name, description: userDescription, modelDescription, icon }, resolver: resolver });
            this.c.$registerVariable(handle, { id, name, description: userDescription, modelDescription, isSlow, fullName, icon });
            return (0, lifecycle_1.$Sc)(() => {
                this.b.delete(handle);
                this.c.$unregisterVariable(handle);
            });
        }
    }
    exports.$Fpc = $Fpc;
    class ChatVariableResolverResponseStream {
        constructor(c, d) {
            this.c = c;
            this.d = d;
            this.a = false;
        }
        close() {
            this.a = true;
        }
        get apiObject() {
            if (!this.b) {
                const that = this;
                function throwIfDone(source) {
                    if (that.a) {
                        const err = new Error('Response stream has been closed');
                        Error.captureStackTrace(err, source);
                        throw err;
                    }
                }
                const _report = (progress) => {
                    this.d.$handleProgressChunk(this.c, progress);
                };
                this.b = {
                    progress(value) {
                        throwIfDone(this.progress);
                        const part = new extHostTypes.$SP(value);
                        const dto = typeConvert.ChatResponseProgressPart.from(part);
                        _report(dto);
                        return this;
                    },
                    reference(value) {
                        throwIfDone(this.reference);
                        const part = new extHostTypes.$WP(value);
                        const dto = typeConvert.ChatResponseReferencePart.from(part);
                        _report(dto);
                        return this;
                    },
                    push(part) {
                        throwIfDone(this.push);
                        if (part instanceof extHostTypes.$WP) {
                            _report(typeConvert.ChatResponseReferencePart.from(part));
                        }
                        else if (part instanceof extHostTypes.$SP) {
                            _report(typeConvert.ChatResponseProgressPart.from(part));
                        }
                        return this;
                    }
                };
            }
            return this.b;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





























define(__m[235/*vs/workbench/api/common/extHostComments*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,71/*vs/base/common/decorators*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,37/*vs/base/common/marshallingIds*/,2/*vs/base/common/uri*/,93/*vs/editor/common/languages*/,18/*vs/platform/extensions/common/extensions*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,5/*vs/workbench/api/common/extHost.protocol*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, async_1, decorators_1, event_1, lifecycle_1, marshallingIds_1, uri_1, languages, extensions_1, extHostTypeConverter, types, extHost_protocol_1, extensions_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Jpc = $Jpc;
    languages = __importStar(languages);
    extHostTypeConverter = __importStar(extHostTypeConverter);
    types = __importStar(types);
    function $Jpc(mainContext, commands, documents) {
        const proxy = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadComments);
        class ExtHostCommentsImpl {
            static { this.a = 0; }
            constructor() {
                this.b = new Map();
                this.c = new extensions_1.$tn();
                commands.registerArgumentProcessor({
                    processArgument: arg => {
                        if (arg && arg.$mid === marshallingIds_1.MarshalledId.CommentController) {
                            const commentController = this.b.get(arg.handle);
                            if (!commentController) {
                                return arg;
                            }
                            return commentController.value;
                        }
                        else if (arg && arg.$mid === marshallingIds_1.MarshalledId.CommentThread) {
                            const marshalledCommentThread = arg;
                            const commentController = this.b.get(marshalledCommentThread.commentControlHandle);
                            if (!commentController) {
                                return marshalledCommentThread;
                            }
                            const commentThread = commentController.getCommentThread(marshalledCommentThread.commentThreadHandle);
                            if (!commentThread) {
                                return marshalledCommentThread;
                            }
                            return commentThread.value;
                        }
                        else if (arg && (arg.$mid === marshallingIds_1.MarshalledId.CommentThreadReply || arg.$mid === marshallingIds_1.MarshalledId.CommentThreadInstance)) {
                            const commentController = this.b.get(arg.thread.commentControlHandle);
                            if (!commentController) {
                                return arg;
                            }
                            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
                            if (!commentThread) {
                                return arg;
                            }
                            if (arg.$mid === marshallingIds_1.MarshalledId.CommentThreadInstance) {
                                return commentThread.value;
                            }
                            return {
                                thread: commentThread.value,
                                text: arg.text
                            };
                        }
                        else if (arg && arg.$mid === marshallingIds_1.MarshalledId.CommentNode) {
                            const commentController = this.b.get(arg.thread.commentControlHandle);
                            if (!commentController) {
                                return arg;
                            }
                            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
                            if (!commentThread) {
                                return arg;
                            }
                            const commentUniqueId = arg.commentUniqueId;
                            const comment = commentThread.getCommentByUniqueId(commentUniqueId);
                            if (!comment) {
                                return arg;
                            }
                            return comment;
                        }
                        else if (arg && arg.$mid === marshallingIds_1.MarshalledId.CommentThreadNode) {
                            const commentController = this.b.get(arg.thread.commentControlHandle);
                            if (!commentController) {
                                return arg;
                            }
                            const commentThread = commentController.getCommentThread(arg.thread.commentThreadHandle);
                            if (!commentThread) {
                                return arg;
                            }
                            const body = arg.text;
                            const commentUniqueId = arg.commentUniqueId;
                            const comment = commentThread.getCommentByUniqueId(commentUniqueId);
                            if (!comment) {
                                return arg;
                            }
                            // If the old comment body was a markdown string, use a markdown string here too.
                            if (typeof comment.body === 'string') {
                                comment.body = body;
                            }
                            else {
                                comment.body = new types.$eO(body);
                            }
                            return comment;
                        }
                        return arg;
                    }
                });
            }
            createCommentController(extension, id, label) {
                const handle = ExtHostCommentsImpl.a++;
                const commentController = new ExtHostCommentController(extension, handle, id, label);
                this.b.set(commentController.handle, commentController);
                const commentControllers = this.c.get(extension.identifier) || [];
                commentControllers.push(commentController);
                this.c.set(extension.identifier, commentControllers);
                return commentController.value;
            }
            async $createCommentThreadTemplate(commentControllerHandle, uriComponents, range, editorId) {
                const commentController = this.b.get(commentControllerHandle);
                if (!commentController) {
                    return;
                }
                commentController.$createCommentThreadTemplate(uriComponents, range, editorId);
            }
            async $setActiveComment(controllerHandle, commentInfo) {
                const commentController = this.b.get(controllerHandle);
                if (!commentController) {
                    return;
                }
                commentController.$setActiveComment(commentInfo ?? undefined);
            }
            async $updateCommentThreadTemplate(commentControllerHandle, threadHandle, range) {
                const commentController = this.b.get(commentControllerHandle);
                if (!commentController) {
                    return;
                }
                commentController.$updateCommentThreadTemplate(threadHandle, range);
            }
            $deleteCommentThread(commentControllerHandle, commentThreadHandle) {
                const commentController = this.b.get(commentControllerHandle);
                commentController?.$deleteCommentThread(commentThreadHandle);
            }
            async $provideCommentingRanges(commentControllerHandle, uriComponents, token) {
                const commentController = this.b.get(commentControllerHandle);
                if (!commentController || !commentController.commentingRangeProvider) {
                    return Promise.resolve(undefined);
                }
                const document = await documents.ensureDocumentData(uri_1.URI.revive(uriComponents));
                return (0, async_1.$xh)(async () => {
                    const rangesResult = await commentController.commentingRangeProvider.provideCommentingRanges(document.document, token);
                    let ranges;
                    if (Array.isArray(rangesResult)) {
                        ranges = {
                            ranges: rangesResult,
                            fileComments: false
                        };
                    }
                    else if (rangesResult) {
                        ranges = {
                            ranges: rangesResult.ranges || [],
                            fileComments: rangesResult.enableFileComments || false
                        };
                    }
                    else {
                        ranges = rangesResult ?? undefined;
                    }
                    return ranges;
                }).then(ranges => {
                    let convertedResult = undefined;
                    if (ranges) {
                        convertedResult = {
                            ranges: ranges.ranges.map(x => extHostTypeConverter.Range.from(x)),
                            fileComments: ranges.fileComments
                        };
                    }
                    return convertedResult;
                });
            }
            $toggleReaction(commentControllerHandle, threadHandle, uri, comment, reaction) {
                const commentController = this.b.get(commentControllerHandle);
                if (!commentController || !commentController.reactionHandler) {
                    return Promise.resolve(undefined);
                }
                return (0, async_1.$xh)(() => {
                    const commentThread = commentController.getCommentThread(threadHandle);
                    if (commentThread) {
                        const vscodeComment = commentThread.getCommentByUniqueId(comment.uniqueIdInThread);
                        if (commentController !== undefined && vscodeComment) {
                            if (commentController.reactionHandler) {
                                return commentController.reactionHandler(vscodeComment, convertFromReaction(reaction));
                            }
                        }
                    }
                    return Promise.resolve(undefined);
                });
            }
        }
        class ExtHostCommentThread {
            static { this.a = 0; }
            set threadId(id) {
                this.n = id;
            }
            get threadId() {
                return this.n;
            }
            get id() {
                return this.n;
            }
            get resource() {
                return this.o;
            }
            get uri() {
                return this.o;
            }
            set range(range) {
                if (((range === undefined) !== (this.p === undefined)) || (!range || !this.p || !range.isEqual(this.p))) {
                    this.p = range;
                    this.b.range = range;
                    this.c.fire();
                }
            }
            get range() {
                return this.p;
            }
            set canReply(state) {
                if (this.d !== state) {
                    this.d = state;
                    this.b.canReply = state;
                    this.c.fire();
                }
            }
            get canReply() {
                return this.d;
            }
            get label() {
                return this.e;
            }
            set label(label) {
                this.e = label;
                this.b.label = label;
                this.c.fire();
            }
            get contextValue() {
                return this.f;
            }
            set contextValue(context) {
                this.f = context;
                this.b.contextValue = context;
                this.c.fire();
            }
            get comments() {
                return this.q;
            }
            set comments(newComments) {
                this.q = newComments;
                this.b.comments = newComments;
                this.c.fire();
            }
            get collapsibleState() {
                return this.g;
            }
            set collapsibleState(newState) {
                this.g = newState;
                this.b.collapsibleState = newState;
                this.c.fire();
            }
            get state() {
                return this.h;
            }
            set state(newState) {
                this.h = newState;
                if (typeof newState === 'object') {
                    (0, extensions_2.$gH)(this.extensionDescription, 'commentThreadApplicability');
                    this.b.state = newState.resolved;
                    this.b.applicability = newState.applicability;
                }
                else {
                    this.b.state = newState;
                }
                this.c.fire();
            }
            get isDisposed() {
                return this.j;
            }
            constructor(commentControllerId, m, n, o, p, q, extensionDescription, r, editorId) {
                this.m = m;
                this.n = n;
                this.o = o;
                this.p = p;
                this.q = q;
                this.extensionDescription = extensionDescription;
                this.r = r;
                this.handle = ExtHostCommentThread.a++;
                this.commentHandle = 0;
                this.b = Object.create(null);
                this.c = new event_1.$le();
                this.onDidUpdateCommentThread = this.c.event;
                this.d = true;
                this.k = new Map();
                this.l = new lifecycle_1.$Vc();
                this.l.value = new lifecycle_1.$Tc();
                if (this.n === undefined) {
                    this.n = `${commentControllerId}.${this.handle}`;
                }
                proxy.$createCommentThread(m, this.handle, this.n, this.o, extHostTypeConverter.Range.from(this.p), this.q.map(cmt => convertToDTOComment(this, cmt, this.k, this.extensionDescription)), extensionDescription.identifier, this.r, editorId);
                this.i = [];
                this.j = false;
                this.i.push(this.onDidUpdateCommentThread(() => {
                    this.eventuallyUpdateCommentThread();
                }));
                this.i.push({
                    dispose: () => {
                        proxy.$deleteCommentThread(m, this.handle);
                    }
                });
                const that = this;
                this.value = {
                    get uri() { return that.uri; },
                    get range() { return that.range; },
                    set range(value) { that.range = value; },
                    get comments() { return that.comments; },
                    set comments(value) { that.comments = value; },
                    get collapsibleState() { return that.collapsibleState; },
                    set collapsibleState(value) { that.collapsibleState = value; },
                    get canReply() { return that.canReply; },
                    set canReply(state) { that.canReply = state; },
                    get contextValue() { return that.contextValue; },
                    set contextValue(value) { that.contextValue = value; },
                    get label() { return that.label; },
                    set label(value) { that.label = value; },
                    get state() { return that.state; },
                    set state(value) { that.state = value; },
                    reveal: (comment, options) => that.reveal(comment, options),
                    hide: () => that.hide(),
                    dispose: () => {
                        that.dispose();
                    }
                };
            }
            s() {
                if (this.r) {
                    this.r = false;
                    this.b.isTemplate = false;
                }
            }
            eventuallyUpdateCommentThread() {
                if (this.j) {
                    return;
                }
                this.s();
                if (!this.l.value) {
                    this.l.value = new lifecycle_1.$Tc();
                }
                const modified = (value) => Object.prototype.hasOwnProperty.call(this.b, value);
                const formattedModifications = {};
                if (modified('range')) {
                    formattedModifications.range = extHostTypeConverter.Range.from(this.p);
                }
                if (modified('label')) {
                    formattedModifications.label = this.label;
                }
                if (modified('contextValue')) {
                    /*
                     * null -> cleared contextValue
                     * undefined -> no change
                     */
                    formattedModifications.contextValue = this.contextValue ?? null;
                }
                if (modified('comments')) {
                    formattedModifications.comments =
                        this.q.map(cmt => convertToDTOComment(this, cmt, this.k, this.extensionDescription));
                }
                if (modified('collapsibleState')) {
                    formattedModifications.collapseState = convertToCollapsibleState(this.g);
                }
                if (modified('canReply')) {
                    formattedModifications.canReply = this.canReply;
                }
                if (modified('state')) {
                    formattedModifications.state = convertToState(this.h);
                }
                if (modified('applicability')) {
                    formattedModifications.applicability = convertToRelevance(this.h);
                }
                if (modified('isTemplate')) {
                    formattedModifications.isTemplate = this.r;
                }
                this.b = {};
                proxy.$updateCommentThread(this.m, this.handle, this.n, this.o, formattedModifications);
            }
            getCommentByUniqueId(uniqueId) {
                for (const key of this.k) {
                    const comment = key[0];
                    const id = key[1];
                    if (uniqueId === id) {
                        return comment;
                    }
                }
                return;
            }
            async reveal(commentOrOptions, options) {
                (0, extensions_2.$gH)(this.extensionDescription, 'commentReveal');
                let comment;
                if (commentOrOptions && commentOrOptions.body !== undefined) {
                    comment = commentOrOptions;
                }
                else {
                    options = options ?? commentOrOptions;
                }
                let commentToReveal = comment ? this.k.get(comment) : undefined;
                commentToReveal ??= this.k.get(this.q[0]);
                let preserveFocus = true;
                let focusReply = false;
                if (options?.focus === types.CommentThreadFocus.Reply) {
                    focusReply = true;
                    preserveFocus = false;
                }
                else if (options?.focus === types.CommentThreadFocus.Comment) {
                    preserveFocus = false;
                }
                return proxy.$revealCommentThread(this.m, this.handle, commentToReveal, { preserveFocus, focusReply });
            }
            async hide() {
                return proxy.$hideCommentThread(this.m, this.handle);
            }
            dispose() {
                this.j = true;
                this.l.dispose();
                this.i.forEach(disposable => disposable.dispose());
            }
        }
        __decorate([
            (0, decorators_1.$$h)(100)
        ], ExtHostCommentThread.prototype, "eventuallyUpdateCommentThread", null);
        class ExtHostCommentController {
            get id() {
                return this.j;
            }
            get label() {
                return this.k;
            }
            get handle() {
                return this.i;
            }
            get commentingRangeProvider() {
                return this.b;
            }
            set commentingRangeProvider(provider) {
                this.b = provider;
                if (provider?.resourceHints) {
                    (0, extensions_2.$gH)(this.h, 'commentingRangeHint');
                }
                proxy.$updateCommentingRanges(this.handle, provider?.resourceHints);
            }
            get reactionHandler() {
                return this.c;
            }
            set reactionHandler(handler) {
                this.c = handler;
                proxy.$updateCommentControllerFeatures(this.handle, { reactionHandler: !!handler });
            }
            get options() {
                return this.d;
            }
            set options(options) {
                this.d = options;
                proxy.$updateCommentControllerFeatures(this.handle, { options: this.d });
            }
            get activeComment() {
                (0, extensions_2.$gH)(this.h, 'activeComment');
                return this.e;
            }
            get activeCommentThread() {
                (0, extensions_2.$gH)(this.h, 'activeComment');
                return this.f;
            }
            constructor(h, i, j, k) {
                this.h = h;
                this.i = i;
                this.j = j;
                this.k = k;
                this.a = new Map();
                proxy.$registerCommentController(this.handle, j, k, this.h.identifier.value);
                const that = this;
                this.value = Object.freeze({
                    id: that.id,
                    label: that.label,
                    get options() { return that.options; },
                    set options(options) { that.options = options; },
                    get commentingRangeProvider() { return that.commentingRangeProvider; },
                    set commentingRangeProvider(commentingRangeProvider) { that.commentingRangeProvider = commentingRangeProvider; },
                    get reactionHandler() { return that.reactionHandler; },
                    set reactionHandler(handler) { that.reactionHandler = handler; },
                    // get activeComment(): vscode.Comment | undefined { return that.activeComment; },
                    get activeCommentThread() { return that.activeCommentThread; },
                    createCommentThread(uri, range, comments) {
                        return that.createCommentThread(uri, range, comments).value;
                    },
                    dispose: () => { that.dispose(); },
                }); // TODO @alexr00 remove this cast when the proposed API is stable
                this.g = [];
                this.g.push({
                    dispose: () => {
                        proxy.$unregisterCommentController(this.handle);
                    }
                });
            }
            createCommentThread(resource, range, comments) {
                if (range === undefined) {
                    (0, extensions_2.$gH)(this.h, 'fileComments');
                }
                const commentThread = new ExtHostCommentThread(this.id, this.handle, undefined, resource, range, comments, this.h, false);
                this.a.set(commentThread.handle, commentThread);
                return commentThread;
            }
            $setActiveComment(commentInfo) {
                if (!commentInfo) {
                    this.e = undefined;
                    this.f = undefined;
                    return;
                }
                const thread = this.a.get(commentInfo.commentThreadHandle);
                if (thread) {
                    this.e = commentInfo.uniqueIdInThread ? thread.getCommentByUniqueId(commentInfo.uniqueIdInThread) : undefined;
                    this.f = thread;
                }
            }
            $createCommentThreadTemplate(uriComponents, range, editorId) {
                const commentThread = new ExtHostCommentThread(this.id, this.handle, undefined, uri_1.URI.revive(uriComponents), extHostTypeConverter.Range.to(range), [], this.h, true, editorId);
                commentThread.collapsibleState = languages.CommentThreadCollapsibleState.Expanded;
                this.a.set(commentThread.handle, commentThread);
                return commentThread;
            }
            $updateCommentThreadTemplate(threadHandle, range) {
                const thread = this.a.get(threadHandle);
                if (thread) {
                    thread.range = extHostTypeConverter.Range.to(range);
                }
            }
            $deleteCommentThread(threadHandle) {
                const thread = this.a.get(threadHandle);
                thread?.dispose();
                this.a.delete(threadHandle);
            }
            getCommentThread(handle) {
                return this.a.get(handle);
            }
            dispose() {
                this.a.forEach(value => {
                    value.dispose();
                });
                this.g.forEach(disposable => disposable.dispose());
            }
        }
        function convertToDTOComment(thread, vscodeComment, commentsMap, extension) {
            let commentUniqueId = commentsMap.get(vscodeComment);
            if (!commentUniqueId) {
                commentUniqueId = ++thread.commentHandle;
                commentsMap.set(vscodeComment, commentUniqueId);
            }
            if (vscodeComment.state !== undefined) {
                (0, extensions_2.$gH)(extension, 'commentsDraftState');
            }
            if (vscodeComment.reactions?.some(reaction => reaction.reactors !== undefined)) {
                (0, extensions_2.$gH)(extension, 'commentReactor');
            }
            return {
                mode: vscodeComment.mode,
                contextValue: vscodeComment.contextValue,
                uniqueIdInThread: commentUniqueId,
                body: (typeof vscodeComment.body === 'string') ? vscodeComment.body : extHostTypeConverter.MarkdownString.from(vscodeComment.body),
                userName: vscodeComment.author.name,
                userIconPath: vscodeComment.author.iconPath,
                label: vscodeComment.label,
                commentReactions: vscodeComment.reactions ? vscodeComment.reactions.map(reaction => convertToReaction(reaction)) : undefined,
                state: vscodeComment.state,
                timestamp: vscodeComment.timestamp?.toJSON()
            };
        }
        function convertToReaction(reaction) {
            return {
                label: reaction.label,
                iconPath: reaction.iconPath ? extHostTypeConverter.$jQ(reaction.iconPath) : undefined,
                count: reaction.count,
                hasReacted: reaction.authorHasReacted,
                reactors: ((reaction.reactors && (reaction.reactors.length > 0) && (typeof reaction.reactors[0] !== 'string')) ? reaction.reactors.map(reactor => reactor.name) : reaction.reactors)
            };
        }
        function convertFromReaction(reaction) {
            return {
                label: reaction.label || '',
                count: reaction.count || 0,
                iconPath: reaction.iconPath ? uri_1.URI.revive(reaction.iconPath) : '',
                authorHasReacted: reaction.hasReacted || false,
                reactors: reaction.reactors?.map(reactor => ({ name: reactor }))
            };
        }
        function convertToCollapsibleState(kind) {
            if (kind !== undefined) {
                switch (kind) {
                    case types.CommentThreadCollapsibleState.Expanded:
                        return languages.CommentThreadCollapsibleState.Expanded;
                    case types.CommentThreadCollapsibleState.Collapsed:
                        return languages.CommentThreadCollapsibleState.Collapsed;
                }
            }
            return languages.CommentThreadCollapsibleState.Collapsed;
        }
        function convertToState(kind) {
            let resolvedKind;
            if (typeof kind === 'object') {
                resolvedKind = kind.resolved;
            }
            else {
                resolvedKind = kind;
            }
            if (resolvedKind !== undefined) {
                switch (resolvedKind) {
                    case types.CommentThreadState.Unresolved:
                        return languages.CommentThreadState.Unresolved;
                    case types.CommentThreadState.Resolved:
                        return languages.CommentThreadState.Resolved;
                }
            }
            return languages.CommentThreadState.Unresolved;
        }
        function convertToRelevance(kind) {
            let applicabilityKind = undefined;
            if (typeof kind === 'object') {
                applicabilityKind = kind.applicability;
            }
            if (applicabilityKind !== undefined) {
                switch (applicabilityKind) {
                    case types.CommentThreadApplicability.Current:
                        return languages.CommentThreadApplicability.Current;
                    case types.CommentThreadApplicability.Outdated:
                        return languages.CommentThreadApplicability.Outdated;
                }
            }
            return languages.CommentThreadApplicability.Current;
        }
        return new ExtHostCommentsImpl();
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[236/*vs/workbench/api/common/extHostCustomEditors*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/cancellation*/,75/*vs/base/common/hash*/,4/*vs/base/common/lifecycle*/,15/*vs/base/common/network*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,8/*vs/workbench/api/common/extHostTypeConverters*/,67/*vs/workbench/api/common/extHostWebview*/,79/*vs/workbench/api/common/cache*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, cancellation_1, hash_1, lifecycle_1, network_1, resources_1, uri_1, typeConverters, extHostWebview_1, cache_1, extHostProtocol, extHostTypes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$2pc = void 0;
    typeConverters = __importStar(typeConverters);
    extHostProtocol = __importStar(extHostProtocol);
    extHostTypes = __importStar(extHostTypes);
    class CustomDocumentStoreEntry {
        constructor(document, b) {
            this.document = document;
            this.b = b;
            this.a = 1;
            this.c = new cache_1.$ppc('custom documents');
        }
        addEdit(item) {
            return this.c.add([item]);
        }
        async undo(editId, isDirty) {
            await this.f(editId).undo();
            if (!isDirty) {
                this.disposeBackup();
            }
        }
        async redo(editId, isDirty) {
            await this.f(editId).redo();
            if (!isDirty) {
                this.disposeBackup();
            }
        }
        disposeEdits(editIds) {
            for (const id of editIds) {
                this.c.delete(id);
            }
        }
        getNewBackupUri() {
            if (!this.b) {
                throw new Error('Backup requires a valid storage path');
            }
            const fileName = hashPath(this.document.uri) + (this.a++);
            return (0, resources_1.$gh)(this.b, fileName);
        }
        updateBackup(backup) {
            this.d?.delete();
            this.d = backup;
        }
        disposeBackup() {
            this.d?.delete();
            this.d = undefined;
        }
        f(editId) {
            const edit = this.c.get(editId, 0);
            if (!edit) {
                throw new Error('No edit found');
            }
            return edit;
        }
    }
    class CustomDocumentStore {
        constructor() {
            this.a = new Map();
        }
        get(viewType, resource) {
            return this.a.get(this.b(viewType, resource));
        }
        add(viewType, document, storagePath) {
            const key = this.b(viewType, document.uri);
            if (this.a.has(key)) {
                throw new Error(`Document already exists for viewType:${viewType} resource:${document.uri}`);
            }
            const entry = new CustomDocumentStoreEntry(document, storagePath);
            this.a.set(key, entry);
            return entry;
        }
        delete(viewType, document) {
            const key = this.b(viewType, document.uri);
            this.a.delete(key);
        }
        b(viewType, resource) {
            return `${viewType}@@@${resource}`;
        }
    }
    var CustomEditorType;
    (function (CustomEditorType) {
        CustomEditorType[CustomEditorType["Text"] = 0] = "Text";
        CustomEditorType[CustomEditorType["Custom"] = 1] = "Custom";
    })(CustomEditorType || (CustomEditorType = {}));
    class EditorProviderStore {
        constructor() {
            this.a = new Map();
        }
        addTextProvider(viewType, extension, provider) {
            return this.b(viewType, { type: CustomEditorType.Text, extension, provider });
        }
        addCustomProvider(viewType, extension, provider) {
            return this.b(viewType, { type: CustomEditorType.Custom, extension, provider });
        }
        get(viewType) {
            return this.a.get(viewType);
        }
        b(viewType, entry) {
            if (this.a.has(viewType)) {
                throw new Error(`Provider for viewType:${viewType} already registered`);
            }
            this.a.set(viewType, entry);
            return new extHostTypes.$MN(() => this.a.delete(viewType));
        }
    }
    class $2pc {
        constructor(mainContext, d, f, g, h) {
            this.d = d;
            this.f = f;
            this.g = g;
            this.h = h;
            this.b = new EditorProviderStore();
            this.c = new CustomDocumentStore();
            this.a = mainContext.getProxy(extHostProtocol.$KN.MainThreadCustomEditors);
        }
        registerCustomEditorProvider(extension, viewType, provider, options) {
            const disposables = new lifecycle_1.$Tc();
            if (isCustomTextEditorProvider(provider)) {
                disposables.add(this.b.addTextProvider(viewType, extension, provider));
                this.a.$registerTextEditorProvider((0, extHostWebview_1.$Ypc)(extension), viewType, options.webviewOptions || {}, {
                    supportsMove: !!provider.moveCustomTextEditor,
                }, (0, extHostWebview_1.$Wpc)(extension));
            }
            else {
                disposables.add(this.b.addCustomProvider(viewType, extension, provider));
                if (isCustomEditorProviderWithEditingCapability(provider)) {
                    disposables.add(provider.onDidChangeCustomDocument(e => {
                        const entry = this.i(viewType, e.document.uri);
                        if (isEditEvent(e)) {
                            const editId = entry.addEdit(e);
                            this.a.$onDidEdit(e.document.uri, viewType, editId, e.label);
                        }
                        else {
                            this.a.$onContentChange(e.document.uri, viewType);
                        }
                    }));
                }
                this.a.$registerCustomEditorProvider((0, extHostWebview_1.$Ypc)(extension), viewType, options.webviewOptions || {}, !!options.supportsMultipleEditorsPerDocument, (0, extHostWebview_1.$Wpc)(extension));
            }
            return extHostTypes.$MN.from(disposables, new extHostTypes.$MN(() => {
                this.a.$unregisterEditorProvider(viewType);
            }));
        }
        async $createCustomDocument(resource, viewType, backupId, untitledDocumentData, cancellation) {
            const entry = this.b.get(viewType);
            if (!entry) {
                throw new Error(`No provider found for '${viewType}'`);
            }
            if (entry.type !== CustomEditorType.Custom) {
                throw new Error(`Invalid provide type for '${viewType}'`);
            }
            const revivedResource = uri_1.URI.revive(resource);
            const document = await entry.provider.openCustomDocument(revivedResource, { backupId, untitledDocumentData: untitledDocumentData?.buffer }, cancellation);
            let storageRoot;
            if (isCustomEditorProviderWithEditingCapability(entry.provider) && this.f) {
                storageRoot = this.f.workspaceValue(entry.extension) ?? this.f.globalValue(entry.extension);
            }
            this.c.add(viewType, document, storageRoot);
            return { editable: isCustomEditorProviderWithEditingCapability(entry.provider) };
        }
        async $disposeCustomDocument(resource, viewType) {
            const entry = this.b.get(viewType);
            if (!entry) {
                throw new Error(`No provider found for '${viewType}'`);
            }
            if (entry.type !== CustomEditorType.Custom) {
                throw new Error(`Invalid provider type for '${viewType}'`);
            }
            const revivedResource = uri_1.URI.revive(resource);
            const { document } = this.i(viewType, revivedResource);
            this.c.delete(viewType, document);
            document.dispose();
        }
        async $resolveCustomEditor(resource, handle, viewType, initData, position, cancellation) {
            const entry = this.b.get(viewType);
            if (!entry) {
                throw new Error(`No provider found for '${viewType}'`);
            }
            const viewColumn = typeConverters.ViewColumn.to(position);
            const webview = this.g.createNewWebview(handle, initData.contentOptions, entry.extension);
            const panel = this.h.createNewWebviewPanel(handle, viewType, initData.title, viewColumn, initData.options, webview, initData.active);
            const revivedResource = uri_1.URI.revive(resource);
            switch (entry.type) {
                case CustomEditorType.Custom: {
                    const { document } = this.i(viewType, revivedResource);
                    return entry.provider.resolveCustomEditor(document, panel, cancellation);
                }
                case CustomEditorType.Text: {
                    const document = this.d.getDocument(revivedResource);
                    return entry.provider.resolveCustomTextEditor(document, panel, cancellation);
                }
                default: {
                    throw new Error('Unknown webview provider type');
                }
            }
        }
        $disposeEdits(resourceComponents, viewType, editIds) {
            const document = this.i(viewType, resourceComponents);
            document.disposeEdits(editIds);
        }
        async $onMoveCustomEditor(handle, newResourceComponents, viewType) {
            const entry = this.b.get(viewType);
            if (!entry) {
                throw new Error(`No provider found for '${viewType}'`);
            }
            if (!entry.provider.moveCustomTextEditor) {
                throw new Error(`Provider does not implement move '${viewType}'`);
            }
            const webview = this.h.getWebviewPanel(handle);
            if (!webview) {
                throw new Error(`No webview found`);
            }
            const resource = uri_1.URI.revive(newResourceComponents);
            const document = this.d.getDocument(resource);
            await entry.provider.moveCustomTextEditor(document, webview, cancellation_1.CancellationToken.None);
        }
        async $undo(resourceComponents, viewType, editId, isDirty) {
            const entry = this.i(viewType, resourceComponents);
            return entry.undo(editId, isDirty);
        }
        async $redo(resourceComponents, viewType, editId, isDirty) {
            const entry = this.i(viewType, resourceComponents);
            return entry.redo(editId, isDirty);
        }
        async $revert(resourceComponents, viewType, cancellation) {
            const entry = this.i(viewType, resourceComponents);
            const provider = this.j(viewType);
            await provider.revertCustomDocument(entry.document, cancellation);
            entry.disposeBackup();
        }
        async $onSave(resourceComponents, viewType, cancellation) {
            const entry = this.i(viewType, resourceComponents);
            const provider = this.j(viewType);
            await provider.saveCustomDocument(entry.document, cancellation);
            entry.disposeBackup();
        }
        async $onSaveAs(resourceComponents, viewType, targetResource, cancellation) {
            const entry = this.i(viewType, resourceComponents);
            const provider = this.j(viewType);
            return provider.saveCustomDocumentAs(entry.document, uri_1.URI.revive(targetResource), cancellation);
        }
        async $backup(resourceComponents, viewType, cancellation) {
            const entry = this.i(viewType, resourceComponents);
            const provider = this.j(viewType);
            const backup = await provider.backupCustomDocument(entry.document, {
                destination: entry.getNewBackupUri(),
            }, cancellation);
            entry.updateBackup(backup);
            return backup.id;
        }
        i(viewType, resource) {
            const entry = this.c.get(viewType, uri_1.URI.revive(resource));
            if (!entry) {
                throw new Error('No custom document found');
            }
            return entry;
        }
        j(viewType) {
            const entry = this.b.get(viewType);
            const provider = entry?.provider;
            if (!provider || !isCustomEditorProviderWithEditingCapability(provider)) {
                throw new Error('Custom document is not editable');
            }
            return provider;
        }
    }
    exports.$2pc = $2pc;
    function isCustomEditorProviderWithEditingCapability(provider) {
        return !!provider.onDidChangeCustomDocument;
    }
    function isCustomTextEditorProvider(provider) {
        return typeof provider.resolveCustomTextEditor === 'function';
    }
    function isEditEvent(e) {
        return typeof e.undo === 'function'
            && typeof e.redo === 'function';
    }
    function hashPath(resource) {
        const str = resource.scheme === network_1.Schemas.file || resource.scheme === network_1.Schemas.untitled ? resource.fsPath : resource.toString();
        return (0, hash_1.$tj)(str) + '';
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[237/*vs/workbench/api/common/extHostDiagnostics*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,107/*vs/platform/markers/common/markers*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/,8/*vs/workbench/api/common/extHostTypeConverters*/,6/*vs/base/common/event*/,11/*vs/platform/log/common/log*/,28/*vs/base/common/map*/,50/*vs/workbench/api/common/extHostFileSystemInfo*/]), function (require, exports, nls_1, markers_1, uri_1, extHost_protocol_1, extHostTypes_1, converter, event_1, log_1, map_1, extHostFileSystemInfo_1) {
    "use strict";
    var $xpc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$xpc = exports.$wpc = void 0;
    converter = __importStar(converter);
    class $wpc {
        #proxy;
        #onDidChangeDiagnostics;
        #data;
        constructor(d, e, f, g, h, extUri, proxy, onDidChangeDiagnostics) {
            this.d = d;
            this.e = e;
            this.f = f;
            this.g = g;
            this.h = h;
            this.c = false;
            this.f = Math.max(g, f);
            this.#data = new map_1.$Ac(uri => extUri.getComparisonKey(uri));
            this.#proxy = proxy;
            this.#onDidChangeDiagnostics = onDidChangeDiagnostics;
        }
        dispose() {
            if (!this.c) {
                this.#onDidChangeDiagnostics.fire([...this.#data.keys()]);
                this.#proxy?.$clear(this.e);
                this.#data.clear();
                this.c = true;
            }
        }
        get name() {
            this.j();
            return this.d;
        }
        set(first, diagnostics) {
            if (!first) {
                // this set-call is a clear-call
                this.clear();
                return;
            }
            // the actual implementation for #set
            this.j();
            let toSync = [];
            if (uri_1.URI.isUri(first)) {
                if (!diagnostics) {
                    // remove this entry
                    this.delete(first);
                    return;
                }
                // update single row
                this.#data.set(first, diagnostics.slice());
                toSync = [first];
            }
            else if (Array.isArray(first)) {
                // update many rows
                toSync = [];
                let lastUri;
                // ensure stable-sort
                first = [...first].sort($wpc.k);
                for (const tuple of first) {
                    const [uri, diagnostics] = tuple;
                    if (!lastUri || uri.toString() !== lastUri.toString()) {
                        if (lastUri && this.#data.get(lastUri).length === 0) {
                            this.#data.delete(lastUri);
                        }
                        lastUri = uri;
                        toSync.push(uri);
                        this.#data.set(uri, []);
                    }
                    if (!diagnostics) {
                        // [Uri, undefined] means clear this
                        const currentDiagnostics = this.#data.get(uri);
                        if (currentDiagnostics) {
                            currentDiagnostics.length = 0;
                        }
                    }
                    else {
                        const currentDiagnostics = this.#data.get(uri);
                        currentDiagnostics?.push(...diagnostics);
                    }
                }
            }
            // send event for extensions
            this.#onDidChangeDiagnostics.fire(toSync);
            // compute change and send to main side
            if (!this.#proxy) {
                return;
            }
            const entries = [];
            let totalMarkerCount = 0;
            for (const uri of toSync) {
                let marker = [];
                const diagnostics = this.#data.get(uri);
                if (diagnostics) {
                    // no more than N diagnostics per file
                    if (diagnostics.length > this.g) {
                        marker = [];
                        const order = [extHostTypes_1.DiagnosticSeverity.Error, extHostTypes_1.DiagnosticSeverity.Warning, extHostTypes_1.DiagnosticSeverity.Information, extHostTypes_1.DiagnosticSeverity.Hint];
                        orderLoop: for (let i = 0; i < 4; i++) {
                            for (const diagnostic of diagnostics) {
                                if (diagnostic.severity === order[i]) {
                                    const len = marker.push({ ...converter.Diagnostic.from(diagnostic), modelVersionId: this.h(uri) });
                                    if (len === this.g) {
                                        break orderLoop;
                                    }
                                }
                            }
                        }
                        // add 'signal' marker for showing omitted errors/warnings
                        marker.push({
                            severity: markers_1.MarkerSeverity.Info,
                            message: (0, nls_1.localize)(11264, null, diagnostics.length - this.g),
                            startLineNumber: marker[marker.length - 1].startLineNumber,
                            startColumn: marker[marker.length - 1].startColumn,
                            endLineNumber: marker[marker.length - 1].endLineNumber,
                            endColumn: marker[marker.length - 1].endColumn
                        });
                    }
                    else {
                        marker = diagnostics.map(diag => ({ ...converter.Diagnostic.from(diag), modelVersionId: this.h(uri) }));
                    }
                }
                entries.push([uri, marker]);
                totalMarkerCount += marker.length;
                if (totalMarkerCount > this.f) {
                    // ignore markers that are above the limit
                    break;
                }
            }
            this.#proxy.$changeMany(this.e, entries);
        }
        delete(uri) {
            this.j();
            this.#onDidChangeDiagnostics.fire([uri]);
            this.#data.delete(uri);
            this.#proxy?.$changeMany(this.e, [[uri, undefined]]);
        }
        clear() {
            this.j();
            this.#onDidChangeDiagnostics.fire([...this.#data.keys()]);
            this.#data.clear();
            this.#proxy?.$clear(this.e);
        }
        forEach(callback, thisArg) {
            this.j();
            for (const [uri, values] of this) {
                callback.call(thisArg, uri, values, this);
            }
        }
        *[Symbol.iterator]() {
            this.j();
            for (const uri of this.#data.keys()) {
                yield [uri, this.get(uri)];
            }
        }
        get(uri) {
            this.j();
            const result = this.#data.get(uri);
            if (Array.isArray(result)) {
                return Object.freeze(result.slice(0));
            }
            return [];
        }
        has(uri) {
            this.j();
            return Array.isArray(this.#data.get(uri));
        }
        j() {
            if (this.c) {
                throw new Error('illegal state - object is disposed');
            }
        }
        static k(a, b) {
            if (a[0].toString() < b[0].toString()) {
                return -1;
            }
            else if (a[0].toString() > b[0].toString()) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }
    exports.$wpc = $wpc;
    let $xpc = class $xpc {
        static { $xpc_1 = this; }
        static { this.c = 0; }
        static { this.d = 1000; }
        static { this.e = 1.1 * this.d; }
        static _mapper(last) {
            const map = new map_1.$Ac();
            for (const uri of last) {
                map.set(uri, uri);
            }
            return { uris: Object.freeze(Array.from(map.values())) };
        }
        constructor(mainContext, j, k, l) {
            this.j = j;
            this.k = k;
            this.l = l;
            this.g = new Map();
            this.h = new event_1.$pe({ merge: all => all.flat(), delay: 50 });
            this.onDidChangeDiagnostics = event_1.Event.map(this.h.event, $xpc_1._mapper);
            this.f = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadDiagnostics);
        }
        createDiagnosticCollection(extensionId, name) {
            const { g: _collections, f: _proxy, h: _onDidChangeDiagnostics, j: _logService, k: _fileSystemInfoService, l: _extHostDocumentsAndEditors } = this;
            const loggingProxy = new class {
                $changeMany(owner, entries) {
                    _proxy.$changeMany(owner, entries);
                    _logService.trace('[DiagnosticCollection] change many (extension, owner, uris)', extensionId.value, owner, entries.length === 0 ? 'CLEARING' : entries);
                }
                $clear(owner) {
                    _proxy.$clear(owner);
                    _logService.trace('[DiagnosticCollection] remove all (extension, owner)', extensionId.value, owner);
                }
                dispose() {
                    _proxy.dispose();
                }
            };
            let owner;
            if (!name) {
                name = '_generated_diagnostic_collection_name_#' + $xpc_1.c++;
                owner = name;
            }
            else if (!_collections.has(name)) {
                owner = name;
            }
            else {
                this.j.warn(`DiagnosticCollection with name '${name}' does already exist.`);
                do {
                    owner = name + $xpc_1.c++;
                } while (_collections.has(owner));
            }
            const result = new class extends $wpc {
                constructor() {
                    super(name, owner, $xpc_1.e, $xpc_1.d, uri => _extHostDocumentsAndEditors.getDocument(uri)?.version, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics);
                    _collections.set(owner, this);
                }
                dispose() {
                    super.dispose();
                    _collections.delete(owner);
                }
            };
            return result;
        }
        getDiagnostics(resource) {
            if (resource) {
                return this.m(resource);
            }
            else {
                const index = new Map();
                const res = [];
                for (const collection of this.g.values()) {
                    collection.forEach((uri, diagnostics) => {
                        let idx = index.get(uri.toString());
                        if (typeof idx === 'undefined') {
                            idx = res.length;
                            index.set(uri.toString(), idx);
                            res.push([uri, []]);
                        }
                        res[idx][1] = res[idx][1].concat(...diagnostics);
                    });
                }
                return res;
            }
        }
        m(resource) {
            let res = [];
            for (const collection of this.g.values()) {
                if (collection.has(resource)) {
                    res = res.concat(collection.get(resource));
                }
            }
            return res;
        }
        $acceptMarkersChange(data) {
            if (!this.n) {
                const name = '_generated_mirror';
                const collection = new $wpc(name, name, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, // no limits because this collection is just a mirror of "sanitized" data
                // no limits because this collection is just a mirror of "sanitized" data
                _uri => undefined, this.k.extUri, undefined, this.h);
                this.g.set(name, collection);
                this.n = collection;
            }
            for (const [uri, markers] of data) {
                this.n.set(uri_1.URI.revive(uri), markers.map(converter.Diagnostic.to));
            }
        }
    };
    exports.$xpc = $xpc;
    exports.$xpc = $xpc = $xpc_1 = __decorate([
        __param(1, log_1.$ak),
        __param(2, extHostFileSystemInfo_1.$vpc)
    ], $xpc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[238/*vs/workbench/api/common/extHostDocumentSaveParticipant*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,13/*vs/base/common/errors*/,7/*vs/workbench/api/common/extHostTypes*/,8/*vs/workbench/api/common/extHostTypeConverters*/,171/*vs/base/common/linkedList*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/]), function (require, exports, uri_1, errors_1, extHostTypes_1, extHostTypeConverters_1, linkedList_1, proxyIdentifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Kqc = void 0;
    class $Kqc {
        constructor(c, d, f, g = { timeout: 1500, errors: 3 }) {
            this.c = c;
            this.d = d;
            this.f = f;
            this.g = g;
            this.a = new linkedList_1.$5c();
            this.b = new WeakMap();
            //
        }
        dispose() {
            this.a.clear();
        }
        getOnWillSaveTextDocumentEvent(extension) {
            return (listener, thisArg, disposables) => {
                const remove = this.a.push([listener, thisArg, extension]);
                const result = { dispose: remove };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        async $participateInSave(data, reason) {
            const resource = uri_1.URI.revive(data);
            let didTimeout = false;
            const didTimeoutHandle = setTimeout(() => didTimeout = true, this.g.timeout);
            const results = [];
            try {
                for (const listener of [...this.a]) { // copy to prevent concurrent modifications
                    if (didTimeout) {
                        // timeout - no more listeners
                        break;
                    }
                    const document = this.d.getDocument(resource);
                    const success = await this.h(listener, { document, reason: extHostTypeConverters_1.TextDocumentSaveReason.to(reason) });
                    results.push(success);
                }
            }
            finally {
                clearTimeout(didTimeoutHandle);
            }
            return results;
        }
        h([listener, thisArg, extension], stubEvent) {
            const errors = this.b.get(listener);
            if (typeof errors === 'number' && errors > this.g.errors) {
                // bad listener - ignore
                return Promise.resolve(false);
            }
            return this.i(extension, listener, thisArg, stubEvent).then(() => {
                // don't send result across the wire
                return true;
            }, err => {
                this.c.error(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' threw ERROR`);
                this.c.error(err);
                if (!(err instanceof Error) || err.message !== 'concurrent_edits') {
                    const errors = this.b.get(listener);
                    this.b.set(listener, !errors ? 1 : errors + 1);
                    if (typeof errors === 'number' && errors > this.g.errors) {
                        this.c.info(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' will now be IGNORED because of timeouts and/or errors`);
                    }
                }
                return false;
            });
        }
        i(extension, listener, thisArg, stubEvent) {
            const promises = [];
            const t1 = Date.now();
            const { document, reason } = stubEvent;
            const { version } = document;
            const event = Object.freeze({
                document,
                reason,
                waitUntil(p) {
                    if (Object.isFrozen(promises)) {
                        throw (0, errors_1.$7)('waitUntil can not be called async');
                    }
                    promises.push(Promise.resolve(p));
                }
            });
            try {
                // fire event
                listener.apply(thisArg, [event]);
            }
            catch (err) {
                return Promise.reject(err);
            }
            // freeze promises after event call
            Object.freeze(promises);
            return new Promise((resolve, reject) => {
                // join on all listener promises, reject after timeout
                const handle = setTimeout(() => reject(new Error('timeout')), this.g.timeout);
                return Promise.all(promises).then(edits => {
                    this.c.debug(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' finished after ${(Date.now() - t1)}ms`);
                    clearTimeout(handle);
                    resolve(edits);
                }).catch(err => {
                    clearTimeout(handle);
                    reject(err);
                });
            }).then(values => {
                const dto = { edits: [] };
                for (const value of values) {
                    if (Array.isArray(value) && value.every(e => e instanceof extHostTypes_1.$VN)) {
                        for (const { newText, newEol, range } of value) {
                            dto.edits.push({
                                resource: document.uri,
                                versionId: undefined,
                                textEdit: {
                                    range: range && extHostTypeConverters_1.Range.from(range),
                                    text: newText,
                                    eol: newEol && extHostTypeConverters_1.EndOfLine.from(newEol),
                                }
                            });
                        }
                    }
                }
                // apply edits if any and if document
                // didn't change somehow in the meantime
                if (dto.edits.length === 0) {
                    return undefined;
                }
                if (version === document.version) {
                    return this.f.$tryApplyWorkspaceEdit(new proxyIdentifier_1.$Xw(dto));
                }
                return Promise.reject(new Error('concurrent_edits'));
            });
        }
    }
    exports.$Kqc = $Kqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[239/*vs/workbench/api/common/extHostDocuments*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,123/*vs/workbench/api/common/extHostDocumentData*/,8/*vs/workbench/api/common/extHostTypeConverters*/,14/*vs/base/common/types*/,25/*vs/base/common/objects*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, event_1, lifecycle_1, uri_1, extHost_protocol_1, extHostDocumentData_1, TypeConverters, types_1, objects_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$ypc = void 0;
    TypeConverters = __importStar(TypeConverters);
    class $ypc {
        constructor(mainContext, documentsAndEditors) {
            this.a = new event_1.$le();
            this.b = new event_1.$le();
            this.c = new event_1.$le();
            this.d = new event_1.$le();
            this.onDidAddDocument = this.a.event;
            this.onDidRemoveDocument = this.b.event;
            this.onDidChangeDocument = this.c.event;
            this.onDidSaveDocument = this.d.event;
            this.e = new lifecycle_1.$Tc();
            this.h = new Map();
            this.f = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadDocuments);
            this.g = documentsAndEditors;
            this.g.onDidRemoveDocuments(documents => {
                for (const data of documents) {
                    this.b.fire(data.document);
                }
            }, undefined, this.e);
            this.g.onDidAddDocuments(documents => {
                for (const data of documents) {
                    this.a.fire(data.document);
                }
            }, undefined, this.e);
        }
        dispose() {
            this.e.dispose();
        }
        getAllDocumentData() {
            return [...this.g.allDocuments()];
        }
        getDocumentData(resource) {
            if (!resource) {
                return undefined;
            }
            const data = this.g.getDocument(resource);
            if (data) {
                return data;
            }
            return undefined;
        }
        getDocument(resource) {
            const data = this.getDocumentData(resource);
            if (!data?.document) {
                throw new Error(`Unable to retrieve document from URI '${resource}'`);
            }
            return data.document;
        }
        ensureDocumentData(uri) {
            const cached = this.g.getDocument(uri);
            if (cached) {
                return Promise.resolve(cached);
            }
            let promise = this.h.get(uri.toString());
            if (!promise) {
                promise = this.f.$tryOpenDocument(uri).then(uriData => {
                    this.h.delete(uri.toString());
                    const canonicalUri = uri_1.URI.revive(uriData);
                    return (0, types_1.$pg)(this.g.getDocument(canonicalUri));
                }, err => {
                    this.h.delete(uri.toString());
                    return Promise.reject(err);
                });
                this.h.set(uri.toString(), promise);
            }
            return promise;
        }
        createDocumentData(options) {
            return this.f.$tryCreateDocument(options).then(data => uri_1.URI.revive(data));
        }
        $acceptModelLanguageChanged(uriComponents, newLanguageId) {
            const uri = uri_1.URI.revive(uriComponents);
            const data = this.g.getDocument(uri);
            if (!data) {
                throw new Error('unknown document');
            }
            // Treat a language change as a remove + add
            this.b.fire(data.document);
            data._acceptLanguageId(newLanguageId);
            this.a.fire(data.document);
        }
        $acceptModelSaved(uriComponents) {
            const uri = uri_1.URI.revive(uriComponents);
            const data = this.g.getDocument(uri);
            if (!data) {
                throw new Error('unknown document');
            }
            this.$acceptDirtyStateChanged(uriComponents, false);
            this.d.fire(data.document);
        }
        $acceptDirtyStateChanged(uriComponents, isDirty) {
            const uri = uri_1.URI.revive(uriComponents);
            const data = this.g.getDocument(uri);
            if (!data) {
                throw new Error('unknown document');
            }
            data._acceptIsDirty(isDirty);
            this.c.fire({
                document: data.document,
                contentChanges: [],
                reason: undefined
            });
        }
        $acceptModelChanged(uriComponents, events, isDirty) {
            const uri = uri_1.URI.revive(uriComponents);
            const data = this.g.getDocument(uri);
            if (!data) {
                throw new Error('unknown document');
            }
            data._acceptIsDirty(isDirty);
            data.onEvents(events);
            let reason = undefined;
            if (events.isUndoing) {
                reason = extHostTypes_1.TextDocumentChangeReason.Undo;
            }
            else if (events.isRedoing) {
                reason = extHostTypes_1.TextDocumentChangeReason.Redo;
            }
            this.c.fire((0, objects_1.$fo)({
                document: data.document,
                contentChanges: events.changes.map((change) => {
                    return {
                        range: TypeConverters.Range.to(change.range),
                        rangeOffset: change.rangeOffset,
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                }),
                reason
            }));
        }
        setWordDefinitionFor(languageId, wordDefinition) {
            (0, extHostDocumentData_1.$mQ)(languageId, wordDefinition);
        }
    }
    exports.$ypc = $ypc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[70/*vs/workbench/api/common/extHostEditorTabs*/], __M([1/*require*/,0/*exports*/,240/*vs/base/common/collections*/,6/*vs/base/common/event*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,5/*vs/workbench/api/common/extHost.protocol*/,16/*vs/workbench/api/common/extHostRpcService*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, collections_1, event_1, types_1, uri_1, instantiation_1, extHost_protocol_1, extHostRpcService_1, typeConverters, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$4pc = exports.$3pc = void 0;
    typeConverters = __importStar(typeConverters);
    exports.$3pc = (0, instantiation_1.$Fi)('IExtHostEditorTabs');
    class ExtHostEditorTab {
        constructor(dto, parentGroup, activeTabIdGetter) {
            this.e = activeTabIdGetter;
            this.d = parentGroup;
            this.acceptDtoUpdate(dto);
        }
        get apiObject() {
            if (!this.a) {
                // Don't want to lose reference to parent `this` in the getters
                const that = this;
                const obj = {
                    get isActive() {
                        // We use a getter function here to always ensure at most 1 active tab per group and prevent iteration for being required
                        return that.b.id === that.e();
                    },
                    get label() {
                        return that.b.label;
                    },
                    get input() {
                        return that.c;
                    },
                    get isDirty() {
                        return that.b.isDirty;
                    },
                    get isPinned() {
                        return that.b.isPinned;
                    },
                    get isPreview() {
                        return that.b.isPreview;
                    },
                    get group() {
                        return that.d.apiObject;
                    }
                };
                this.a = Object.freeze(obj);
            }
            return this.a;
        }
        get tabId() {
            return this.b.id;
        }
        acceptDtoUpdate(dto) {
            this.b = dto;
            this.c = this.f();
        }
        f() {
            switch (this.b.input.kind) {
                case extHost_protocol_1.TabInputKind.TextInput:
                    return new extHostTypes_1.$AP(uri_1.URI.revive(this.b.input.uri));
                case extHost_protocol_1.TabInputKind.TextDiffInput:
                    return new extHostTypes_1.$BP(uri_1.URI.revive(this.b.input.original), uri_1.URI.revive(this.b.input.modified));
                case extHost_protocol_1.TabInputKind.TextMergeInput:
                    return new extHostTypes_1.$CP(uri_1.URI.revive(this.b.input.base), uri_1.URI.revive(this.b.input.input1), uri_1.URI.revive(this.b.input.input2), uri_1.URI.revive(this.b.input.result));
                case extHost_protocol_1.TabInputKind.CustomEditorInput:
                    return new extHostTypes_1.$DP(uri_1.URI.revive(this.b.input.uri), this.b.input.viewType);
                case extHost_protocol_1.TabInputKind.WebviewEditorInput:
                    return new extHostTypes_1.$EP(this.b.input.viewType);
                case extHost_protocol_1.TabInputKind.NotebookInput:
                    return new extHostTypes_1.$FP(uri_1.URI.revive(this.b.input.uri), this.b.input.notebookType);
                case extHost_protocol_1.TabInputKind.NotebookDiffInput:
                    return new extHostTypes_1.$GP(uri_1.URI.revive(this.b.input.original), uri_1.URI.revive(this.b.input.modified), this.b.input.notebookType);
                case extHost_protocol_1.TabInputKind.TerminalEditorInput:
                    return new extHostTypes_1.$HP();
                case extHost_protocol_1.TabInputKind.InteractiveEditorInput:
                    return new extHostTypes_1.$IP(uri_1.URI.revive(this.b.input.uri), uri_1.URI.revive(this.b.input.inputBoxUri));
                case extHost_protocol_1.TabInputKind.ChatEditorInput:
                    return new extHostTypes_1.$JP();
                case extHost_protocol_1.TabInputKind.MultiDiffEditorInput:
                    return new extHostTypes_1.$KP(this.b.input.diffEditors.map(diff => new extHostTypes_1.$BP(uri_1.URI.revive(diff.original), uri_1.URI.revive(diff.modified))));
                default:
                    return undefined;
            }
        }
    }
    class ExtHostEditorTabGroup {
        constructor(dto, activeGroupIdGetter) {
            this.c = [];
            this.d = '';
            this.b = dto;
            this.e = activeGroupIdGetter;
            // Construct all tabs from the given dto
            for (const tabDto of dto.tabs) {
                if (tabDto.isActive) {
                    this.d = tabDto.id;
                }
                this.c.push(new ExtHostEditorTab(tabDto, this, () => this.activeTabId()));
            }
        }
        get apiObject() {
            if (!this.a) {
                // Don't want to lose reference to parent `this` in the getters
                const that = this;
                const obj = {
                    get isActive() {
                        // We use a getter function here to always ensure at most 1 active group and prevent iteration for being required
                        return that.b.groupId === that.e();
                    },
                    get viewColumn() {
                        return typeConverters.ViewColumn.to(that.b.viewColumn);
                    },
                    get activeTab() {
                        return that.c.find(tab => tab.tabId === that.d)?.apiObject;
                    },
                    get tabs() {
                        return Object.freeze(that.c.map(tab => tab.apiObject));
                    }
                };
                this.a = Object.freeze(obj);
            }
            return this.a;
        }
        get groupId() {
            return this.b.groupId;
        }
        get tabs() {
            return this.c;
        }
        acceptGroupDtoUpdate(dto) {
            this.b = dto;
        }
        acceptTabOperation(operation) {
            // In the open case we add the tab to the group
            if (operation.kind === extHost_protocol_1.TabModelOperationKind.TAB_OPEN) {
                const tab = new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId());
                // Insert tab at editor index
                this.c.splice(operation.index, 0, tab);
                if (operation.tabDto.isActive) {
                    this.d = tab.tabId;
                }
                return tab;
            }
            else if (operation.kind === extHost_protocol_1.TabModelOperationKind.TAB_CLOSE) {
                const tab = this.c.splice(operation.index, 1)[0];
                if (!tab) {
                    throw new Error(`Tab close updated received for index ${operation.index} which does not exist`);
                }
                if (tab.tabId === this.d) {
                    this.d = '';
                }
                return tab;
            }
            else if (operation.kind === extHost_protocol_1.TabModelOperationKind.TAB_MOVE) {
                if (operation.oldIndex === undefined) {
                    throw new Error('Invalid old index on move IPC');
                }
                // Splice to remove at old index and insert at new index === moving the tab
                const tab = this.c.splice(operation.oldIndex, 1)[0];
                if (!tab) {
                    throw new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);
                }
                this.c.splice(operation.index, 0, tab);
                return tab;
            }
            const tab = this.c.find(extHostTab => extHostTab.tabId === operation.tabDto.id);
            if (!tab) {
                throw new Error('INVALID tab');
            }
            if (operation.tabDto.isActive) {
                this.d = operation.tabDto.id;
            }
            else if (this.d === operation.tabDto.id && !operation.tabDto.isActive) {
                // Events aren't guaranteed to be in order so if we receive a dto that matches the active tab id
                // but isn't active we mark the active tab id as empty. This prevent onDidActiveTabChange from
                // firing incorrectly
                this.d = '';
            }
            tab.acceptDtoUpdate(operation.tabDto);
            return tab;
        }
        // Not a getter since it must be a function to be used as a callback for the tabs
        activeTabId() {
            return this.d;
        }
    }
    let $4pc = class $4pc {
        constructor(extHostRpc) {
            this.b = new event_1.$le();
            this.c = new event_1.$le();
            this.e = [];
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadEditorTabs);
        }
        get tabGroups() {
            if (!this.f) {
                const that = this;
                const obj = {
                    // never changes -> simple value
                    onDidChangeTabGroups: that.c.event,
                    onDidChangeTabs: that.b.event,
                    // dynamic -> getters
                    get all() {
                        return Object.freeze(that.e.map(group => group.apiObject));
                    },
                    get activeTabGroup() {
                        const activeTabGroupId = that.d;
                        const activeTabGroup = (0, types_1.$pg)(that.e.find(candidate => candidate.groupId === activeTabGroupId)?.apiObject);
                        return activeTabGroup;
                    },
                    close: async (tabOrTabGroup, preserveFocus) => {
                        const tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];
                        if (!tabsOrTabGroups.length) {
                            return true;
                        }
                        // Check which type was passed in and call the appropriate close
                        // Casting is needed as typescript doesn't seem to infer enough from this
                        if (isTabGroup(tabsOrTabGroups[0])) {
                            return this.j(tabsOrTabGroups, preserveFocus);
                        }
                        else {
                            return this.i(tabsOrTabGroups, preserveFocus);
                        }
                    },
                    // move: async (tab: vscode.Tab, viewColumn: ViewColumn, index: number, preserveFocus?: boolean) => {
                    // 	const extHostTab = this._findExtHostTabFromApi(tab);
                    // 	if (!extHostTab) {
                    // 		throw new Error('Invalid tab');
                    // 	}
                    // 	this._proxy.$moveTab(extHostTab.tabId, index, typeConverters.ViewColumn.from(viewColumn), preserveFocus);
                    // 	return;
                    // }
                };
                this.f = Object.freeze(obj);
            }
            return this.f;
        }
        $acceptEditorTabModel(tabGroups) {
            const groupIdsBefore = new Set(this.e.map(group => group.groupId));
            const groupIdsAfter = new Set(tabGroups.map(dto => dto.groupId));
            const diff = (0, collections_1.$d)(groupIdsBefore, groupIdsAfter);
            const closed = this.e.filter(group => diff.removed.includes(group.groupId)).map(group => group.apiObject);
            const opened = [];
            const changed = [];
            this.e = tabGroups.map(tabGroup => {
                const group = new ExtHostEditorTabGroup(tabGroup, () => this.d);
                if (diff.added.includes(group.groupId)) {
                    opened.push(group.apiObject);
                }
                else {
                    changed.push(group.apiObject);
                }
                return group;
            });
            // Set the active tab group id
            const activeTabGroupId = (0, types_1.$pg)(tabGroups.find(group => group.isActive === true)?.groupId);
            if (activeTabGroupId !== undefined && this.d !== activeTabGroupId) {
                this.d = activeTabGroupId;
            }
            this.c.fire(Object.freeze({ opened, closed, changed }));
        }
        $acceptTabGroupUpdate(groupDto) {
            const group = this.e.find(group => group.groupId === groupDto.groupId);
            if (!group) {
                throw new Error('Update Group IPC call received before group creation.');
            }
            group.acceptGroupDtoUpdate(groupDto);
            if (groupDto.isActive) {
                this.d = groupDto.groupId;
            }
            this.c.fire(Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }));
        }
        $acceptTabOperation(operation) {
            const group = this.e.find(group => group.groupId === operation.groupId);
            if (!group) {
                throw new Error('Update Tabs IPC call received before group creation.');
            }
            const tab = group.acceptTabOperation(operation);
            // Construct the tab change event based on the operation
            switch (operation.kind) {
                case extHost_protocol_1.TabModelOperationKind.TAB_OPEN:
                    this.b.fire(Object.freeze({
                        opened: [tab.apiObject],
                        closed: [],
                        changed: []
                    }));
                    return;
                case extHost_protocol_1.TabModelOperationKind.TAB_CLOSE:
                    this.b.fire(Object.freeze({
                        opened: [],
                        closed: [tab.apiObject],
                        changed: []
                    }));
                    return;
                case extHost_protocol_1.TabModelOperationKind.TAB_MOVE:
                case extHost_protocol_1.TabModelOperationKind.TAB_UPDATE:
                    this.b.fire(Object.freeze({
                        opened: [],
                        closed: [],
                        changed: [tab.apiObject]
                    }));
                    return;
            }
        }
        g(apiTab) {
            for (const group of this.e) {
                for (const tab of group.tabs) {
                    if (tab.apiObject === apiTab) {
                        return tab;
                    }
                }
            }
            return;
        }
        h(apiTabGroup) {
            return this.e.find(candidate => candidate.apiObject === apiTabGroup);
        }
        async i(tabs, preserveFocus) {
            const extHostTabIds = [];
            for (const tab of tabs) {
                const extHostTab = this.g(tab);
                if (!extHostTab) {
                    throw new Error('Tab close: Invalid tab not found!');
                }
                extHostTabIds.push(extHostTab.tabId);
            }
            return this.a.$closeTab(extHostTabIds, preserveFocus);
        }
        async j(groups, preserverFoucs) {
            const extHostGroupIds = [];
            for (const group of groups) {
                const extHostGroup = this.h(group);
                if (!extHostGroup) {
                    throw new Error('Group close: Invalid group not found!');
                }
                extHostGroupIds.push(extHostGroup.groupId);
            }
            return this.a.$closeGroup(extHostGroupIds, preserverFoucs);
        }
    };
    exports.$4pc = $4pc;
    exports.$4pc = $4pc = __decorate([
        __param(0, extHostRpcService_1.$kQ)
    ], $4pc);
    //#region Utils
    function isTabGroup(obj) {
        const tabGroup = obj;
        if (tabGroup.tabs !== undefined) {
            return true;
        }
        return false;
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[241/*vs/workbench/api/common/extHostFileSystem*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,29/*vs/platform/files/common/files*/,4/*vs/base/common/lifecycle*/,7/*vs/workbench/api/common/extHostTypes*/,8/*vs/workbench/api/common/extHostTypeConverters*/,285/*vs/editor/common/languages/linkComputer*/,12/*vs/base/common/strings*/,27/*vs/base/common/charCode*/,22/*vs/base/common/buffer*/,24/*vs/workbench/services/extensions/common/extensions*/,59/*vs/base/common/htmlContent*/]), function (require, exports, uri_1, extHost_protocol_1, files, lifecycle_1, extHostTypes_1, typeConverter, linkComputer_1, strings_1, charCode_1, buffer_1, extensions_1, htmlContent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Nqc = void 0;
    files = __importStar(files);
    typeConverter = __importStar(typeConverter);
    class FsLinkProvider {
        constructor() {
            this.a = [];
        }
        add(scheme) {
            this.b = undefined;
            this.a.push(scheme);
        }
        delete(scheme) {
            const idx = this.a.indexOf(scheme);
            if (idx >= 0) {
                this.a.splice(idx, 1);
                this.b = undefined;
            }
        }
        c() {
            if (!this.b) {
                // sort and compute common prefix with previous scheme
                // then build state transitions based on the data
                const schemes = this.a.sort();
                const edges = [];
                let prevScheme;
                let prevState;
                let lastState = linkComputer_1.State.LastKnownState;
                let nextState = linkComputer_1.State.LastKnownState;
                for (const scheme of schemes) {
                    // skip the common prefix of the prev scheme
                    // and continue with its last state
                    let pos = !prevScheme ? 0 : (0, strings_1.$Hf)(prevScheme, scheme);
                    if (pos === 0) {
                        prevState = linkComputer_1.State.Start;
                    }
                    else {
                        prevState = nextState;
                    }
                    for (; pos < scheme.length; pos++) {
                        // keep creating new (next) states until the
                        // end (and the BeforeColon-state) is reached
                        if (pos + 1 === scheme.length) {
                            // Save the last state here, because we need to continue for the next scheme
                            lastState = nextState;
                            nextState = linkComputer_1.State.BeforeColon;
                        }
                        else {
                            nextState += 1;
                        }
                        edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);
                        edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);
                        prevState = nextState;
                    }
                    prevScheme = scheme;
                    // Restore the last state
                    nextState = lastState;
                }
                // all link must match this pattern `<scheme>:/<more>`
                edges.push([linkComputer_1.State.BeforeColon, charCode_1.CharCode.Colon, linkComputer_1.State.AfterColon]);
                edges.push([linkComputer_1.State.AfterColon, charCode_1.CharCode.Slash, linkComputer_1.State.End]);
                this.b = new linkComputer_1.$f4(edges);
            }
        }
        provideDocumentLinks(document) {
            this.c();
            const result = [];
            const links = linkComputer_1.$g4.computeLinks({
                getLineContent(lineNumber) {
                    return document.lineAt(lineNumber - 1).text;
                },
                getLineCount() {
                    return document.lineCount;
                }
            }, this.b);
            for (const link of links) {
                const docLink = typeConverter.DocumentLink.to(link);
                if (docLink.target) {
                    result.push(docLink);
                }
            }
            return result;
        }
    }
    class $Nqc {
        constructor(mainContext, i) {
            this.i = i;
            this.b = new FsLinkProvider();
            this.c = new Map();
            this.d = new Set();
            this.f = new Map();
            this.h = 0;
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadFileSystem);
        }
        dispose() {
            this.g?.dispose();
        }
        registerFileSystemProvider(extension, scheme, provider, options = {}) {
            // validate the given provider is complete
            $Nqc.j(provider);
            if (this.d.has(scheme)) {
                throw new Error(`a provider for the scheme '${scheme}' is already registered`);
            }
            //
            if (!this.g) {
                this.g = this.i.registerDocumentLinkProvider(extension, '*', this.b);
            }
            const handle = this.h++;
            this.b.add(scheme);
            this.d.add(scheme);
            this.c.set(handle, provider);
            let capabilities = files.FileSystemProviderCapabilities.FileReadWrite;
            if (options.isCaseSensitive) {
                capabilities += files.FileSystemProviderCapabilities.PathCaseSensitive;
            }
            if (options.isReadonly) {
                capabilities += files.FileSystemProviderCapabilities.Readonly;
            }
            if (typeof provider.copy === 'function') {
                capabilities += files.FileSystemProviderCapabilities.FileFolderCopy;
            }
            if (typeof provider.open === 'function' && typeof provider.close === 'function'
                && typeof provider.read === 'function' && typeof provider.write === 'function') {
                (0, extensions_1.$gH)(extension, 'fsChunks');
                capabilities += files.FileSystemProviderCapabilities.FileOpenReadWriteClose;
            }
            let readOnlyMessage;
            if (options.isReadonly && (0, htmlContent_1.$6k)(options.isReadonly) && options.isReadonly.value !== '') {
                readOnlyMessage = {
                    value: options.isReadonly.value,
                    isTrusted: options.isReadonly.isTrusted,
                    supportThemeIcons: options.isReadonly.supportThemeIcons,
                    supportHtml: options.isReadonly.supportHtml,
                    baseUri: options.isReadonly.baseUri,
                    uris: options.isReadonly.uris
                };
            }
            this.a.$registerFileSystemProvider(handle, scheme, capabilities, readOnlyMessage).catch(err => {
                console.error(`FAILED to register filesystem provider of ${extension.identifier.value}-extension for the scheme ${scheme}`);
                console.error(err);
            });
            const subscription = provider.onDidChangeFile(event => {
                const mapped = [];
                for (const e of event) {
                    const { uri: resource, type } = e;
                    if (resource.scheme !== scheme) {
                        // dropping events for wrong scheme
                        continue;
                    }
                    let newType;
                    switch (type) {
                        case extHostTypes_1.FileChangeType.Changed:
                            newType = files.FileChangeType.UPDATED;
                            break;
                        case extHostTypes_1.FileChangeType.Created:
                            newType = files.FileChangeType.ADDED;
                            break;
                        case extHostTypes_1.FileChangeType.Deleted:
                            newType = files.FileChangeType.DELETED;
                            break;
                        default:
                            throw new Error('Unknown FileChangeType');
                    }
                    mapped.push({ resource, type: newType });
                }
                this.a.$onFileSystemChange(handle, mapped);
            });
            return (0, lifecycle_1.$Sc)(() => {
                subscription.dispose();
                this.b.delete(scheme);
                this.d.delete(scheme);
                this.c.delete(handle);
                this.a.$unregisterProvider(handle);
            });
        }
        static j(provider) {
            if (!provider) {
                throw new Error('MISSING provider');
            }
            if (typeof provider.watch !== 'function') {
                throw new Error('Provider does NOT implement watch');
            }
            if (typeof provider.stat !== 'function') {
                throw new Error('Provider does NOT implement stat');
            }
            if (typeof provider.readDirectory !== 'function') {
                throw new Error('Provider does NOT implement readDirectory');
            }
            if (typeof provider.createDirectory !== 'function') {
                throw new Error('Provider does NOT implement createDirectory');
            }
            if (typeof provider.readFile !== 'function') {
                throw new Error('Provider does NOT implement readFile');
            }
            if (typeof provider.writeFile !== 'function') {
                throw new Error('Provider does NOT implement writeFile');
            }
            if (typeof provider.delete !== 'function') {
                throw new Error('Provider does NOT implement delete');
            }
            if (typeof provider.rename !== 'function') {
                throw new Error('Provider does NOT implement rename');
            }
        }
        static k(stat) {
            const { type, ctime, mtime, size, permissions } = stat;
            return { type, ctime, mtime, size, permissions };
        }
        $stat(handle, resource) {
            return Promise.resolve(this.l(handle).stat(uri_1.URI.revive(resource))).then(stat => $Nqc.k(stat));
        }
        $readdir(handle, resource) {
            return Promise.resolve(this.l(handle).readDirectory(uri_1.URI.revive(resource)));
        }
        $readFile(handle, resource) {
            return Promise.resolve(this.l(handle).readFile(uri_1.URI.revive(resource))).then(data => buffer_1.$Ne.wrap(data));
        }
        $writeFile(handle, resource, content, opts) {
            return Promise.resolve(this.l(handle).writeFile(uri_1.URI.revive(resource), content.buffer, opts));
        }
        $delete(handle, resource, opts) {
            return Promise.resolve(this.l(handle).delete(uri_1.URI.revive(resource), opts));
        }
        $rename(handle, oldUri, newUri, opts) {
            return Promise.resolve(this.l(handle).rename(uri_1.URI.revive(oldUri), uri_1.URI.revive(newUri), opts));
        }
        $copy(handle, oldUri, newUri, opts) {
            const provider = this.l(handle);
            if (!provider.copy) {
                throw new Error('FileSystemProvider does not implement "copy"');
            }
            return Promise.resolve(provider.copy(uri_1.URI.revive(oldUri), uri_1.URI.revive(newUri), opts));
        }
        $mkdir(handle, resource) {
            return Promise.resolve(this.l(handle).createDirectory(uri_1.URI.revive(resource)));
        }
        $watch(handle, session, resource, opts) {
            const subscription = this.l(handle).watch(uri_1.URI.revive(resource), opts);
            this.f.set(session, subscription);
        }
        $unwatch(_handle, session) {
            const subscription = this.f.get(session);
            if (subscription) {
                subscription.dispose();
                this.f.delete(session);
            }
        }
        $open(handle, resource, opts) {
            const provider = this.l(handle);
            if (!provider.open) {
                throw new Error('FileSystemProvider does not implement "open"');
            }
            return Promise.resolve(provider.open(uri_1.URI.revive(resource), opts));
        }
        $close(handle, fd) {
            const provider = this.l(handle);
            if (!provider.close) {
                throw new Error('FileSystemProvider does not implement "close"');
            }
            return Promise.resolve(provider.close(fd));
        }
        $read(handle, fd, pos, length) {
            const provider = this.l(handle);
            if (!provider.read) {
                throw new Error('FileSystemProvider does not implement "read"');
            }
            const data = buffer_1.$Ne.alloc(length);
            return Promise.resolve(provider.read(fd, pos, data.buffer, 0, length)).then(read => {
                return data.slice(0, read); // don't send zeros
            });
        }
        $write(handle, fd, pos, data) {
            const provider = this.l(handle);
            if (!provider.write) {
                throw new Error('FileSystemProvider does not implement "write"');
            }
            return Promise.resolve(provider.write(fd, pos, data.buffer, 0, data.byteLength));
        }
        l(handle) {
            const provider = this.c.get(handle);
            if (!provider) {
                const err = new Error();
                err.name = 'ENOPRO';
                err.message = `no provider`;
                throw err;
            }
            return provider;
        }
    }
    exports.$Nqc = $Nqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[242/*vs/workbench/api/common/extHostFileSystemEventService*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,41/*vs/base/common/glob*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,29/*vs/platform/files/common/files*/,48/*vs/base/common/lazy*/]), function (require, exports, event_1, glob_1, uri_1, extHost_protocol_1, typeConverter, extHostTypes_1, files_1, lazy_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Oqc = void 0;
    typeConverter = __importStar(typeConverter);
    class FileSystemWatcher {
        get ignoreCreateEvents() {
            return Boolean(this.h & 0b001);
        }
        get ignoreChangeEvents() {
            return Boolean(this.h & 0b010);
        }
        get ignoreDeleteEvents() {
            return Boolean(this.h & 0b100);
        }
        constructor(mainContext, workspace, extension, dispatcher, globPattern, options) {
            this.a = Math.random();
            this.b = new event_1.$le();
            this.c = new event_1.$le();
            this.d = new event_1.$le();
            this.h = 0;
            if (options?.ignoreCreateEvents) {
                this.h += 0b001;
            }
            if (options?.ignoreChangeEvents) {
                this.h += 0b010;
            }
            if (options?.ignoreDeleteEvents) {
                this.h += 0b100;
            }
            const parsedPattern = (0, glob_1.$Ak)(globPattern);
            // 1.64.x behaviour change: given the new support to watch any folder
            // we start to ignore events outside the workspace when only a string
            // pattern is provided to avoid sending events to extensions that are
            // unexpected.
            // https://github.com/microsoft/vscode/issues/3025
            const excludeOutOfWorkspaceEvents = typeof globPattern === 'string';
            // 1.84.x introduces new proposed API for a watcher to set exclude
            // rules. In these cases, we turn the file watcher into correlation
            // mode and ignore any event that does not match the correlation ID.
            const excludeUncorrelatedEvents = options?.correlate;
            const subscription = dispatcher(events => {
                if (typeof events.session === 'number' && events.session !== this.a) {
                    return; // ignore events from other file watchers that are in correlation mode
                }
                if (excludeUncorrelatedEvents && typeof events.session === 'undefined') {
                    return; // ignore events from other non-correlating file watcher when we are in correlation mode
                }
                if (!options?.ignoreCreateEvents) {
                    for (const created of events.created) {
                        const uri = uri_1.URI.revive(created);
                        if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
                            this.b.fire(uri);
                        }
                    }
                }
                if (!options?.ignoreChangeEvents) {
                    for (const changed of events.changed) {
                        const uri = uri_1.URI.revive(changed);
                        if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
                            this.c.fire(uri);
                        }
                    }
                }
                if (!options?.ignoreDeleteEvents) {
                    for (const deleted of events.deleted) {
                        const uri = uri_1.URI.revive(deleted);
                        if (parsedPattern(uri.fsPath) && (!excludeOutOfWorkspaceEvents || workspace.getWorkspaceFolder(uri))) {
                            this.d.fire(uri);
                        }
                    }
                }
            });
            this.g = extHostTypes_1.$MN.from(this.i(mainContext, extension, globPattern, options, options?.correlate), this.b, this.c, this.d, subscription);
        }
        i(mainContext, extension, globPattern, options, correlate) {
            const disposable = extHostTypes_1.$MN.from();
            if (typeof globPattern === 'string') {
                return disposable; // workspace is already watched by default, no need to watch again!
            }
            if (options?.ignoreChangeEvents && options?.ignoreCreateEvents && options?.ignoreDeleteEvents) {
                return disposable; // no need to watch if we ignore all events
            }
            const proxy = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadFileSystemEventService);
            let recursive = false;
            if (globPattern.pattern.includes(glob_1.$wk) || globPattern.pattern.includes(glob_1.$xk)) {
                recursive = true; // only watch recursively if pattern indicates the need for it
            }
            let filter;
            if (correlate) {
                if (options?.ignoreChangeEvents || options?.ignoreCreateEvents || options?.ignoreDeleteEvents) {
                    filter = files_1.FileChangeFilter.UPDATED | files_1.FileChangeFilter.ADDED | files_1.FileChangeFilter.DELETED;
                    if (options?.ignoreChangeEvents) {
                        filter &= ~files_1.FileChangeFilter.UPDATED;
                    }
                    if (options?.ignoreCreateEvents) {
                        filter &= ~files_1.FileChangeFilter.ADDED;
                    }
                    if (options?.ignoreDeleteEvents) {
                        filter &= ~files_1.FileChangeFilter.DELETED;
                    }
                }
            }
            proxy.$watch(extension.identifier.value, this.a, globPattern.baseUri, { recursive, excludes: options?.excludes ?? [], filter }, Boolean(correlate));
            return extHostTypes_1.$MN.from({ dispose: () => proxy.$unwatch(this.a) });
        }
        dispose() {
            this.g.dispose();
        }
        get onDidCreate() {
            return this.b.event;
        }
        get onDidChange() {
            return this.c.event;
        }
        get onDidDelete() {
            return this.d.event;
        }
    }
    class LazyRevivedFileSystemEvents {
        constructor(a) {
            this.a = a;
            this.session = this.a.session;
            this.b = new lazy_1.$T(() => this.a.created.map(uri_1.URI.revive));
            this.c = new lazy_1.$T(() => this.a.changed.map(uri_1.URI.revive));
            this.d = new lazy_1.$T(() => this.a.deleted.map(uri_1.URI.revive));
        }
        get created() { return this.b.value; }
        get changed() { return this.c.value; }
        get deleted() { return this.d.value; }
    }
    class $Oqc {
        constructor(j, k, l) {
            this.j = j;
            this.k = k;
            this.l = l;
            this.a = new event_1.$le();
            this.b = new event_1.$le();
            this.c = new event_1.$le();
            this.d = new event_1.$le();
            this.g = new event_1.$ne();
            this.h = new event_1.$ne();
            this.i = new event_1.$ne();
            this.onDidRenameFile = this.b.event;
            this.onDidCreateFile = this.c.event;
            this.onDidDeleteFile = this.d.event;
            //
        }
        //--- file events
        createFileSystemWatcher(workspace, extension, globPattern, options) {
            return new FileSystemWatcher(this.j, workspace, extension, this.a.event, typeConverter.GlobPattern.from(globPattern), options);
        }
        $onFileEvent(events) {
            this.a.fire(new LazyRevivedFileSystemEvents(events));
        }
        //--- file operations
        $onDidRunFileOperation(operation, files) {
            switch (operation) {
                case files_1.FileOperation.MOVE:
                    this.b.fire(Object.freeze({ files: files.map(f => ({ oldUri: uri_1.URI.revive(f.source), newUri: uri_1.URI.revive(f.target) })) }));
                    break;
                case files_1.FileOperation.DELETE:
                    this.d.fire(Object.freeze({ files: files.map(f => uri_1.URI.revive(f.target)) }));
                    break;
                case files_1.FileOperation.CREATE:
                case files_1.FileOperation.COPY:
                    this.c.fire(Object.freeze({ files: files.map(f => uri_1.URI.revive(f.target)) }));
                    break;
                default:
                //ignore, dont send
            }
        }
        getOnWillRenameFileEvent(extension) {
            return this.m(extension, this.g);
        }
        getOnWillCreateFileEvent(extension) {
            return this.m(extension, this.h);
        }
        getOnWillDeleteFileEvent(extension) {
            return this.m(extension, this.i);
        }
        m(extension, emitter) {
            return (listener, thisArg, disposables) => {
                const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };
                wrappedListener.extension = extension;
                return emitter.event(wrappedListener, undefined, disposables);
            };
        }
        async $onWillRunFileOperation(operation, files, timeout, token) {
            switch (operation) {
                case files_1.FileOperation.MOVE:
                    return await this.n(this.g, { files: files.map(f => ({ oldUri: uri_1.URI.revive(f.source), newUri: uri_1.URI.revive(f.target) })) }, timeout, token);
                case files_1.FileOperation.DELETE:
                    return await this.n(this.i, { files: files.map(f => uri_1.URI.revive(f.target)) }, timeout, token);
                case files_1.FileOperation.CREATE:
                case files_1.FileOperation.COPY:
                    return await this.n(this.h, { files: files.map(f => uri_1.URI.revive(f.target)) }, timeout, token);
            }
            return undefined;
        }
        async n(emitter, data, timeout, token) {
            const extensionNames = new Set();
            const edits = [];
            await emitter.fireAsync(data, token, async (thenable, listener) => {
                // ignore all results except for WorkspaceEdits. Those are stored in an array.
                const now = Date.now();
                const result = await Promise.resolve(thenable);
                if (result instanceof extHostTypes_1.$YN) {
                    edits.push([listener.extension, result]);
                    extensionNames.add(listener.extension.displayName ?? listener.extension.identifier.value);
                }
                if (Date.now() - now > timeout) {
                    this.k.warn('SLOW file-participant', listener.extension.identifier);
                }
            });
            if (token.isCancellationRequested) {
                return undefined;
            }
            if (edits.length === 0) {
                return undefined;
            }
            // concat all WorkspaceEdits collected via waitUntil-call and send them over to the renderer
            const dto = { edits: [] };
            for (const [, edit] of edits) {
                const { edits } = typeConverter.WorkspaceEdit.from(edit, {
                    getTextDocumentVersion: uri => this.l.getDocument(uri)?.version,
                    getNotebookDocumentVersion: () => undefined,
                });
                dto.edits = dto.edits.concat(edits);
            }
            return { edit: dto, extensionNames: Array.from(extensionNames) };
        }
    }
    exports.$Oqc = $Oqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[243/*vs/workbench/api/common/extHostLanguageFeatures*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,13/*vs/base/common/errors*/,96/*vs/base/common/idGenerator*/,4/*vs/base/common/lifecycle*/,25/*vs/base/common/objects*/,69/*vs/base/common/stopwatch*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,32/*vs/editor/common/core/range*/,286/*vs/editor/common/core/selection*/,93/*vs/editor/common/languages*/,103/*vs/editor/common/services/semanticTokensDto*/,9/*vs/nls*/,18/*vs/platform/extensions/common/extensions*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,24/*vs/workbench/services/extensions/common/extensions*/,79/*vs/workbench/api/common/cache*/,5/*vs/workbench/api/common/extHost.protocol*/]), function (require, exports, arrays_1, async_1, cancellation_1, errors_1, idGenerator_1, lifecycle_1, objects_1, stopwatch_1, strings_1, types_1, uri_1, range_1, selection_1, languages, semanticTokensDto_1, nls_1, extensions_1, typeConvert, extHostTypes_1, extensions_2, cache_1, extHostProtocol) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$zpc = void 0;
    languages = __importStar(languages);
    typeConvert = __importStar(typeConvert);
    extHostProtocol = __importStar(extHostProtocol);
    // --- adapter
    class DocumentSymbolAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDocumentSymbols(resource, token) {
            const doc = this.d.getDocument(resource);
            const value = await this.e.provideDocumentSymbols(doc, token);
            if ((0, arrays_1.$Jb)(value)) {
                return undefined;
            }
            else if (value[0] instanceof extHostTypes_1.$9N) {
                return value.map(typeConvert.DocumentSymbol.from);
            }
            else {
                return DocumentSymbolAdapter.f(value);
            }
        }
        static f(infos) {
            // first sort by start (and end) and then loop over all elements
            // and build a tree based on containment.
            infos = infos.slice(0).sort((a, b) => {
                let res = a.location.range.start.compareTo(b.location.range.start);
                if (res === 0) {
                    res = b.location.range.end.compareTo(a.location.range.end);
                }
                return res;
            });
            const res = [];
            const parentStack = [];
            for (const info of infos) {
                const element = {
                    name: info.name || '!!MISSING: name!!',
                    kind: typeConvert.SymbolKind.from(info.kind),
                    tags: info.tags?.map(typeConvert.SymbolTag.from) || [],
                    detail: '',
                    containerName: info.containerName,
                    range: typeConvert.Range.from(info.location.range),
                    selectionRange: typeConvert.Range.from(info.location.range),
                    children: []
                };
                while (true) {
                    if (parentStack.length === 0) {
                        parentStack.push(element);
                        res.push(element);
                        break;
                    }
                    const parent = parentStack[parentStack.length - 1];
                    if (range_1.$Ot.containsRange(parent.range, element.range) && !range_1.$Ot.equalsRange(parent.range, element.range)) {
                        parent.children?.push(element);
                        parentStack.push(element);
                        break;
                    }
                    parentStack.pop();
                }
            }
            return res;
        }
    }
    class CodeLensAdapter {
        constructor(f, g, h, j, k, l) {
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.l = l;
            this.d = new cache_1.$ppc('CodeLens');
            this.e = new Map();
        }
        async provideCodeLenses(resource, token) {
            const doc = this.f.getDocument(resource);
            const lenses = await this.h.provideCodeLenses(doc, token);
            if (!lenses || token.isCancellationRequested) {
                return undefined;
            }
            const cacheId = this.d.add(lenses);
            const disposables = new lifecycle_1.$Tc();
            this.e.set(cacheId, disposables);
            const result = {
                cacheId,
                lenses: [],
            };
            for (let i = 0; i < lenses.length; i++) {
                result.lenses.push({
                    cacheId: [cacheId, i],
                    range: typeConvert.Range.from(lenses[i].range),
                    command: this.g.toInternal(lenses[i].command, disposables)
                });
            }
            return result;
        }
        async resolveCodeLens(symbol, token) {
            const lens = symbol.cacheId && this.d.get(...symbol.cacheId);
            if (!lens) {
                return undefined;
            }
            let resolvedLens;
            if (typeof this.h.resolveCodeLens !== 'function' || lens.isResolved) {
                resolvedLens = lens;
            }
            else {
                resolvedLens = await this.h.resolveCodeLens(lens, token);
            }
            if (!resolvedLens) {
                resolvedLens = lens;
            }
            if (token.isCancellationRequested) {
                return undefined;
            }
            const disposables = symbol.cacheId && this.e.get(symbol.cacheId[0]);
            if (!disposables) {
                // disposed in the meantime
                return undefined;
            }
            if (!resolvedLens.command) {
                const error = new Error('INVALID code lens resolved, lacks command: ' + this.j.identifier.value);
                this.k.onExtensionError(this.j.identifier, error);
                this.l.error(error);
                return undefined;
            }
            symbol.command = this.g.toInternal(resolvedLens.command, disposables);
            return symbol;
        }
        releaseCodeLenses(cachedId) {
            this.e.get(cachedId)?.dispose();
            this.e.delete(cachedId);
            this.d.delete(cachedId);
        }
    }
    function convertToLocationLinks(value) {
        if (Array.isArray(value)) {
            return value.map(typeConvert.DefinitionLink.from);
        }
        else if (value) {
            return [typeConvert.DefinitionLink.from(value)];
        }
        return [];
    }
    class DefinitionAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDefinition(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideDefinition(doc, pos, token);
            return convertToLocationLinks(value);
        }
    }
    class DeclarationAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDeclaration(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideDeclaration(doc, pos, token);
            return convertToLocationLinks(value);
        }
    }
    class ImplementationAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideImplementation(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideImplementation(doc, pos, token);
            return convertToLocationLinks(value);
        }
    }
    class TypeDefinitionAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideTypeDefinition(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideTypeDefinition(doc, pos, token);
            return convertToLocationLinks(value);
        }
    }
    class HoverAdapter {
        static { this.f = 10; }
        constructor(g, h) {
            this.g = g;
            this.h = h;
            this.d = 0;
            this.e = new Map();
        }
        async provideHover(resource, position, context, token) {
            const doc = this.g.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            let value;
            if (context && context.verbosityRequest) {
                const previousHoverId = context.verbosityRequest.previousHover.id;
                const previousHover = this.e.get(previousHoverId);
                if (!previousHover) {
                    throw new Error(`Hover with id ${previousHoverId} not found`);
                }
                const hoverContext = { verbosityDelta: context.verbosityRequest.verbosityDelta, previousHover };
                value = await this.h.provideHover(doc, pos, token, hoverContext);
            }
            else {
                value = await this.h.provideHover(doc, pos, token);
            }
            if (!value || (0, arrays_1.$Jb)(value.contents)) {
                return undefined;
            }
            if (!value.range) {
                value.range = doc.getWordRangeAtPosition(pos);
            }
            if (!value.range) {
                value.range = new extHostTypes_1.$ON(pos, pos);
            }
            const convertedHover = typeConvert.Hover.from(value);
            const id = this.d;
            // Check if hover map has more than 10 elements and if yes, remove oldest from the map
            if (this.e.size === HoverAdapter.f) {
                const minimumId = Math.min(...this.e.keys());
                this.e.delete(minimumId);
            }
            this.e.set(id, value);
            this.d += 1;
            const hover = {
                ...convertedHover,
                id
            };
            return hover;
        }
        releaseHover(id) {
            this.e.delete(id);
        }
    }
    class EvaluatableExpressionAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideEvaluatableExpression(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideEvaluatableExpression(doc, pos, token);
            if (value) {
                return typeConvert.EvaluatableExpression.from(value);
            }
            return undefined;
        }
    }
    class InlineValuesAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideInlineValues(resource, viewPort, context, token) {
            const doc = this.d.getDocument(resource);
            const value = await this.e.provideInlineValues(doc, typeConvert.Range.to(viewPort), typeConvert.InlineValueContext.to(context), token);
            if (Array.isArray(value)) {
                return value.map(iv => typeConvert.InlineValue.from(iv));
            }
            return undefined;
        }
    }
    class DocumentHighlightAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDocumentHighlights(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideDocumentHighlights(doc, pos, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.DocumentHighlight.from);
            }
            return undefined;
        }
    }
    class MultiDocumentHighlightAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideMultiDocumentHighlights(resource, position, otherResources, token) {
            const doc = this.d.getDocument(resource);
            const otherDocuments = otherResources.map(r => this.d.getDocument(r));
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideMultiDocumentHighlights(doc, pos, otherDocuments, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.MultiDocumentHighlight.from);
            }
            return undefined;
        }
    }
    class LinkedEditingRangeAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideLinkedEditingRanges(resource, position, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideLinkedEditingRanges(doc, pos, token);
            if (value && Array.isArray(value.ranges)) {
                return {
                    ranges: (0, arrays_1.$Gb)(value.ranges.map(typeConvert.Range.from)),
                    wordPattern: value.wordPattern
                };
            }
            return undefined;
        }
    }
    class ReferenceAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideReferences(resource, position, context, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideReferences(doc, pos, context, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.location.from);
            }
            return undefined;
        }
    }
    class CodeActionAdapter {
        static { this.d = 1000; }
        constructor(g, h, j, k, l, m, n) {
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.l = l;
            this.m = m;
            this.n = n;
            this.e = new cache_1.$ppc('CodeAction');
            this.f = new Map();
        }
        async provideCodeActions(resource, rangeOrSelection, context, token) {
            const doc = this.g.getDocument(resource);
            const ran = selection_1.$Qt.isISelection(rangeOrSelection)
                ? typeConvert.Selection.to(rangeOrSelection)
                : typeConvert.Range.to(rangeOrSelection);
            const allDiagnostics = [];
            for (const diagnostic of this.j.getDiagnostics(resource)) {
                if (ran.intersection(diagnostic.range)) {
                    const newLen = allDiagnostics.push(diagnostic);
                    if (newLen > CodeActionAdapter.d) {
                        break;
                    }
                }
            }
            const codeActionContext = {
                diagnostics: allDiagnostics,
                only: context.only ? new extHostTypes_1.$$N(context.only) : undefined,
                triggerKind: typeConvert.CodeActionTriggerKind.to(context.trigger),
            };
            const commandsOrActions = await this.k.provideCodeActions(doc, ran, codeActionContext, token);
            if (!(0, arrays_1.$Kb)(commandsOrActions) || token.isCancellationRequested) {
                return undefined;
            }
            const cacheId = this.e.add(commandsOrActions);
            const disposables = new lifecycle_1.$Tc();
            this.f.set(cacheId, disposables);
            const actions = [];
            for (let i = 0; i < commandsOrActions.length; i++) {
                const candidate = commandsOrActions[i];
                if (!candidate) {
                    continue;
                }
                if (CodeActionAdapter.o(candidate)) {
                    // old school: synthetic code action
                    this.n.report('CodeActionProvider.provideCodeActions - return commands', this.m, `Return 'CodeAction' instances instead.`);
                    actions.push({
                        _isSynthetic: true,
                        title: candidate.title,
                        command: this.h.toInternal(candidate, disposables),
                    });
                }
                else {
                    if (codeActionContext.only) {
                        if (!candidate.kind) {
                            this.l.warn(`${this.m.identifier.value} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);
                        }
                        else if (!codeActionContext.only.contains(candidate.kind)) {
                            this.l.warn(`${this.m.identifier.value} - Code actions of kind '${codeActionContext.only.value}' requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);
                        }
                    }
                    // Ensures that this is either a Range[] or an empty array so we don't get Array<Range | undefined>
                    const range = candidate.ranges ?? [];
                    // new school: convert code action
                    actions.push({
                        cacheId: [cacheId, i],
                        title: candidate.title,
                        command: candidate.command && this.h.toInternal(candidate.command, disposables),
                        diagnostics: candidate.diagnostics && candidate.diagnostics.map(typeConvert.Diagnostic.from),
                        edit: candidate.edit && typeConvert.WorkspaceEdit.from(candidate.edit, undefined),
                        kind: candidate.kind && candidate.kind.value,
                        isPreferred: candidate.isPreferred,
                        isAI: (0, extensions_2.$fH)(this.m, 'codeActionAI') ? candidate.isAI : false,
                        ranges: (0, extensions_2.$fH)(this.m, 'codeActionRanges') ? (0, arrays_1.$Gb)(range.map(typeConvert.Range.from)) : undefined,
                        disabled: candidate.disabled?.reason
                    });
                }
            }
            return { cacheId, actions };
        }
        async resolveCodeAction(id, token) {
            const [sessionId, itemId] = id;
            const item = this.e.get(sessionId, itemId);
            if (!item || CodeActionAdapter.o(item)) {
                return {}; // code actions only!
            }
            if (!this.k.resolveCodeAction) {
                return {}; // this should not happen...
            }
            const resolvedItem = (await this.k.resolveCodeAction(item, token)) ?? item;
            let resolvedEdit;
            if (resolvedItem.edit) {
                resolvedEdit = typeConvert.WorkspaceEdit.from(resolvedItem.edit, undefined);
            }
            let resolvedCommand;
            if (resolvedItem.command) {
                const disposables = this.f.get(sessionId);
                if (disposables) {
                    resolvedCommand = this.h.toInternal(resolvedItem.command, disposables);
                }
            }
            return { edit: resolvedEdit, command: resolvedCommand };
        }
        releaseCodeActions(cachedId) {
            this.f.get(cachedId)?.dispose();
            this.f.delete(cachedId);
            this.e.delete(cachedId);
        }
        static o(thing) {
            return typeof thing.command === 'string' && typeof thing.title === 'string';
        }
    }
    class DocumentPasteEditProvider {
        constructor(e, f, g, h, j) {
            this.e = e;
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.d = new cache_1.$ppc('DocumentPasteEdit');
        }
        async prepareDocumentPaste(resource, ranges, dataTransferDto, token) {
            if (!this.g.prepareDocumentPaste) {
                return;
            }
            const doc = this.f.getDocument(resource);
            const vscodeRanges = ranges.map(range => typeConvert.Range.to(range));
            const dataTransfer = typeConvert.DataTransfer.toDataTransfer(dataTransferDto, () => {
                throw new errors_1.$0();
            });
            await this.g.prepareDocumentPaste(doc, vscodeRanges, dataTransfer, token);
            if (token.isCancellationRequested) {
                return;
            }
            // Only send back values that have been added to the data transfer
            const entries = Array.from(dataTransfer).filter(([, value]) => !(value instanceof extHostTypes_1.$EO));
            return typeConvert.DataTransfer.from(entries);
        }
        async providePasteEdits(requestId, resource, ranges, dataTransferDto, context, token) {
            if (!this.g.provideDocumentPasteEdits) {
                return [];
            }
            const doc = this.f.getDocument(resource);
            const vscodeRanges = ranges.map(range => typeConvert.Range.to(range));
            const dataTransfer = typeConvert.DataTransfer.toDataTransfer(dataTransferDto, async (id) => {
                return (await this.e.$resolvePasteFileData(this.h, requestId, id)).buffer;
            });
            const edits = await this.g.provideDocumentPasteEdits(doc, vscodeRanges, dataTransfer, {
                only: context.only ? new extHostTypes_1.$JO(context.only) : undefined,
                triggerKind: context.triggerKind,
            }, token);
            if (!edits || token.isCancellationRequested) {
                return [];
            }
            const cacheId = this.d.add(edits);
            return edits.map((edit, i) => ({
                _cacheId: [cacheId, i],
                title: edit.title ?? (0, nls_1.localize)(11260, null, this.j.displayName || this.j.name),
                kind: edit.kind,
                yieldTo: edit.yieldTo?.map(x => x.value),
                insertText: typeof edit.insertText === 'string' ? edit.insertText : { snippet: edit.insertText.value },
                additionalEdit: edit.additionalEdit ? typeConvert.WorkspaceEdit.from(edit.additionalEdit, undefined) : undefined,
            }));
        }
        async resolvePasteEdit(id, token) {
            const [sessionId, itemId] = id;
            const item = this.d.get(sessionId, itemId);
            if (!item || !this.g.resolveDocumentPasteEdit) {
                return {}; // this should not happen...
            }
            const resolvedItem = (await this.g.resolveDocumentPasteEdit(item, token)) ?? item;
            const additionalEdit = resolvedItem.additionalEdit ? typeConvert.WorkspaceEdit.from(resolvedItem.additionalEdit, undefined) : undefined;
            return { additionalEdit };
        }
        releasePasteEdits(id) {
            this.d.delete(id);
        }
    }
    class DocumentFormattingAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDocumentFormattingEdits(resource, options, token) {
            const document = this.d.getDocument(resource);
            const value = await this.e.provideDocumentFormattingEdits(document, options, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.TextEdit.from);
            }
            return undefined;
        }
    }
    class RangeFormattingAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDocumentRangeFormattingEdits(resource, range, options, token) {
            const document = this.d.getDocument(resource);
            const ran = typeConvert.Range.to(range);
            const value = await this.e.provideDocumentRangeFormattingEdits(document, ran, options, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.TextEdit.from);
            }
            return undefined;
        }
        async provideDocumentRangesFormattingEdits(resource, ranges, options, token) {
            (0, types_1.$og)(typeof this.e.provideDocumentRangesFormattingEdits === 'function', 'INVALID invocation of `provideDocumentRangesFormattingEdits`');
            const document = this.d.getDocument(resource);
            const _ranges = ranges.map(typeConvert.Range.to);
            const value = await this.e.provideDocumentRangesFormattingEdits(document, _ranges, options, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.TextEdit.from);
            }
            return undefined;
        }
    }
    class OnTypeFormattingAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
            this.autoFormatTriggerCharacters = []; // not here
        }
        async provideOnTypeFormattingEdits(resource, position, ch, options, token) {
            const document = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const value = await this.e.provideOnTypeFormattingEdits(document, pos, ch, options, token);
            if (Array.isArray(value)) {
                return value.map(typeConvert.TextEdit.from);
            }
            return undefined;
        }
    }
    class NavigateTypeAdapter {
        constructor(e, f) {
            this.e = e;
            this.f = f;
            this.d = new cache_1.$ppc('WorkspaceSymbols');
        }
        async provideWorkspaceSymbols(search, token) {
            const value = await this.e.provideWorkspaceSymbols(search, token);
            if (!(0, arrays_1.$Kb)(value)) {
                return { symbols: [] };
            }
            const sid = this.d.add(value);
            const result = {
                cacheId: sid,
                symbols: []
            };
            for (let i = 0; i < value.length; i++) {
                const item = value[i];
                if (!item || !item.name) {
                    this.f.warn('INVALID SymbolInformation', item);
                    continue;
                }
                result.symbols.push({
                    ...typeConvert.WorkspaceSymbol.from(item),
                    cacheId: [sid, i]
                });
            }
            return result;
        }
        async resolveWorkspaceSymbol(symbol, token) {
            if (typeof this.e.resolveWorkspaceSymbol !== 'function') {
                return symbol;
            }
            if (!symbol.cacheId) {
                return symbol;
            }
            const item = this.d.get(...symbol.cacheId);
            if (item) {
                const value = await this.e.resolveWorkspaceSymbol(item, token);
                return value && (0, objects_1.$ho)(symbol, typeConvert.WorkspaceSymbol.from(value), true);
            }
            return undefined;
        }
        releaseWorkspaceSymbols(id) {
            this.d.delete(id);
        }
    }
    class RenameAdapter {
        static supportsResolving(provider) {
            return typeof provider.prepareRename === 'function';
        }
        constructor(d, e, f) {
            this.d = d;
            this.e = e;
            this.f = f;
        }
        async provideRenameEdits(resource, position, newName, token) {
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            try {
                const value = await this.e.provideRenameEdits(doc, pos, newName, token);
                if (!value) {
                    return undefined;
                }
                return typeConvert.WorkspaceEdit.from(value);
            }
            catch (err) {
                const rejectReason = RenameAdapter.g(err);
                if (rejectReason) {
                    return { rejectReason, edits: undefined };
                }
                else {
                    // generic error
                    return Promise.reject(err);
                }
            }
        }
        async resolveRenameLocation(resource, position, token) {
            if (typeof this.e.prepareRename !== 'function') {
                return Promise.resolve(undefined);
            }
            const doc = this.d.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            try {
                const rangeOrLocation = await this.e.prepareRename(doc, pos, token);
                let range;
                let text;
                if (extHostTypes_1.$ON.isRange(rangeOrLocation)) {
                    range = rangeOrLocation;
                    text = doc.getText(rangeOrLocation);
                }
                else if ((0, types_1.$gg)(rangeOrLocation)) {
                    range = rangeOrLocation.range;
                    text = rangeOrLocation.placeholder;
                }
                if (!range || !text) {
                    return undefined;
                }
                if (range.start.line > pos.line || range.end.line < pos.line) {
                    this.f.warn('INVALID rename location: position line must be within range start/end lines');
                    return undefined;
                }
                return { range: typeConvert.Range.from(range), text };
            }
            catch (err) {
                const rejectReason = RenameAdapter.g(err);
                if (rejectReason) {
                    return { rejectReason, range: undefined, text: undefined };
                }
                else {
                    return Promise.reject(err);
                }
            }
        }
        static g(err) {
            if (typeof err === 'string') {
                return err;
            }
            else if (err instanceof Error && typeof err.message === 'string') {
                return err.message;
            }
            else {
                return undefined;
            }
        }
    }
    class NewSymbolNamesAdapter {
        static { this.d = {
            [languages.NewSymbolNameTriggerKind.Invoke]: extHostTypes_1.NewSymbolNameTriggerKind.Invoke,
            [languages.NewSymbolNameTriggerKind.Automatic]: extHostTypes_1.NewSymbolNameTriggerKind.Automatic,
        }; }
        constructor(e, f, g) {
            this.e = e;
            this.f = f;
            this.g = g;
        }
        async supportsAutomaticNewSymbolNamesTriggerKind() {
            return this.f.supportsAutomaticTriggerKind;
        }
        async provideNewSymbolNames(resource, range, triggerKind, token) {
            const doc = this.e.getDocument(resource);
            const pos = typeConvert.Range.to(range);
            try {
                const kind = NewSymbolNamesAdapter.d[triggerKind];
                const value = await this.f.provideNewSymbolNames(doc, pos, kind, token);
                if (!value) {
                    return undefined;
                }
                return value.map(v => typeof v === 'string' /* @ulugbekna: for backward compatibility because `value` used to be just `string[]` */
                    ? { newSymbolName: v }
                    : { newSymbolName: v.newSymbolName, tags: v.tags });
            }
            catch (err) {
                this.g.error(NewSymbolNamesAdapter.h(err) ?? JSON.stringify(err, null, '\t') /* @ulugbekna: assuming `err` doesn't have circular references that could result in an exception when converting to JSON */);
                return undefined;
            }
        }
        // @ulugbekna: this method is also defined in RenameAdapter but seems OK to be duplicated
        static h(err) {
            if (typeof err === 'string') {
                return err;
            }
            else if (err instanceof Error && typeof err.message === 'string') {
                return err.message;
            }
            else {
                return undefined;
            }
        }
    }
    class SemanticTokensPreviousResult {
        constructor(resultId, tokens) {
            this.resultId = resultId;
            this.tokens = tokens;
        }
    }
    class DocumentSemanticTokensAdapter {
        constructor(f, g) {
            this.f = f;
            this.g = g;
            this.e = 1;
            this.d = new Map();
        }
        async provideDocumentSemanticTokens(resource, previousResultId, token) {
            const doc = this.f.getDocument(resource);
            const previousResult = (previousResultId !== 0 ? this.d.get(previousResultId) : null);
            let value = typeof previousResult?.resultId === 'string' && typeof this.g.provideDocumentSemanticTokensEdits === 'function'
                ? await this.g.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token)
                : await this.g.provideDocumentSemanticTokens(doc, token);
            if (previousResult) {
                this.d.delete(previousResultId);
            }
            if (!value) {
                return null;
            }
            value = DocumentSemanticTokensAdapter.h(value);
            return this.o(DocumentSemanticTokensAdapter.n(previousResult, value), value);
        }
        async releaseDocumentSemanticColoring(semanticColoringResultId) {
            this.d.delete(semanticColoringResultId);
        }
        static h(v) {
            if (DocumentSemanticTokensAdapter.j(v)) {
                if (DocumentSemanticTokensAdapter.k(v)) {
                    return v;
                }
                return new extHostTypes_1.$0O(new Uint32Array(v.data), v.resultId);
            }
            else if (DocumentSemanticTokensAdapter.l(v)) {
                if (DocumentSemanticTokensAdapter.m(v)) {
                    return v;
                }
                return new extHostTypes_1.$_O(v.edits.map(edit => new extHostTypes_1.$$O(edit.start, edit.deleteCount, edit.data ? new Uint32Array(edit.data) : edit.data)), v.resultId);
            }
            return v;
        }
        static j(v) {
            return v && !!(v.data);
        }
        static k(v) {
            return (v.data instanceof Uint32Array);
        }
        static l(v) {
            return v && Array.isArray(v.edits);
        }
        static m(v) {
            for (const edit of v.edits) {
                if (!(edit.data instanceof Uint32Array)) {
                    return false;
                }
            }
            return true;
        }
        static n(previousResult, newResult) {
            if (!DocumentSemanticTokensAdapter.j(newResult)) {
                return newResult;
            }
            if (!previousResult || !previousResult.tokens) {
                return newResult;
            }
            const oldData = previousResult.tokens;
            const oldLength = oldData.length;
            const newData = newResult.data;
            const newLength = newData.length;
            let commonPrefixLength = 0;
            const maxCommonPrefixLength = Math.min(oldLength, newLength);
            while (commonPrefixLength < maxCommonPrefixLength && oldData[commonPrefixLength] === newData[commonPrefixLength]) {
                commonPrefixLength++;
            }
            if (commonPrefixLength === oldLength && commonPrefixLength === newLength) {
                // complete overlap!
                return new extHostTypes_1.$_O([], newResult.resultId);
            }
            let commonSuffixLength = 0;
            const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength;
            while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {
                commonSuffixLength++;
            }
            return new extHostTypes_1.$_O([{
                    start: commonPrefixLength,
                    deleteCount: (oldLength - commonPrefixLength - commonSuffixLength),
                    data: newData.subarray(commonPrefixLength, newLength - commonSuffixLength)
                }], newResult.resultId);
        }
        o(value, original) {
            if (DocumentSemanticTokensAdapter.j(value)) {
                const myId = this.e++;
                this.d.set(myId, new SemanticTokensPreviousResult(value.resultId, value.data));
                return (0, semanticTokensDto_1.$Adb)({
                    id: myId,
                    type: 'full',
                    data: value.data
                });
            }
            if (DocumentSemanticTokensAdapter.l(value)) {
                const myId = this.e++;
                if (DocumentSemanticTokensAdapter.j(original)) {
                    // store the original
                    this.d.set(myId, new SemanticTokensPreviousResult(original.resultId, original.data));
                }
                else {
                    this.d.set(myId, new SemanticTokensPreviousResult(value.resultId));
                }
                return (0, semanticTokensDto_1.$Adb)({
                    id: myId,
                    type: 'delta',
                    deltas: (value.edits || []).map(edit => ({ start: edit.start, deleteCount: edit.deleteCount, data: edit.data }))
                });
            }
            return null;
        }
    }
    class DocumentRangeSemanticTokensAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideDocumentRangeSemanticTokens(resource, range, token) {
            const doc = this.d.getDocument(resource);
            const value = await this.e.provideDocumentRangeSemanticTokens(doc, typeConvert.Range.to(range), token);
            if (!value) {
                return null;
            }
            return this.f(value);
        }
        f(value) {
            return (0, semanticTokensDto_1.$Adb)({
                id: 0,
                type: 'full',
                data: value.data
            });
        }
    }
    class CompletionsAdapter {
        static supportsResolving(provider) {
            return typeof provider.resolveCompletionItem === 'function';
        }
        constructor(f, g, h, j, k) {
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.d = new cache_1.$ppc('CompletionItem');
            this.e = new Map();
        }
        async provideCompletionItems(resource, position, context, token) {
            const doc = this.f.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            // The default insert/replace ranges. It's important to compute them
            // before asynchronously asking the provider for its results. See
            // https://github.com/microsoft/vscode/issues/83400#issuecomment-546851421
            const replaceRange = doc.getWordRangeAtPosition(pos) || new extHostTypes_1.$ON(pos, pos);
            const insertRange = replaceRange.with({ end: pos });
            const sw = new stopwatch_1.$fe();
            const itemsOrList = await this.h.provideCompletionItems(doc, pos, token, typeConvert.CompletionContext.to(context));
            if (!itemsOrList) {
                // undefined and null are valid results
                return undefined;
            }
            if (token.isCancellationRequested) {
                // cancelled -> return without further ado, esp no caching
                // of results as they will leak
                return undefined;
            }
            const list = Array.isArray(itemsOrList) ? new extHostTypes_1.$lO(itemsOrList) : itemsOrList;
            // keep result for providers that support resolving
            const pid = CompletionsAdapter.supportsResolving(this.h) ? this.d.add(list.items) : this.d.add([]);
            const disposables = new lifecycle_1.$Tc();
            this.e.set(pid, disposables);
            const completions = [];
            const result = {
                x: pid,
                [extHostProtocol.ISuggestResultDtoField.completions]: completions,
                [extHostProtocol.ISuggestResultDtoField.defaultRanges]: { replace: typeConvert.Range.from(replaceRange), insert: typeConvert.Range.from(insertRange) },
                [extHostProtocol.ISuggestResultDtoField.isIncomplete]: list.isIncomplete || undefined,
                [extHostProtocol.ISuggestResultDtoField.duration]: sw.elapsed()
            };
            for (let i = 0; i < list.items.length; i++) {
                const item = list.items[i];
                // check for bad completion item first
                const dto = this.l(item, [pid, i], insertRange, replaceRange);
                completions.push(dto);
            }
            return result;
        }
        async resolveCompletionItem(id, token) {
            if (typeof this.h.resolveCompletionItem !== 'function') {
                return undefined;
            }
            const item = this.d.get(...id);
            if (!item) {
                return undefined;
            }
            const dto1 = this.l(item, id);
            const resolvedItem = await this.h.resolveCompletionItem(item, token);
            if (!resolvedItem) {
                return undefined;
            }
            const dto2 = this.l(resolvedItem, id);
            if (dto1[extHostProtocol.ISuggestDataDtoField.insertText] !== dto2[extHostProtocol.ISuggestDataDtoField.insertText]
                || dto1[extHostProtocol.ISuggestDataDtoField.insertTextRules] !== dto2[extHostProtocol.ISuggestDataDtoField.insertTextRules]) {
                this.j.report('CompletionItem.insertText', this.k, 'extension MAY NOT change \'insertText\' of a CompletionItem during resolve');
            }
            if (dto1[extHostProtocol.ISuggestDataDtoField.commandIdent] !== dto2[extHostProtocol.ISuggestDataDtoField.commandIdent]
                || dto1[extHostProtocol.ISuggestDataDtoField.commandId] !== dto2[extHostProtocol.ISuggestDataDtoField.commandId]
                || !(0, objects_1.$io)(dto1[extHostProtocol.ISuggestDataDtoField.commandArguments], dto2[extHostProtocol.ISuggestDataDtoField.commandArguments])) {
                this.j.report('CompletionItem.command', this.k, 'extension MAY NOT change \'command\' of a CompletionItem during resolve');
            }
            return {
                ...dto1,
                [extHostProtocol.ISuggestDataDtoField.documentation]: dto2[extHostProtocol.ISuggestDataDtoField.documentation],
                [extHostProtocol.ISuggestDataDtoField.detail]: dto2[extHostProtocol.ISuggestDataDtoField.detail],
                [extHostProtocol.ISuggestDataDtoField.additionalTextEdits]: dto2[extHostProtocol.ISuggestDataDtoField.additionalTextEdits],
                // (fishy) async insertText
                [extHostProtocol.ISuggestDataDtoField.insertText]: dto2[extHostProtocol.ISuggestDataDtoField.insertText],
                [extHostProtocol.ISuggestDataDtoField.insertTextRules]: dto2[extHostProtocol.ISuggestDataDtoField.insertTextRules],
                // (fishy) async command
                [extHostProtocol.ISuggestDataDtoField.commandIdent]: dto2[extHostProtocol.ISuggestDataDtoField.commandIdent],
                [extHostProtocol.ISuggestDataDtoField.commandId]: dto2[extHostProtocol.ISuggestDataDtoField.commandId],
                [extHostProtocol.ISuggestDataDtoField.commandArguments]: dto2[extHostProtocol.ISuggestDataDtoField.commandArguments],
            };
        }
        releaseCompletionItems(id) {
            this.e.get(id)?.dispose();
            this.e.delete(id);
            this.d.delete(id);
        }
        l(item, id, defaultInsertRange, defaultReplaceRange) {
            const disposables = this.e.get(id[0]);
            if (!disposables) {
                throw Error('DisposableStore is missing...');
            }
            const command = this.g.toInternal(item.command, disposables);
            const result = {
                //
                x: id,
                //
                [extHostProtocol.ISuggestDataDtoField.label]: item.label,
                [extHostProtocol.ISuggestDataDtoField.kind]: item.kind !== undefined ? typeConvert.CompletionItemKind.from(item.kind) : undefined,
                [extHostProtocol.ISuggestDataDtoField.kindModifier]: item.tags && item.tags.map(typeConvert.CompletionItemTag.from),
                [extHostProtocol.ISuggestDataDtoField.detail]: item.detail,
                [extHostProtocol.ISuggestDataDtoField.documentation]: typeof item.documentation === 'undefined' ? undefined : typeConvert.MarkdownString.fromStrict(item.documentation),
                [extHostProtocol.ISuggestDataDtoField.sortText]: item.sortText !== item.label ? item.sortText : undefined,
                [extHostProtocol.ISuggestDataDtoField.filterText]: item.filterText !== item.label ? item.filterText : undefined,
                [extHostProtocol.ISuggestDataDtoField.preselect]: item.preselect || undefined,
                [extHostProtocol.ISuggestDataDtoField.insertTextRules]: item.keepWhitespace ? languages.CompletionItemInsertTextRule.KeepWhitespace : languages.CompletionItemInsertTextRule.None,
                [extHostProtocol.ISuggestDataDtoField.commitCharacters]: item.commitCharacters?.join(''),
                [extHostProtocol.ISuggestDataDtoField.additionalTextEdits]: item.additionalTextEdits && item.additionalTextEdits.map(typeConvert.TextEdit.from),
                [extHostProtocol.ISuggestDataDtoField.commandIdent]: command?.$ident,
                [extHostProtocol.ISuggestDataDtoField.commandId]: command?.id,
                [extHostProtocol.ISuggestDataDtoField.commandArguments]: command?.$ident ? undefined : command?.arguments, // filled in on main side from $ident
            };
            // 'insertText'-logic
            if (item.textEdit) {
                this.j.report('CompletionItem.textEdit', this.k, `Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.`);
                result[extHostProtocol.ISuggestDataDtoField.insertText] = item.textEdit.newText;
            }
            else if (typeof item.insertText === 'string') {
                result[extHostProtocol.ISuggestDataDtoField.insertText] = item.insertText;
            }
            else if (item.insertText instanceof extHostTypes_1.$ZN) {
                result[extHostProtocol.ISuggestDataDtoField.insertText] = item.insertText.value;
                result[extHostProtocol.ISuggestDataDtoField.insertTextRules] |= languages.CompletionItemInsertTextRule.InsertAsSnippet;
            }
            // 'overwrite[Before|After]'-logic
            let range;
            if (item.textEdit) {
                range = item.textEdit.range;
            }
            else if (item.range) {
                range = item.range;
            }
            if (extHostTypes_1.$ON.isRange(range)) {
                // "old" range
                result[extHostProtocol.ISuggestDataDtoField.range] = typeConvert.Range.from(range);
            }
            else if (range && (!defaultInsertRange?.isEqual(range.inserting) || !defaultReplaceRange?.isEqual(range.replacing))) {
                // ONLY send range when it's different from the default ranges (safe bandwidth)
                result[extHostProtocol.ISuggestDataDtoField.range] = {
                    insert: typeConvert.Range.from(range.inserting),
                    replace: typeConvert.Range.from(range.replacing)
                };
            }
            return result;
        }
    }
    class InlineCompletionAdapterBase {
        async provideInlineCompletions(resource, position, context, token) {
            return undefined;
        }
        async provideInlineEdits(resource, range, context, token) {
            return undefined;
        }
        disposeCompletions(pid) { }
        handleDidShowCompletionItem(pid, idx, updatedInsertText) { }
        handlePartialAccept(pid, idx, acceptedCharacters, info) { }
    }
    class InlineCompletionAdapter extends InlineCompletionAdapterBase {
        constructor(f, g, h, j) {
            super();
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.d = new ReferenceMap();
            this.e = (0, extensions_2.$fH)(this.f, 'inlineCompletionsAdditions');
            this.k = {
                [languages.InlineCompletionTriggerKind.Automatic]: extHostTypes_1.InlineCompletionTriggerKind.Automatic,
                [languages.InlineCompletionTriggerKind.Explicit]: extHostTypes_1.InlineCompletionTriggerKind.Invoke,
            };
        }
        get supportsHandleEvents() {
            return (0, extensions_2.$fH)(this.f, 'inlineCompletionsAdditions')
                && (typeof this.h.handleDidShowCompletionItem === 'function'
                    || typeof this.h.handleDidPartiallyAcceptCompletionItem === 'function');
        }
        async provideInlineCompletions(resource, position, context, token) {
            const doc = this.g.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const result = await this.h.provideInlineCompletionItems(doc, pos, {
                selectedCompletionInfo: context.selectedSuggestionInfo
                    ? {
                        range: typeConvert.Range.to(context.selectedSuggestionInfo.range),
                        text: context.selectedSuggestionInfo.text
                    }
                    : undefined,
                triggerKind: this.k[context.triggerKind]
            }, token);
            if (!result) {
                // undefined and null are valid results
                return undefined;
            }
            if (token.isCancellationRequested) {
                // cancelled -> return without further ado, esp no caching
                // of results as they will leak
                return undefined;
            }
            const normalizedResult = Array.isArray(result) ? result : result.items;
            const commands = this.e ? Array.isArray(result) ? [] : result.commands || [] : [];
            const enableForwardStability = this.e && !Array.isArray(result) ? result.enableForwardStability : undefined;
            let disposableStore = undefined;
            const pid = this.d.createReferenceId({
                dispose() {
                    disposableStore?.dispose();
                },
                items: normalizedResult
            });
            return {
                pid,
                items: normalizedResult.map((item, idx) => {
                    let command = undefined;
                    if (item.command) {
                        if (!disposableStore) {
                            disposableStore = new lifecycle_1.$Tc();
                        }
                        command = this.j.toInternal(item.command, disposableStore);
                    }
                    const insertText = item.insertText;
                    return ({
                        insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },
                        filterText: item.filterText,
                        range: item.range ? typeConvert.Range.from(item.range) : undefined,
                        command,
                        idx: idx,
                        completeBracketPairs: this.e ? item.completeBracketPairs : false,
                    });
                }),
                commands: commands.map(c => {
                    if (!disposableStore) {
                        disposableStore = new lifecycle_1.$Tc();
                    }
                    return this.j.toInternal(c, disposableStore);
                }),
                suppressSuggestions: false,
                enableForwardStability,
            };
        }
        async provideInlineEdits(resource, range, context, token) {
            if (!this.h.provideInlineEdits) {
                return undefined;
            }
            (0, extensions_2.$gH)(this.f, 'inlineCompletionsAdditions');
            const doc = this.g.getDocument(resource);
            const r = typeConvert.Range.to(range);
            const result = await this.h.provideInlineEdits(doc, r, {
                selectedCompletionInfo: context.selectedSuggestionInfo
                    ? {
                        range: typeConvert.Range.to(context.selectedSuggestionInfo.range),
                        text: context.selectedSuggestionInfo.text
                    }
                    : undefined,
                triggerKind: this.k[context.triggerKind],
                userPrompt: context.userPrompt,
            }, token);
            if (!result) {
                // undefined and null are valid results
                return undefined;
            }
            if (token.isCancellationRequested) {
                // cancelled -> return without further ado, esp no caching
                // of results as they will leak
                return undefined;
            }
            const normalizedResult = Array.isArray(result) ? result : result.items;
            const commands = this.e ? Array.isArray(result) ? [] : result.commands || [] : [];
            const enableForwardStability = this.e && !Array.isArray(result) ? result.enableForwardStability : undefined;
            let disposableStore = undefined;
            const pid = this.d.createReferenceId({
                dispose() {
                    disposableStore?.dispose();
                },
                items: normalizedResult
            });
            return {
                pid,
                items: normalizedResult.map((item, idx) => {
                    let command = undefined;
                    if (item.command) {
                        if (!disposableStore) {
                            disposableStore = new lifecycle_1.$Tc();
                        }
                        command = this.j.toInternal(item.command, disposableStore);
                    }
                    const insertText = item.insertText;
                    return ({
                        insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },
                        filterText: item.filterText,
                        range: item.range ? typeConvert.Range.from(item.range) : undefined,
                        command,
                        idx: idx,
                        completeBracketPairs: this.e ? item.completeBracketPairs : false,
                    });
                }),
                commands: commands.map(c => {
                    if (!disposableStore) {
                        disposableStore = new lifecycle_1.$Tc();
                    }
                    return this.j.toInternal(c, disposableStore);
                }),
                suppressSuggestions: false,
                enableForwardStability,
            };
        }
        disposeCompletions(pid) {
            const data = this.d.disposeReferenceId(pid);
            data?.dispose();
        }
        handleDidShowCompletionItem(pid, idx, updatedInsertText) {
            const completionItem = this.d.get(pid)?.items[idx];
            if (completionItem) {
                if (this.h.handleDidShowCompletionItem && this.e) {
                    this.h.handleDidShowCompletionItem(completionItem, updatedInsertText);
                }
            }
        }
        handlePartialAccept(pid, idx, acceptedCharacters, info) {
            const completionItem = this.d.get(pid)?.items[idx];
            if (completionItem) {
                if (this.h.handleDidPartiallyAcceptCompletionItem && this.e) {
                    this.h.handleDidPartiallyAcceptCompletionItem(completionItem, acceptedCharacters);
                    this.h.handleDidPartiallyAcceptCompletionItem(completionItem, typeConvert.PartialAcceptInfo.to(info));
                }
            }
        }
    }
    class InlineEditAdapter {
        async provideInlineEdits(uri, context, token) {
            const doc = this.f.getDocument(uri);
            const result = await this.g.provideInlineEdit(doc, {
                triggerKind: this.e[context.triggerKind]
            }, token);
            if (!result) {
                // undefined and null are valid results
                return undefined;
            }
            if (token.isCancellationRequested) {
                // cancelled -> return without further ado, esp no caching
                // of results as they will leak
                return undefined;
            }
            let disposableStore = undefined;
            const pid = this.d.createReferenceId({
                dispose() {
                    disposableStore?.dispose();
                },
                item: result
            });
            let acceptCommand = undefined;
            if (result.accepted) {
                if (!disposableStore) {
                    disposableStore = new lifecycle_1.$Tc();
                }
                acceptCommand = this.h.toInternal(result.accepted, disposableStore);
            }
            let rejectCommand = undefined;
            if (result.rejected) {
                if (!disposableStore) {
                    disposableStore = new lifecycle_1.$Tc();
                }
                rejectCommand = this.h.toInternal(result.rejected, disposableStore);
            }
            const langResult = {
                pid,
                text: result.text,
                range: typeConvert.Range.from(result.range),
                accepted: acceptCommand,
                rejected: rejectCommand,
            };
            return langResult;
        }
        disposeEdit(pid) {
            const data = this.d.disposeReferenceId(pid);
            data?.dispose();
        }
        constructor(_extension, f, g, h) {
            this.f = f;
            this.g = g;
            this.h = h;
            this.d = new ReferenceMap();
            this.e = {
                [languages.InlineEditTriggerKind.Automatic]: extHostTypes_1.InlineEditTriggerKind.Automatic,
                [languages.InlineEditTriggerKind.Invoke]: extHostTypes_1.InlineEditTriggerKind.Invoke,
            };
        }
    }
    class ReferenceMap {
        constructor() {
            this.d = new Map();
            this.e = 1;
        }
        createReferenceId(value) {
            const id = this.e++;
            this.d.set(id, value);
            return id;
        }
        disposeReferenceId(referenceId) {
            const value = this.d.get(referenceId);
            this.d.delete(referenceId);
            return value;
        }
        get(referenceId) {
            return this.d.get(referenceId);
        }
    }
    class SignatureHelpAdapter {
        constructor(e, f) {
            this.e = e;
            this.f = f;
            this.d = new cache_1.$ppc('SignatureHelp');
        }
        async provideSignatureHelp(resource, position, context, token) {
            const doc = this.e.getDocument(resource);
            const pos = typeConvert.Position.to(position);
            const vscodeContext = this.g(context);
            const value = await this.f.provideSignatureHelp(doc, pos, token, vscodeContext);
            if (value) {
                const id = this.d.add([value]);
                return { ...typeConvert.SignatureHelp.from(value), id };
            }
            return undefined;
        }
        g(context) {
            let activeSignatureHelp = undefined;
            if (context.activeSignatureHelp) {
                const revivedSignatureHelp = typeConvert.SignatureHelp.to(context.activeSignatureHelp);
                const saved = this.d.get(context.activeSignatureHelp.id, 0);
                if (saved) {
                    activeSignatureHelp = saved;
                    activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;
                    activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;
                }
                else {
                    activeSignatureHelp = revivedSignatureHelp;
                }
            }
            return { ...context, activeSignatureHelp };
        }
        releaseSignatureHelp(id) {
            this.d.delete(id);
        }
    }
    class InlayHintsAdapter {
        constructor(f, g, h, j, k) {
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.d = new cache_1.$ppc('InlayHints');
            this.e = new Map();
        }
        async provideInlayHints(resource, ran, token) {
            const doc = this.f.getDocument(resource);
            const range = typeConvert.Range.to(ran);
            const hints = await this.h.provideInlayHints(doc, range, token);
            if (!Array.isArray(hints) || hints.length === 0) {
                // bad result
                this.j.trace(`[InlayHints] NO inlay hints from '${this.k.identifier.value}' for range ${JSON.stringify(ran)}`);
                return undefined;
            }
            if (token.isCancellationRequested) {
                // cancelled -> return without further ado, esp no caching
                // of results as they will leak
                return undefined;
            }
            const pid = this.d.add(hints);
            this.e.set(pid, new lifecycle_1.$Tc());
            const result = { hints: [], cacheId: pid };
            for (let i = 0; i < hints.length; i++) {
                if (this.l(hints[i], range)) {
                    result.hints.push(this.m(hints[i], [pid, i]));
                }
            }
            this.j.trace(`[InlayHints] ${result.hints.length} inlay hints from '${this.k.identifier.value}' for range ${JSON.stringify(ran)}`);
            return result;
        }
        async resolveInlayHint(id, token) {
            if (typeof this.h.resolveInlayHint !== 'function') {
                return undefined;
            }
            const item = this.d.get(...id);
            if (!item) {
                return undefined;
            }
            const hint = await this.h.resolveInlayHint(item, token);
            if (!hint) {
                return undefined;
            }
            if (!this.l(hint)) {
                return undefined;
            }
            return this.m(hint, id);
        }
        releaseHints(id) {
            this.e.get(id)?.dispose();
            this.e.delete(id);
            this.d.delete(id);
        }
        l(hint, range) {
            if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every(part => part.value.length === 0)) {
                console.log('INVALID inlay hint, empty label', hint);
                return false;
            }
            if (range && !range.contains(hint.position)) {
                // console.log('INVALID inlay hint, position outside range', range, hint);
                return false;
            }
            return true;
        }
        m(hint, id) {
            const disposables = this.e.get(id[0]);
            if (!disposables) {
                throw Error('DisposableStore is missing...');
            }
            const result = {
                label: '', // fill-in below
                cacheId: id,
                tooltip: typeConvert.MarkdownString.fromStrict(hint.tooltip),
                position: typeConvert.Position.from(hint.position),
                textEdits: hint.textEdits && hint.textEdits.map(typeConvert.TextEdit.from),
                kind: hint.kind && typeConvert.InlayHintKind.from(hint.kind),
                paddingLeft: hint.paddingLeft,
                paddingRight: hint.paddingRight,
            };
            if (typeof hint.label === 'string') {
                result.label = hint.label;
            }
            else {
                const parts = [];
                result.label = parts;
                for (const part of hint.label) {
                    if (!part.value) {
                        console.warn('INVALID inlay hint, empty label part', this.k.identifier.value);
                        continue;
                    }
                    const part2 = {
                        label: part.value,
                        tooltip: typeConvert.MarkdownString.fromStrict(part.tooltip)
                    };
                    if (extHostTypes_1.$1N.isLocation(part.location)) {
                        part2.location = typeConvert.location.from(part.location);
                    }
                    if (part.command) {
                        part2.command = this.g.toInternal(part.command, disposables);
                    }
                    parts.push(part2);
                }
            }
            return result;
        }
    }
    class LinkProviderAdapter {
        constructor(e, f) {
            this.e = e;
            this.f = f;
            this.d = new cache_1.$ppc('DocumentLink');
        }
        async provideLinks(resource, token) {
            const doc = this.e.getDocument(resource);
            const links = await this.f.provideDocumentLinks(doc, token);
            if (!Array.isArray(links) || links.length === 0) {
                // bad result
                return undefined;
            }
            if (token.isCancellationRequested) {
                // cancelled -> return without further ado, esp no caching
                // of results as they will leak
                return undefined;
            }
            if (typeof this.f.resolveDocumentLink !== 'function') {
                // no resolve -> no caching
                return { links: links.filter(LinkProviderAdapter.g).map(typeConvert.DocumentLink.from) };
            }
            else {
                // cache links for future resolving
                const pid = this.d.add(links);
                const result = { links: [], cacheId: pid };
                for (let i = 0; i < links.length; i++) {
                    if (!LinkProviderAdapter.g(links[i])) {
                        continue;
                    }
                    const dto = typeConvert.DocumentLink.from(links[i]);
                    dto.cacheId = [pid, i];
                    result.links.push(dto);
                }
                return result;
            }
        }
        static g(link) {
            if (link.target && link.target.path.length > 50_000) {
                console.warn('DROPPING link because it is too long');
                return false;
            }
            return true;
        }
        async resolveLink(id, token) {
            if (typeof this.f.resolveDocumentLink !== 'function') {
                return undefined;
            }
            const item = this.d.get(...id);
            if (!item) {
                return undefined;
            }
            const link = await this.f.resolveDocumentLink(item, token);
            if (!link || !LinkProviderAdapter.g(link)) {
                return undefined;
            }
            return typeConvert.DocumentLink.from(link);
        }
        releaseLinks(id) {
            this.d.delete(id);
        }
    }
    class ColorProviderAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideColors(resource, token) {
            const doc = this.d.getDocument(resource);
            const colors = await this.e.provideDocumentColors(doc, token);
            if (!Array.isArray(colors)) {
                return [];
            }
            const colorInfos = colors.map(ci => {
                return {
                    color: typeConvert.Color.from(ci.color),
                    range: typeConvert.Range.from(ci.range)
                };
            });
            return colorInfos;
        }
        async provideColorPresentations(resource, raw, token) {
            const document = this.d.getDocument(resource);
            const range = typeConvert.Range.to(raw.range);
            const color = typeConvert.Color.to(raw.color);
            const value = await this.e.provideColorPresentations(color, { document, range }, token);
            if (!Array.isArray(value)) {
                return undefined;
            }
            return value.map(typeConvert.ColorPresentation.from);
        }
    }
    class FoldingProviderAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideFoldingRanges(resource, context, token) {
            const doc = this.d.getDocument(resource);
            const ranges = await this.e.provideFoldingRanges(doc, context, token);
            if (!Array.isArray(ranges)) {
                return undefined;
            }
            return ranges.map(typeConvert.FoldingRange.from);
        }
    }
    class SelectionRangeAdapter {
        constructor(d, e, f) {
            this.d = d;
            this.e = e;
            this.f = f;
        }
        async provideSelectionRanges(resource, pos, token) {
            const document = this.d.getDocument(resource);
            const positions = pos.map(typeConvert.Position.to);
            const allProviderRanges = await this.e.provideSelectionRanges(document, positions, token);
            if (!(0, arrays_1.$Kb)(allProviderRanges)) {
                return [];
            }
            if (allProviderRanges.length !== positions.length) {
                this.f.warn('BAD selection ranges, provider must return ranges for each position');
                return [];
            }
            const allResults = [];
            for (let i = 0; i < positions.length; i++) {
                const oneResult = [];
                allResults.push(oneResult);
                let last = positions[i];
                let selectionRange = allProviderRanges[i];
                while (true) {
                    if (!selectionRange.range.contains(last)) {
                        throw new Error('INVALID selection range, must contain the previous range');
                    }
                    oneResult.push(typeConvert.SelectionRange.from(selectionRange));
                    if (!selectionRange.parent) {
                        break;
                    }
                    last = selectionRange.range;
                    selectionRange = selectionRange.parent;
                }
            }
            return allResults;
        }
    }
    class CallHierarchyAdapter {
        constructor(f, g) {
            this.f = f;
            this.g = g;
            this.d = new idGenerator_1.$pQ('');
            this.e = new Map();
        }
        async prepareSession(uri, position, token) {
            const doc = this.f.getDocument(uri);
            const pos = typeConvert.Position.to(position);
            const items = await this.g.prepareCallHierarchy(doc, pos, token);
            if (!items) {
                return undefined;
            }
            const sessionId = this.d.nextId();
            this.e.set(sessionId, new Map());
            if (Array.isArray(items)) {
                return items.map(item => this.h(sessionId, item));
            }
            else {
                return [this.h(sessionId, items)];
            }
        }
        async provideCallsTo(sessionId, itemId, token) {
            const item = this.j(sessionId, itemId);
            if (!item) {
                throw new Error('missing call hierarchy item');
            }
            const calls = await this.g.provideCallHierarchyIncomingCalls(item, token);
            if (!calls) {
                return undefined;
            }
            return calls.map(call => {
                return {
                    from: this.h(sessionId, call.from),
                    fromRanges: call.fromRanges.map(r => typeConvert.Range.from(r))
                };
            });
        }
        async provideCallsFrom(sessionId, itemId, token) {
            const item = this.j(sessionId, itemId);
            if (!item) {
                throw new Error('missing call hierarchy item');
            }
            const calls = await this.g.provideCallHierarchyOutgoingCalls(item, token);
            if (!calls) {
                return undefined;
            }
            return calls.map(call => {
                return {
                    to: this.h(sessionId, call.to),
                    fromRanges: call.fromRanges.map(r => typeConvert.Range.from(r))
                };
            });
        }
        releaseSession(sessionId) {
            this.e.delete(sessionId);
        }
        h(sessionId, item) {
            const map = this.e.get(sessionId);
            const dto = typeConvert.CallHierarchyItem.from(item, sessionId, map.size.toString(36));
            map.set(dto._itemId, item);
            return dto;
        }
        j(sessionId, itemId) {
            const map = this.e.get(sessionId);
            return map?.get(itemId);
        }
    }
    class TypeHierarchyAdapter {
        constructor(f, g) {
            this.f = f;
            this.g = g;
            this.d = new idGenerator_1.$pQ('');
            this.e = new Map();
        }
        async prepareSession(uri, position, token) {
            const doc = this.f.getDocument(uri);
            const pos = typeConvert.Position.to(position);
            const items = await this.g.prepareTypeHierarchy(doc, pos, token);
            if (!items) {
                return undefined;
            }
            const sessionId = this.d.nextId();
            this.e.set(sessionId, new Map());
            if (Array.isArray(items)) {
                return items.map(item => this.h(sessionId, item));
            }
            else {
                return [this.h(sessionId, items)];
            }
        }
        async provideSupertypes(sessionId, itemId, token) {
            const item = this.j(sessionId, itemId);
            if (!item) {
                throw new Error('missing type hierarchy item');
            }
            const supertypes = await this.g.provideTypeHierarchySupertypes(item, token);
            if (!supertypes) {
                return undefined;
            }
            return supertypes.map(supertype => {
                return this.h(sessionId, supertype);
            });
        }
        async provideSubtypes(sessionId, itemId, token) {
            const item = this.j(sessionId, itemId);
            if (!item) {
                throw new Error('missing type hierarchy item');
            }
            const subtypes = await this.g.provideTypeHierarchySubtypes(item, token);
            if (!subtypes) {
                return undefined;
            }
            return subtypes.map(subtype => {
                return this.h(sessionId, subtype);
            });
        }
        releaseSession(sessionId) {
            this.e.delete(sessionId);
        }
        h(sessionId, item) {
            const map = this.e.get(sessionId);
            const dto = typeConvert.TypeHierarchyItem.from(item, sessionId, map.size.toString(36));
            map.set(dto._itemId, item);
            return dto;
        }
        j(sessionId, itemId) {
            const map = this.e.get(sessionId);
            return map?.get(itemId);
        }
    }
    class DocumentDropEditAdapter {
        constructor(e, f, g, h, j) {
            this.e = e;
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.d = new cache_1.$ppc('DocumentDropEdit');
        }
        async provideDocumentOnDropEdits(requestId, uri, position, dataTransferDto, token) {
            const doc = this.f.getDocument(uri);
            const pos = typeConvert.Position.to(position);
            const dataTransfer = typeConvert.DataTransfer.toDataTransfer(dataTransferDto, async (id) => {
                return (await this.e.$resolveDocumentOnDropFileData(this.h, requestId, id)).buffer;
            });
            const edits = await this.g.provideDocumentDropEdits(doc, pos, dataTransfer, token);
            if (!edits) {
                return undefined;
            }
            const editsArray = (0, arrays_1.$1b)(edits);
            const cacheId = this.d.add(editsArray);
            return editsArray.map((edit, i) => ({
                _cacheId: [cacheId, i],
                title: edit.title ?? (0, nls_1.localize)(11261, null, this.j.displayName || this.j.name),
                kind: edit.kind?.value,
                yieldTo: edit.yieldTo?.map(x => x.value),
                insertText: typeof edit.insertText === 'string' ? edit.insertText : { snippet: edit.insertText.value },
                additionalEdit: edit.additionalEdit ? typeConvert.WorkspaceEdit.from(edit.additionalEdit, undefined) : undefined,
            }));
        }
        async resolveDropEdit(id, token) {
            const [sessionId, itemId] = id;
            const item = this.d.get(sessionId, itemId);
            if (!item || !this.g.resolveDocumentDropEdit) {
                return {}; // this should not happen...
            }
            const resolvedItem = (await this.g.resolveDocumentDropEdit(item, token)) ?? item;
            const additionalEdit = resolvedItem.additionalEdit ? typeConvert.WorkspaceEdit.from(resolvedItem.additionalEdit, undefined) : undefined;
            return { additionalEdit };
        }
        releaseDropEdits(id) {
            this.d.delete(id);
        }
    }
    class MappedEditsAdapter {
        constructor(d, e) {
            this.d = d;
            this.e = e;
        }
        async provideMappedEdits(resource, codeBlocks, context, token) {
            const uri = uri_1.URI.revive(resource);
            const doc = this.d.getDocument(uri);
            const usedContext = context.documents.map((docSubArray) => docSubArray.map((r) => {
                return {
                    uri: uri_1.URI.revive(r.uri),
                    version: r.version,
                    ranges: r.ranges.map((range) => typeConvert.Range.to(range)),
                };
            }));
            const ctx = {
                documents: usedContext,
                selections: usedContext[0]?.[0]?.ranges ?? [] // @ulugbekna: this is a hack for backward compatibility
            };
            const mappedEdits = await this.e.provideMappedEdits(doc, codeBlocks, ctx, token);
            return mappedEdits ? typeConvert.WorkspaceEdit.from(mappedEdits) : null;
        }
    }
    class AdapterData {
        constructor(adapter, extension) {
            this.adapter = adapter;
            this.extension = extension;
        }
    }
    class $zpc {
        static { this.d = 0; }
        constructor(mainContext, g, h, j, k, l, m, n) {
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.l = l;
            this.m = m;
            this.n = n;
            this.f = new Map();
            this.e = mainContext.getProxy(extHostProtocol.$KN.MainThreadLanguageFeatures);
        }
        o(selector, extension) {
            return typeConvert.DocumentSelector.from(selector, this.g, extension);
        }
        p(handle) {
            return new extHostTypes_1.$MN(() => {
                this.f.delete(handle);
                this.e.$unregister(handle);
            });
        }
        q() {
            return $zpc.d++;
        }
        async s(handle, ctor, callback, fallbackValue, tokenToRaceAgainst, doNotLog = false) {
            const data = this.f.get(handle);
            if (!data || !(data.adapter instanceof ctor)) {
                return fallbackValue;
            }
            const t1 = Date.now();
            if (!doNotLog) {
                this.l.trace(`[${data.extension.identifier.value}] INVOKE provider '${callback.toString().replace(/[\r\n]/g, '')}'`);
            }
            const result = callback(data.adapter, data.extension);
            // logging,tracing
            Promise.resolve(result).catch(err => {
                if (!(0, errors_1.$3)(err)) {
                    this.l.error(`[${data.extension.identifier.value}] provider FAILED`);
                    this.l.error(err);
                    this.n.onExtensionError(data.extension.identifier, err);
                }
            }).finally(() => {
                if (!doNotLog) {
                    this.l.trace(`[${data.extension.identifier.value}] provider DONE after ${Date.now() - t1}ms`);
                }
            });
            if (cancellation_1.CancellationToken.isCancellationToken(tokenToRaceAgainst)) {
                return (0, async_1.$uh)(result, tokenToRaceAgainst);
            }
            return result;
        }
        t(adapter, extension) {
            const handle = this.q();
            this.f.set(handle, new AdapterData(adapter, extension));
            return handle;
        }
        static u(ext) {
            return ext.displayName || ext.name;
        }
        static w(ext) {
            return ext.identifier.value;
        }
        // --- outline
        registerDocumentSymbolProvider(extension, selector, provider, metadata) {
            const handle = this.t(new DocumentSymbolAdapter(this.h, provider), extension);
            const displayName = (metadata && metadata.label) || $zpc.u(extension);
            this.e.$registerDocumentSymbolProvider(handle, this.o(selector, extension), displayName);
            return this.p(handle);
        }
        $provideDocumentSymbols(handle, resource, token) {
            return this.s(handle, DocumentSymbolAdapter, adapter => adapter.provideDocumentSymbols(uri_1.URI.revive(resource), token), undefined, token);
        }
        // --- code lens
        registerCodeLensProvider(extension, selector, provider) {
            const handle = this.q();
            const eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this.q() : undefined;
            this.f.set(handle, new AdapterData(new CodeLensAdapter(this.h, this.j.converter, provider, extension, this.n, this.l), extension));
            this.e.$registerCodeLensSupport(handle, this.o(selector, extension), eventHandle);
            let result = this.p(handle);
            if (eventHandle !== undefined) {
                const subscription = provider.onDidChangeCodeLenses(_ => this.e.$emitCodeLensEvent(eventHandle));
                result = extHostTypes_1.$MN.from(result, subscription);
            }
            return result;
        }
        $provideCodeLenses(handle, resource, token) {
            return this.s(handle, CodeLensAdapter, adapter => adapter.provideCodeLenses(uri_1.URI.revive(resource), token), undefined, token);
        }
        $resolveCodeLens(handle, symbol, token) {
            return this.s(handle, CodeLensAdapter, adapter => adapter.resolveCodeLens(symbol, token), undefined, undefined);
        }
        $releaseCodeLenses(handle, cacheId) {
            this.s(handle, CodeLensAdapter, adapter => Promise.resolve(adapter.releaseCodeLenses(cacheId)), undefined, undefined);
        }
        // --- declaration
        registerDefinitionProvider(extension, selector, provider) {
            const handle = this.t(new DefinitionAdapter(this.h, provider), extension);
            this.e.$registerDefinitionSupport(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideDefinition(handle, resource, position, token) {
            return this.s(handle, DefinitionAdapter, adapter => adapter.provideDefinition(uri_1.URI.revive(resource), position, token), [], token);
        }
        registerDeclarationProvider(extension, selector, provider) {
            const handle = this.t(new DeclarationAdapter(this.h, provider), extension);
            this.e.$registerDeclarationSupport(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideDeclaration(handle, resource, position, token) {
            return this.s(handle, DeclarationAdapter, adapter => adapter.provideDeclaration(uri_1.URI.revive(resource), position, token), [], token);
        }
        registerImplementationProvider(extension, selector, provider) {
            const handle = this.t(new ImplementationAdapter(this.h, provider), extension);
            this.e.$registerImplementationSupport(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideImplementation(handle, resource, position, token) {
            return this.s(handle, ImplementationAdapter, adapter => adapter.provideImplementation(uri_1.URI.revive(resource), position, token), [], token);
        }
        registerTypeDefinitionProvider(extension, selector, provider) {
            const handle = this.t(new TypeDefinitionAdapter(this.h, provider), extension);
            this.e.$registerTypeDefinitionSupport(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideTypeDefinition(handle, resource, position, token) {
            return this.s(handle, TypeDefinitionAdapter, adapter => adapter.provideTypeDefinition(uri_1.URI.revive(resource), position, token), [], token);
        }
        // --- extra info
        registerHoverProvider(extension, selector, provider, extensionId) {
            const handle = this.t(new HoverAdapter(this.h, provider), extension);
            this.e.$registerHoverProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideHover(handle, resource, position, context, token) {
            return this.s(handle, HoverAdapter, adapter => adapter.provideHover(uri_1.URI.revive(resource), position, context, token), undefined, token);
        }
        $releaseHover(handle, id) {
            this.s(handle, HoverAdapter, adapter => Promise.resolve(adapter.releaseHover(id)), undefined, undefined);
        }
        // --- debug hover
        registerEvaluatableExpressionProvider(extension, selector, provider, extensionId) {
            const handle = this.t(new EvaluatableExpressionAdapter(this.h, provider), extension);
            this.e.$registerEvaluatableExpressionProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideEvaluatableExpression(handle, resource, position, token) {
            return this.s(handle, EvaluatableExpressionAdapter, adapter => adapter.provideEvaluatableExpression(uri_1.URI.revive(resource), position, token), undefined, token);
        }
        // --- debug inline values
        registerInlineValuesProvider(extension, selector, provider, extensionId) {
            const eventHandle = typeof provider.onDidChangeInlineValues === 'function' ? this.q() : undefined;
            const handle = this.t(new InlineValuesAdapter(this.h, provider), extension);
            this.e.$registerInlineValuesProvider(handle, this.o(selector, extension), eventHandle);
            let result = this.p(handle);
            if (eventHandle !== undefined) {
                const subscription = provider.onDidChangeInlineValues(_ => this.e.$emitInlineValuesEvent(eventHandle));
                result = extHostTypes_1.$MN.from(result, subscription);
            }
            return result;
        }
        $provideInlineValues(handle, resource, range, context, token) {
            return this.s(handle, InlineValuesAdapter, adapter => adapter.provideInlineValues(uri_1.URI.revive(resource), range, context, token), undefined, token);
        }
        // --- occurrences
        registerDocumentHighlightProvider(extension, selector, provider) {
            const handle = this.t(new DocumentHighlightAdapter(this.h, provider), extension);
            this.e.$registerDocumentHighlightProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        registerMultiDocumentHighlightProvider(extension, selector, provider) {
            const handle = this.t(new MultiDocumentHighlightAdapter(this.h, provider), extension);
            this.e.$registerMultiDocumentHighlightProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideDocumentHighlights(handle, resource, position, token) {
            return this.s(handle, DocumentHighlightAdapter, adapter => adapter.provideDocumentHighlights(uri_1.URI.revive(resource), position, token), undefined, token);
        }
        $provideMultiDocumentHighlights(handle, resource, position, otherModels, token) {
            return this.s(handle, MultiDocumentHighlightAdapter, adapter => adapter.provideMultiDocumentHighlights(uri_1.URI.revive(resource), position, otherModels.map(model => uri_1.URI.revive(model)), token), undefined, token);
        }
        // --- linked editing
        registerLinkedEditingRangeProvider(extension, selector, provider) {
            const handle = this.t(new LinkedEditingRangeAdapter(this.h, provider), extension);
            this.e.$registerLinkedEditingRangeProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideLinkedEditingRanges(handle, resource, position, token) {
            return this.s(handle, LinkedEditingRangeAdapter, async (adapter) => {
                const res = await adapter.provideLinkedEditingRanges(uri_1.URI.revive(resource), position, token);
                if (res) {
                    return {
                        ranges: res.ranges,
                        wordPattern: res.wordPattern ? $zpc.y(res.wordPattern) : undefined
                    };
                }
                return undefined;
            }, undefined, token);
        }
        // --- references
        registerReferenceProvider(extension, selector, provider) {
            const handle = this.t(new ReferenceAdapter(this.h, provider), extension);
            this.e.$registerReferenceSupport(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideReferences(handle, resource, position, context, token) {
            return this.s(handle, ReferenceAdapter, adapter => adapter.provideReferences(uri_1.URI.revive(resource), position, context, token), undefined, token);
        }
        // --- code actions
        registerCodeActionProvider(extension, selector, provider, metadata) {
            const store = new lifecycle_1.$Tc();
            const handle = this.t(new CodeActionAdapter(this.h, this.j.converter, this.k, provider, this.l, extension, this.m), extension);
            this.e.$registerCodeActionSupport(handle, this.o(selector, extension), {
                providedKinds: metadata?.providedCodeActionKinds?.map(kind => kind.value),
                documentation: metadata?.documentation?.map(x => ({
                    kind: x.kind.value,
                    command: this.j.converter.toInternal(x.command, store),
                }))
            }, $zpc.u(extension), $zpc.w(extension), Boolean(provider.resolveCodeAction));
            store.add(this.p(handle));
            return store;
        }
        $provideCodeActions(handle, resource, rangeOrSelection, context, token) {
            return this.s(handle, CodeActionAdapter, adapter => adapter.provideCodeActions(uri_1.URI.revive(resource), rangeOrSelection, context, token), undefined, token);
        }
        $resolveCodeAction(handle, id, token) {
            return this.s(handle, CodeActionAdapter, adapter => adapter.resolveCodeAction(id, token), {}, undefined);
        }
        $releaseCodeActions(handle, cacheId) {
            this.s(handle, CodeActionAdapter, adapter => Promise.resolve(adapter.releaseCodeActions(cacheId)), undefined, undefined);
        }
        // --- formatting
        registerDocumentFormattingEditProvider(extension, selector, provider) {
            const handle = this.t(new DocumentFormattingAdapter(this.h, provider), extension);
            this.e.$registerDocumentFormattingSupport(handle, this.o(selector, extension), extension.identifier, extension.displayName || extension.name);
            return this.p(handle);
        }
        $provideDocumentFormattingEdits(handle, resource, options, token) {
            return this.s(handle, DocumentFormattingAdapter, adapter => adapter.provideDocumentFormattingEdits(uri_1.URI.revive(resource), options, token), undefined, token);
        }
        registerDocumentRangeFormattingEditProvider(extension, selector, provider) {
            const canFormatMultipleRanges = typeof provider.provideDocumentRangesFormattingEdits === 'function';
            const handle = this.t(new RangeFormattingAdapter(this.h, provider), extension);
            this.e.$registerRangeFormattingSupport(handle, this.o(selector, extension), extension.identifier, extension.displayName || extension.name, canFormatMultipleRanges);
            return this.p(handle);
        }
        $provideDocumentRangeFormattingEdits(handle, resource, range, options, token) {
            return this.s(handle, RangeFormattingAdapter, adapter => adapter.provideDocumentRangeFormattingEdits(uri_1.URI.revive(resource), range, options, token), undefined, token);
        }
        $provideDocumentRangesFormattingEdits(handle, resource, ranges, options, token) {
            return this.s(handle, RangeFormattingAdapter, adapter => adapter.provideDocumentRangesFormattingEdits(uri_1.URI.revive(resource), ranges, options, token), undefined, token);
        }
        registerOnTypeFormattingEditProvider(extension, selector, provider, triggerCharacters) {
            const handle = this.t(new OnTypeFormattingAdapter(this.h, provider), extension);
            this.e.$registerOnTypeFormattingSupport(handle, this.o(selector, extension), triggerCharacters, extension.identifier);
            return this.p(handle);
        }
        $provideOnTypeFormattingEdits(handle, resource, position, ch, options, token) {
            return this.s(handle, OnTypeFormattingAdapter, adapter => adapter.provideOnTypeFormattingEdits(uri_1.URI.revive(resource), position, ch, options, token), undefined, token);
        }
        // --- navigate types
        registerWorkspaceSymbolProvider(extension, provider) {
            const handle = this.t(new NavigateTypeAdapter(provider, this.l), extension);
            this.e.$registerNavigateTypeSupport(handle, typeof provider.resolveWorkspaceSymbol === 'function');
            return this.p(handle);
        }
        $provideWorkspaceSymbols(handle, search, token) {
            return this.s(handle, NavigateTypeAdapter, adapter => adapter.provideWorkspaceSymbols(search, token), { symbols: [] }, token);
        }
        $resolveWorkspaceSymbol(handle, symbol, token) {
            return this.s(handle, NavigateTypeAdapter, adapter => adapter.resolveWorkspaceSymbol(symbol, token), undefined, undefined);
        }
        $releaseWorkspaceSymbols(handle, id) {
            this.s(handle, NavigateTypeAdapter, adapter => adapter.releaseWorkspaceSymbols(id), undefined, undefined);
        }
        // --- rename
        registerRenameProvider(extension, selector, provider) {
            const handle = this.t(new RenameAdapter(this.h, provider, this.l), extension);
            this.e.$registerRenameSupport(handle, this.o(selector, extension), RenameAdapter.supportsResolving(provider));
            return this.p(handle);
        }
        $provideRenameEdits(handle, resource, position, newName, token) {
            return this.s(handle, RenameAdapter, adapter => adapter.provideRenameEdits(uri_1.URI.revive(resource), position, newName, token), undefined, token);
        }
        $resolveRenameLocation(handle, resource, position, token) {
            return this.s(handle, RenameAdapter, adapter => adapter.resolveRenameLocation(uri_1.URI.revive(resource), position, token), undefined, token);
        }
        registerNewSymbolNamesProvider(extension, selector, provider) {
            const handle = this.t(new NewSymbolNamesAdapter(this.h, provider, this.l), extension);
            this.e.$registerNewSymbolNamesProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $supportsAutomaticNewSymbolNamesTriggerKind(handle) {
            return this.s(handle, NewSymbolNamesAdapter, adapter => adapter.supportsAutomaticNewSymbolNamesTriggerKind(), false, undefined);
        }
        $provideNewSymbolNames(handle, resource, range, triggerKind, token) {
            return this.s(handle, NewSymbolNamesAdapter, adapter => adapter.provideNewSymbolNames(uri_1.URI.revive(resource), range, triggerKind, token), undefined, token);
        }
        //#region semantic coloring
        registerDocumentSemanticTokensProvider(extension, selector, provider, legend) {
            const handle = this.t(new DocumentSemanticTokensAdapter(this.h, provider), extension);
            const eventHandle = (typeof provider.onDidChangeSemanticTokens === 'function' ? this.q() : undefined);
            this.e.$registerDocumentSemanticTokensProvider(handle, this.o(selector, extension), legend, eventHandle);
            let result = this.p(handle);
            if (eventHandle) {
                const subscription = provider.onDidChangeSemanticTokens(_ => this.e.$emitDocumentSemanticTokensEvent(eventHandle));
                result = extHostTypes_1.$MN.from(result, subscription);
            }
            return result;
        }
        $provideDocumentSemanticTokens(handle, resource, previousResultId, token) {
            return this.s(handle, DocumentSemanticTokensAdapter, adapter => adapter.provideDocumentSemanticTokens(uri_1.URI.revive(resource), previousResultId, token), null, token);
        }
        $releaseDocumentSemanticTokens(handle, semanticColoringResultId) {
            this.s(handle, DocumentSemanticTokensAdapter, adapter => adapter.releaseDocumentSemanticColoring(semanticColoringResultId), undefined, undefined);
        }
        registerDocumentRangeSemanticTokensProvider(extension, selector, provider, legend) {
            const handle = this.t(new DocumentRangeSemanticTokensAdapter(this.h, provider), extension);
            this.e.$registerDocumentRangeSemanticTokensProvider(handle, this.o(selector, extension), legend);
            return this.p(handle);
        }
        $provideDocumentRangeSemanticTokens(handle, resource, range, token) {
            return this.s(handle, DocumentRangeSemanticTokensAdapter, adapter => adapter.provideDocumentRangeSemanticTokens(uri_1.URI.revive(resource), range, token), null, token);
        }
        //#endregion
        // --- suggestion
        registerCompletionItemProvider(extension, selector, provider, triggerCharacters) {
            const handle = this.t(new CompletionsAdapter(this.h, this.j.converter, provider, this.m, extension), extension);
            this.e.$registerCompletionsProvider(handle, this.o(selector, extension), triggerCharacters, CompletionsAdapter.supportsResolving(provider), extension.identifier);
            return this.p(handle);
        }
        $provideCompletionItems(handle, resource, position, context, token) {
            return this.s(handle, CompletionsAdapter, adapter => adapter.provideCompletionItems(uri_1.URI.revive(resource), position, context, token), undefined, token);
        }
        $resolveCompletionItem(handle, id, token) {
            return this.s(handle, CompletionsAdapter, adapter => adapter.resolveCompletionItem(id, token), undefined, token);
        }
        $releaseCompletionItems(handle, id) {
            this.s(handle, CompletionsAdapter, adapter => adapter.releaseCompletionItems(id), undefined, undefined);
        }
        // --- ghost test
        registerInlineCompletionsProvider(extension, selector, provider, metadata) {
            const adapter = new InlineCompletionAdapter(extension, this.h, provider, this.j.converter);
            const handle = this.t(adapter, extension);
            this.e.$registerInlineCompletionsSupport(handle, this.o(selector, extension), adapter.supportsHandleEvents, extensions_1.$rn.toKey(extension.identifier.value), metadata?.yieldTo?.map(extId => extensions_1.$rn.toKey(extId)) || []);
            return this.p(handle);
        }
        $provideInlineCompletions(handle, resource, position, context, token) {
            return this.s(handle, InlineCompletionAdapterBase, adapter => adapter.provideInlineCompletions(uri_1.URI.revive(resource), position, context, token), undefined, token);
        }
        $provideInlineEdits(handle, resource, range, context, token) {
            return this.s(handle, InlineCompletionAdapterBase, adapter => adapter.provideInlineEdits(uri_1.URI.revive(resource), range, context, token), undefined, token);
        }
        $handleInlineCompletionDidShow(handle, pid, idx, updatedInsertText) {
            this.s(handle, InlineCompletionAdapterBase, async (adapter) => {
                adapter.handleDidShowCompletionItem(pid, idx, updatedInsertText);
            }, undefined, undefined);
        }
        $handleInlineCompletionPartialAccept(handle, pid, idx, acceptedCharacters, info) {
            this.s(handle, InlineCompletionAdapterBase, async (adapter) => {
                adapter.handlePartialAccept(pid, idx, acceptedCharacters, info);
            }, undefined, undefined);
        }
        $freeInlineCompletionsList(handle, pid) {
            this.s(handle, InlineCompletionAdapterBase, async (adapter) => { adapter.disposeCompletions(pid); }, undefined, undefined);
        }
        // --- inline edit
        registerInlineEditProvider(extension, selector, provider) {
            const adapter = new InlineEditAdapter(extension, this.h, provider, this.j.converter);
            const handle = this.t(adapter, extension);
            this.e.$registerInlineEditProvider(handle, this.o(selector, extension), extension.identifier);
            return this.p(handle);
        }
        $provideInlineEdit(handle, resource, context, token) {
            return this.s(handle, InlineEditAdapter, adapter => adapter.provideInlineEdits(uri_1.URI.revive(resource), context, token), undefined, token);
        }
        $freeInlineEdit(handle, pid) {
            this.s(handle, InlineEditAdapter, async (adapter) => { adapter.disposeEdit(pid); }, undefined, undefined);
        }
        // --- parameter hints
        registerSignatureHelpProvider(extension, selector, provider, metadataOrTriggerChars) {
            const metadata = Array.isArray(metadataOrTriggerChars)
                ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] }
                : metadataOrTriggerChars;
            const handle = this.t(new SignatureHelpAdapter(this.h, provider), extension);
            this.e.$registerSignatureHelpProvider(handle, this.o(selector, extension), metadata);
            return this.p(handle);
        }
        $provideSignatureHelp(handle, resource, position, context, token) {
            return this.s(handle, SignatureHelpAdapter, adapter => adapter.provideSignatureHelp(uri_1.URI.revive(resource), position, context, token), undefined, token);
        }
        $releaseSignatureHelp(handle, id) {
            this.s(handle, SignatureHelpAdapter, adapter => adapter.releaseSignatureHelp(id), undefined, undefined);
        }
        // --- inline hints
        registerInlayHintsProvider(extension, selector, provider) {
            const eventHandle = typeof provider.onDidChangeInlayHints === 'function' ? this.q() : undefined;
            const handle = this.t(new InlayHintsAdapter(this.h, this.j.converter, provider, this.l, extension), extension);
            this.e.$registerInlayHintsProvider(handle, this.o(selector, extension), typeof provider.resolveInlayHint === 'function', eventHandle, $zpc.u(extension));
            let result = this.p(handle);
            if (eventHandle !== undefined) {
                const subscription = provider.onDidChangeInlayHints(uri => this.e.$emitInlayHintsEvent(eventHandle));
                result = extHostTypes_1.$MN.from(result, subscription);
            }
            return result;
        }
        $provideInlayHints(handle, resource, range, token) {
            return this.s(handle, InlayHintsAdapter, adapter => adapter.provideInlayHints(uri_1.URI.revive(resource), range, token), undefined, token);
        }
        $resolveInlayHint(handle, id, token) {
            return this.s(handle, InlayHintsAdapter, adapter => adapter.resolveInlayHint(id, token), undefined, token);
        }
        $releaseInlayHints(handle, id) {
            this.s(handle, InlayHintsAdapter, adapter => adapter.releaseHints(id), undefined, undefined);
        }
        // --- links
        registerDocumentLinkProvider(extension, selector, provider) {
            const handle = this.t(new LinkProviderAdapter(this.h, provider), extension);
            this.e.$registerDocumentLinkProvider(handle, this.o(selector, extension), typeof provider.resolveDocumentLink === 'function');
            return this.p(handle);
        }
        $provideDocumentLinks(handle, resource, token) {
            return this.s(handle, LinkProviderAdapter, adapter => adapter.provideLinks(uri_1.URI.revive(resource), token), undefined, token, resource.scheme === 'output');
        }
        $resolveDocumentLink(handle, id, token) {
            return this.s(handle, LinkProviderAdapter, adapter => adapter.resolveLink(id, token), undefined, undefined, true);
        }
        $releaseDocumentLinks(handle, id) {
            this.s(handle, LinkProviderAdapter, adapter => adapter.releaseLinks(id), undefined, undefined, true);
        }
        registerColorProvider(extension, selector, provider) {
            const handle = this.t(new ColorProviderAdapter(this.h, provider), extension);
            this.e.$registerDocumentColorProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideDocumentColors(handle, resource, token) {
            return this.s(handle, ColorProviderAdapter, adapter => adapter.provideColors(uri_1.URI.revive(resource), token), [], token);
        }
        $provideColorPresentations(handle, resource, colorInfo, token) {
            return this.s(handle, ColorProviderAdapter, adapter => adapter.provideColorPresentations(uri_1.URI.revive(resource), colorInfo, token), undefined, token);
        }
        registerFoldingRangeProvider(extension, selector, provider) {
            const handle = this.q();
            const eventHandle = typeof provider.onDidChangeFoldingRanges === 'function' ? this.q() : undefined;
            this.f.set(handle, new AdapterData(new FoldingProviderAdapter(this.h, provider), extension));
            this.e.$registerFoldingRangeProvider(handle, this.o(selector, extension), extension.identifier, eventHandle);
            let result = this.p(handle);
            if (eventHandle !== undefined) {
                const subscription = provider.onDidChangeFoldingRanges(() => this.e.$emitFoldingRangeEvent(eventHandle));
                result = extHostTypes_1.$MN.from(result, subscription);
            }
            return result;
        }
        $provideFoldingRanges(handle, resource, context, token) {
            return this.s(handle, FoldingProviderAdapter, (adapter) => adapter.provideFoldingRanges(uri_1.URI.revive(resource), context, token), undefined, token);
        }
        // --- smart select
        registerSelectionRangeProvider(extension, selector, provider) {
            const handle = this.t(new SelectionRangeAdapter(this.h, provider, this.l), extension);
            this.e.$registerSelectionRangeProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $provideSelectionRanges(handle, resource, positions, token) {
            return this.s(handle, SelectionRangeAdapter, adapter => adapter.provideSelectionRanges(uri_1.URI.revive(resource), positions, token), [], token);
        }
        // --- call hierarchy
        registerCallHierarchyProvider(extension, selector, provider) {
            const handle = this.t(new CallHierarchyAdapter(this.h, provider), extension);
            this.e.$registerCallHierarchyProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $prepareCallHierarchy(handle, resource, position, token) {
            return this.s(handle, CallHierarchyAdapter, adapter => Promise.resolve(adapter.prepareSession(uri_1.URI.revive(resource), position, token)), undefined, token);
        }
        $provideCallHierarchyIncomingCalls(handle, sessionId, itemId, token) {
            return this.s(handle, CallHierarchyAdapter, adapter => adapter.provideCallsTo(sessionId, itemId, token), undefined, token);
        }
        $provideCallHierarchyOutgoingCalls(handle, sessionId, itemId, token) {
            return this.s(handle, CallHierarchyAdapter, adapter => adapter.provideCallsFrom(sessionId, itemId, token), undefined, token);
        }
        $releaseCallHierarchy(handle, sessionId) {
            this.s(handle, CallHierarchyAdapter, adapter => Promise.resolve(adapter.releaseSession(sessionId)), undefined, undefined);
        }
        // --- type hierarchy
        registerTypeHierarchyProvider(extension, selector, provider) {
            const handle = this.t(new TypeHierarchyAdapter(this.h, provider), extension);
            this.e.$registerTypeHierarchyProvider(handle, this.o(selector, extension));
            return this.p(handle);
        }
        $prepareTypeHierarchy(handle, resource, position, token) {
            return this.s(handle, TypeHierarchyAdapter, adapter => Promise.resolve(adapter.prepareSession(uri_1.URI.revive(resource), position, token)), undefined, token);
        }
        $provideTypeHierarchySupertypes(handle, sessionId, itemId, token) {
            return this.s(handle, TypeHierarchyAdapter, adapter => adapter.provideSupertypes(sessionId, itemId, token), undefined, token);
        }
        $provideTypeHierarchySubtypes(handle, sessionId, itemId, token) {
            return this.s(handle, TypeHierarchyAdapter, adapter => adapter.provideSubtypes(sessionId, itemId, token), undefined, token);
        }
        $releaseTypeHierarchy(handle, sessionId) {
            this.s(handle, TypeHierarchyAdapter, adapter => Promise.resolve(adapter.releaseSession(sessionId)), undefined, undefined);
        }
        // --- Document on drop
        registerDocumentOnDropEditProvider(extension, selector, provider, metadata) {
            const handle = this.q();
            this.f.set(handle, new AdapterData(new DocumentDropEditAdapter(this.e, this.h, provider, handle, extension), extension));
            this.e.$registerDocumentOnDropEditProvider(handle, this.o(selector, extension), (0, extensions_2.$fH)(extension, 'documentPaste') && metadata ? {
                supportsResolve: !!provider.resolveDocumentDropEdit,
                dropMimeTypes: metadata.dropMimeTypes,
            } : undefined);
            return this.p(handle);
        }
        $provideDocumentOnDropEdits(handle, requestId, resource, position, dataTransferDto, token) {
            return this.s(handle, DocumentDropEditAdapter, adapter => Promise.resolve(adapter.provideDocumentOnDropEdits(requestId, uri_1.URI.revive(resource), position, dataTransferDto, token)), undefined, undefined);
        }
        $resolveDropEdit(handle, id, token) {
            return this.s(handle, DocumentDropEditAdapter, adapter => adapter.resolveDropEdit(id, token), {}, undefined);
        }
        $releaseDocumentOnDropEdits(handle, cacheId) {
            this.s(handle, DocumentDropEditAdapter, adapter => Promise.resolve(adapter.releaseDropEdits(cacheId)), undefined, undefined);
        }
        // --- mapped edits
        registerMappedEditsProvider(extension, selector, provider) {
            const handle = this.t(new MappedEditsAdapter(this.h, provider), extension);
            this.e.$registerMappedEditsProvider(handle, this.o(selector, extension), extension.displayName ?? extension.name);
            return this.p(handle);
        }
        $provideMappedEdits(handle, document, codeBlocks, context, token) {
            return this.s(handle, MappedEditsAdapter, adapter => Promise.resolve(adapter.provideMappedEdits(document, codeBlocks, context, token)), null, token);
        }
        // --- copy/paste actions
        registerDocumentPasteEditProvider(extension, selector, provider, metadata) {
            const handle = this.q();
            this.f.set(handle, new AdapterData(new DocumentPasteEditProvider(this.e, this.h, provider, handle, extension), extension));
            this.e.$registerPasteEditProvider(handle, this.o(selector, extension), {
                supportsCopy: !!provider.prepareDocumentPaste,
                supportsPaste: !!provider.provideDocumentPasteEdits,
                supportsResolve: !!provider.resolveDocumentPasteEdit,
                providedPasteEditKinds: metadata.providedPasteEditKinds?.map(x => x.value),
                copyMimeTypes: metadata.copyMimeTypes,
                pasteMimeTypes: metadata.pasteMimeTypes,
            });
            return this.p(handle);
        }
        $prepareDocumentPaste(handle, resource, ranges, dataTransfer, token) {
            return this.s(handle, DocumentPasteEditProvider, adapter => adapter.prepareDocumentPaste(uri_1.URI.revive(resource), ranges, dataTransfer, token), undefined, token);
        }
        $providePasteEdits(handle, requestId, resource, ranges, dataTransferDto, context, token) {
            return this.s(handle, DocumentPasteEditProvider, adapter => adapter.providePasteEdits(requestId, uri_1.URI.revive(resource), ranges, dataTransferDto, context, token), undefined, token);
        }
        $resolvePasteEdit(handle, id, token) {
            return this.s(handle, DocumentPasteEditProvider, adapter => adapter.resolvePasteEdit(id, token), {}, undefined);
        }
        $releasePasteEdits(handle, cacheId) {
            this.s(handle, DocumentPasteEditProvider, adapter => Promise.resolve(adapter.releasePasteEdits(cacheId)), undefined, undefined);
        }
        // --- configuration
        static y(regExp) {
            return {
                pattern: regExp.source,
                flags: regExp.flags,
            };
        }
        static z(indentationRule) {
            return {
                decreaseIndentPattern: $zpc.y(indentationRule.decreaseIndentPattern),
                increaseIndentPattern: $zpc.y(indentationRule.increaseIndentPattern),
                indentNextLinePattern: indentationRule.indentNextLinePattern ? $zpc.y(indentationRule.indentNextLinePattern) : undefined,
                unIndentedLinePattern: indentationRule.unIndentedLinePattern ? $zpc.y(indentationRule.unIndentedLinePattern) : undefined,
            };
        }
        static B(onEnterRule) {
            return {
                beforeText: $zpc.y(onEnterRule.beforeText),
                afterText: onEnterRule.afterText ? $zpc.y(onEnterRule.afterText) : undefined,
                previousLineText: onEnterRule.previousLineText ? $zpc.y(onEnterRule.previousLineText) : undefined,
                action: onEnterRule.action
            };
        }
        static C(onEnterRules) {
            return onEnterRules.map($zpc.B);
        }
        static D(autoClosingPair) {
            return {
                open: autoClosingPair.open,
                close: autoClosingPair.close,
                notIn: autoClosingPair.notIn ? autoClosingPair.notIn.map(v => extHostTypes_1.SyntaxTokenType.toString(v)) : undefined,
            };
        }
        static E(autoClosingPairs) {
            return autoClosingPairs.map($zpc.D);
        }
        setLanguageConfiguration(extension, languageId, configuration) {
            const { wordPattern } = configuration;
            // check for a valid word pattern
            if (wordPattern && (0, strings_1.$rf)(wordPattern)) {
                throw new Error(`Invalid language configuration: wordPattern '${wordPattern}' is not allowed to match the empty string.`);
            }
            // word definition
            if (wordPattern) {
                this.h.setWordDefinitionFor(languageId, wordPattern);
            }
            else {
                this.h.setWordDefinitionFor(languageId, undefined);
            }
            if (configuration.__electricCharacterSupport) {
                this.m.report('LanguageConfiguration.__electricCharacterSupport', extension, `Do not use.`);
            }
            if (configuration.__characterPairSupport) {
                this.m.report('LanguageConfiguration.__characterPairSupport', extension, `Do not use.`);
            }
            const handle = this.q();
            const serializedConfiguration = {
                comments: configuration.comments,
                brackets: configuration.brackets,
                wordPattern: configuration.wordPattern ? $zpc.y(configuration.wordPattern) : undefined,
                indentationRules: configuration.indentationRules ? $zpc.z(configuration.indentationRules) : undefined,
                onEnterRules: configuration.onEnterRules ? $zpc.C(configuration.onEnterRules) : undefined,
                __electricCharacterSupport: configuration.__electricCharacterSupport,
                __characterPairSupport: configuration.__characterPairSupport,
                autoClosingPairs: configuration.autoClosingPairs ? $zpc.E(configuration.autoClosingPairs) : undefined,
            };
            this.e.$setLanguageConfiguration(handle, languageId, serializedConfiguration);
            return this.p(handle);
        }
        $setWordDefinitions(wordDefinitions) {
            for (const wordDefinition of wordDefinitions) {
                this.h.setWordDefinitionFor(wordDefinition.languageId, new RegExp(wordDefinition.regexSource, wordDefinition.regexFlags));
            }
        }
    }
    exports.$zpc = $zpc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[244/*vs/workbench/api/common/extHostLanguageModelTools*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,36/*vs/base/common/marshalling*/,5/*vs/workbench/api/common/extHost.protocol*/,8/*vs/workbench/api/common/extHostTypeConverters*/]), function (require, exports, lifecycle_1, marshalling_1, extHost_protocol_1, typeConvert) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$4qc = void 0;
    typeConvert = __importStar(typeConvert);
    class $4qc {
        constructor(mainContext) {
            /** A map of tools that were registered in this EH */
            this.a = new Map();
            /** A map of all known tools, from other EHs or registered in vscode core */
            this.c = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadLanguageModelTools);
            this.b.$getTools().then(tools => {
                for (const tool of tools) {
                    this.c.set(tool.name, (0, marshalling_1.$ci)(tool));
                }
            });
        }
        async invokeTool(name, parameters, token) {
            // Making the round trip here because not all tools were necessarily registered in this EH
            return await this.b.$invokeTool(name, parameters, token);
        }
        async $acceptToolDelta(delta) {
            if (delta.added) {
                this.c.set(delta.added.name, delta.added);
            }
            if (delta.removed) {
                this.c.delete(delta.removed);
            }
        }
        get tools() {
            return Array.from(this.c.values())
                .map(tool => typeConvert.LanguageModelToolDescription.to(tool));
        }
        async $invokeTool(name, parameters, token) {
            const item = this.a.get(name);
            if (!item) {
                throw new Error(`Unknown tool ${name}`);
            }
            return await item.tool.invoke(parameters, token);
        }
        registerTool(extension, name, tool) {
            this.a.set(name, { extension, tool });
            this.b.$registerTool(name);
            return (0, lifecycle_1.$Sc)(() => {
                this.a.delete(name);
                this.b.$unregisterTool(name);
            });
        }
    }
    exports.$4qc = $4qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[94/*vs/workbench/api/common/extHostLanguageModels*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,42/*vs/base/common/errorMessage*/,13/*vs/base/common/errors*/,6/*vs/base/common/event*/,40/*vs/base/common/iterator*/,4/*vs/base/common/lifecycle*/,9/*vs/nls*/,18/*vs/platform/extensions/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,76/*vs/platform/progress/common/progress*/,5/*vs/workbench/api/common/extHost.protocol*/,90/*vs/workbench/api/common/extHostAuthentication*/,16/*vs/workbench/api/common/extHostRpcService*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,117/*vs/workbench/services/authentication/common/authentication*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, async_1, cancellation_1, errorMessage_1, errors_1, event_1, iterator_1, lifecycle_1, nls_1, extensions_1, instantiation_1, log_1, progress_1, extHost_protocol_1, extHostAuthentication_1, extHostRpcService_1, typeConvert, extHostTypes, authentication_1, extensions_2) {
    "use strict";
    var $hqc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$hqc = exports.$gqc = void 0;
    typeConvert = __importStar(typeConvert);
    extHostTypes = __importStar(extHostTypes);
    exports.$gqc = (0, instantiation_1.$Fi)('IExtHostLanguageModels');
    class LanguageModelResponseStream {
        constructor(option, stream) {
            this.option = option;
            this.stream = new async_1.$9h();
            this.stream = stream ?? new async_1.$9h();
        }
    }
    class LanguageModelResponse {
        constructor() {
            this.a = new Map();
            this.b = new async_1.$9h();
            this.c = false;
            const that = this;
            this.apiObject = {
                // result: promise,
                get stream() {
                    return that.b.asyncIterable;
                },
                get text() {
                    return async_1.$6h.map(that.b.asyncIterable, part => {
                        if (part instanceof extHostTypes.$7P) {
                            return part.value;
                        }
                        else {
                            return undefined;
                        }
                    }).coalesce();
                },
            };
        }
        *d() {
            if (this.a.size > 0) {
                for (const [, value] of this.a) {
                    yield value.stream;
                }
            }
            else {
                yield this.b;
            }
        }
        handleFragment(fragment) {
            if (this.c) {
                return;
            }
            let res = this.a.get(fragment.index);
            if (!res) {
                if (this.a.size === 0) {
                    // the first response claims the default response
                    res = new LanguageModelResponseStream(fragment.index, this.b);
                }
                else {
                    res = new LanguageModelResponseStream(fragment.index);
                }
                this.a.set(fragment.index, res);
            }
            let out;
            if (fragment.part.type === 'text') {
                out = new extHostTypes.$7P(fragment.part.value);
            }
            else {
                out = new extHostTypes.$6P(fragment.part.name, fragment.part.parameters);
            }
            res.stream.emitOne(out);
        }
        reject(err) {
            this.c = true;
            for (const stream of this.d()) {
                stream.reject(err);
            }
        }
        resolve() {
            this.c = true;
            for (const stream of this.d()) {
                stream.resolve();
            }
        }
    }
    let $hqc = class $hqc {
        static { $hqc_1 = this; }
        static { this.a = 1; }
        constructor(extHostRpc, j, k) {
            this.j = j;
            this.k = k;
            this.c = new event_1.$le();
            this.d = new event_1.$le();
            this.onDidChangeProviders = this.d.event;
            this.f = new Map();
            this.g = new Map(); // these are ALL models, not just the one in this EH
            this.h = new extensions_1.$tn();
            this.i = new Map();
            this.s = new Set();
            this.b = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadLanguageModels);
        }
        dispose() {
            this.c.dispose();
            this.d.dispose();
        }
        registerLanguageModel(extension, identifier, provider, metadata) {
            const handle = $hqc_1.a++;
            this.f.set(handle, { extension: extension.identifier, provider, languageModelId: identifier });
            let auth;
            if (metadata.auth) {
                auth = {
                    providerLabel: extension.displayName || extension.name,
                    accountLabel: typeof metadata.auth === 'object' ? metadata.auth.label : undefined
                };
            }
            this.b.$registerLanguageModelProvider(handle, `${extensions_1.$rn.toKey(extension.identifier)}/${handle}/${identifier}`, {
                extension: extension.identifier,
                id: identifier,
                vendor: metadata.vendor ?? extensions_1.$rn.toKey(extension.identifier),
                name: metadata.name ?? '',
                family: metadata.family ?? '',
                version: metadata.version,
                maxInputTokens: metadata.maxInputTokens,
                maxOutputTokens: metadata.maxOutputTokens,
                auth,
                targetExtensions: metadata.extensions
            });
            const responseReceivedListener = provider.onDidReceiveLanguageModelResponse2?.(({ extensionId, participant, tokenCount }) => {
                this.b.$whenLanguageModelChatRequestMade(identifier, new extensions_1.$rn(extensionId), participant, tokenCount);
            });
            return (0, lifecycle_1.$Sc)(() => {
                this.f.delete(handle);
                this.b.$unregisterProvider(handle);
                responseReceivedListener?.dispose();
            });
        }
        async $startChatRequest(handle, requestId, from, messages, options, token) {
            const data = this.f.get(handle);
            if (!data) {
                throw new Error('Provider not found');
            }
            const progress = new progress_1.$zw(async (fragment) => {
                if (token.isCancellationRequested) {
                    this.j.warn(`[CHAT](${data.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
                    return;
                }
                let part;
                if (fragment.part instanceof extHostTypes.$6P) {
                    part = { type: 'function_use', name: fragment.part.name, parameters: fragment.part.parameters };
                }
                else if (fragment.part instanceof extHostTypes.$7P) {
                    part = { type: 'text', value: fragment.part.value };
                }
                if (!part) {
                    this.j.warn(`[CHAT](${data.extension.value}) UNKNOWN part ${JSON.stringify(fragment)}`);
                    return;
                }
                this.b.$reportResponsePart(requestId, { index: fragment.index, part });
            });
            let p;
            if (data.provider.provideLanguageModelResponse2) {
                p = Promise.resolve(data.provider.provideLanguageModelResponse2(messages.map(typeConvert.LanguageModelChatMessage.to), options, extensions_1.$rn.toKey(from), progress, token));
            }
            else {
                const progress2 = new progress_1.$zw(async (fragment) => {
                    progress.report({ index: fragment.index, part: new extHostTypes.$7P(fragment.part) });
                });
                p = Promise.resolve(data.provider.provideLanguageModelResponse(messages.map(typeConvert.LanguageModelChatMessage.to), options?.modelOptions ?? {}, extensions_1.$rn.toKey(from), progress2, token));
            }
            p.then(() => {
                this.b.$reportResponseDone(requestId, undefined);
            }, err => {
                this.b.$reportResponseDone(requestId, (0, errors_1.$1)(err));
            });
        }
        //#region --- token counting
        $provideTokenLength(handle, value, token) {
            const data = this.f.get(handle);
            if (!data) {
                return Promise.resolve(0);
            }
            return Promise.resolve(data.provider.provideTokenCount(value, token));
        }
        //#region --- making request
        $acceptChatModelMetadata(data) {
            if (data.added) {
                for (const { identifier, metadata } of data.added) {
                    this.g.set(identifier, { metadata, apiObjects: new extensions_1.$tn() });
                }
            }
            if (data.removed) {
                for (const id of data.removed) {
                    // clean up
                    this.g.delete(id);
                    // cancel pending requests for this model
                    for (const [key, value] of this.i) {
                        if (value.languageModelId === id) {
                            value.res.reject(new errors_1.$4());
                            this.i.delete(key);
                        }
                    }
                }
            }
            // TODO@jrieken@TylerLeonhardt - this is a temporary hack to populate the auth providers
            data.added?.forEach(added => this.q(added.metadata));
            this.d.fire(undefined);
        }
        async selectLanguageModels(extension, selector) {
            // this triggers extension activation
            const models = await this.b.$selectChatModels({ ...selector, extension: extension.identifier });
            const result = [];
            const that = this;
            for (const identifier of models) {
                const data = this.g.get(identifier);
                if (!data) {
                    // model gone? is this an error on us?
                    continue;
                }
                // make sure auth information is correct
                if (this.o(extension.identifier, data.metadata)) {
                    await this.q(data.metadata);
                }
                let apiObject = data.apiObjects.get(extension.identifier);
                if (!apiObject) {
                    apiObject = {
                        id: identifier,
                        vendor: data.metadata.vendor,
                        family: data.metadata.family,
                        version: data.metadata.version,
                        name: data.metadata.name,
                        maxInputTokens: data.metadata.maxInputTokens,
                        countTokens(text, token) {
                            if (!that.g.has(identifier)) {
                                throw extHostTypes.$$P.NotFound(identifier);
                            }
                            return that.r(identifier, text, token ?? cancellation_1.CancellationToken.None);
                        },
                        sendRequest(messages, options, token) {
                            if (!that.g.has(identifier)) {
                                throw extHostTypes.$$P.NotFound(identifier);
                            }
                            return that.l(extension, identifier, messages, options ?? {}, token ?? cancellation_1.CancellationToken.None);
                        }
                    };
                    Object.freeze(apiObject);
                    data.apiObjects.set(extension.identifier, apiObject);
                }
                result.push(apiObject);
            }
            return result;
        }
        async l(extension, languageModelId, messages, options, token) {
            const internalMessages = this.m(extension, messages);
            const from = extension.identifier;
            const metadata = this.g.get(languageModelId)?.metadata;
            if (!metadata || !this.g.has(languageModelId)) {
                throw extHostTypes.$$P.NotFound(`Language model '${languageModelId}' is unknown.`);
            }
            if (this.o(from, metadata)) {
                const success = await this.n(extension, { identifier: metadata.extension, displayName: metadata.auth.providerLabel }, options.justification, false);
                if (!success || !this.h.get(from)?.has(metadata.extension)) {
                    throw extHostTypes.$$P.NoPermissions(`Language model '${languageModelId}' cannot be used by '${from.value}'.`);
                }
            }
            try {
                const requestId = (Math.random() * 1e6) | 0;
                const res = new LanguageModelResponse();
                this.i.set(requestId, { languageModelId, res });
                try {
                    await this.b.$tryStartChatRequest(from, languageModelId, requestId, internalMessages, options, token);
                }
                catch (error) {
                    // error'ing here means that the request could NOT be started/made, e.g. wrong model, no access, etc, but
                    // later the response can fail as well. Those failures are communicated via the stream-object
                    this.i.delete(requestId);
                    throw error;
                }
                return res.apiObject;
            }
            catch (error) {
                if (error.name === extHostTypes.$$P.name) {
                    throw error;
                }
                throw new extHostTypes.$$P(`Language model '${languageModelId}' errored: ${(0, errorMessage_1.$qj)(error)}`, 'Unknown', error);
            }
        }
        m(extension, messages) {
            const internalMessages = [];
            for (const message of messages) {
                if (message.role === extHostTypes.LanguageModelChatMessageRole.System) {
                    (0, extensions_2.$gH)(extension, 'languageModelSystem');
                }
                if (message.content2 instanceof extHostTypes.$4P) {
                    (0, extensions_2.$gH)(extension, 'lmTools');
                }
                internalMessages.push(typeConvert.LanguageModelChatMessage.from(message));
            }
            return internalMessages;
        }
        async $acceptResponsePart(requestId, chunk) {
            const data = this.i.get(requestId);
            if (data) {
                data.res.handleFragment(chunk);
            }
        }
        async $acceptResponseDone(requestId, error) {
            const data = this.i.get(requestId);
            if (!data) {
                return;
            }
            this.i.delete(requestId);
            if (error) {
                // we error the stream because that's the only way to signal
                // that the request has failed
                data.res.reject((0, errors_1.$2)(error));
            }
            else {
                data.res.resolve();
            }
        }
        // BIG HACK: Using AuthenticationProviders to check access to Language Models
        async n(from, to, justification, silent) {
            // This needs to be done in both MainThread & ExtHost ChatProvider
            const providerId = authentication_1.$MM + to.identifier.value;
            const session = await this.k.getSession(from, providerId, [], { silent: true });
            if (session) {
                this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);
                return true;
            }
            if (silent) {
                return false;
            }
            try {
                const detail = justification
                    ? (0, nls_1.localize)(11259, null, to.displayName, justification)
                    : undefined;
                await this.k.getSession(from, providerId, [], { forceNewSession: { detail } });
                this.$updateModelAccesslist([{ from: from.identifier, to: to.identifier, enabled: true }]);
                return true;
            }
            catch (err) {
                // ignore
                return false;
            }
        }
        o(from, toMetadata) {
            // If the 'to' extension uses an auth check
            return !!toMetadata.auth
                // And we're asking from a different extension
                && !extensions_1.$rn.equals(toMetadata.extension, from);
        }
        async q(metadata) {
            if (!metadata.auth) {
                return;
            }
            for (const from of this.s) {
                try {
                    await this.n(from, { identifier: metadata.extension, displayName: '' }, undefined, true);
                }
                catch (err) {
                    this.j.error('Fake Auth request failed');
                    this.j.error(err);
                }
            }
        }
        async r(languageModelId, value, token) {
            const data = this.g.get(languageModelId);
            if (!data) {
                throw extHostTypes.$$P.NotFound(`Language model '${languageModelId}' is unknown.`);
            }
            const local = iterator_1.Iterable.find(this.f.values(), candidate => candidate.languageModelId === languageModelId);
            if (local) {
                // stay inside the EH
                return local.provider.provideTokenCount(value, token);
            }
            return this.b.$countTokens(languageModelId, (typeof value === 'string' ? value : typeConvert.LanguageModelChatMessage.from(value)), token);
        }
        $updateModelAccesslist(data) {
            const updated = new Array();
            for (const { from, to, enabled } of data) {
                const set = this.h.get(from) ?? new extensions_1.$sn();
                const oldValue = set.has(to);
                if (oldValue !== enabled) {
                    if (enabled) {
                        set.add(to);
                    }
                    else {
                        set.delete(to);
                    }
                    this.h.set(from, set);
                    const newItem = { from, to };
                    updated.push(newItem);
                    this.c.fire(newItem);
                }
            }
        }
        createLanguageModelAccessInformation(from) {
            this.s.add(from);
            const that = this;
            const _onDidChangeAccess = event_1.Event.signal(event_1.Event.filter(this.c.event, e => extensions_1.$rn.equals(e.from, from.identifier)));
            const _onDidAddRemove = event_1.Event.signal(this.d.event);
            return {
                get onDidChange() {
                    return event_1.Event.any(_onDidChangeAccess, _onDidAddRemove);
                },
                canSendRequest(chat) {
                    let metadata;
                    out: for (const [_, value] of that.g) {
                        for (const candidate of value.apiObjects.values()) {
                            if (candidate === chat) {
                                metadata = value.metadata;
                                break out;
                            }
                        }
                    }
                    if (!metadata) {
                        return undefined;
                    }
                    if (!that.o(from.identifier, metadata)) {
                        return true;
                    }
                    const list = that.h.get(from.identifier);
                    if (!list) {
                        return undefined;
                    }
                    return list.has(metadata.extension);
                }
            };
        }
    };
    exports.$hqc = $hqc;
    exports.$hqc = $hqc = $hqc_1 = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, log_1.$ak),
        __param(2, extHostAuthentication_1.$Bpc)
    ], $hqc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[245/*vs/workbench/api/common/extHostLanguages*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,35/*vs/base/common/severity*/,10/*vs/base/common/async*/,4/*vs/base/common/lifecycle*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, extHost_protocol_1, typeConvert, extHostTypes_1, severity_1, async_1, lifecycle_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$5qc = void 0;
    typeConvert = __importStar(typeConvert);
    severity_1 = __importDefault(severity_1);
    class $5qc {
        constructor(mainContext, c, d, e) {
            this.c = c;
            this.d = d;
            this.e = e;
            this.b = [];
            this.f = 0;
            this.g = new Set();
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadLanguages);
        }
        $acceptLanguageIds(ids) {
            this.b = ids;
        }
        async getLanguages() {
            return this.b.slice(0);
        }
        async changeLanguage(uri, languageId) {
            await this.a.$changeLanguage(uri, languageId);
            const data = this.c.getDocumentData(uri);
            if (!data) {
                throw new Error(`document '${uri.toString()}' NOT found`);
            }
            return data.document;
        }
        async tokenAtPosition(document, position) {
            const versionNow = document.version;
            const pos = typeConvert.Position.from(position);
            const info = await this.a.$tokensAtPosition(document.uri, pos);
            const defaultRange = {
                type: extHostTypes_1.StandardTokenType.Other,
                range: document.getWordRangeAtPosition(position) ?? new extHostTypes_1.$ON(position.line, position.character, position.line, position.character)
            };
            if (!info) {
                // no result
                return defaultRange;
            }
            const result = {
                range: typeConvert.Range.to(info.range),
                type: typeConvert.TokenType.to(info.type)
            };
            if (!result.range.contains(position)) {
                // bogous result
                return defaultRange;
            }
            if (versionNow !== document.version) {
                // concurrent change
                return defaultRange;
            }
            return result;
        }
        createLanguageStatusItem(extension, id, selector) {
            const handle = this.f++;
            const proxy = this.a;
            const ids = this.g;
            // enforce extension unique identifier
            const fullyQualifiedId = `${extension.identifier.value}/${id}`;
            if (ids.has(fullyQualifiedId)) {
                throw new Error(`LanguageStatusItem with id '${id}' ALREADY exists`);
            }
            ids.add(fullyQualifiedId);
            const data = {
                selector,
                id,
                name: extension.displayName ?? extension.name,
                severity: extHostTypes_1.LanguageStatusSeverity.Information,
                command: undefined,
                text: '',
                detail: '',
                busy: false
            };
            let soonHandle;
            const commandDisposables = new lifecycle_1.$Tc();
            const updateAsync = () => {
                soonHandle?.dispose();
                if (!ids.has(fullyQualifiedId)) {
                    console.warn(`LanguageStatusItem (${id}) from ${extension.identifier.value} has been disposed and CANNOT be updated anymore`);
                    return; // disposed in the meantime
                }
                soonHandle = (0, async_1.$Hh)(() => {
                    commandDisposables.clear();
                    this.a.$setLanguageStatus(handle, {
                        id: fullyQualifiedId,
                        name: data.name ?? extension.displayName ?? extension.name,
                        source: extension.displayName ?? extension.name,
                        selector: typeConvert.DocumentSelector.from(data.selector, this.e),
                        label: data.text,
                        detail: data.detail ?? '',
                        severity: data.severity === extHostTypes_1.LanguageStatusSeverity.Error ? severity_1.default.Error : data.severity === extHostTypes_1.LanguageStatusSeverity.Warning ? severity_1.default.Warning : severity_1.default.Info,
                        command: data.command && this.d.toInternal(data.command, commandDisposables),
                        accessibilityInfo: data.accessibilityInformation,
                        busy: data.busy
                    });
                }, 0);
            };
            const result = {
                dispose() {
                    commandDisposables.dispose();
                    soonHandle?.dispose();
                    proxy.$removeLanguageStatus(handle);
                    ids.delete(fullyQualifiedId);
                },
                get id() {
                    return data.id;
                },
                get name() {
                    return data.name;
                },
                set name(value) {
                    data.name = value;
                    updateAsync();
                },
                get selector() {
                    return data.selector;
                },
                set selector(value) {
                    data.selector = value;
                    updateAsync();
                },
                get text() {
                    return data.text;
                },
                set text(value) {
                    data.text = value;
                    updateAsync();
                },
                set text2(value) {
                    (0, extensions_1.$gH)(extension, 'languageStatusText');
                    data.text = value;
                    updateAsync();
                },
                get text2() {
                    (0, extensions_1.$gH)(extension, 'languageStatusText');
                    return data.text;
                },
                get detail() {
                    return data.detail;
                },
                set detail(value) {
                    data.detail = value;
                    updateAsync();
                },
                get severity() {
                    return data.severity;
                },
                set severity(value) {
                    data.severity = value;
                    updateAsync();
                },
                get accessibilityInformation() {
                    return data.accessibilityInformation;
                },
                set accessibilityInformation(value) {
                    data.accessibilityInformation = value;
                    updateAsync();
                },
                get command() {
                    return data.command;
                },
                set command(value) {
                    data.command = value;
                    updateAsync();
                },
                get busy() {
                    return data.busy;
                },
                set busy(value) {
                    data.busy = value;
                    updateAsync();
                }
            };
            updateAsync();
            return result;
        }
    }
    exports.$5qc = $5qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[246/*vs/workbench/api/common/extHostNotebookDocument*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/network*/,2/*vs/base/common/uri*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,89/*vs/workbench/contrib/notebook/common/notebookCommon*/]), function (require, exports, network_1, uri_1, extHostTypeConverters, extHostTypes_1, notebookCommon) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Qqc = exports.$Pqc = void 0;
    extHostTypeConverters = __importStar(extHostTypeConverters);
    notebookCommon = __importStar(notebookCommon);
    class RawContentChangeEvent {
        constructor(start, deletedCount, deletedItems, items) {
            this.start = start;
            this.deletedCount = deletedCount;
            this.deletedItems = deletedItems;
            this.items = items;
        }
        asApiEvent() {
            return {
                range: new extHostTypes_1.$eP(this.start, this.start + this.deletedCount),
                addedCells: this.items.map(cell => cell.apiCell),
                removedCells: this.deletedItems,
            };
        }
    }
    class $Pqc {
        static asModelAddData(cell) {
            return {
                EOL: cell.eol,
                lines: cell.source,
                languageId: cell.language,
                uri: cell.uri,
                isDirty: false,
                versionId: 1
            };
        }
        constructor(notebook, h, j) {
            this.notebook = notebook;
            this.h = h;
            this.j = j;
            this.handle = j.handle;
            this.uri = uri_1.URI.revive(j.uri);
            this.cellKind = j.cellKind;
            this.a = j.outputs.map(extHostTypeConverters.NotebookCellOutput.to);
            this.e = j.internalMetadata ?? {};
            this.b = Object.freeze(j.metadata ?? {});
            this.d = Object.freeze(extHostTypeConverters.NotebookCellExecutionSummary.to(j.internalMetadata ?? {}));
        }
        get internalMetadata() {
            return this.e;
        }
        get apiCell() {
            if (!this.f) {
                const that = this;
                const data = this.h.getDocument(this.uri);
                if (!data) {
                    throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`);
                }
                const apiCell = {
                    get index() { return that.notebook.getCellIndex(that); },
                    notebook: that.notebook.apiNotebook,
                    kind: extHostTypeConverters.NotebookCellKind.to(this.j.cellKind),
                    document: data.document,
                    get mime() { return that.g; },
                    set mime(value) { that.g = value; },
                    get outputs() { return that.a.slice(0); },
                    get metadata() { return that.b; },
                    get executionSummary() { return that.d; }
                };
                this.f = Object.freeze(apiCell);
            }
            return this.f;
        }
        setOutputs(newOutputs) {
            this.a = newOutputs.map(extHostTypeConverters.NotebookCellOutput.to);
        }
        setOutputItems(outputId, append, newOutputItems) {
            const newItems = newOutputItems.map(extHostTypeConverters.NotebookCellOutputItem.to);
            const output = this.a.find(op => op.id === outputId);
            if (output) {
                if (!append) {
                    output.items.length = 0;
                }
                output.items.push(...newItems);
                if (output.items.length > 1 && output.items.every(item => notebookCommon.$ML(item.mime))) {
                    // Look for the mimes in the items, and keep track of their order.
                    // Merge the streams into one output item, per mime type.
                    const mimeOutputs = new Map();
                    const mimeTypes = [];
                    output.items.forEach(item => {
                        let items;
                        if (mimeOutputs.has(item.mime)) {
                            items = mimeOutputs.get(item.mime);
                        }
                        else {
                            items = [];
                            mimeOutputs.set(item.mime, items);
                            mimeTypes.push(item.mime);
                        }
                        items.push(item.data);
                    });
                    output.items.length = 0;
                    mimeTypes.forEach(mime => {
                        const compressed = notebookCommon.$NL(mimeOutputs.get(mime));
                        output.items.push({
                            mime,
                            data: compressed.data.buffer
                        });
                    });
                }
            }
        }
        setMetadata(newMetadata) {
            this.b = Object.freeze(newMetadata);
        }
        setInternalMetadata(newInternalMetadata) {
            this.e = newInternalMetadata;
            this.d = Object.freeze(extHostTypeConverters.NotebookCellExecutionSummary.to(newInternalMetadata));
        }
        setMime(newMime) {
        }
    }
    exports.$Pqc = $Pqc;
    class $Qqc {
        static { this.a = 0; }
        constructor(k, l, m, uri, data) {
            this.k = k;
            this.l = l;
            this.m = m;
            this.uri = uri;
            this.handle = $Qqc.a++;
            this.b = [];
            this.g = 0;
            this.h = false;
            this.j = false;
            this.d = data.viewType;
            this.f = Object.freeze(data.metadata ?? Object.create(null));
            this.r([[0, 0, data.cells]], true /* init -> no event*/, undefined);
            this.g = data.versionId;
        }
        dispose() {
            this.j = true;
        }
        get versionId() {
            return this.g;
        }
        get apiNotebook() {
            if (!this.e) {
                const that = this;
                const apiObject = {
                    get uri() { return that.uri; },
                    get version() { return that.g; },
                    get notebookType() { return that.d; },
                    get isDirty() { return that.h; },
                    get isUntitled() { return that.uri.scheme === network_1.Schemas.untitled; },
                    get isClosed() { return that.j; },
                    get metadata() { return that.f; },
                    get cellCount() { return that.b.length; },
                    cellAt(index) {
                        index = that.n(index);
                        return that.b[index].apiCell;
                    },
                    getCells(range) {
                        const cells = range ? that.p(range) : that.b;
                        return cells.map(cell => cell.apiCell);
                    },
                    save() {
                        return that.q();
                    },
                    [Symbol.for('debug.description')]() {
                        return `NotebookDocument(${this.uri.toString()})`;
                    }
                };
                this.e = Object.freeze(apiObject);
            }
            return this.e;
        }
        acceptDocumentPropertiesChanged(data) {
            if (data.metadata) {
                this.f = Object.freeze({ ...this.f, ...data.metadata });
            }
        }
        acceptDirty(isDirty) {
            this.h = isDirty;
        }
        acceptModelChanged(event, isDirty, newMetadata) {
            this.g = event.versionId;
            this.h = isDirty;
            this.acceptDocumentPropertiesChanged({ metadata: newMetadata });
            const result = {
                notebook: this.apiNotebook,
                metadata: newMetadata,
                cellChanges: [],
                contentChanges: [],
            };
            const relaxedCellChanges = [];
            // -- apply change and populate content changes
            for (const rawEvent of event.rawEvents) {
                if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ModelChange) {
                    this.r(rawEvent.changes, false, result.contentChanges);
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.Move) {
                    this.s(rawEvent.index, rawEvent.length, rawEvent.newIdx, result.contentChanges);
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.Output) {
                    this.t(rawEvent.index, rawEvent.outputs);
                    relaxedCellChanges.push({ cell: this.b[rawEvent.index].apiCell, outputs: this.b[rawEvent.index].apiCell.outputs });
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.OutputItem) {
                    this.u(rawEvent.index, rawEvent.outputId, rawEvent.append, rawEvent.outputItems);
                    relaxedCellChanges.push({ cell: this.b[rawEvent.index].apiCell, outputs: this.b[rawEvent.index].apiCell.outputs });
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellLanguage) {
                    this.v(rawEvent.index, rawEvent.language);
                    relaxedCellChanges.push({ cell: this.b[rawEvent.index].apiCell, document: this.b[rawEvent.index].apiCell.document });
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellContent) {
                    relaxedCellChanges.push({ cell: this.b[rawEvent.index].apiCell, document: this.b[rawEvent.index].apiCell.document });
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellMime) {
                    this.w(rawEvent.index, rawEvent.mime);
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellMetadata) {
                    this.x(rawEvent.index, rawEvent.metadata);
                    relaxedCellChanges.push({ cell: this.b[rawEvent.index].apiCell, metadata: this.b[rawEvent.index].apiCell.metadata });
                }
                else if (rawEvent.kind === notebookCommon.NotebookCellsChangeType.ChangeCellInternalMetadata) {
                    this.y(rawEvent.index, rawEvent.internalMetadata);
                    relaxedCellChanges.push({ cell: this.b[rawEvent.index].apiCell, executionSummary: this.b[rawEvent.index].apiCell.executionSummary });
                }
            }
            // -- compact cellChanges
            const map = new Map();
            for (let i = 0; i < relaxedCellChanges.length; i++) {
                const relaxedCellChange = relaxedCellChanges[i];
                const existing = map.get(relaxedCellChange.cell);
                if (existing === undefined) {
                    const newLen = result.cellChanges.push({
                        document: undefined,
                        executionSummary: undefined,
                        metadata: undefined,
                        outputs: undefined,
                        ...relaxedCellChange,
                    });
                    map.set(relaxedCellChange.cell, newLen - 1);
                }
                else {
                    result.cellChanges[existing] = {
                        ...result.cellChanges[existing],
                        ...relaxedCellChange
                    };
                }
            }
            // Freeze event properties so handlers cannot accidentally modify them
            Object.freeze(result);
            Object.freeze(result.cellChanges);
            Object.freeze(result.contentChanges);
            return result;
        }
        n(index) {
            index = index | 0;
            if (index < 0) {
                return 0;
            }
            else if (index >= this.b.length) {
                return this.b.length - 1;
            }
            else {
                return index;
            }
        }
        o(range) {
            let start = range.start | 0;
            let end = range.end | 0;
            if (start < 0) {
                start = 0;
            }
            if (end > this.b.length) {
                end = this.b.length;
            }
            return range.with({ start, end });
        }
        p(range) {
            range = this.o(range);
            const result = [];
            for (let i = range.start; i < range.end; i++) {
                result.push(this.b[i]);
            }
            return result;
        }
        async q() {
            if (this.j) {
                return Promise.reject(new Error('Notebook has been closed'));
            }
            return this.k.$trySaveNotebook(this.uri);
        }
        r(splices, initialization, bucket) {
            if (this.j) {
                return;
            }
            const contentChangeEvents = [];
            const addedCellDocuments = [];
            const removedCellDocuments = [];
            splices.reverse().forEach(splice => {
                const cellDtos = splice[2];
                const newCells = cellDtos.map(cell => {
                    const extCell = new $Pqc(this, this.l, cell);
                    if (!initialization) {
                        addedCellDocuments.push($Pqc.asModelAddData(cell));
                    }
                    return extCell;
                });
                const changeEvent = new RawContentChangeEvent(splice[0], splice[1], [], newCells);
                const deletedItems = this.b.splice(splice[0], splice[1], ...newCells);
                for (const cell of deletedItems) {
                    removedCellDocuments.push(cell.uri);
                    changeEvent.deletedItems.push(cell.apiCell);
                }
                contentChangeEvents.push(changeEvent);
            });
            this.l.acceptDocumentsAndEditorsDelta({
                addedDocuments: addedCellDocuments,
                removedDocuments: removedCellDocuments
            });
            if (bucket) {
                for (const changeEvent of contentChangeEvents) {
                    bucket.push(changeEvent.asApiEvent());
                }
            }
        }
        s(index, length, newIdx, bucket) {
            const cells = this.b.splice(index, length);
            this.b.splice(newIdx, 0, ...cells);
            const changes = [
                new RawContentChangeEvent(index, length, cells.map(c => c.apiCell), []),
                new RawContentChangeEvent(newIdx, 0, [], cells)
            ];
            for (const change of changes) {
                bucket.push(change.asApiEvent());
            }
        }
        t(index, outputs) {
            const cell = this.b[index];
            cell.setOutputs(outputs);
        }
        u(index, outputId, append, outputItems) {
            const cell = this.b[index];
            cell.setOutputItems(outputId, append, outputItems);
        }
        v(index, newLanguageId) {
            const cell = this.b[index];
            if (cell.apiCell.document.languageId !== newLanguageId) {
                this.m.$acceptModelLanguageChanged(cell.uri, newLanguageId);
            }
        }
        w(index, newMime) {
            const cell = this.b[index];
            cell.apiCell.mime = newMime;
        }
        x(index, newMetadata) {
            const cell = this.b[index];
            cell.setMetadata(newMetadata);
        }
        y(index, newInternalMetadata) {
            const cell = this.b[index];
            cell.setInternalMetadata(newInternalMetadata);
        }
        getCellFromApiCell(apiCell) {
            return this.b.find(cell => cell.apiCell === apiCell);
        }
        getCellFromIndex(index) {
            return this.b[index];
        }
        getCell(cellHandle) {
            return this.b.find(cell => cell.handle === cellHandle);
        }
        getCellIndex(cell) {
            return this.b.indexOf(cell);
        }
    }
    exports.$Qqc = $Qqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[247/*vs/workbench/api/common/extHostNotebookDocumentSaveParticipant*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,2/*vs/base/common/uri*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/]), function (require, exports, event_1, uri_1, extHostTypeConverters_1, extHostTypes_1, proxyIdentifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$7qc = void 0;
    class $7qc {
        constructor(b, c, d, f = { timeout: 1500, errors: 3 }) {
            this.b = b;
            this.c = c;
            this.d = d;
            this.f = f;
            this.a = new event_1.$ne();
        }
        dispose() {
        }
        getOnWillSaveNotebookDocumentEvent(extension) {
            return (listener, thisArg, disposables) => {
                const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };
                wrappedListener.extension = extension;
                return this.a.event(wrappedListener, undefined, disposables);
            };
        }
        async $participateInSave(resource, reason, token) {
            const revivedUri = uri_1.URI.revive(resource);
            const document = this.c.getNotebookDocument(revivedUri);
            if (!document) {
                throw new Error('Unable to resolve notebook document');
            }
            const edits = [];
            await this.a.fireAsync({ notebook: document.apiNotebook, reason: extHostTypeConverters_1.TextDocumentSaveReason.to(reason) }, token, async (thenable, listener) => {
                const now = Date.now();
                const data = await await Promise.resolve(thenable);
                if (Date.now() - now > this.f.timeout) {
                    this.b.warn('onWillSaveNotebookDocument-listener from extension', listener.extension.identifier);
                }
                if (token.isCancellationRequested) {
                    return;
                }
                if (data) {
                    if (data instanceof extHostTypes_1.$YN) {
                        edits.push(data);
                    }
                    else {
                        // ignore invalid data
                        this.b.warn('onWillSaveNotebookDocument-listener from extension', listener.extension.identifier, 'ignored due to invalid data');
                    }
                }
                return;
            });
            if (token.isCancellationRequested) {
                return false;
            }
            if (edits.length === 0) {
                return true;
            }
            const dto = { edits: [] };
            for (const edit of edits) {
                const { edits } = extHostTypeConverters_1.WorkspaceEdit.from(edit);
                dto.edits = dto.edits.concat(edits);
            }
            return this.d.$tryApplyWorkspaceEdit(new proxyIdentifier_1.$Xw(dto));
        }
    }
    exports.$7qc = $7qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[124/*vs/workbench/api/common/extHostNotebookEditor*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, errors_1, extHostConverter, extHostTypes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Rqc = void 0;
    extHostConverter = __importStar(extHostConverter);
    extHostTypes = __importStar(extHostTypes);
    class $Rqc {
        static { this.apiEditorsToExtHost = new WeakMap(); }
        constructor(id, f, notebookData, visibleRanges, selections, viewColumn) {
            this.id = id;
            this.f = f;
            this.notebookData = notebookData;
            this.a = [];
            this.b = [];
            this.d = false;
            this.a = selections;
            this.b = visibleRanges;
            this.c = viewColumn;
        }
        get apiEditor() {
            if (!this.e) {
                const that = this;
                this.e = {
                    get notebook() {
                        return that.notebookData.apiNotebook;
                    },
                    get selection() {
                        return that.a[0];
                    },
                    set selection(selection) {
                        this.selections = [selection];
                    },
                    get selections() {
                        return that.a;
                    },
                    set selections(value) {
                        if (!Array.isArray(value) || !value.every(extHostTypes.$eP.isNotebookRange)) {
                            throw (0, errors_1.$6)('selections');
                        }
                        that.a = value;
                        that.g(value);
                    },
                    get visibleRanges() {
                        return that.b;
                    },
                    revealRange(range, revealType) {
                        that.f.$tryRevealRange(that.id, extHostConverter.NotebookRange.from(range), revealType ?? extHostTypes.NotebookEditorRevealType.Default);
                    },
                    get viewColumn() {
                        return that.c;
                    },
                    [Symbol.for('debug.description')]() {
                        return `NotebookEditor(${this.notebook.uri.toString()})`;
                    }
                };
                $Rqc.apiEditorsToExtHost.set(this.e, this);
            }
            return this.e;
        }
        get visible() {
            return this.d;
        }
        _acceptVisibility(value) {
            this.d = value;
        }
        _acceptVisibleRanges(value) {
            this.b = value;
        }
        _acceptSelections(selections) {
            this.a = selections;
        }
        g(value) {
            this.f.$trySetSelections(this.id, value.map(extHostConverter.NotebookRange.from));
        }
        _acceptViewColumn(value) {
            this.c = value;
        }
    }
    exports.$Rqc = $Rqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[248/*vs/workbench/api/common/extHostNotebookEditors*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,11/*vs/platform/log/common/log*/,8/*vs/workbench/api/common/extHostTypeConverters*/]), function (require, exports, event_1, log_1, typeConverters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$9qc = void 0;
    typeConverters = __importStar(typeConverters);
    let $9qc = class $9qc {
        constructor(c, d) {
            this.c = c;
            this.d = d;
            this.a = new event_1.$le();
            this.b = new event_1.$le();
            this.onDidChangeNotebookEditorSelection = this.a.event;
            this.onDidChangeNotebookEditorVisibleRanges = this.b.event;
        }
        $acceptEditorPropertiesChanged(id, data) {
            this.c.debug('ExtHostNotebook#$acceptEditorPropertiesChanged', id, data);
            const editor = this.d.getEditorById(id);
            // ONE: make all state updates
            if (data.visibleRanges) {
                editor._acceptVisibleRanges(data.visibleRanges.ranges.map(typeConverters.NotebookRange.to));
            }
            if (data.selections) {
                editor._acceptSelections(data.selections.selections.map(typeConverters.NotebookRange.to));
            }
            // TWO: send all events after states have been updated
            if (data.visibleRanges) {
                this.b.fire({
                    notebookEditor: editor.apiEditor,
                    visibleRanges: editor.apiEditor.visibleRanges
                });
            }
            if (data.selections) {
                this.a.fire(Object.freeze({
                    notebookEditor: editor.apiEditor,
                    selections: editor.apiEditor.selections
                }));
            }
        }
        $acceptEditorViewColumns(data) {
            for (const id in data) {
                const editor = this.d.getEditorById(id);
                editor._acceptViewColumn(typeConverters.ViewColumn.to(data[id]));
            }
        }
    };
    exports.$9qc = $9qc;
    exports.$9qc = $9qc = __decorate([
        __param(0, log_1.$ak)
    ], $9qc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[249/*vs/workbench/api/common/extHostNotebookRenderers*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,5/*vs/workbench/api/common/extHost.protocol*/,124/*vs/workbench/api/common/extHostNotebookEditor*/]), function (require, exports, event_1, extHost_protocol_1, extHostNotebookEditor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$_qc = void 0;
    class $_qc {
        constructor(mainContext, c) {
            this.c = c;
            this.a = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadNotebookRenderers);
        }
        $postRendererMessage(editorId, rendererId, message) {
            const editor = this.c.getEditorById(editorId);
            this.a.get(rendererId)?.fire({ editor: editor.apiEditor, message });
        }
        createRendererMessaging(manifest, rendererId) {
            if (!manifest.contributes?.notebookRenderer?.some(r => r.id === rendererId)) {
                throw new Error(`Extensions may only call createRendererMessaging() for renderers they contribute (got ${rendererId})`);
            }
            const messaging = {
                onDidReceiveMessage: (listener, thisArg, disposables) => {
                    return this.d(rendererId).event(listener, thisArg, disposables);
                },
                postMessage: (message, editorOrAlias) => {
                    if (extHostNotebookEditor_1.$Rqc.apiEditorsToExtHost.has(message)) { // back compat for swapped args
                        [message, editorOrAlias] = [editorOrAlias, message];
                    }
                    const extHostEditor = editorOrAlias && extHostNotebookEditor_1.$Rqc.apiEditorsToExtHost.get(editorOrAlias);
                    return this.b.$postMessage(extHostEditor?.id, rendererId, message);
                },
            };
            return messaging;
        }
        d(rendererId) {
            let emitter = this.a.get(rendererId);
            if (emitter) {
                return emitter;
            }
            emitter = new event_1.$le({
                onDidRemoveLastListener: () => {
                    emitter?.dispose();
                    this.a.delete(rendererId);
                }
            });
            this.a.set(rendererId, emitter);
            return emitter;
        }
    }
    exports.$_qc = $_qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






define(__m[250/*vs/workbench/api/common/extHostProgress*/], __M([1/*require*/,0/*exports*/,8/*vs/workbench/api/common/extHostTypeConverters*/,76/*vs/platform/progress/common/progress*/,21/*vs/base/common/cancellation*/,71/*vs/base/common/decorators*/,13/*vs/base/common/errors*/]), function (require, exports, extHostTypeConverters_1, progress_1, cancellation_1, decorators_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$drc = void 0;
    class $drc {
        constructor(proxy) {
            this.b = 0;
            this.c = new Map();
            this.a = proxy;
        }
        async withProgress(extension, options, task) {
            const handle = this.b++;
            const { title, location, cancellable } = options;
            const source = { label: extension.displayName || extension.name, id: extension.identifier.value };
            this.a.$startProgress(handle, { location: extHostTypeConverters_1.ProgressLocation.from(location), title, source, cancellable }, !extension.isUnderDevelopment ? extension.identifier.value : undefined).catch(errors_1.$Z);
            return this.d(handle, task, !!cancellable);
        }
        d(handle, task, cancellable) {
            let source;
            if (cancellable) {
                source = new cancellation_1.$we();
                this.c.set(handle, source);
            }
            const progressEnd = (handle) => {
                this.a.$progressEnd(handle);
                this.c.delete(handle);
                source?.dispose();
            };
            let p;
            try {
                p = task(new ProgressCallback(this.a, handle), cancellable && source ? source.token : cancellation_1.CancellationToken.None);
            }
            catch (err) {
                progressEnd(handle);
                throw err;
            }
            p.then(result => progressEnd(handle), err => progressEnd(handle));
            return p;
        }
        $acceptProgressCanceled(handle) {
            const source = this.c.get(handle);
            if (source) {
                source.cancel();
                this.c.delete(handle);
            }
        }
    }
    exports.$drc = $drc;
    function mergeProgress(result, currentValue) {
        result.message = currentValue.message;
        if (typeof currentValue.increment === 'number') {
            if (typeof result.increment === 'number') {
                result.increment += currentValue.increment;
            }
            else {
                result.increment = currentValue.increment;
            }
        }
        return result;
    }
    class ProgressCallback extends progress_1.$zw {
        constructor(c, d) {
            super(p => this.throttledReport(p));
            this.c = c;
            this.d = d;
        }
        throttledReport(p) {
            this.c.$progressReport(this.d, p);
        }
    }
    __decorate([
        (0, decorators_1.$_h)(100, (result, currentValue) => mergeProgress(result, currentValue), () => Object.create(null))
    ], ProgressCallback.prototype, "throttledReport", null);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[251/*vs/workbench/api/common/extHostQuickDiff*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,10/*vs/base/common/async*/,8/*vs/workbench/api/common/extHostTypeConverters*/]), function (require, exports, uri_1, extHost_protocol_1, async_1, extHostTypeConverters_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$erc = void 0;
    class $erc {
        static { this.a = 0; }
        constructor(mainContext, d) {
            this.d = d;
            this.c = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadQuickDiff);
        }
        $provideOriginalResource(handle, uriComponents, token) {
            const uri = uri_1.URI.revive(uriComponents);
            const provider = this.c.get(handle);
            if (!provider) {
                return Promise.resolve(null);
            }
            return (0, async_1.$xh)(() => provider.provideOriginalResource(uri, token))
                .then(r => r || null);
        }
        registerQuickDiffProvider(selector, quickDiffProvider, label, rootUri) {
            const handle = $erc.a++;
            this.c.set(handle, quickDiffProvider);
            this.b.$registerQuickDiffProvider(handle, extHostTypeConverters_1.DocumentSelector.from(selector, this.d), label, rootUri);
            return {
                dispose: () => {
                    this.b.$unregisterQuickDiffProvider(handle);
                    this.c.delete(handle);
                }
            };
        }
    }
    exports.$erc = $erc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[252/*vs/workbench/api/common/extHostQuickOpen*/], __M([1/*require*/,0/*exports*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,5/*vs/workbench/api/common/extHost.protocol*/,2/*vs/base/common/uri*/,7/*vs/workbench/api/common/extHostTypes*/,13/*vs/base/common/errors*/,17/*vs/base/common/arrays*/,35/*vs/base/common/severity*/,34/*vs/base/common/themables*/,24/*vs/workbench/services/extensions/common/extensions*/,8/*vs/workbench/api/common/extHostTypeConverters*/]), function (require, exports, cancellation_1, event_1, lifecycle_1, extHost_protocol_1, uri_1, extHostTypes_1, errors_1, arrays_1, severity_1, themables_1, extensions_1, extHostTypeConverters_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$frc = $frc;
    severity_1 = __importDefault(severity_1);
    function $frc(mainContext, workspace, commands) {
        const proxy = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadQuickOpen);
        class ExtHostQuickOpenImpl {
            constructor(workspace, commands) {
                this.e = new Map();
                this.f = 0;
                this.a = workspace;
                this.b = commands;
            }
            showQuickPick(extension, itemsOrItemsPromise, options, token = cancellation_1.CancellationToken.None) {
                // clear state from last invocation
                this.c = undefined;
                const itemsPromise = Promise.resolve(itemsOrItemsPromise);
                const instance = ++this.f;
                const quickPickWidget = proxy.$show(instance, {
                    title: options?.title,
                    placeHolder: options?.placeHolder,
                    matchOnDescription: options?.matchOnDescription,
                    matchOnDetail: options?.matchOnDetail,
                    ignoreFocusLost: options?.ignoreFocusOut,
                    canPickMany: options?.canPickMany,
                }, token);
                const widgetClosedMarker = {};
                const widgetClosedPromise = quickPickWidget.then(() => widgetClosedMarker);
                return Promise.race([widgetClosedPromise, itemsPromise]).then(result => {
                    if (result === widgetClosedMarker) {
                        return undefined;
                    }
                    const allowedTooltips = (0, extensions_1.$fH)(extension, 'quickPickItemTooltip');
                    return itemsPromise.then(items => {
                        const pickItems = [];
                        for (let handle = 0; handle < items.length; handle++) {
                            const item = items[handle];
                            if (typeof item === 'string') {
                                pickItems.push({ label: item, handle });
                            }
                            else if (item.kind === extHostTypes_1.QuickPickItemKind.Separator) {
                                pickItems.push({ type: 'separator', label: item.label });
                            }
                            else {
                                if (item.tooltip && !allowedTooltips) {
                                    console.warn(`Extension '${extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
                                }
                                const icon = (item.iconPath) ? getIconPathOrClass(item.iconPath) : undefined;
                                pickItems.push({
                                    label: item.label,
                                    iconPath: icon?.iconPath,
                                    iconClass: icon?.iconClass,
                                    description: item.description,
                                    detail: item.detail,
                                    picked: item.picked,
                                    alwaysShow: item.alwaysShow,
                                    tooltip: allowedTooltips ? extHostTypeConverters_1.MarkdownString.fromStrict(item.tooltip) : undefined,
                                    handle
                                });
                            }
                        }
                        // handle selection changes
                        if (options && typeof options.onDidSelectItem === 'function') {
                            this.c = (handle) => {
                                options.onDidSelectItem(items[handle]);
                            };
                        }
                        // show items
                        proxy.$setItems(instance, pickItems);
                        return quickPickWidget.then(handle => {
                            if (typeof handle === 'number') {
                                return items[handle];
                            }
                            else if (Array.isArray(handle)) {
                                return handle.map(h => items[h]);
                            }
                            return undefined;
                        });
                    });
                }).then(undefined, err => {
                    if ((0, errors_1.$3)(err)) {
                        return undefined;
                    }
                    proxy.$setError(instance, err);
                    return Promise.reject(err);
                });
            }
            $onItemSelected(handle) {
                this.c?.(handle);
            }
            // ---- input
            showInput(options, token = cancellation_1.CancellationToken.None) {
                // global validate fn used in callback below
                this.d = options?.validateInput;
                return proxy.$input(options, typeof this.d === 'function', token)
                    .then(undefined, err => {
                    if ((0, errors_1.$3)(err)) {
                        return undefined;
                    }
                    return Promise.reject(err);
                });
            }
            async $validateInput(input) {
                if (!this.d) {
                    return;
                }
                const result = await this.d(input);
                if (!result || typeof result === 'string') {
                    return result;
                }
                let severity;
                switch (result.severity) {
                    case extHostTypes_1.InputBoxValidationSeverity.Info:
                        severity = severity_1.default.Info;
                        break;
                    case extHostTypes_1.InputBoxValidationSeverity.Warning:
                        severity = severity_1.default.Warning;
                        break;
                    case extHostTypes_1.InputBoxValidationSeverity.Error:
                        severity = severity_1.default.Error;
                        break;
                    default:
                        severity = result.message ? severity_1.default.Error : severity_1.default.Ignore;
                        break;
                }
                return {
                    content: result.message,
                    severity
                };
            }
            // ---- workspace folder picker
            async showWorkspaceFolderPick(options, token = cancellation_1.CancellationToken.None) {
                const selectedFolder = await this.b.executeCommand('_workbench.pickWorkspaceFolder', [options]);
                if (!selectedFolder) {
                    return undefined;
                }
                const workspaceFolders = await this.a.getWorkspaceFolders2();
                if (!workspaceFolders) {
                    return undefined;
                }
                return workspaceFolders.find(folder => folder.uri.toString() === selectedFolder.uri.toString());
            }
            // ---- QuickInput
            createQuickPick(extension) {
                const session = new ExtHostQuickPick(extension, () => this.e.delete(session._id));
                this.e.set(session._id, session);
                return session;
            }
            createInputBox(extension) {
                const session = new ExtHostInputBox(extension, () => this.e.delete(session._id));
                this.e.set(session._id, session);
                return session;
            }
            $onDidChangeValue(sessionId, value) {
                const session = this.e.get(sessionId);
                session?._fireDidChangeValue(value);
            }
            $onDidAccept(sessionId) {
                const session = this.e.get(sessionId);
                session?._fireDidAccept();
            }
            $onDidChangeActive(sessionId, handles) {
                const session = this.e.get(sessionId);
                if (session instanceof ExtHostQuickPick) {
                    session._fireDidChangeActive(handles);
                }
            }
            $onDidChangeSelection(sessionId, handles) {
                const session = this.e.get(sessionId);
                if (session instanceof ExtHostQuickPick) {
                    session._fireDidChangeSelection(handles);
                }
            }
            $onDidTriggerButton(sessionId, handle) {
                const session = this.e.get(sessionId);
                session?._fireDidTriggerButton(handle);
            }
            $onDidTriggerItemButton(sessionId, itemHandle, buttonHandle) {
                const session = this.e.get(sessionId);
                if (session instanceof ExtHostQuickPick) {
                    session._fireDidTriggerItemButton(itemHandle, buttonHandle);
                }
            }
            $onDidHide(sessionId) {
                const session = this.e.get(sessionId);
                session?._fireDidHide();
            }
        }
        class ExtHostQuickInput {
            static { this.a = 1; }
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this._id = ExtHostQuickPick.a++;
                this.e = false;
                this.f = false;
                this.g = true;
                this.j = false;
                this.k = true;
                this.l = '';
                this.n = [];
                this.o = new Map();
                this.p = new event_1.$le();
                this.q = new event_1.$le();
                this.r = new event_1.$le();
                this.s = new event_1.$le();
                this.u = { id: this._id };
                this.v = false;
                this.w = [
                    this.r,
                    this.s,
                    this.p,
                    this.q
                ];
                this.onDidChangeValue = this.q.event;
                this.onDidAccept = this.p.event;
                this.onDidTriggerButton = this.r.event;
                this.onDidHide = this.s.event;
            }
            get title() {
                return this.b;
            }
            set title(title) {
                this.b = title;
                this.z({ title });
            }
            get step() {
                return this.c;
            }
            set step(step) {
                this.c = step;
                this.z({ step });
            }
            get totalSteps() {
                return this.d;
            }
            set totalSteps(totalSteps) {
                this.d = totalSteps;
                this.z({ totalSteps });
            }
            get enabled() {
                return this.g;
            }
            set enabled(enabled) {
                this.g = enabled;
                this.z({ enabled });
            }
            get busy() {
                return this.j;
            }
            set busy(busy) {
                this.j = busy;
                this.z({ busy });
            }
            get ignoreFocusOut() {
                return this.k;
            }
            set ignoreFocusOut(ignoreFocusOut) {
                this.k = ignoreFocusOut;
                this.z({ ignoreFocusOut });
            }
            get value() {
                return this.l;
            }
            set value(value) {
                this.l = value;
                this.z({ value });
            }
            get placeholder() {
                return this.m;
            }
            set placeholder(placeholder) {
                this.m = placeholder;
                this.z({ placeholder });
            }
            get buttons() {
                return this.n;
            }
            set buttons(buttons) {
                const allowedButtonLocation = (0, extensions_1.$fH)(this.x, 'quickInputButtonLocation');
                if (!allowedButtonLocation && buttons.some(button => button.location)) {
                    console.warn(`Extension '${this.x.identifier.value}' uses a button location which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.x.identifier.value}`);
                }
                this.n = buttons.slice();
                this.o.clear();
                buttons.forEach((button, i) => {
                    const handle = button === extHostTypes_1.$bP.Back ? -1 : i;
                    this.o.set(handle, button);
                });
                this.z({
                    buttons: buttons.map((button, i) => {
                        return {
                            ...getIconPathOrClass(button.iconPath),
                            tooltip: button.tooltip,
                            handle: button === extHostTypes_1.$bP.Back ? -1 : i,
                            location: allowedButtonLocation ? button.location : undefined
                        };
                    })
                });
            }
            show() {
                this.e = true;
                this.f = true;
                this.z({ visible: true });
            }
            hide() {
                this.e = false;
                this.z({ visible: false });
            }
            _fireDidAccept() {
                this.p.fire();
            }
            _fireDidChangeValue(value) {
                this.l = value;
                this.q.fire(value);
            }
            _fireDidTriggerButton(handle) {
                const button = this.o.get(handle);
                if (button) {
                    this.r.fire(button);
                }
            }
            _fireDidHide() {
                if (this.f) {
                    // if this._visible is true, it means that .show() was called between
                    // .hide() and .onDidHide. To ensure the correct number of onDidHide events
                    // are emitted, we set this._expectingHide to this value so that
                    // the next time .hide() is called, we can emit the event again.
                    // Example:
                    // .show() -> .hide() -> .show() -> .hide() should emit 2 onDidHide events.
                    // .show() -> .hide() -> .hide() should emit 1 onDidHide event.
                    // Fixes #135747
                    this.f = this.e;
                    this.s.fire();
                }
            }
            dispose() {
                if (this.v) {
                    return;
                }
                this.v = true;
                this._fireDidHide();
                this.w = (0, lifecycle_1.$Pc)(this.w);
                if (this.t) {
                    clearTimeout(this.t);
                    this.t = undefined;
                }
                this.y();
                proxy.$dispose(this._id);
            }
            z(properties) {
                if (this.v) {
                    return;
                }
                for (const key of Object.keys(properties)) {
                    const value = properties[key];
                    this.u[key] = value === undefined ? null : value;
                }
                if ('visible' in this.u) {
                    if (this.t) {
                        clearTimeout(this.t);
                        this.t = undefined;
                    }
                    this.A();
                }
                else if (this.e && !this.t) {
                    // Defer the update so that multiple changes to setters dont cause a redraw each
                    this.t = setTimeout(() => {
                        this.t = undefined;
                        this.A();
                    }, 0);
                }
            }
            A() {
                proxy.$createOrUpdate(this.u);
                this.u = { id: this._id };
            }
        }
        function getIconUris(iconPath) {
            if (iconPath instanceof extHostTypes_1.$LO) {
                return { id: iconPath.id };
            }
            const dark = getDarkIconUri(iconPath);
            const light = getLightIconUri(iconPath);
            // Tolerate strings: https://github.com/microsoft/vscode/issues/110432#issuecomment-726144556
            return {
                dark: typeof dark === 'string' ? uri_1.URI.file(dark) : dark,
                light: typeof light === 'string' ? uri_1.URI.file(light) : light
            };
        }
        function getLightIconUri(iconPath) {
            return typeof iconPath === 'object' && 'light' in iconPath ? iconPath.light : iconPath;
        }
        function getDarkIconUri(iconPath) {
            return typeof iconPath === 'object' && 'dark' in iconPath ? iconPath.dark : iconPath;
        }
        function getIconPathOrClass(icon) {
            const iconPathOrIconClass = getIconUris(icon);
            let iconPath;
            let iconClass;
            if ('id' in iconPathOrIconClass) {
                iconClass = themables_1.ThemeIcon.asClassName(iconPathOrIconClass);
            }
            else {
                iconPath = iconPathOrIconClass;
            }
            return {
                iconPath,
                iconClass
            };
        }
        class ExtHostQuickPick extends ExtHostQuickInput {
            constructor(extension, onDispose) {
                super(extension, onDispose);
                this.B = [];
                this.C = new Map();
                this.D = new Map();
                this.E = false;
                this.F = true;
                this.G = true;
                this.H = true;
                this.I = false;
                this.J = [];
                this.K = new event_1.$le();
                this.L = [];
                this.M = new event_1.$le();
                this.N = new event_1.$le();
                this.onDidChangeActive = this.K.event;
                this.onDidChangeSelection = this.M.event;
                this.onDidTriggerItemButton = this.N.event;
                this.w.push(this.K, this.M, this.N);
                this.z({ type: 'quickPick' });
            }
            get items() {
                return this.B;
            }
            set items(items) {
                this.B = items.slice();
                this.C.clear();
                this.D.clear();
                items.forEach((item, i) => {
                    this.C.set(i, item);
                    this.D.set(item, i);
                });
                const allowedTooltips = (0, extensions_1.$fH)(this.x, 'quickPickItemTooltip');
                const pickItems = [];
                for (let handle = 0; handle < items.length; handle++) {
                    const item = items[handle];
                    if (item.kind === extHostTypes_1.QuickPickItemKind.Separator) {
                        pickItems.push({ type: 'separator', label: item.label });
                    }
                    else {
                        if (item.tooltip && !allowedTooltips) {
                            console.warn(`Extension '${this.x.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.x.identifier.value}`);
                        }
                        const icon = (item.iconPath) ? getIconPathOrClass(item.iconPath) : undefined;
                        pickItems.push({
                            handle,
                            label: item.label,
                            iconPath: icon?.iconPath,
                            iconClass: icon?.iconClass,
                            description: item.description,
                            detail: item.detail,
                            picked: item.picked,
                            alwaysShow: item.alwaysShow,
                            tooltip: allowedTooltips ? extHostTypeConverters_1.MarkdownString.fromStrict(item.tooltip) : undefined,
                            buttons: item.buttons?.map((button, i) => {
                                return {
                                    ...getIconPathOrClass(button.iconPath),
                                    tooltip: button.tooltip,
                                    handle: i
                                };
                            }),
                        });
                    }
                }
                this.z({
                    items: pickItems,
                });
            }
            get canSelectMany() {
                return this.E;
            }
            set canSelectMany(canSelectMany) {
                this.E = canSelectMany;
                this.z({ canSelectMany });
            }
            get matchOnDescription() {
                return this.F;
            }
            set matchOnDescription(matchOnDescription) {
                this.F = matchOnDescription;
                this.z({ matchOnDescription });
            }
            get matchOnDetail() {
                return this.G;
            }
            set matchOnDetail(matchOnDetail) {
                this.G = matchOnDetail;
                this.z({ matchOnDetail });
            }
            get sortByLabel() {
                return this.H;
            }
            set sortByLabel(sortByLabel) {
                this.H = sortByLabel;
                this.z({ sortByLabel });
            }
            get keepScrollPosition() {
                return this.I;
            }
            set keepScrollPosition(keepScrollPosition) {
                this.I = keepScrollPosition;
                this.z({ keepScrollPosition });
            }
            get activeItems() {
                return this.J;
            }
            set activeItems(activeItems) {
                this.J = activeItems.filter(item => this.D.has(item));
                this.z({ activeItems: this.J.map(item => this.D.get(item)) });
            }
            get selectedItems() {
                return this.L;
            }
            set selectedItems(selectedItems) {
                this.L = selectedItems.filter(item => this.D.has(item));
                this.z({ selectedItems: this.L.map(item => this.D.get(item)) });
            }
            _fireDidChangeActive(handles) {
                const items = (0, arrays_1.$Gb)(handles.map(handle => this.C.get(handle)));
                this.J = items;
                this.K.fire(items);
            }
            _fireDidChangeSelection(handles) {
                const items = (0, arrays_1.$Gb)(handles.map(handle => this.C.get(handle)));
                this.L = items;
                this.M.fire(items);
            }
            _fireDidTriggerItemButton(itemHandle, buttonHandle) {
                const item = this.C.get(itemHandle);
                if (!item || !item.buttons || !item.buttons.length) {
                    return;
                }
                const button = item.buttons[buttonHandle];
                if (button) {
                    this.N.fire({
                        button,
                        item
                    });
                }
            }
        }
        class ExtHostInputBox extends ExtHostQuickInput {
            constructor(extension, onDispose) {
                super(extension, onDispose);
                this.B = false;
                this.z({ type: 'inputBox' });
            }
            get password() {
                return this.B;
            }
            set password(password) {
                this.B = password;
                this.z({ password });
            }
            get prompt() {
                return this.C;
            }
            set prompt(prompt) {
                this.C = prompt;
                this.z({ prompt });
            }
            get valueSelection() {
                return this.D;
            }
            set valueSelection(valueSelection) {
                this.D = valueSelection;
                this.z({ valueSelection });
            }
            get validationMessage() {
                return this.E;
            }
            set validationMessage(validationMessage) {
                this.E = validationMessage;
                if (!validationMessage) {
                    this.z({ validationMessage: undefined, severity: severity_1.default.Ignore });
                }
                else if (typeof validationMessage === 'string') {
                    this.z({ validationMessage, severity: severity_1.default.Error });
                }
                else {
                    this.z({ validationMessage: validationMessage.message, severity: validationMessage.severity ?? severity_1.default.Error });
                }
            }
        }
        return new ExtHostQuickOpenImpl(workspace, commands);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[253/*vs/workbench/api/common/extHostSCM*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,6/*vs/base/common/event*/,71/*vs/base/common/decorators*/,4/*vs/base/common/lifecycle*/,10/*vs/base/common/async*/,5/*vs/workbench/api/common/extHost.protocol*/,17/*vs/base/common/arrays*/,145/*vs/base/common/comparers*/,11/*vs/platform/log/common/log*/,18/*vs/platform/extensions/common/extensions*/,37/*vs/base/common/marshallingIds*/,34/*vs/base/common/themables*/,8/*vs/workbench/api/common/extHostTypeConverters*/,24/*vs/workbench/services/extensions/common/extensions*/,15/*vs/base/common/network*/,20/*vs/base/common/platform*/]), function (require, exports, uri_1, event_1, decorators_1, lifecycle_1, async_1, extHost_protocol_1, arrays_1, comparers_1, log_1, extensions_1, marshallingIds_1, themables_1, extHostTypeConverters_1, extensions_2, network_1, platform_1) {
    "use strict";
    var $hrc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$hrc = exports.$grc = void 0;
    function isUri(thing) {
        return thing instanceof uri_1.URI;
    }
    function uriEquals(a, b) {
        if (a.scheme === network_1.Schemas.file && b.scheme === network_1.Schemas.file && platform_1.$l) {
            return a.toString() === b.toString();
        }
        return a.toString().toLowerCase() === b.toString().toLowerCase();
    }
    function getIconResource(decorations) {
        if (!decorations) {
            return undefined;
        }
        else if (typeof decorations.iconPath === 'string') {
            return uri_1.URI.file(decorations.iconPath);
        }
        else if (uri_1.URI.isUri(decorations.iconPath)) {
            return decorations.iconPath;
        }
        else if (themables_1.ThemeIcon.isThemeIcon(decorations.iconPath)) {
            return decorations.iconPath;
        }
        else {
            return undefined;
        }
    }
    function getHistoryItemIconDto(icon) {
        if (!icon) {
            return undefined;
        }
        else if (uri_1.URI.isUri(icon)) {
            return icon;
        }
        else if (themables_1.ThemeIcon.isThemeIcon(icon)) {
            return icon;
        }
        else {
            const iconDto = icon;
            return { light: iconDto.light, dark: iconDto.dark };
        }
    }
    function toSCMHistoryItemDto(historyItem) {
        const icon = getHistoryItemIconDto(historyItem.icon);
        const labels = historyItem.labels?.map(l => ({ title: l.title, icon: getHistoryItemIconDto(l.icon) }));
        return { ...historyItem, icon, labels };
    }
    function compareResourceThemableDecorations(a, b) {
        if (!a.iconPath && !b.iconPath) {
            return 0;
        }
        else if (!a.iconPath) {
            return -1;
        }
        else if (!b.iconPath) {
            return 1;
        }
        const aPath = typeof a.iconPath === 'string' ? a.iconPath : uri_1.URI.isUri(a.iconPath) ? a.iconPath.fsPath : a.iconPath.id;
        const bPath = typeof b.iconPath === 'string' ? b.iconPath : uri_1.URI.isUri(b.iconPath) ? b.iconPath.fsPath : b.iconPath.id;
        return (0, comparers_1.$Kr)(aPath, bPath);
    }
    function compareResourceStatesDecorations(a, b) {
        let result = 0;
        if (a.strikeThrough !== b.strikeThrough) {
            return a.strikeThrough ? 1 : -1;
        }
        if (a.faded !== b.faded) {
            return a.faded ? 1 : -1;
        }
        if (a.tooltip !== b.tooltip) {
            return (a.tooltip || '').localeCompare(b.tooltip || '');
        }
        result = compareResourceThemableDecorations(a, b);
        if (result !== 0) {
            return result;
        }
        if (a.light && b.light) {
            result = compareResourceThemableDecorations(a.light, b.light);
        }
        else if (a.light) {
            return 1;
        }
        else if (b.light) {
            return -1;
        }
        if (result !== 0) {
            return result;
        }
        if (a.dark && b.dark) {
            result = compareResourceThemableDecorations(a.dark, b.dark);
        }
        else if (a.dark) {
            return 1;
        }
        else if (b.dark) {
            return -1;
        }
        return result;
    }
    function compareCommands(a, b) {
        if (a.command !== b.command) {
            return a.command < b.command ? -1 : 1;
        }
        if (a.title !== b.title) {
            return a.title < b.title ? -1 : 1;
        }
        if (a.tooltip !== b.tooltip) {
            if (a.tooltip !== undefined && b.tooltip !== undefined) {
                return a.tooltip < b.tooltip ? -1 : 1;
            }
            else if (a.tooltip !== undefined) {
                return 1;
            }
            else if (b.tooltip !== undefined) {
                return -1;
            }
        }
        if (a.arguments === b.arguments) {
            return 0;
        }
        else if (!a.arguments) {
            return -1;
        }
        else if (!b.arguments) {
            return 1;
        }
        else if (a.arguments.length !== b.arguments.length) {
            return a.arguments.length - b.arguments.length;
        }
        for (let i = 0; i < a.arguments.length; i++) {
            const aArg = a.arguments[i];
            const bArg = b.arguments[i];
            if (aArg === bArg) {
                continue;
            }
            if (isUri(aArg) && isUri(bArg) && uriEquals(aArg, bArg)) {
                continue;
            }
            return aArg < bArg ? -1 : 1;
        }
        return 0;
    }
    function compareResourceStates(a, b) {
        let result = (0, comparers_1.$Kr)(a.resourceUri.fsPath, b.resourceUri.fsPath, true);
        if (result !== 0) {
            return result;
        }
        if (a.command && b.command) {
            result = compareCommands(a.command, b.command);
        }
        else if (a.command) {
            return 1;
        }
        else if (b.command) {
            return -1;
        }
        if (result !== 0) {
            return result;
        }
        if (a.decorations && b.decorations) {
            result = compareResourceStatesDecorations(a.decorations, b.decorations);
        }
        else if (a.decorations) {
            return 1;
        }
        else if (b.decorations) {
            return -1;
        }
        if (a.multiFileDiffEditorModifiedUri && b.multiFileDiffEditorModifiedUri) {
            result = (0, comparers_1.$Kr)(a.multiFileDiffEditorModifiedUri.fsPath, b.multiFileDiffEditorModifiedUri.fsPath, true);
        }
        else if (a.multiFileDiffEditorModifiedUri) {
            return 1;
        }
        else if (b.multiFileDiffEditorModifiedUri) {
            return -1;
        }
        if (a.multiDiffEditorOriginalUri && b.multiDiffEditorOriginalUri) {
            result = (0, comparers_1.$Kr)(a.multiDiffEditorOriginalUri.fsPath, b.multiDiffEditorOriginalUri.fsPath, true);
        }
        else if (a.multiDiffEditorOriginalUri) {
            return 1;
        }
        else if (b.multiDiffEditorOriginalUri) {
            return -1;
        }
        return result;
    }
    function compareArgs(a, b) {
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    function commandEquals(a, b) {
        return a.command === b.command
            && a.title === b.title
            && a.tooltip === b.tooltip
            && (a.arguments && b.arguments ? compareArgs(a.arguments, b.arguments) : a.arguments === b.arguments);
    }
    function commandListEquals(a, b) {
        return (0, arrays_1.$tb)(a, b, commandEquals);
    }
    class $grc {
        #proxy;
        #extHostDocuments;
        get value() {
            return this.d;
        }
        set value(value) {
            value = value ?? '';
            this.#proxy.$setInputBoxValue(this.m, value);
            this.o(value);
        }
        get onDidChange() {
            return this.e.event;
        }
        get placeholder() {
            return this.f;
        }
        set placeholder(placeholder) {
            this.#proxy.$setInputBoxPlaceholder(this.m, placeholder);
            this.f = placeholder;
        }
        get validateInput() {
            (0, extensions_2.$gH)(this.k, 'scmValidation');
            return this.g;
        }
        set validateInput(fn) {
            (0, extensions_2.$gH)(this.k, 'scmValidation');
            if (fn && typeof fn !== 'function') {
                throw new Error(`[${this.k.identifier.value}]: Invalid SCM input box validation function`);
            }
            this.g = fn;
            this.#proxy.$setValidationProviderIsEnabled(this.m, !!fn);
        }
        get enabled() {
            return this.h;
        }
        set enabled(enabled) {
            enabled = !!enabled;
            if (this.h === enabled) {
                return;
            }
            this.h = enabled;
            this.#proxy.$setInputBoxEnablement(this.m, enabled);
        }
        get visible() {
            return this.j;
        }
        set visible(visible) {
            visible = !!visible;
            if (this.j === visible) {
                return;
            }
            this.j = visible;
            this.#proxy.$setInputBoxVisibility(this.m, visible);
        }
        get document() {
            (0, extensions_2.$gH)(this.k, 'scmTextDocument');
            return this.#extHostDocuments.getDocument(this.n);
        }
        constructor(k, _extHostDocuments, proxy, m, n) {
            this.k = k;
            this.m = m;
            this.n = n;
            this.d = '';
            this.e = new event_1.$le();
            this.f = '';
            this.h = true;
            this.j = true;
            this.#extHostDocuments = _extHostDocuments;
            this.#proxy = proxy;
        }
        showValidationMessage(message, type) {
            (0, extensions_2.$gH)(this.k, 'scmValidation');
            this.#proxy.$showValidationMessage(this.m, message, type);
        }
        $onInputBoxValueChange(value) {
            this.o(value);
        }
        o(value) {
            this.d = value;
            this.e.fire(value);
        }
    }
    exports.$grc = $grc;
    class ExtHostSourceControlResourceGroup {
        static { this.d = 0; }
        get disposed() { return this.m; }
        get id() { return this.v; }
        get label() { return this.w; }
        set label(label) {
            this.w = label;
            this.s.$updateGroupLabel(this.u, this.handle, label);
        }
        get hideWhenEmpty() { return this.q; }
        set hideWhenEmpty(hideWhenEmpty) {
            this.q = hideWhenEmpty;
            this.s.$updateGroup(this.u, this.handle, this.features);
        }
        get features() {
            return {
                hideWhenEmpty: this.hideWhenEmpty
            };
        }
        get resourceStates() { return [...this.f]; }
        set resourceStates(resources) {
            this.f = [...resources];
            this.k.fire();
        }
        constructor(s, t, u, v, w, multiDiffEditorEnableViewChanges, x) {
            this.s = s;
            this.t = t;
            this.u = u;
            this.v = v;
            this.w = w;
            this.multiDiffEditorEnableViewChanges = multiDiffEditorEnableViewChanges;
            this.x = x;
            this.e = 0;
            this.f = [];
            this.g = new Map();
            this.h = new Map();
            this.j = new Map();
            this.k = new event_1.$le();
            this.onDidUpdateResourceStates = this.k.event;
            this.m = false;
            this.n = new event_1.$le();
            this.onDidDispose = this.n.event;
            this.o = [];
            this.p = [];
            this.q = undefined;
            this.handle = ExtHostSourceControlResourceGroup.d++;
        }
        getResourceState(handle) {
            return this.g.get(handle);
        }
        $executeResourceCommand(handle, preserveFocus) {
            const command = this.h.get(handle);
            if (!command) {
                return Promise.resolve(undefined);
            }
            return (0, async_1.$xh)(() => this.t.executeCommand(command.command, ...(command.arguments || []), preserveFocus));
        }
        _takeResourceStateSnapshot() {
            const snapshot = [...this.f].sort(compareResourceStates);
            const diffs = (0, arrays_1.$Cb)(this.p, snapshot, compareResourceStates);
            const splices = diffs.map(diff => {
                const toInsert = diff.toInsert.map(r => {
                    const handle = this.e++;
                    this.g.set(handle, r);
                    const sourceUri = r.resourceUri;
                    let command;
                    if (r.command) {
                        if (r.command.command === 'vscode.open' || r.command.command === 'vscode.diff' || r.command.command === 'vscode.changes') {
                            const disposables = new lifecycle_1.$Tc();
                            command = this.t.converter.toInternal(r.command, disposables);
                            this.j.set(handle, disposables);
                        }
                        else {
                            this.h.set(handle, r.command);
                        }
                    }
                    const hasScmMultiDiffEditorProposalEnabled = (0, extensions_2.$fH)(this.x, 'scmMultiDiffEditor');
                    const multiFileDiffEditorOriginalUri = hasScmMultiDiffEditorProposalEnabled ? r.multiDiffEditorOriginalUri : undefined;
                    const multiFileDiffEditorModifiedUri = hasScmMultiDiffEditorProposalEnabled ? r.multiFileDiffEditorModifiedUri : undefined;
                    const icon = getIconResource(r.decorations);
                    const lightIcon = r.decorations && getIconResource(r.decorations.light) || icon;
                    const darkIcon = r.decorations && getIconResource(r.decorations.dark) || icon;
                    const icons = [lightIcon, darkIcon];
                    const tooltip = (r.decorations && r.decorations.tooltip) || '';
                    const strikeThrough = r.decorations && !!r.decorations.strikeThrough;
                    const faded = r.decorations && !!r.decorations.faded;
                    const contextValue = r.contextValue || '';
                    const rawResource = [handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command, multiFileDiffEditorOriginalUri, multiFileDiffEditorModifiedUri];
                    return { rawResource, handle };
                });
                return { start: diff.start, deleteCount: diff.deleteCount, toInsert };
            });
            const rawResourceSplices = splices
                .map(({ start, deleteCount, toInsert }) => [start, deleteCount, toInsert.map(i => i.rawResource)]);
            const reverseSplices = splices.reverse();
            for (const { start, deleteCount, toInsert } of reverseSplices) {
                const handles = toInsert.map(i => i.handle);
                const handlesToDelete = this.o.splice(start, deleteCount, ...handles);
                for (const handle of handlesToDelete) {
                    this.g.delete(handle);
                    this.h.delete(handle);
                    this.j.get(handle)?.dispose();
                    this.j.delete(handle);
                }
            }
            this.p = snapshot;
            return rawResourceSplices;
        }
        dispose() {
            this.m = true;
            this.n.fire();
        }
    }
    class ExtHostSourceControl {
        static { this.d = 0; }
        #proxy;
        get id() {
            return this.A;
        }
        get label() {
            return this.B;
        }
        get rootUri() {
            return this.C;
        }
        get inputBox() { return this.f; }
        get count() {
            return this.g;
        }
        set count(count) {
            if (this.g === count) {
                return;
            }
            this.g = count;
            this.#proxy.$updateSourceControl(this.x, { count });
        }
        get quickDiffProvider() {
            return this.h;
        }
        set quickDiffProvider(quickDiffProvider) {
            this.h = quickDiffProvider;
            let quickDiffLabel = undefined;
            if ((0, extensions_2.$fH)(this.y, 'quickDiffProvider')) {
                quickDiffLabel = quickDiffProvider?.label;
            }
            this.#proxy.$updateSourceControl(this.x, { hasQuickDiffProvider: !!quickDiffProvider, quickDiffLabel });
        }
        get historyProvider() {
            (0, extensions_2.$gH)(this.y, 'scmHistoryProvider');
            return this.j;
        }
        set historyProvider(historyProvider) {
            (0, extensions_2.$gH)(this.y, 'scmHistoryProvider');
            this.j = historyProvider;
            this.k.value = new lifecycle_1.$Tc();
            this.#proxy.$updateSourceControl(this.x, { hasHistoryProvider: !!historyProvider });
            if (historyProvider) {
                this.k.value.add(historyProvider.onDidChangeCurrentHistoryItemGroup(() => {
                    this.m = historyProvider?.currentHistoryItemGroup;
                    this.#proxy.$onDidChangeHistoryProviderCurrentHistoryItemGroup(this.x, this.m);
                }));
            }
        }
        get commitTemplate() {
            return this.n;
        }
        set commitTemplate(commitTemplate) {
            if (commitTemplate === this.n) {
                return;
            }
            this.n = commitTemplate;
            this.#proxy.$updateSourceControl(this.x, { commitTemplate });
        }
        get acceptInputCommand() {
            return this.p;
        }
        set acceptInputCommand(acceptInputCommand) {
            this.o.value = new lifecycle_1.$Tc();
            this.p = acceptInputCommand;
            const internal = this.z.converter.toInternal(acceptInputCommand, this.o.value);
            this.#proxy.$updateSourceControl(this.x, { acceptInputCommand: internal });
        }
        get actionButton() {
            (0, extensions_2.$gH)(this.y, 'scmActionButton');
            return this.s;
        }
        set actionButton(actionButton) {
            (0, extensions_2.$gH)(this.y, 'scmActionButton');
            this.q.value = new lifecycle_1.$Tc();
            this.s = actionButton;
            const internal = actionButton !== undefined ?
                {
                    command: this.z.converter.toInternal(actionButton.command, this.q.value),
                    secondaryCommands: actionButton.secondaryCommands?.map(commandGroup => {
                        return commandGroup.map(command => this.z.converter.toInternal(command, this.q.value));
                    }),
                    description: actionButton.description,
                    enabled: actionButton.enabled
                } : undefined;
            this.#proxy.$updateSourceControl(this.x, { actionButton: internal ?? null });
        }
        get statusBarCommands() {
            return this.u;
        }
        set statusBarCommands(statusBarCommands) {
            if (this.u && statusBarCommands && commandListEquals(this.u, statusBarCommands)) {
                return;
            }
            this.t.value = new lifecycle_1.$Tc();
            this.u = statusBarCommands;
            const internal = (statusBarCommands || []).map(c => this.z.converter.toInternal(c, this.t.value));
            this.#proxy.$updateSourceControl(this.x, { statusBarCommands: internal });
        }
        get selected() {
            return this.v;
        }
        constructor(y, _extHostDocuments, proxy, z, A, B, C) {
            this.y = y;
            this.z = z;
            this.A = A;
            this.B = B;
            this.C = C;
            this.e = new Map();
            this.g = undefined;
            this.h = undefined;
            this.k = new lifecycle_1.$Vc();
            this.n = undefined;
            this.o = new lifecycle_1.$Vc();
            this.p = undefined;
            this.q = new lifecycle_1.$Vc();
            this.t = new lifecycle_1.$Vc();
            this.u = undefined;
            this.v = false;
            this.w = new event_1.$le();
            this.onDidChangeSelection = this.w.event;
            this.x = ExtHostSourceControl.d++;
            this.D = new Map();
            this.E = new Set();
            this.#proxy = proxy;
            const inputBoxDocumentUri = uri_1.URI.from({
                scheme: network_1.Schemas.vscodeSourceControl,
                path: `${A}/scm${this.x}/input`,
                query: C ? `rootUri=${encodeURIComponent(C.toString())}` : undefined
            });
            this.f = new $grc(y, _extHostDocuments, this.#proxy, this.x, inputBoxDocumentUri);
            this.#proxy.$registerSourceControl(this.x, A, B, C, inputBoxDocumentUri);
        }
        createResourceGroup(id, label, options) {
            const multiDiffEditorEnableViewChanges = (0, extensions_2.$fH)(this.y, 'scmMultiDiffEditor') && options?.multiDiffEditorEnableViewChanges === true;
            const group = new ExtHostSourceControlResourceGroup(this.#proxy, this.z, this.x, id, label, multiDiffEditorEnableViewChanges, this.y);
            const disposable = event_1.Event.once(group.onDidDispose)(() => this.D.delete(group));
            this.D.set(group, disposable);
            this.eventuallyAddResourceGroups();
            return group;
        }
        eventuallyAddResourceGroups() {
            const groups = [];
            const splices = [];
            for (const [group, disposable] of this.D) {
                disposable.dispose();
                const updateListener = group.onDidUpdateResourceStates(() => {
                    this.E.add(group);
                    this.eventuallyUpdateResourceStates();
                });
                event_1.Event.once(group.onDidDispose)(() => {
                    this.E.delete(group);
                    updateListener.dispose();
                    this.e.delete(group.handle);
                    this.#proxy.$unregisterGroup(this.x, group.handle);
                });
                groups.push([group.handle, group.id, group.label, group.features, group.multiDiffEditorEnableViewChanges]);
                const snapshot = group._takeResourceStateSnapshot();
                if (snapshot.length > 0) {
                    splices.push([group.handle, snapshot]);
                }
                this.e.set(group.handle, group);
            }
            this.#proxy.$registerGroups(this.x, groups, splices);
            this.D.clear();
        }
        eventuallyUpdateResourceStates() {
            const splices = [];
            this.E.forEach(group => {
                const snapshot = group._takeResourceStateSnapshot();
                if (snapshot.length === 0) {
                    return;
                }
                splices.push([group.handle, snapshot]);
            });
            if (splices.length > 0) {
                this.#proxy.$spliceResourceStates(this.x, splices);
            }
            this.E.clear();
        }
        getResourceGroup(handle) {
            return this.e.get(handle);
        }
        setSelectionState(selected) {
            this.v = selected;
            this.w.fire(selected);
        }
        dispose() {
            this.o.dispose();
            this.q.dispose();
            this.t.dispose();
            this.e.forEach(group => group.dispose());
            this.#proxy.$unregisterSourceControl(this.x);
        }
    }
    __decorate([
        (0, decorators_1.$$h)(100)
    ], ExtHostSourceControl.prototype, "eventuallyAddResourceGroups", null);
    __decorate([
        (0, decorators_1.$$h)(100)
    ], ExtHostSourceControl.prototype, "eventuallyUpdateResourceStates", null);
    let $hrc = class $hrc {
        static { $hrc_1 = this; }
        static { this.d = 0; }
        get onDidChangeActiveProvider() { return this.j.event; }
        constructor(mainContext, m, n, o) {
            this.m = m;
            this.n = n;
            this.o = o;
            this.g = new Map();
            this.h = new extensions_1.$tn();
            this.j = new event_1.$le();
            this.e = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadSCM);
            this.f = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadTelemetry);
            m.registerArgumentProcessor({
                processArgument: arg => {
                    if (arg && arg.$mid === marshallingIds_1.MarshalledId.ScmResource) {
                        const sourceControl = this.g.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        const group = sourceControl.getResourceGroup(arg.groupHandle);
                        if (!group) {
                            return arg;
                        }
                        return group.getResourceState(arg.handle);
                    }
                    else if (arg && arg.$mid === marshallingIds_1.MarshalledId.ScmResourceGroup) {
                        const sourceControl = this.g.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl.getResourceGroup(arg.groupHandle);
                    }
                    else if (arg && arg.$mid === marshallingIds_1.MarshalledId.ScmProvider) {
                        const sourceControl = this.g.get(arg.handle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl;
                    }
                    return arg;
                }
            });
        }
        createSourceControl(extension, id, label, rootUri) {
            this.o.trace('ExtHostSCM#createSourceControl', extension.identifier.value, id, label, rootUri);
            this.f.$publicLog2('api/scm/createSourceControl', {
                extensionId: extension.identifier.value,
            });
            const handle = $hrc_1.d++;
            const sourceControl = new ExtHostSourceControl(extension, this.n, this.e, this.m, id, label, rootUri);
            this.g.set(handle, sourceControl);
            const sourceControls = this.h.get(extension.identifier) || [];
            sourceControls.push(sourceControl);
            this.h.set(extension.identifier, sourceControls);
            return sourceControl;
        }
        // Deprecated
        getLastInputBox(extension) {
            this.o.trace('ExtHostSCM#getLastInputBox', extension.identifier.value);
            const sourceControls = this.h.get(extension.identifier);
            const sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
            return sourceControl && sourceControl.inputBox;
        }
        $provideOriginalResource(sourceControlHandle, uriComponents, token) {
            const uri = uri_1.URI.revive(uriComponents);
            this.o.trace('ExtHostSCM#$provideOriginalResource', sourceControlHandle, uri.toString());
            const sourceControl = this.g.get(sourceControlHandle);
            if (!sourceControl || !sourceControl.quickDiffProvider || !sourceControl.quickDiffProvider.provideOriginalResource) {
                return Promise.resolve(null);
            }
            return (0, async_1.$xh)(() => sourceControl.quickDiffProvider.provideOriginalResource(uri, token))
                .then(r => r || null);
        }
        $onInputBoxValueChange(sourceControlHandle, value) {
            this.o.trace('ExtHostSCM#$onInputBoxValueChange', sourceControlHandle);
            const sourceControl = this.g.get(sourceControlHandle);
            if (!sourceControl) {
                return Promise.resolve(undefined);
            }
            sourceControl.inputBox.$onInputBoxValueChange(value);
            return Promise.resolve(undefined);
        }
        $executeResourceCommand(sourceControlHandle, groupHandle, handle, preserveFocus) {
            this.o.trace('ExtHostSCM#$executeResourceCommand', sourceControlHandle, groupHandle, handle);
            const sourceControl = this.g.get(sourceControlHandle);
            if (!sourceControl) {
                return Promise.resolve(undefined);
            }
            const group = sourceControl.getResourceGroup(groupHandle);
            if (!group) {
                return Promise.resolve(undefined);
            }
            return group.$executeResourceCommand(handle, preserveFocus);
        }
        $validateInput(sourceControlHandle, value, cursorPosition) {
            this.o.trace('ExtHostSCM#$validateInput', sourceControlHandle);
            const sourceControl = this.g.get(sourceControlHandle);
            if (!sourceControl) {
                return Promise.resolve(undefined);
            }
            if (!sourceControl.inputBox.validateInput) {
                return Promise.resolve(undefined);
            }
            return (0, async_1.$xh)(() => sourceControl.inputBox.validateInput(value, cursorPosition)).then(result => {
                if (!result) {
                    return Promise.resolve(undefined);
                }
                const message = extHostTypeConverters_1.MarkdownString.fromStrict(result.message);
                if (!message) {
                    return Promise.resolve(undefined);
                }
                return Promise.resolve([message, result.type]);
            });
        }
        $setSelectedSourceControl(selectedSourceControlHandle) {
            this.o.trace('ExtHostSCM#$setSelectedSourceControl', selectedSourceControlHandle);
            if (selectedSourceControlHandle !== undefined) {
                this.g.get(selectedSourceControlHandle)?.setSelectionState(true);
            }
            if (this.k !== undefined) {
                this.g.get(this.k)?.setSelectionState(false);
            }
            this.k = selectedSourceControlHandle;
            return Promise.resolve(undefined);
        }
        async $resolveHistoryItemGroupCommonAncestor(sourceControlHandle, historyItemGroupId1, historyItemGroupId2, token) {
            const historyProvider = this.g.get(sourceControlHandle)?.historyProvider;
            return await historyProvider?.resolveHistoryItemGroupCommonAncestor(historyItemGroupId1, historyItemGroupId2, token) ?? undefined;
        }
        async $resolveHistoryItemGroupCommonAncestor2(sourceControlHandle, historyItemGroupIds, token) {
            const historyProvider = this.g.get(sourceControlHandle)?.historyProvider;
            return await historyProvider?.resolveHistoryItemGroupCommonAncestor2(historyItemGroupIds, token) ?? undefined;
        }
        async $provideHistoryItems(sourceControlHandle, historyItemGroupId, options, token) {
            const historyProvider = this.g.get(sourceControlHandle)?.historyProvider;
            const historyItems = await historyProvider?.provideHistoryItems(historyItemGroupId, options, token);
            return historyItems?.map(item => toSCMHistoryItemDto(item)) ?? undefined;
        }
        async $provideHistoryItems2(sourceControlHandle, options, token) {
            const historyProvider = this.g.get(sourceControlHandle)?.historyProvider;
            const historyItems = await historyProvider?.provideHistoryItems2(options, token);
            return historyItems?.map(item => toSCMHistoryItemDto(item)) ?? undefined;
        }
        async $provideHistoryItemSummary(sourceControlHandle, historyItemId, historyItemParentId, token) {
            const historyProvider = this.g.get(sourceControlHandle)?.historyProvider;
            if (typeof historyProvider?.provideHistoryItemSummary !== 'function') {
                return undefined;
            }
            const historyItem = await historyProvider.provideHistoryItemSummary(historyItemId, historyItemParentId, token);
            return historyItem ? toSCMHistoryItemDto(historyItem) : undefined;
        }
        async $provideHistoryItemChanges(sourceControlHandle, historyItemId, historyItemParentId, token) {
            const historyProvider = this.g.get(sourceControlHandle)?.historyProvider;
            return await historyProvider?.provideHistoryItemChanges(historyItemId, historyItemParentId, token) ?? undefined;
        }
    };
    exports.$hrc = $hrc;
    exports.$hrc = $hrc = $hrc_1 = __decorate([
        __param(3, log_1.$ak)
    ], $hrc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[254/*vs/workbench/api/common/extHostShare*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,8/*vs/workbench/api/common/extHostTypeConverters*/,2/*vs/base/common/uri*/]), function (require, exports, extHost_protocol_1, extHostTypeConverters_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$irc = void 0;
    class $irc {
        static { this.a = 0; }
        constructor(mainContext, d) {
            this.d = d;
            this.c = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadShare);
        }
        async $provideShare(handle, shareableItem, token) {
            const provider = this.c.get(handle);
            const result = await provider?.provideShare({ selection: extHostTypeConverters_1.Range.to(shareableItem.selection), resourceUri: uri_1.URI.revive(shareableItem.resourceUri) }, token);
            return result ?? undefined;
        }
        registerShareProvider(selector, provider) {
            const handle = $irc.a++;
            this.c.set(handle, provider);
            this.b.$registerShareProvider(handle, extHostTypeConverters_1.DocumentSelector.from(selector, this.d), provider.id, provider.label, provider.priority);
            return {
                dispose: () => {
                    this.b.$unregisterShareProvider(handle);
                    this.c.delete(handle);
                }
            };
        }
    }
    exports.$irc = $irc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[255/*vs/workbench/api/common/extHostStatusBar*/], __M([1/*require*/,0/*exports*/,7/*vs/workbench/api/common/extHostTypes*/,5/*vs/workbench/api/common/extHost.protocol*/,9/*vs/nls*/,4/*vs/base/common/lifecycle*/,8/*vs/workbench/api/common/extHostTypeConverters*/,14/*vs/base/common/types*/]), function (require, exports, extHostTypes_1, extHost_protocol_1, nls_1, lifecycle_1, extHostTypeConverters_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$lrc = exports.$krc = void 0;
    class $krc {
        static { this.a = 0; }
        static { this.b = new Map([
            ['statusBarItem.errorBackground', new extHostTypes_1.$MO('statusBarItem.errorForeground')],
            ['statusBarItem.warningBackground', new extHostTypes_1.$MO('statusBarItem.warningForeground')]
        ]); }
        #proxy;
        #commands;
        constructor(proxy, commands, staticItems, extension, id, alignment = extHostTypes_1.StatusBarAlignment.Left, priority) {
            this.i = false;
            this.k = '';
            this.q = new lifecycle_1.$Tc();
            this.#proxy = proxy;
            this.#commands = commands;
            if (id && extension) {
                this.c = (0, extHostTypes_1.$oO)(extension.identifier, id);
                // if new item already exists mark it as visible and copy properties
                // this can only happen when an item was contributed by an extension
                const item = staticItems.get(this.c);
                if (item) {
                    alignment = item.alignLeft ? extHostTypes_1.StatusBarAlignment.Left : extHostTypes_1.StatusBarAlignment.Right;
                    priority = item.priority;
                    this.j = true;
                    this.name = item.name;
                    this.text = item.text;
                    this.tooltip = item.tooltip;
                    this.command = item.command;
                    this.accessibilityInformation = item.accessibilityInformation;
                }
            }
            else {
                this.c = String($krc.a++);
            }
            this.e = extension;
            this.f = id;
            this.g = alignment;
            this.h = this.u(priority);
        }
        u(priority) {
            if (!(0, types_1.$ig)(priority)) {
                return undefined; // using this method to catch `NaN` too!
            }
            // Our RPC mechanism use JSON to serialize data which does
            // not support `Infinity` so we need to fill in the number
            // equivalent as close as possible.
            // https://github.com/microsoft/vscode/issues/133317
            if (priority === Number.POSITIVE_INFINITY) {
                return Number.MAX_VALUE;
            }
            if (priority === Number.NEGATIVE_INFINITY) {
                return -Number.MAX_VALUE;
            }
            return priority;
        }
        get id() {
            return this.f ?? this.e.identifier.value;
        }
        get alignment() {
            return this.g;
        }
        get priority() {
            return this.h;
        }
        get text() {
            return this.k;
        }
        get name() {
            return this.m;
        }
        get tooltip() {
            return this.l;
        }
        get color() {
            return this.n;
        }
        get backgroundColor() {
            return this.o;
        }
        get command() {
            return this.r?.fromApi;
        }
        get accessibilityInformation() {
            return this.t;
        }
        set text(text) {
            this.k = text;
            this.v();
        }
        set name(name) {
            this.m = name;
            this.v();
        }
        set tooltip(tooltip) {
            this.l = tooltip;
            this.v();
        }
        set color(color) {
            this.n = color;
            this.v();
        }
        set backgroundColor(color) {
            if (color && !$krc.b.has(color.id)) {
                color = undefined;
            }
            this.o = color;
            this.v();
        }
        set command(command) {
            if (this.r?.fromApi === command) {
                return;
            }
            if (this.p) {
                this.q.add(this.p);
            }
            this.p = new lifecycle_1.$Tc();
            if (typeof command === 'string') {
                this.r = {
                    fromApi: command,
                    internal: this.#commands.toInternal({ title: '', command }, this.p),
                };
            }
            else if (command) {
                this.r = {
                    fromApi: command,
                    internal: this.#commands.toInternal(command, this.p),
                };
            }
            else {
                this.r = undefined;
            }
            this.v();
        }
        set accessibilityInformation(accessibilityInformation) {
            this.t = accessibilityInformation;
            this.v();
        }
        show() {
            this.j = true;
            this.v();
        }
        hide() {
            clearTimeout(this.s);
            this.j = false;
            this.#proxy.$disposeEntry(this.c);
        }
        v() {
            if (this.i || !this.j) {
                return;
            }
            clearTimeout(this.s);
            // Defer the update so that multiple changes to setters dont cause a redraw each
            this.s = setTimeout(() => {
                this.s = undefined;
                // If the id is not set, derive it from the extension identifier,
                // otherwise make sure to prefix it with the extension identifier
                // to get a more unique value across extensions.
                let id;
                if (this.e) {
                    if (this.f) {
                        id = `${this.e.identifier.value}.${this.f}`;
                    }
                    else {
                        id = this.e.identifier.value;
                    }
                }
                else {
                    id = this.f;
                }
                // If the name is not set, derive it from the extension descriptor
                let name;
                if (this.m) {
                    name = this.m;
                }
                else {
                    name = (0, nls_1.localize)(11252, null, this.e.displayName || this.e.name);
                }
                // If a background color is set, the foreground is determined
                let color = this.n;
                if (this.o) {
                    color = $krc.b.get(this.o.id);
                }
                const tooltip = extHostTypeConverters_1.MarkdownString.fromStrict(this.l);
                // Set to status bar
                this.#proxy.$setEntry(this.c, id, this.e?.identifier.value, name, this.k, tooltip, this.r?.internal, color, this.o, this.g === extHostTypes_1.StatusBarAlignment.Left, this.h, this.t);
                // clean-up state commands _after_ updating the UI
                this.q.clear();
            }, 0);
        }
        dispose() {
            this.hide();
            this.i = true;
        }
    }
    exports.$krc = $krc;
    class StatusBarMessage {
        constructor(statusBar) {
            this.b = [];
            this.a = statusBar.createStatusBarEntry(undefined, 'status.extensionMessage', extHostTypes_1.StatusBarAlignment.Left, Number.MIN_VALUE);
            this.a.name = (0, nls_1.localize)(11253, null);
        }
        dispose() {
            this.b.length = 0;
            this.a.dispose();
        }
        setMessage(message) {
            const data = { message }; // use object to not confuse equal strings
            this.b.unshift(data);
            this.c();
            return new extHostTypes_1.$MN(() => {
                const idx = this.b.indexOf(data);
                if (idx >= 0) {
                    this.b.splice(idx, 1);
                    this.c();
                }
            });
        }
        c() {
            if (this.b.length > 0) {
                this.a.text = this.b[0].message;
                this.a.show();
            }
            else {
                this.a.hide();
            }
        }
    }
    class $lrc {
        constructor(mainContext, commands) {
            this.e = new Map();
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadStatusBar);
            this.b = commands;
            this.c = new StatusBarMessage(this);
        }
        $acceptStaticEntries(added) {
            for (const item of added) {
                this.e.set(item.entryId, item);
            }
        }
        createStatusBarEntry(extension, id, alignment, priority) {
            return new $krc(this.a, this.b, this.e, extension, id, alignment, priority);
        }
        setStatusBarMessage(text, timeoutOrThenable) {
            const d = this.c.setMessage(text);
            let handle;
            if (typeof timeoutOrThenable === 'number') {
                handle = setTimeout(() => d.dispose(), timeoutOrThenable);
            }
            else if (typeof timeoutOrThenable !== 'undefined') {
                timeoutOrThenable.then(() => d.dispose(), () => d.dispose());
            }
            return new extHostTypes_1.$MN(() => {
                d.dispose();
                clearTimeout(handle);
            });
        }
    }
    exports.$lrc = $lrc;
});
























define(__m[125/*vs/workbench/api/common/extHostTestItem*/], __M([1/*require*/,0/*exports*/,32/*vs/editor/common/core/range*/,116/*vs/workbench/api/common/extHostTestingPrivateApi*/,54/*vs/workbench/contrib/testing/common/testId*/,81/*vs/workbench/contrib/testing/common/testItemCollection*/,55/*vs/workbench/contrib/testing/common/testTypes*/,8/*vs/workbench/api/common/extHostTypeConverters*/,2/*vs/base/common/uri*/]), function (require, exports, editorRange, extHostTestingPrivateApi_1, testId_1, testItemCollection_1, testTypes_1, Convert, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$zQ = exports.$yQ = exports.$xQ = exports.$wQ = void 0;
    editorRange = __importStar(editorRange);
    Convert = __importStar(Convert);
    const testItemPropAccessor = (api, defaultValue, equals, toUpdate) => {
        let value = defaultValue;
        return {
            enumerable: true,
            configurable: false,
            get() {
                return value;
            },
            set(newValue) {
                if (!equals(value, newValue)) {
                    const oldValue = value;
                    value = newValue;
                    api.listener?.(toUpdate(newValue, oldValue));
                }
            },
        };
    };
    const strictEqualComparator = (a, b) => a === b;
    const propComparators = {
        range: (a, b) => {
            if (a === b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            return a.isEqual(b);
        },
        label: strictEqualComparator,
        description: strictEqualComparator,
        sortText: strictEqualComparator,
        busy: strictEqualComparator,
        error: strictEqualComparator,
        canResolveChildren: strictEqualComparator,
        tags: (a, b) => {
            if (a.length !== b.length) {
                return false;
            }
            if (a.some(t1 => !b.find(t2 => t1.id === t2.id))) {
                return false;
            }
            return true;
        },
    };
    const evSetProps = (fn) => v => ({ op: testItemCollection_1.TestItemEventOp.SetProp, update: fn(v) });
    const makePropDescriptors = (api, label) => ({
        range: (() => {
            let value;
            const updateProps = evSetProps(r => ({ range: editorRange.$Ot.lift(Convert.Range.from(r)) }));
            return {
                enumerable: true,
                configurable: false,
                get() {
                    return value;
                },
                set(newValue) {
                    api.listener?.({ op: testItemCollection_1.TestItemEventOp.DocumentSynced });
                    if (!propComparators.range(value, newValue)) {
                        value = newValue;
                        api.listener?.(updateProps(newValue));
                    }
                },
            };
        })(),
        label: testItemPropAccessor(api, label, propComparators.label, evSetProps(label => ({ label }))),
        description: testItemPropAccessor(api, undefined, propComparators.description, evSetProps(description => ({ description }))),
        sortText: testItemPropAccessor(api, undefined, propComparators.sortText, evSetProps(sortText => ({ sortText }))),
        canResolveChildren: testItemPropAccessor(api, false, propComparators.canResolveChildren, state => ({
            op: testItemCollection_1.TestItemEventOp.UpdateCanResolveChildren,
            state,
        })),
        busy: testItemPropAccessor(api, false, propComparators.busy, evSetProps(busy => ({ busy }))),
        error: testItemPropAccessor(api, undefined, propComparators.error, evSetProps(error => ({ error: Convert.MarkdownString.fromStrict(error) || null }))),
        tags: testItemPropAccessor(api, [], propComparators.tags, (current, previous) => ({
            op: testItemCollection_1.TestItemEventOp.SetTags,
            new: current.map(Convert.TestTag.from),
            old: previous.map(Convert.TestTag.from),
        })),
    });
    const toItemFromPlain = (item) => {
        const testId = testId_1.$7I.fromString(item.extId);
        const testItem = new $xQ(testId.controllerId, testId.localId, item.label, uri_1.URI.revive(item.uri) || undefined);
        testItem.range = Convert.Range.to(item.range || undefined);
        testItem.description = item.description || undefined;
        testItem.sortText = item.sortText || undefined;
        testItem.tags = item.tags.map(t => Convert.TestTag.to({ id: (0, testTypes_1.$aJ)(t).tagId }));
        return testItem;
    };
    const $wQ = (context) => {
        let node;
        for (const test of context.tests) {
            const next = toItemFromPlain(test.item);
            (0, extHostTestingPrivateApi_1.$gQ)(next).parent = node;
            node = next;
        }
        return node;
    };
    exports.$wQ = $wQ;
    class $xQ {
        /**
         * Note that data is deprecated and here for back-compat only
         */
        constructor(controllerId, id, label, uri) {
            if (id.includes(testId_1.TestIdPathParts.Delimiter)) {
                throw new Error(`Test IDs may not include the ${JSON.stringify(id)} symbol`);
            }
            const api = (0, extHostTestingPrivateApi_1.$fQ)(this, controllerId);
            Object.defineProperties(this, {
                id: {
                    value: id,
                    enumerable: true,
                    writable: false,
                },
                uri: {
                    value: uri,
                    enumerable: true,
                    writable: false,
                },
                parent: {
                    enumerable: false,
                    get() {
                        return api.parent instanceof $yQ ? undefined : api.parent;
                    },
                },
                children: {
                    value: (0, testItemCollection_1.$eQ)(api, extHostTestingPrivateApi_1.$gQ, $xQ),
                    enumerable: true,
                    writable: false,
                },
                ...makePropDescriptors(api, label),
            });
        }
    }
    exports.$xQ = $xQ;
    class $yQ extends $xQ {
        constructor(controllerId, label) {
            super(controllerId, controllerId, label, undefined);
            this._isRoot = true;
        }
    }
    exports.$yQ = $yQ;
    class $zQ extends testItemCollection_1.$aQ {
        constructor(controllerId, controllerLabel, editors) {
            super({
                controllerId,
                getDocumentVersion: uri => uri && editors.getDocument(uri)?.version,
                getApiFor: extHostTestingPrivateApi_1.$gQ,
                getChildren: (item) => item.children,
                root: new $yQ(controllerId, controllerLabel),
                toITestItem: Convert.TestItem.from,
            });
        }
    }
    exports.$zQ = $zQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[33/*vs/workbench/api/common/extHostCommands*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/types*/,7/*vs/workbench/api/common/extHostTypes*/,8/*vs/workbench/api/common/extHostTypeConverters*/,25/*vs/base/common/objects*/,5/*vs/workbench/api/common/extHost.protocol*/,17/*vs/base/common/arrays*/,11/*vs/platform/log/common/log*/,36/*vs/base/common/marshalling*/,32/*vs/editor/common/core/range*/,101/*vs/editor/common/core/position*/,2/*vs/base/common/uri*/,4/*vs/base/common/lifecycle*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/,125/*vs/workbench/api/common/extHostTestItem*/,22/*vs/base/common/buffer*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/,42/*vs/base/common/errorMessage*/,69/*vs/base/common/stopwatch*/,63/*vs/platform/telemetry/common/telemetryUtils*/,66/*vs/workbench/api/common/extHostTelemetry*/,38/*vs/base/common/uuid*/]), function (require, exports, types_1, extHostTypes, extHostTypeConverter, objects_1, extHost_protocol_1, arrays_1, log_1, marshalling_1, range_1, position_1, uri_1, lifecycle_1, instantiation_1, extHostRpcService_1, extHostTestItem_1, buffer_1, proxyIdentifier_1, errorMessage_1, stopwatch_1, telemetryUtils_1, extHostTelemetry_1, uuid_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$KQ = exports.$JQ = exports.$IQ = exports.$HQ = exports.$GQ = exports.$FQ = void 0;
    extHostTypes = __importStar(extHostTypes);
    extHostTypeConverter = __importStar(extHostTypeConverter);
    let $FQ = class $FQ {
        #proxy;
        #telemetry;
        #extHostTelemetry;
        constructor(extHostRpc, logService, extHostTelemetry) {
            this.b = new Map();
            this.c = new Map();
            this.#proxy = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadCommands);
            this.d = logService;
            this.#extHostTelemetry = extHostTelemetry;
            this.#telemetry = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadTelemetry);
            this.converter = new $HQ(this, id => {
                // API commands that have no return type (void) can be
                // converted to their internal command and don't need
                // any indirection commands
                const candidate = this.c.get(id);
                return candidate?.result === $JQ.Void
                    ? candidate : undefined;
            }, logService);
            this.f = [
                {
                    processArgument(a) {
                        // URI, Regex
                        return (0, marshalling_1.$ci)(a);
                    }
                },
                {
                    processArgument(arg) {
                        return (0, objects_1.$go)(arg, function (obj) {
                            // Reverse of https://github.com/microsoft/vscode/blob/1f28c5fc681f4c01226460b6d1c7e91b8acb4a5b/src/vs/workbench/api/node/extHostCommands.ts#L112-L127
                            if (range_1.$Ot.isIRange(obj)) {
                                return extHostTypeConverter.Range.to(obj);
                            }
                            if (position_1.$Nt.isIPosition(obj)) {
                                return extHostTypeConverter.Position.to(obj);
                            }
                            if (range_1.$Ot.isIRange(obj.range) && uri_1.URI.isUri(obj.uri)) {
                                return extHostTypeConverter.location.to(obj);
                            }
                            if (obj instanceof buffer_1.$Ne) {
                                return obj.buffer.buffer;
                            }
                            if (!Array.isArray(obj)) {
                                return obj;
                            }
                        });
                    }
                }
            ];
        }
        registerArgumentProcessor(processor) {
            this.f.push(processor);
        }
        registerApiCommand(apiCommand) {
            const registration = this.registerCommand(false, apiCommand.id, async (...apiArgs) => {
                const internalArgs = apiCommand.args.map((arg, i) => {
                    if (!arg.validate(apiArgs[i])) {
                        throw new Error(`Invalid argument '${arg.name}' when running '${apiCommand.id}', received: ${typeof apiArgs[i] === 'object' ? JSON.stringify(apiArgs[i], null, '\t') : apiArgs[i]} `);
                    }
                    return arg.convert(apiArgs[i]);
                });
                const internalResult = await this.executeCommand(apiCommand.internalId, ...internalArgs);
                return apiCommand.result.convert(internalResult, apiArgs, this.converter);
            }, undefined, {
                description: apiCommand.description,
                args: apiCommand.args,
                returns: apiCommand.result.description
            });
            this.c.set(apiCommand.id, apiCommand);
            return new extHostTypes.$MN(() => {
                registration.dispose();
                this.c.delete(apiCommand.id);
            });
        }
        registerCommand(global, id, callback, thisArg, metadata, extension) {
            this.d.trace('ExtHostCommands#registerCommand', id);
            if (!id.trim().length) {
                throw new Error('invalid id');
            }
            if (this.b.has(id)) {
                throw new Error(`command '${id}' already exists`);
            }
            this.b.set(id, { callback, thisArg, metadata, extension });
            if (global) {
                this.#proxy.$registerCommand(id);
            }
            return new extHostTypes.$MN(() => {
                if (this.b.delete(id)) {
                    if (global) {
                        this.#proxy.$unregisterCommand(id);
                    }
                }
            });
        }
        executeCommand(id, ...args) {
            this.d.trace('ExtHostCommands#executeCommand', id);
            return this.g(id, args, true);
        }
        async g(id, args, retry) {
            if (this.b.has(id)) {
                // - We stay inside the extension host and support
                // 	 to pass any kind of parameters around.
                // - We still emit the corresponding activation event
                //   BUT we don't await that event
                this.#proxy.$fireCommandActivationEvent(id);
                return this.h(id, args, false);
            }
            else {
                // automagically convert some argument types
                let hasBuffers = false;
                const toArgs = (0, objects_1.$go)(args, function (value) {
                    if (value instanceof extHostTypes.$NN) {
                        return extHostTypeConverter.Position.from(value);
                    }
                    else if (value instanceof extHostTypes.$ON) {
                        return extHostTypeConverter.Range.from(value);
                    }
                    else if (value instanceof extHostTypes.$1N) {
                        return extHostTypeConverter.location.from(value);
                    }
                    else if (extHostTypes.$eP.isNotebookRange(value)) {
                        return extHostTypeConverter.NotebookRange.from(value);
                    }
                    else if (value instanceof ArrayBuffer) {
                        hasBuffers = true;
                        return buffer_1.$Ne.wrap(new Uint8Array(value));
                    }
                    else if (value instanceof Uint8Array) {
                        hasBuffers = true;
                        return buffer_1.$Ne.wrap(value);
                    }
                    else if (value instanceof buffer_1.$Ne) {
                        hasBuffers = true;
                        return value;
                    }
                    if (!Array.isArray(value)) {
                        return value;
                    }
                });
                try {
                    const result = await this.#proxy.$executeCommand(id, hasBuffers ? new proxyIdentifier_1.$Xw(toArgs) : toArgs, retry);
                    return (0, marshalling_1.$ci)(result);
                }
                catch (e) {
                    // Rerun the command when it wasn't known, had arguments, and when retry
                    // is enabled. We do this because the command might be registered inside
                    // the extension host now and can therefore accept the arguments as-is.
                    if (e instanceof Error && e.message === '$executeCommand:retry') {
                        return this.g(id, args, false);
                    }
                    else {
                        throw e;
                    }
                }
            }
        }
        async h(id, args, annotateError) {
            const command = this.b.get(id);
            if (!command) {
                throw new Error('Unknown command');
            }
            const { callback, thisArg, metadata } = command;
            if (metadata?.args) {
                for (let i = 0; i < metadata.args.length; i++) {
                    try {
                        (0, types_1.$vg)(args[i], metadata.args[i].constraint);
                    }
                    catch (err) {
                        throw new Error(`Running the contributed command: '${id}' failed. Illegal argument '${metadata.args[i].name}' - ${metadata.args[i].description}`);
                    }
                }
            }
            const stopWatch = stopwatch_1.$fe.create();
            try {
                return await callback.apply(thisArg, args);
            }
            catch (err) {
                // The indirection-command from the converter can fail when invoking the actual
                // command and in that case it is better to blame the correct command
                if (id === this.converter.delegatingCommandId) {
                    const actual = this.converter.getActualCommand(...args);
                    if (actual) {
                        id = actual.command;
                    }
                }
                this.d.error(err, id, command.extension?.identifier);
                if (!annotateError) {
                    throw err;
                }
                if (command.extension?.identifier) {
                    const reported = this.#extHostTelemetry.onExtensionError(command.extension.identifier, err);
                    this.d.trace('forwarded error to extension?', reported, command.extension?.identifier);
                }
                throw new class CommandError extends Error {
                    constructor() {
                        super((0, errorMessage_1.$qj)(err));
                        this.id = id;
                        this.source = command.extension?.displayName ?? command.extension?.name;
                    }
                };
            }
            finally {
                this.j(command, id, stopWatch.elapsed());
            }
        }
        j(command, id, duration) {
            if (!command.extension) {
                return;
            }
            this.#telemetry.$publicLog2('Extension:ActionExecuted', {
                extensionId: command.extension.identifier.value,
                id: new telemetryUtils_1.$xp(id),
                duration: duration,
            });
        }
        $executeContributedCommand(id, ...args) {
            this.d.trace('ExtHostCommands#$executeContributedCommand', id);
            const cmdHandler = this.b.get(id);
            if (!cmdHandler) {
                return Promise.reject(new Error(`Contributed command '${id}' does not exist.`));
            }
            else {
                args = args.map(arg => this.f.reduce((r, p) => p.processArgument(r, cmdHandler.extension?.identifier), arg));
                return this.h(id, args, true);
            }
        }
        getCommands(filterUnderscoreCommands = false) {
            this.d.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);
            return this.#proxy.$getCommands().then(result => {
                if (filterUnderscoreCommands) {
                    result = result.filter(command => command[0] !== '_');
                }
                return result;
            });
        }
        $getContributedCommandMetadata() {
            const result = Object.create(null);
            for (const [id, command] of this.b) {
                const { metadata } = command;
                if (metadata) {
                    result[id] = metadata;
                }
            }
            return Promise.resolve(result);
        }
    };
    exports.$FQ = $FQ;
    exports.$FQ = $FQ = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, log_1.$ak),
        __param(2, extHostTelemetry_1.$EQ)
    ], $FQ);
    exports.$GQ = (0, instantiation_1.$Fi)('IExtHostCommands');
    class $HQ {
        // --- conversion between internal and api commands
        constructor(d, f, g) {
            this.d = d;
            this.f = f;
            this.g = g;
            this.delegatingCommandId = `__vsc${(0, uuid_1.$2g)()}`;
            this.b = new Map();
            this.c = 0;
            this.d.registerCommand(true, this.delegatingCommandId, this.h, this);
        }
        toInternal(command, disposables) {
            if (!command) {
                return undefined;
            }
            const result = {
                $ident: undefined,
                id: command.command,
                title: command.title,
                tooltip: command.tooltip
            };
            if (!command.command) {
                // falsy command id -> return converted command but don't attempt any
                // argument or API-command dance since this command won't run anyways
                return result;
            }
            const apiCommand = this.f(command.command);
            if (apiCommand) {
                // API command with return-value can be converted inplace
                result.id = apiCommand.internalId;
                result.arguments = apiCommand.args.map((arg, i) => arg.convert(command.arguments && command.arguments[i]));
            }
            else if ((0, arrays_1.$Kb)(command.arguments)) {
                // we have a contributed command with arguments. that
                // means we don't want to send the arguments around
                const id = `${command.command} /${++this.c}`;
                this.b.set(id, command);
                disposables.add((0, lifecycle_1.$Sc)(() => {
                    this.b.delete(id);
                    this.g.trace('CommandsConverter#DISPOSE', id);
                }));
                result.$ident = id;
                result.id = this.delegatingCommandId;
                result.arguments = [id];
                this.g.trace('CommandsConverter#CREATE', command.command, id);
            }
            return result;
        }
        fromInternal(command) {
            if (typeof command.$ident === 'string') {
                return this.b.get(command.$ident);
            }
            else {
                return {
                    command: command.id,
                    title: command.title,
                    arguments: command.arguments
                };
            }
        }
        getActualCommand(...args) {
            return this.b.get(args[0]);
        }
        h(...args) {
            const actualCmd = this.getActualCommand(...args);
            this.g.trace('CommandsConverter#EXECUTE', args[0], actualCmd ? actualCmd.command : 'MISSING');
            if (!actualCmd) {
                return Promise.reject(`Actual command not found, wanted to execute ${args[0]}`);
            }
            return this.d.executeCommand(actualCmd.command, ...(actualCmd.arguments || []));
        }
    }
    exports.$HQ = $HQ;
    class $IQ {
        static { this.Uri = new $IQ('uri', 'Uri of a text document', v => uri_1.URI.isUri(v), v => v); }
        static { this.Position = new $IQ('position', 'A position in a text document', v => extHostTypes.$NN.isPosition(v), extHostTypeConverter.Position.from); }
        static { this.Range = new $IQ('range', 'A range in a text document', v => extHostTypes.$ON.isRange(v), extHostTypeConverter.Range.from); }
        static { this.Selection = new $IQ('selection', 'A selection in a text document', v => extHostTypes.$PN.isSelection(v), extHostTypeConverter.Selection.from); }
        static { this.Number = new $IQ('number', '', v => typeof v === 'number', v => v); }
        static { this.String = new $IQ('string', '', v => typeof v === 'string', v => v); }
        static { this.StringArray = $IQ.Arr($IQ.String); }
        static Arr(element) {
            return new $IQ(`${element.name}_array`, `Array of ${element.name}, ${element.description}`, (v) => Array.isArray(v) && v.every(e => element.validate(e)), (v) => v.map(e => element.convert(e)));
        }
        static { this.CallHierarchyItem = new $IQ('item', 'A call hierarchy item', v => v instanceof extHostTypes.$aO, extHostTypeConverter.CallHierarchyItem.from); }
        static { this.TypeHierarchyItem = new $IQ('item', 'A type hierarchy item', v => v instanceof extHostTypes.$zP, extHostTypeConverter.TypeHierarchyItem.from); }
        static { this.TestItem = new $IQ('testItem', 'A VS Code TestItem', v => v instanceof extHostTestItem_1.$xQ, extHostTypeConverter.TestItem.from); }
        constructor(name, description, validate, convert) {
            this.name = name;
            this.description = description;
            this.validate = validate;
            this.convert = convert;
        }
        optional() {
            return new $IQ(this.name, `(optional) ${this.description}`, value => value === undefined || value === null || this.validate(value), value => value === undefined ? undefined : value === null ? null : this.convert(value));
        }
        with(name, description) {
            return new $IQ(name ?? this.name, description ?? this.description, this.validate, this.convert);
        }
    }
    exports.$IQ = $IQ;
    class $JQ {
        static { this.Void = new $JQ('no result', v => v); }
        constructor(description, convert) {
            this.description = description;
            this.convert = convert;
        }
    }
    exports.$JQ = $JQ;
    class $KQ {
        constructor(id, internalId, description, args, result) {
            this.id = id;
            this.internalId = internalId;
            this.description = description;
            this.args = args;
            this.result = result;
        }
    }
    exports.$KQ = $KQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[256/*vs/workbench/api/common/extHostApiCommands*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,15/*vs/base/common/network*/,2/*vs/base/common/uri*/,93/*vs/editor/common/languages*/,103/*vs/editor/common/services/semanticTokensDto*/,31/*vs/platform/contextkey/common/contextkey*/,33/*vs/workbench/api/common/extHostCommands*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, arrays_1, network_1, uri_1, languages, semanticTokensDto_1, contextkey_1, extHostCommands_1, typeConverters, types) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Apc = void 0;
    languages = __importStar(languages);
    typeConverters = __importStar(typeConverters);
    types = __importStar(types);
    //#region --- NEW world
    const newCommands = [
        // -- document highlights
        new extHostCommands_1.$KQ('vscode.executeDocumentHighlights', '_executeDocumentHighlights', 'Execute document highlight provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of DocumentHighlight-instances.', tryMapWith(typeConverters.DocumentHighlight.to))),
        // -- document symbols
        new extHostCommands_1.$KQ('vscode.executeDocumentSymbolProvider', '_executeDocumentSymbolProvider', 'Execute document symbol provider.', [extHostCommands_1.$IQ.Uri], new extHostCommands_1.$JQ('A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.', (value, apiArgs) => {
            if ((0, arrays_1.$Jb)(value)) {
                return undefined;
            }
            class MergedInfo extends types.$8N {
                static to(symbol) {
                    const res = new MergedInfo(symbol.name, typeConverters.SymbolKind.to(symbol.kind), symbol.containerName || '', new types.$1N(apiArgs[0], typeConverters.Range.to(symbol.range)));
                    res.detail = symbol.detail;
                    res.range = res.location.range;
                    res.selectionRange = typeConverters.Range.to(symbol.selectionRange);
                    res.children = symbol.children ? symbol.children.map(MergedInfo.to) : [];
                    return res;
                }
            }
            return value.map(MergedInfo.to);
        })),
        // -- formatting
        new extHostCommands_1.$KQ('vscode.executeFormatDocumentProvider', '_executeFormatDocumentProvider', 'Execute document format provider.', [extHostCommands_1.$IQ.Uri, new extHostCommands_1.$IQ('options', 'Formatting options', _ => true, v => v)], new extHostCommands_1.$JQ('A promise that resolves to an array of TextEdits.', tryMapWith(typeConverters.TextEdit.to))),
        new extHostCommands_1.$KQ('vscode.executeFormatRangeProvider', '_executeFormatRangeProvider', 'Execute range format provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Range, new extHostCommands_1.$IQ('options', 'Formatting options', _ => true, v => v)], new extHostCommands_1.$JQ('A promise that resolves to an array of TextEdits.', tryMapWith(typeConverters.TextEdit.to))),
        new extHostCommands_1.$KQ('vscode.executeFormatOnTypeProvider', '_executeFormatOnTypeProvider', 'Execute format on type provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position, new extHostCommands_1.$IQ('ch', 'Trigger character', v => typeof v === 'string', v => v), new extHostCommands_1.$IQ('options', 'Formatting options', _ => true, v => v)], new extHostCommands_1.$JQ('A promise that resolves to an array of TextEdits.', tryMapWith(typeConverters.TextEdit.to))),
        // -- go to symbol (definition, type definition, declaration, impl, references)
        new extHostCommands_1.$KQ('vscode.executeDefinitionProvider', '_executeDefinitionProvider', 'Execute all definition providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.experimental.executeDefinitionProvider_recursive', '_executeDefinitionProvider_recursive', 'Execute all definition providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.executeTypeDefinitionProvider', '_executeTypeDefinitionProvider', 'Execute all type definition providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.experimental.executeTypeDefinitionProvider_recursive', '_executeTypeDefinitionProvider_recursive', 'Execute all type definition providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.executeDeclarationProvider', '_executeDeclarationProvider', 'Execute all declaration providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.experimental.executeDeclarationProvider_recursive', '_executeDeclarationProvider_recursive', 'Execute all declaration providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.executeImplementationProvider', '_executeImplementationProvider', 'Execute all implementation providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.experimental.executeImplementationProvider_recursive', '_executeImplementationProvider_recursive', 'Execute all implementation providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location or LocationLink instances.', mapLocationOrLocationLink)),
        new extHostCommands_1.$KQ('vscode.executeReferenceProvider', '_executeReferenceProvider', 'Execute all reference providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location-instances.', tryMapWith(typeConverters.location.to))),
        new extHostCommands_1.$KQ('vscode.experimental.executeReferenceProvider', '_executeReferenceProvider_recursive', 'Execute all reference providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Location-instances.', tryMapWith(typeConverters.location.to))),
        // -- hover
        new extHostCommands_1.$KQ('vscode.executeHoverProvider', '_executeHoverProvider', 'Execute all hover providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Hover-instances.', tryMapWith(typeConverters.Hover.to))),
        new extHostCommands_1.$KQ('vscode.experimental.executeHoverProvider_recursive', '_executeHoverProvider_recursive', 'Execute all hover providers.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of Hover-instances.', tryMapWith(typeConverters.Hover.to))),
        // -- selection range
        new extHostCommands_1.$KQ('vscode.executeSelectionRangeProvider', '_executeSelectionRangeProvider', 'Execute selection range provider.', [extHostCommands_1.$IQ.Uri, new extHostCommands_1.$IQ('position', 'A position in a text document', v => Array.isArray(v) && v.every(v => types.$NN.isPosition(v)), v => v.map(typeConverters.Position.from))], new extHostCommands_1.$JQ('A promise that resolves to an array of ranges.', result => {
            return result.map(ranges => {
                let node;
                for (const range of ranges.reverse()) {
                    node = new types.$_N(typeConverters.Range.to(range), node);
                }
                return node;
            });
        })),
        // -- symbol search
        new extHostCommands_1.$KQ('vscode.executeWorkspaceSymbolProvider', '_executeWorkspaceSymbolProvider', 'Execute all workspace symbol providers.', [extHostCommands_1.$IQ.String.with('query', 'Search string')], new extHostCommands_1.$JQ('A promise that resolves to an array of SymbolInformation-instances.', value => {
            return value.map(typeConverters.WorkspaceSymbol.to);
        })),
        // --- call hierarchy
        new extHostCommands_1.$KQ('vscode.prepareCallHierarchy', '_executePrepareCallHierarchy', 'Prepare call hierarchy at a position inside a document', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of CallHierarchyItem-instances', v => v.map(typeConverters.CallHierarchyItem.to))),
        new extHostCommands_1.$KQ('vscode.provideIncomingCalls', '_executeProvideIncomingCalls', 'Compute incoming calls for an item', [extHostCommands_1.$IQ.CallHierarchyItem], new extHostCommands_1.$JQ('A promise that resolves to an array of CallHierarchyIncomingCall-instances', v => v.map(typeConverters.CallHierarchyIncomingCall.to))),
        new extHostCommands_1.$KQ('vscode.provideOutgoingCalls', '_executeProvideOutgoingCalls', 'Compute outgoing calls for an item', [extHostCommands_1.$IQ.CallHierarchyItem], new extHostCommands_1.$JQ('A promise that resolves to an array of CallHierarchyOutgoingCall-instances', v => v.map(typeConverters.CallHierarchyOutgoingCall.to))),
        // --- rename
        new extHostCommands_1.$KQ('vscode.prepareRename', '_executePrepareRename', 'Execute the prepareRename of rename provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to a range and placeholder text.', value => {
            if (!value) {
                return undefined;
            }
            return {
                range: typeConverters.Range.to(value.range),
                placeholder: value.text
            };
        })),
        new extHostCommands_1.$KQ('vscode.executeDocumentRenameProvider', '_executeDocumentRenameProvider', 'Execute rename provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position, extHostCommands_1.$IQ.String.with('newName', 'The new symbol name')], new extHostCommands_1.$JQ('A promise that resolves to a WorkspaceEdit.', value => {
            if (!value) {
                return undefined;
            }
            if (value.rejectReason) {
                throw new Error(value.rejectReason);
            }
            return typeConverters.WorkspaceEdit.to(value);
        })),
        // --- links
        new extHostCommands_1.$KQ('vscode.executeLinkProvider', '_executeLinkProvider', 'Execute document link provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Number.with('linkResolveCount', 'Number of links that should be resolved, only when links are unresolved.').optional()], new extHostCommands_1.$JQ('A promise that resolves to an array of DocumentLink-instances.', value => value.map(typeConverters.DocumentLink.to))),
        // --- semantic tokens
        new extHostCommands_1.$KQ('vscode.provideDocumentSemanticTokensLegend', '_provideDocumentSemanticTokensLegend', 'Provide semantic tokens legend for a document', [extHostCommands_1.$IQ.Uri], new extHostCommands_1.$JQ('A promise that resolves to SemanticTokensLegend.', value => {
            if (!value) {
                return undefined;
            }
            return new types.$8O(value.tokenTypes, value.tokenModifiers);
        })),
        new extHostCommands_1.$KQ('vscode.provideDocumentSemanticTokens', '_provideDocumentSemanticTokens', 'Provide semantic tokens for a document', [extHostCommands_1.$IQ.Uri], new extHostCommands_1.$JQ('A promise that resolves to SemanticTokens.', value => {
            if (!value) {
                return undefined;
            }
            const semanticTokensDto = (0, semanticTokensDto_1.$Bdb)(value);
            if (semanticTokensDto.type !== 'full') {
                // only accepting full semantic tokens from provideDocumentSemanticTokens
                return undefined;
            }
            return new types.$0O(semanticTokensDto.data, undefined);
        })),
        new extHostCommands_1.$KQ('vscode.provideDocumentRangeSemanticTokensLegend', '_provideDocumentRangeSemanticTokensLegend', 'Provide semantic tokens legend for a document range', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Range.optional()], new extHostCommands_1.$JQ('A promise that resolves to SemanticTokensLegend.', value => {
            if (!value) {
                return undefined;
            }
            return new types.$8O(value.tokenTypes, value.tokenModifiers);
        })),
        new extHostCommands_1.$KQ('vscode.provideDocumentRangeSemanticTokens', '_provideDocumentRangeSemanticTokens', 'Provide semantic tokens for a document range', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Range], new extHostCommands_1.$JQ('A promise that resolves to SemanticTokens.', value => {
            if (!value) {
                return undefined;
            }
            const semanticTokensDto = (0, semanticTokensDto_1.$Bdb)(value);
            if (semanticTokensDto.type !== 'full') {
                // only accepting full semantic tokens from provideDocumentRangeSemanticTokens
                return undefined;
            }
            return new types.$0O(semanticTokensDto.data, undefined);
        })),
        // --- completions
        new extHostCommands_1.$KQ('vscode.executeCompletionItemProvider', '_executeCompletionItemProvider', 'Execute completion item provider.', [
            extHostCommands_1.$IQ.Uri,
            extHostCommands_1.$IQ.Position,
            extHostCommands_1.$IQ.String.with('triggerCharacter', 'Trigger completion when the user types the character, like `,` or `(`').optional(),
            extHostCommands_1.$IQ.Number.with('itemResolveCount', 'Number of completions to resolve (too large numbers slow down completions)').optional()
        ], new extHostCommands_1.$JQ('A promise that resolves to a CompletionList-instance.', (value, _args, converter) => {
            if (!value) {
                return new types.$lO([]);
            }
            const items = value.suggestions.map(suggestion => typeConverters.CompletionItem.to(suggestion, converter));
            return new types.$lO(items, value.incomplete);
        })),
        // --- signature help
        new extHostCommands_1.$KQ('vscode.executeSignatureHelpProvider', '_executeSignatureHelpProvider', 'Execute signature help provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position, extHostCommands_1.$IQ.String.with('triggerCharacter', 'Trigger signature help when the user types the character, like `,` or `(`').optional()], new extHostCommands_1.$JQ('A promise that resolves to SignatureHelp.', value => {
            if (value) {
                return typeConverters.SignatureHelp.to(value);
            }
            return undefined;
        })),
        // --- code lens
        new extHostCommands_1.$KQ('vscode.executeCodeLensProvider', '_executeCodeLensProvider', 'Execute code lens provider.', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Number.with('itemResolveCount', 'Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)').optional()], new extHostCommands_1.$JQ('A promise that resolves to an array of CodeLens-instances.', (value, _args, converter) => {
            return tryMapWith(item => {
                return new types.$dO(typeConverters.Range.to(item.range), item.command && converter.fromInternal(item.command));
            })(value);
        })),
        // --- code actions
        new extHostCommands_1.$KQ('vscode.executeCodeActionProvider', '_executeCodeActionProvider', 'Execute code action provider.', [
            extHostCommands_1.$IQ.Uri,
            new extHostCommands_1.$IQ('rangeOrSelection', 'Range in a text document. Some refactoring provider requires Selection object.', v => types.$ON.isRange(v), v => types.$PN.isSelection(v) ? typeConverters.Selection.from(v) : typeConverters.Range.from(v)),
            extHostCommands_1.$IQ.String.with('kind', 'Code action kind to return code actions for').optional(),
            extHostCommands_1.$IQ.Number.with('itemResolveCount', 'Number of code actions to resolve (too large numbers slow down code actions)').optional()
        ], new extHostCommands_1.$JQ('A promise that resolves to an array of Command-instances.', (value, _args, converter) => {
            return tryMapWith((codeAction) => {
                if (codeAction._isSynthetic) {
                    if (!codeAction.command) {
                        throw new Error('Synthetic code actions must have a command');
                    }
                    return converter.fromInternal(codeAction.command);
                }
                else {
                    const ret = new types.$0N(codeAction.title, codeAction.kind ? new types.$$N(codeAction.kind) : undefined);
                    if (codeAction.edit) {
                        ret.edit = typeConverters.WorkspaceEdit.to(codeAction.edit);
                    }
                    if (codeAction.command) {
                        ret.command = converter.fromInternal(codeAction.command);
                    }
                    ret.isPreferred = codeAction.isPreferred;
                    return ret;
                }
            })(value);
        })),
        // --- colors
        new extHostCommands_1.$KQ('vscode.executeDocumentColorProvider', '_executeDocumentColorProvider', 'Execute document color provider.', [extHostCommands_1.$IQ.Uri], new extHostCommands_1.$JQ('A promise that resolves to an array of ColorInformation objects.', result => {
            if (result) {
                return result.map(ci => new types.$rO(typeConverters.Range.to(ci.range), typeConverters.Color.to(ci.color)));
            }
            return [];
        })),
        new extHostCommands_1.$KQ('vscode.executeColorPresentationProvider', '_executeColorPresentationProvider', 'Execute color presentation provider.', [
            new extHostCommands_1.$IQ('color', 'The color to show and insert', v => v instanceof types.$qO, typeConverters.Color.from),
            new extHostCommands_1.$IQ('context', 'Context object with uri and range', _v => true, v => ({ uri: v.uri, range: typeConverters.Range.from(v.range) })),
        ], new extHostCommands_1.$JQ('A promise that resolves to an array of ColorPresentation objects.', result => {
            if (result) {
                return result.map(typeConverters.ColorPresentation.to);
            }
            return [];
        })),
        // --- inline hints
        new extHostCommands_1.$KQ('vscode.executeInlayHintProvider', '_executeInlayHintProvider', 'Execute inlay hints provider', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Range], new extHostCommands_1.$JQ('A promise that resolves to an array of Inlay objects', (result, args, converter) => {
            return result.map(typeConverters.InlayHint.to.bind(undefined, converter));
        })),
        // --- folding
        new extHostCommands_1.$KQ('vscode.executeFoldingRangeProvider', '_executeFoldingRangeProvider', 'Execute folding range provider', [extHostCommands_1.$IQ.Uri], new extHostCommands_1.$JQ('A promise that resolves to an array of FoldingRange objects', (result, args) => {
            if (result) {
                return result.map(typeConverters.FoldingRange.to);
            }
            return undefined;
        })),
        // --- notebooks
        new extHostCommands_1.$KQ('vscode.resolveNotebookContentProviders', '_resolveNotebookContentProvider', 'Resolve Notebook Content Providers', [
        // new ApiCommandArgument<string, string>('viewType', '', v => typeof v === 'string', v => v),
        // new ApiCommandArgument<string, string>('displayName', '', v => typeof v === 'string', v => v),
        // new ApiCommandArgument<object, object>('options', '', v => typeof v === 'object', v => v),
        ], new extHostCommands_1.$JQ('A promise that resolves to an array of NotebookContentProvider static info objects.', tryMapWith(item => {
            return {
                viewType: item.viewType,
                displayName: item.displayName,
                options: {
                    transientOutputs: item.options.transientOutputs,
                    transientCellMetadata: item.options.transientCellMetadata,
                    transientDocumentMetadata: item.options.transientDocumentMetadata
                },
                filenamePattern: item.filenamePattern.map(pattern => typeConverters.NotebookExclusiveDocumentPattern.to(pattern))
            };
        }))),
        // --- debug support
        new extHostCommands_1.$KQ('vscode.executeInlineValueProvider', '_executeInlineValueProvider', 'Execute inline value provider', [
            extHostCommands_1.$IQ.Uri,
            extHostCommands_1.$IQ.Range,
            new extHostCommands_1.$IQ('context', 'An InlineValueContext', v => v && typeof v.frameId === 'number' && v.stoppedLocation instanceof types.$ON, v => typeConverters.InlineValueContext.from(v))
        ], new extHostCommands_1.$JQ('A promise that resolves to an array of InlineValue objects', result => {
            return result.map(typeConverters.InlineValue.to);
        })),
        // --- open'ish commands
        new extHostCommands_1.$KQ('vscode.open', '_workbench.open', 'Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.', [
            new extHostCommands_1.$IQ('uriOrString', 'Uri-instance or string (only http/https)', v => uri_1.URI.isUri(v) || (typeof v === 'string' && (0, network_1.$Pg)(v, network_1.Schemas.http, network_1.Schemas.https)), v => v),
            new extHostCommands_1.$IQ('columnOrOptions', 'Either the column in which to open or editor options, see vscode.TextDocumentShowOptions', v => v === undefined || typeof v === 'number' || typeof v === 'object', v => !v ? v : typeof v === 'number' ? [typeConverters.ViewColumn.from(v), undefined] : [typeConverters.ViewColumn.from(v.viewColumn), typeConverters.TextEditorOpenOptions.from(v)]).optional(),
            extHostCommands_1.$IQ.String.with('label', '').optional()
        ], extHostCommands_1.$JQ.Void),
        new extHostCommands_1.$KQ('vscode.openWith', '_workbench.openWith', 'Opens the provided resource with a specific editor.', [
            extHostCommands_1.$IQ.Uri.with('resource', 'Resource to open'),
            extHostCommands_1.$IQ.String.with('viewId', 'Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use \'default\' to use VS Code\'s default text editor'),
            new extHostCommands_1.$IQ('columnOrOptions', 'Either the column in which to open or editor options, see vscode.TextDocumentShowOptions', v => v === undefined || typeof v === 'number' || typeof v === 'object', v => !v ? v : typeof v === 'number' ? [typeConverters.ViewColumn.from(v), undefined] : [typeConverters.ViewColumn.from(v.viewColumn), typeConverters.TextEditorOpenOptions.from(v)]).optional()
        ], extHostCommands_1.$JQ.Void),
        new extHostCommands_1.$KQ('vscode.diff', '_workbench.diff', 'Opens the provided resources in the diff editor to compare their contents.', [
            extHostCommands_1.$IQ.Uri.with('left', 'Left-hand side resource of the diff editor'),
            extHostCommands_1.$IQ.Uri.with('right', 'Right-hand side resource of the diff editor'),
            extHostCommands_1.$IQ.String.with('title', 'Human readable title for the diff editor').optional(),
            new extHostCommands_1.$IQ('columnOrOptions', 'Either the column in which to open or editor options, see vscode.TextDocumentShowOptions', v => v === undefined || typeof v === 'object', v => v && [typeConverters.ViewColumn.from(v.viewColumn), typeConverters.TextEditorOpenOptions.from(v)]).optional(),
        ], extHostCommands_1.$JQ.Void),
        new extHostCommands_1.$KQ('vscode.changes', '_workbench.changes', 'Opens a list of resources in the changes editor to compare their contents.', [
            extHostCommands_1.$IQ.String.with('title', 'Human readable title for the changes editor'),
            new extHostCommands_1.$IQ('resourceList', 'List of resources to compare', resources => {
                for (const resource of resources) {
                    if (resource.length !== 3) {
                        return false;
                    }
                    const [label, left, right] = resource;
                    if (!uri_1.URI.isUri(label) ||
                        (!uri_1.URI.isUri(left) && left !== undefined && left !== null) ||
                        (!uri_1.URI.isUri(right) && right !== undefined && right !== null)) {
                        return false;
                    }
                }
                return true;
            }, v => v)
        ], extHostCommands_1.$JQ.Void),
        // --- type hierarchy
        new extHostCommands_1.$KQ('vscode.prepareTypeHierarchy', '_executePrepareTypeHierarchy', 'Prepare type hierarchy at a position inside a document', [extHostCommands_1.$IQ.Uri, extHostCommands_1.$IQ.Position], new extHostCommands_1.$JQ('A promise that resolves to an array of TypeHierarchyItem-instances', v => v.map(typeConverters.TypeHierarchyItem.to))),
        new extHostCommands_1.$KQ('vscode.provideSupertypes', '_executeProvideSupertypes', 'Compute supertypes for an item', [extHostCommands_1.$IQ.TypeHierarchyItem], new extHostCommands_1.$JQ('A promise that resolves to an array of TypeHierarchyItem-instances', v => v.map(typeConverters.TypeHierarchyItem.to))),
        new extHostCommands_1.$KQ('vscode.provideSubtypes', '_executeProvideSubtypes', 'Compute subtypes for an item', [extHostCommands_1.$IQ.TypeHierarchyItem], new extHostCommands_1.$JQ('A promise that resolves to an array of TypeHierarchyItem-instances', v => v.map(typeConverters.TypeHierarchyItem.to))),
        // --- testing
        new extHostCommands_1.$KQ('vscode.revealTestInExplorer', '_revealTestInExplorer', 'Reveals a test instance in the explorer', [extHostCommands_1.$IQ.TestItem], extHostCommands_1.$JQ.Void),
        // --- continue edit session
        new extHostCommands_1.$KQ('vscode.experimental.editSession.continue', '_workbench.editSessions.actions.continueEditSession', 'Continue the current edit session in a different workspace', [extHostCommands_1.$IQ.Uri.with('workspaceUri', 'The target workspace to continue the current edit session in')], extHostCommands_1.$JQ.Void),
        // --- context keys
        new extHostCommands_1.$KQ('setContext', '_setContext', 'Set a custom context key value that can be used in when clauses.', [
            extHostCommands_1.$IQ.String.with('name', 'The context key name'),
            new extHostCommands_1.$IQ('value', 'The context key value', () => true, v => v),
        ], extHostCommands_1.$JQ.Void),
        // --- mapped edits
        new extHostCommands_1.$KQ('vscode.executeMappedEditsProvider', '_executeMappedEditsProvider', 'Execute Mapped Edits Provider', [
            extHostCommands_1.$IQ.Uri,
            extHostCommands_1.$IQ.StringArray,
            new extHostCommands_1.$IQ('MappedEditsContext', 'Mapped Edits Context', (v) => typeConverters.MappedEditsContext.is(v), (v) => typeConverters.MappedEditsContext.from(v))
        ], new extHostCommands_1.$JQ('A promise that resolves to a workspace edit or null', (value) => {
            return value ? typeConverters.WorkspaceEdit.to(value) : null;
        })),
        // --- inline chat
        new extHostCommands_1.$KQ('vscode.editorChat.start', 'inlineChat.start', 'Invoke a new editor chat session', [new extHostCommands_1.$IQ('Run arguments', '', _v => true, v => {
                if (!v) {
                    return undefined;
                }
                return {
                    initialRange: v.initialRange ? typeConverters.Range.from(v.initialRange) : undefined,
                    initialSelection: types.$PN.isSelection(v.initialSelection) ? typeConverters.Selection.from(v.initialSelection) : undefined,
                    message: v.message,
                    autoSend: v.autoSend,
                    position: v.position ? typeConverters.Position.from(v.position) : undefined,
                };
            })], extHostCommands_1.$JQ.Void)
    ];
    //#endregion
    //#region OLD world
    class $Apc {
        static register(commands) {
            newCommands.forEach(commands.registerApiCommand, commands);
            this.a(commands);
        }
        static a(commands) {
            commands.registerCommand(false, '_validateWhenClauses', contextkey_1.$Ej);
        }
    }
    exports.$Apc = $Apc;
    function tryMapWith(f) {
        return (value) => {
            if (Array.isArray(value)) {
                return value.map(f);
            }
            return undefined;
        };
    }
    function mapLocationOrLocationLink(values) {
        if (!Array.isArray(values)) {
            return undefined;
        }
        const result = [];
        for (const item of values) {
            if (languages.$Lu(item)) {
                result.push(typeConverters.DefinitionLink.to(item));
            }
            else {
                result.push(typeConverters.location.to(item));
            }
        }
        return result;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[257/*vs/workbench/api/common/extHostInteractive*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,33/*vs/workbench/api/common/extHostCommands*/]), function (require, exports, uri_1, extHostCommands_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$2qc = void 0;
    class $2qc {
        constructor(mainContext, a, b, c, _logService) {
            this.a = a;
            this.b = b;
            this.c = c;
            const openApiCommand = new extHostCommands_1.$KQ('interactive.open', '_interactive.open', 'Open interactive window and return notebook editor and input URI', [
                new extHostCommands_1.$IQ('showOptions', 'Show Options', v => true, v => v),
                new extHostCommands_1.$IQ('resource', 'Interactive resource Uri', v => true, v => v),
                new extHostCommands_1.$IQ('controllerId', 'Notebook controller Id', v => true, v => v),
                new extHostCommands_1.$IQ('title', 'Interactive editor title', v => true, v => v)
            ], new extHostCommands_1.$JQ('Notebook and input URI', (v) => {
                _logService.debug('[ExtHostInteractive] open iw with notebook editor id', v.notebookEditorId);
                if (v.notebookEditorId !== undefined) {
                    const editor = this.a.getEditorById(v.notebookEditorId);
                    _logService.debug('[ExtHostInteractive] notebook editor found', editor.id);
                    return { notebookUri: uri_1.URI.revive(v.notebookUri), inputUri: uri_1.URI.revive(v.inputUri), notebookEditor: editor.apiEditor };
                }
                _logService.debug('[ExtHostInteractive] notebook editor not found, uris for the interactive document', v.notebookUri, v.inputUri);
                return { notebookUri: uri_1.URI.revive(v.notebookUri), inputUri: uri_1.URI.revive(v.inputUri) };
            }));
            this.c.registerApiCommand(openApiCommand);
        }
        $willAddInteractiveDocument(uri, eol, languageId, notebookUri) {
            this.b.acceptDocumentsAndEditorsDelta({
                addedDocuments: [{
                        EOL: eol,
                        lines: [''],
                        languageId: languageId,
                        uri: uri,
                        isDirty: false,
                        versionId: 1,
                    }]
            });
        }
        $willRemoveInteractiveDocument(uri, notebookUri) {
            this.b.acceptDocumentsAndEditorsDelta({
                removedDocuments: [uri]
            });
        }
    }
    exports.$2qc = $2qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[258/*vs/workbench/api/common/extHostNotebookKernels*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,28/*vs/base/common/map*/,2/*vs/base/common/uri*/,18/*vs/platform/extensions/common/extensions*/,11/*vs/platform/log/common/log*/,5/*vs/workbench/api/common/extHost.protocol*/,33/*vs/workbench/api/common/extHostCommands*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,82/*vs/workbench/contrib/webview/common/webview*/,197/*vs/workbench/contrib/notebook/common/notebookExecutionService*/,24/*vs/workbench/services/extensions/common/extensions*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/,198/*vs/workbench/contrib/notebook/common/notebookKernelService*/]), function (require, exports, arrays_1, async_1, cancellation_1, event_1, lifecycle_1, map_1, uri_1, extensions_1, log_1, extHost_protocol_1, extHostCommands_1, extHostTypeConverters, extHostTypes_1, webview_1, notebookExecutionService_1, extensions_2, proxyIdentifier_1, notebookKernelService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$0qc = void 0;
    exports.$$qc = $$qc;
    extHostTypeConverters = __importStar(extHostTypeConverters);
    let $0qc = class $0qc {
        constructor(mainContext, m, n, o, q) {
            this.m = m;
            this.n = n;
            this.o = o;
            this.q = q;
            this.b = new map_1.$Ac();
            this.c = new map_1.$Ac();
            this.f = new Map();
            this.g = 0;
            this.h = new Map();
            this.i = 0;
            this.j = new Map();
            this.k = 0;
            this.l = new event_1.$le();
            this.onDidChangeNotebookCellExecutionState = this.l.event;
            this.r = 0;
            this.s = {};
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadNotebookKernels);
            // todo@rebornix @joyceerhl: move to APICommands once stabilized.
            const selectKernelApiCommand = new extHostCommands_1.$KQ('notebook.selectKernel', '_notebook.selectKernel', 'Trigger kernel picker for specified notebook editor widget', [
                new extHostCommands_1.$IQ('options', 'Select kernel options', v => true, (v) => {
                    if (v && 'notebookEditor' in v && 'id' in v) {
                        const notebookEditorId = this.n.getIdByEditor(v.notebookEditor);
                        return {
                            id: v.id, extension: v.extension, notebookEditorId
                        };
                    }
                    else if (v && 'notebookEditor' in v) {
                        const notebookEditorId = this.n.getIdByEditor(v.notebookEditor);
                        if (notebookEditorId === undefined) {
                            throw new Error(`Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${v.notebookEditor.notebook.uri.toString()}`);
                        }
                        return { notebookEditorId };
                    }
                    return v;
                })
            ], extHostCommands_1.$JQ.Void);
            const requestKernelVariablesApiCommand = new extHostCommands_1.$KQ('vscode.executeNotebookVariableProvider', '_executeNotebookVariableProvider', 'Execute notebook variable provider', [extHostCommands_1.$IQ.Uri], new extHostCommands_1.$JQ('A promise that resolves to an array of variables', (value, apiArgs) => {
                return value.map(variable => {
                    return {
                        variable: {
                            name: variable.name,
                            value: variable.value,
                            expression: variable.expression,
                            type: variable.type,
                            language: variable.language
                        },
                        hasNamedChildren: variable.hasNamedChildren,
                        indexedChildrenCount: variable.indexedChildrenCount
                    };
                });
            }));
            this.o.registerApiCommand(selectKernelApiCommand);
            this.o.registerApiCommand(requestKernelVariablesApiCommand);
        }
        createNotebookController(extension, id, viewType, label, handler, preloads) {
            for (const data of this.j.values()) {
                if (data.controller.id === id && extensions_1.$rn.equals(extension.identifier, data.extensionId)) {
                    throw new Error(`notebook controller with id '${id}' ALREADY exist`);
                }
            }
            const handle = this.k++;
            const that = this;
            this.q.trace(`NotebookController[${handle}], CREATED by ${extension.identifier.value}, ${id}`);
            const _defaultExecutHandler = () => console.warn(`NO execute handler from notebook controller '${data.id}' of extension: '${extension.identifier}'`);
            let isDisposed = false;
            const onDidChangeSelection = new event_1.$le();
            const onDidReceiveMessage = new event_1.$le();
            const data = {
                id: $$qc(extension.identifier, id),
                notebookType: viewType,
                extensionId: extension.identifier,
                extensionLocation: extension.extensionLocation,
                label: label || extension.identifier.value,
                preloads: preloads ? preloads.map(extHostTypeConverters.NotebookRendererScript.from) : []
            };
            //
            let _executeHandler = handler ?? _defaultExecutHandler;
            let _interruptHandler;
            let _variableProvider;
            this.a.$addKernel(handle, data).catch(err => {
                // this can happen when a kernel with that ID is already registered
                console.log(err);
                isDisposed = true;
            });
            // update: all setters write directly into the dto object
            // and trigger an update. the actual update will only happen
            // once per event loop execution
            let tokenPool = 0;
            const _update = () => {
                if (isDisposed) {
                    return;
                }
                const myToken = ++tokenPool;
                Promise.resolve().then(() => {
                    if (myToken === tokenPool) {
                        this.a.$updateKernel(handle, data);
                    }
                });
            };
            // notebook documents that are associated to this controller
            const associatedNotebooks = new map_1.$Ac();
            const controller = {
                get id() { return id; },
                get notebookType() { return data.notebookType; },
                onDidChangeSelectedNotebooks: onDidChangeSelection.event,
                get label() {
                    return data.label;
                },
                set label(value) {
                    data.label = value ?? extension.displayName ?? extension.name;
                    _update();
                },
                get detail() {
                    return data.detail ?? '';
                },
                set detail(value) {
                    data.detail = value;
                    _update();
                },
                get description() {
                    return data.description ?? '';
                },
                set description(value) {
                    data.description = value;
                    _update();
                },
                get supportedLanguages() {
                    return data.supportedLanguages;
                },
                set supportedLanguages(value) {
                    data.supportedLanguages = value;
                    _update();
                },
                get supportsExecutionOrder() {
                    return data.supportsExecutionOrder ?? false;
                },
                set supportsExecutionOrder(value) {
                    data.supportsExecutionOrder = value;
                    _update();
                },
                get rendererScripts() {
                    return data.preloads ? data.preloads.map(extHostTypeConverters.NotebookRendererScript.to) : [];
                },
                get executeHandler() {
                    return _executeHandler;
                },
                set executeHandler(value) {
                    _executeHandler = value ?? _defaultExecutHandler;
                },
                get interruptHandler() {
                    return _interruptHandler;
                },
                set interruptHandler(value) {
                    _interruptHandler = value;
                    data.supportsInterrupt = Boolean(value);
                    _update();
                },
                set variableProvider(value) {
                    (0, extensions_2.$gH)(extension, 'notebookVariableProvider');
                    _variableProvider = value;
                    data.hasVariableProvider = !!value;
                    value?.onDidChangeVariables(e => that.a.$variablesUpdated(e.uri));
                    _update();
                },
                get variableProvider() {
                    return _variableProvider;
                },
                createNotebookCellExecution(cell) {
                    if (isDisposed) {
                        throw new Error('notebook controller is DISPOSED');
                    }
                    if (!associatedNotebooks.has(cell.notebook.uri)) {
                        that.q.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map(u => u.toString()));
                        throw new Error(`notebook controller is NOT associated to notebook: ${cell.notebook.uri.toString()}`);
                    }
                    return that._createNotebookCellExecution(cell, $$qc(extension.identifier, this.id));
                },
                createNotebookExecution(notebook) {
                    (0, extensions_2.$gH)(extension, 'notebookExecution');
                    if (isDisposed) {
                        throw new Error('notebook controller is DISPOSED');
                    }
                    if (!associatedNotebooks.has(notebook.uri)) {
                        that.q.trace(`NotebookController[${handle}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(associatedNotebooks.keys()).map(u => u.toString()));
                        throw new Error(`notebook controller is NOT associated to notebook: ${notebook.uri.toString()}`);
                    }
                    return that._createNotebookExecution(notebook, $$qc(extension.identifier, this.id));
                },
                dispose: () => {
                    if (!isDisposed) {
                        this.q.trace(`NotebookController[${handle}], DISPOSED`);
                        isDisposed = true;
                        this.j.delete(handle);
                        onDidChangeSelection.dispose();
                        onDidReceiveMessage.dispose();
                        this.a.$removeKernel(handle);
                    }
                },
                // --- priority
                updateNotebookAffinity(notebook, priority) {
                    if (priority === extHostTypes_1.NotebookControllerAffinity2.Hidden) {
                        // This api only adds an extra enum value, the function is the same, so just gate on the new value being passed
                        // for proposedAPI check.
                        (0, extensions_2.$gH)(extension, 'notebookControllerAffinityHidden');
                    }
                    that.a.$updateNotebookPriority(handle, notebook.uri, priority);
                },
                // --- ipc
                onDidReceiveMessage: onDidReceiveMessage.event,
                postMessage(message, editor) {
                    (0, extensions_2.$gH)(extension, 'notebookMessaging');
                    return that.a.$postMessage(handle, editor && that.n.getIdByEditor(editor), message);
                },
                asWebviewUri(uri) {
                    (0, extensions_2.$gH)(extension, 'notebookMessaging');
                    return (0, webview_1.$EDb)(uri, that.m.remote);
                },
            };
            this.j.set(handle, {
                extensionId: extension.identifier,
                controller,
                onDidReceiveMessage,
                onDidChangeSelection,
                associatedNotebooks
            });
            return controller;
        }
        getIdByController(controller) {
            for (const [_, candidate] of this.j) {
                if (candidate.controller === controller) {
                    return $$qc(candidate.extensionId, controller.id);
                }
            }
            return null;
        }
        createNotebookControllerDetectionTask(extension, viewType) {
            const handle = this.g++;
            const that = this;
            this.q.trace(`NotebookControllerDetectionTask[${handle}], CREATED by ${extension.identifier.value}`);
            this.a.$addKernelDetectionTask(handle, viewType);
            const detectionTask = {
                dispose: () => {
                    this.f.delete(handle);
                    that.a.$removeKernelDetectionTask(handle);
                }
            };
            this.f.set(handle, detectionTask);
            return detectionTask;
        }
        registerKernelSourceActionProvider(extension, viewType, provider) {
            const handle = this.i++;
            const eventHandle = typeof provider.onDidChangeNotebookKernelSourceActions === 'function' ? handle : undefined;
            const that = this;
            this.h.set(handle, provider);
            this.q.trace(`NotebookKernelSourceActionProvider[${handle}], CREATED by ${extension.identifier.value}`);
            this.a.$addKernelSourceActionProvider(handle, handle, viewType);
            let subscription;
            if (eventHandle !== undefined) {
                subscription = provider.onDidChangeNotebookKernelSourceActions(_ => this.a.$emitNotebookKernelSourceActionsChangeEvent(eventHandle));
            }
            return {
                dispose: () => {
                    this.h.delete(handle);
                    that.a.$removeKernelSourceActionProvider(handle, handle);
                    subscription?.dispose();
                }
            };
        }
        async $provideKernelSourceActions(handle, token) {
            const provider = this.h.get(handle);
            if (provider) {
                const disposables = new lifecycle_1.$Tc();
                const ret = await provider.provideNotebookKernelSourceActions(token);
                return (ret ?? []).map(item => extHostTypeConverters.NotebookKernelSourceAction.from(item, this.o.converter, disposables));
            }
            return [];
        }
        $acceptNotebookAssociation(handle, uri, value) {
            const obj = this.j.get(handle);
            if (obj) {
                // update data structure
                const notebook = this.n.getNotebookDocument(uri_1.URI.revive(uri));
                if (value) {
                    obj.associatedNotebooks.set(notebook.uri, true);
                }
                else {
                    obj.associatedNotebooks.delete(notebook.uri);
                }
                this.q.trace(`NotebookController[${handle}] ASSOCIATE notebook`, notebook.uri.toString(), value);
                // send event
                obj.onDidChangeSelection.fire({
                    selected: value,
                    notebook: notebook.apiNotebook
                });
            }
        }
        async $executeCells(handle, uri, handles) {
            const obj = this.j.get(handle);
            if (!obj) {
                // extension can dispose kernels in the meantime
                return;
            }
            const document = this.n.getNotebookDocument(uri_1.URI.revive(uri));
            const cells = [];
            for (const cellHandle of handles) {
                const cell = document.getCell(cellHandle);
                if (cell) {
                    cells.push(cell.apiCell);
                }
            }
            try {
                this.q.trace(`NotebookController[${handle}] EXECUTE cells`, document.uri.toString(), cells.length);
                await obj.controller.executeHandler.call(obj.controller, cells, document.apiNotebook, obj.controller);
            }
            catch (err) {
                //
                this.q.error(`NotebookController[${handle}] execute cells FAILED`, err);
                console.error(err);
            }
        }
        async $cancelCells(handle, uri, handles) {
            const obj = this.j.get(handle);
            if (!obj) {
                // extension can dispose kernels in the meantime
                return;
            }
            // cancel or interrupt depends on the controller. When an interrupt handler is used we
            // don't trigger the cancelation token of executions.
            const document = this.n.getNotebookDocument(uri_1.URI.revive(uri));
            if (obj.controller.interruptHandler) {
                await obj.controller.interruptHandler.call(obj.controller, document.apiNotebook);
            }
            else {
                for (const cellHandle of handles) {
                    const cell = document.getCell(cellHandle);
                    if (cell) {
                        this.b.get(cell.uri)?.cancel();
                    }
                }
            }
            if (obj.controller.interruptHandler) {
                // If we're interrupting all cells, we also need to cancel the notebook level execution.
                const items = this.c.get(document.uri);
                this.c.delete(document.uri);
                if (handles.length && Array.isArray(items) && items.length) {
                    items.forEach(d => d.dispose());
                }
            }
        }
        async $provideVariables(handle, requestId, notebookUri, parentId, kind, start, token) {
            const obj = this.j.get(handle);
            if (!obj) {
                return;
            }
            const document = this.n.getNotebookDocument(uri_1.URI.revive(notebookUri));
            const variableProvider = obj.controller.variableProvider;
            if (!variableProvider) {
                return;
            }
            let parent = undefined;
            if (parentId !== undefined) {
                parent = this.s[parentId];
                if (!parent) {
                    // request for unknown parent
                    return;
                }
            }
            else {
                // root request, clear store
                this.s = {};
            }
            const requestKind = kind === 'named' ? extHostTypes_1.NotebookVariablesRequestKind.Named : extHostTypes_1.NotebookVariablesRequestKind.Indexed;
            const variableResults = variableProvider.provideVariables(document.apiNotebook, parent, requestKind, start, token);
            let resultCount = 0;
            for await (const result of variableResults) {
                if (token.isCancellationRequested) {
                    return;
                }
                const variable = {
                    id: this.r++,
                    name: result.variable.name,
                    value: result.variable.value,
                    type: result.variable.type,
                    interfaces: result.variable.interfaces,
                    language: result.variable.language,
                    expression: result.variable.expression,
                    hasNamedChildren: result.hasNamedChildren,
                    indexedChildrenCount: result.indexedChildrenCount,
                    extensionId: obj.extensionId.value,
                };
                this.s[variable.id] = result.variable;
                this.a.$receiveVariable(requestId, variable);
                if (resultCount++ >= notebookKernelService_1.$ZK) {
                    return;
                }
            }
        }
        $acceptKernelMessageFromRenderer(handle, editorId, message) {
            const obj = this.j.get(handle);
            if (!obj) {
                // extension can dispose kernels in the meantime
                return;
            }
            const editor = this.n.getEditorById(editorId);
            obj.onDidReceiveMessage.fire(Object.freeze({ editor: editor.apiEditor, message }));
        }
        $cellExecutionChanged(uri, cellHandle, state) {
            const document = this.n.getNotebookDocument(uri_1.URI.revive(uri));
            const cell = document.getCell(cellHandle);
            if (cell) {
                const newState = state ? extHostTypeConverters.NotebookCellExecutionState.to(state) : extHostTypes_1.NotebookCellExecutionState.Idle;
                if (newState !== undefined) {
                    this.l.fire({
                        cell: cell.apiCell,
                        state: newState
                    });
                }
            }
        }
        // ---
        _createNotebookCellExecution(cell, controllerId) {
            if (cell.index < 0) {
                throw new Error('CANNOT execute cell that has been REMOVED from notebook');
            }
            const notebook = this.n.getNotebookDocument(cell.notebook.uri);
            const cellObj = notebook.getCellFromApiCell(cell);
            if (!cellObj) {
                throw new Error('invalid cell');
            }
            if (this.b.has(cellObj.uri)) {
                throw new Error(`duplicate execution for ${cellObj.uri}`);
            }
            const execution = new NotebookCellExecutionTask(controllerId, cellObj, this.a);
            this.b.set(cellObj.uri, execution);
            const listener = execution.onDidChangeState(() => {
                if (execution.state === NotebookCellExecutionTaskState.Resolved) {
                    execution.dispose();
                    listener.dispose();
                    this.b.delete(cellObj.uri);
                }
            });
            return execution.asApiObject();
        }
        // ---
        _createNotebookExecution(nb, controllerId) {
            const notebook = this.n.getNotebookDocument(nb.uri);
            const runningCell = nb.getCells().find(cell => {
                const apiCell = notebook.getCellFromApiCell(cell);
                return apiCell && this.b.has(apiCell.uri);
            });
            if (runningCell) {
                throw new Error(`duplicate cell execution for ${runningCell.document.uri}`);
            }
            if (this.c.has(notebook.uri)) {
                throw new Error(`duplicate notebook execution for ${notebook.uri}`);
            }
            const execution = new NotebookExecutionTask(controllerId, notebook, this.a);
            const listener = execution.onDidChangeState(() => {
                if (execution.state === NotebookExecutionTaskState.Resolved) {
                    execution.dispose();
                    listener.dispose();
                    this.c.delete(notebook.uri);
                }
            });
            this.c.set(notebook.uri, [execution, listener]);
            return execution.asApiObject();
        }
    };
    exports.$0qc = $0qc;
    exports.$0qc = $0qc = __decorate([
        __param(4, log_1.$ak)
    ], $0qc);
    var NotebookCellExecutionTaskState;
    (function (NotebookCellExecutionTaskState) {
        NotebookCellExecutionTaskState[NotebookCellExecutionTaskState["Init"] = 0] = "Init";
        NotebookCellExecutionTaskState[NotebookCellExecutionTaskState["Started"] = 1] = "Started";
        NotebookCellExecutionTaskState[NotebookCellExecutionTaskState["Resolved"] = 2] = "Resolved";
    })(NotebookCellExecutionTaskState || (NotebookCellExecutionTaskState = {}));
    class NotebookCellExecutionTask extends lifecycle_1.$Uc {
        static { this.a = 0; }
        get state() { return this.f; }
        constructor(controllerId, m, n) {
            super();
            this.m = m;
            this.n = n;
            this.b = NotebookCellExecutionTask.a++;
            this.c = new event_1.$le();
            this.onDidChangeState = this.c.event;
            this.f = NotebookCellExecutionTaskState.Init;
            this.g = this.B(new cancellation_1.$we());
            this.h = new TimeoutBasedCollector(10, updates => this.s(updates));
            this.j = m.internalMetadata.executionOrder;
            this.n.$createExecution(this.b, controllerId, this.m.notebook.uri, this.m.handle);
        }
        cancel() {
            this.g.cancel();
        }
        async r(update) {
            await this.h.addItem(update);
        }
        async s(update) {
            const updates = Array.isArray(update) ? update : [update];
            return this.n.$updateExecution(this.b, new proxyIdentifier_1.$Xw(updates));
        }
        t() {
            if (this.f === NotebookCellExecutionTaskState.Init) {
                throw new Error('Must call start before modifying cell output');
            }
            if (this.f === NotebookCellExecutionTaskState.Resolved) {
                throw new Error('Cannot modify cell output after calling resolve');
            }
        }
        w(cellOrCellIndex) {
            let cell = this.m;
            if (cellOrCellIndex) {
                cell = this.m.notebook.getCellFromApiCell(cellOrCellIndex);
            }
            if (!cell) {
                throw new Error('INVALID cell');
            }
            return cell.handle;
        }
        y(items) {
            return items.map(output => {
                const newOutput = extHostTypes_1.$iP.ensureUniqueMimeTypes(output.items, true);
                if (newOutput === output.items) {
                    return extHostTypeConverters.NotebookCellOutput.from(output);
                }
                return extHostTypeConverters.NotebookCellOutput.from({
                    items: newOutput,
                    id: output.id,
                    metadata: output.metadata
                });
            });
        }
        async z(outputs, cell, append) {
            const handle = this.w(cell);
            const outputDtos = this.y((0, arrays_1.$1b)(outputs));
            return this.r({
                editType: notebookExecutionService_1.CellExecutionUpdateType.Output,
                cellHandle: handle,
                append,
                outputs: outputDtos
            });
        }
        async C(items, output, append) {
            items = extHostTypes_1.$iP.ensureUniqueMimeTypes((0, arrays_1.$1b)(items), true);
            return this.r({
                editType: notebookExecutionService_1.CellExecutionUpdateType.OutputItems,
                items: items.map(extHostTypeConverters.NotebookCellOutputItem.from),
                outputId: output.id,
                append
            });
        }
        asApiObject() {
            const that = this;
            const result = {
                get token() { return that.g.token; },
                get cell() { return that.m.apiCell; },
                get executionOrder() { return that.j; },
                set executionOrder(v) {
                    that.j = v;
                    that.s([{
                            editType: notebookExecutionService_1.CellExecutionUpdateType.ExecutionState,
                            executionOrder: that.j
                        }]);
                },
                start(startTime) {
                    if (that.f === NotebookCellExecutionTaskState.Resolved || that.f === NotebookCellExecutionTaskState.Started) {
                        throw new Error('Cannot call start again');
                    }
                    that.f = NotebookCellExecutionTaskState.Started;
                    that.c.fire();
                    that.s({
                        editType: notebookExecutionService_1.CellExecutionUpdateType.ExecutionState,
                        runStartTime: startTime
                    });
                },
                end(success, endTime, executionError) {
                    if (that.f === NotebookCellExecutionTaskState.Resolved) {
                        throw new Error('Cannot call resolve twice');
                    }
                    that.f = NotebookCellExecutionTaskState.Resolved;
                    that.c.fire();
                    // The last update needs to be ordered correctly and applied immediately,
                    // so we use updateSoon and immediately flush.
                    that.h.flush();
                    const error = executionError ? {
                        message: executionError.message,
                        stack: executionError.stack,
                        location: executionError?.location ? {
                            startLineNumber: executionError.location.start.line,
                            startColumn: executionError.location.start.character,
                            endLineNumber: executionError.location.end.line,
                            endColumn: executionError.location.end.character
                        } : undefined,
                        uri: executionError.uri
                    } : undefined;
                    that.n.$completeExecution(that.b, new proxyIdentifier_1.$Xw({
                        runEndTime: endTime,
                        lastRunSuccess: success,
                        error
                    }));
                },
                clearOutput(cell) {
                    that.t();
                    return that.z([], cell, false);
                },
                appendOutput(outputs, cell) {
                    that.t();
                    return that.z(outputs, cell, true);
                },
                replaceOutput(outputs, cell) {
                    that.t();
                    return that.z(outputs, cell, false);
                },
                appendOutputItems(items, output) {
                    that.t();
                    return that.C(items, output, true);
                },
                replaceOutputItems(items, output) {
                    that.t();
                    return that.C(items, output, false);
                }
            };
            return Object.freeze(result);
        }
    }
    var NotebookExecutionTaskState;
    (function (NotebookExecutionTaskState) {
        NotebookExecutionTaskState[NotebookExecutionTaskState["Init"] = 0] = "Init";
        NotebookExecutionTaskState[NotebookExecutionTaskState["Started"] = 1] = "Started";
        NotebookExecutionTaskState[NotebookExecutionTaskState["Resolved"] = 2] = "Resolved";
    })(NotebookExecutionTaskState || (NotebookExecutionTaskState = {}));
    class NotebookExecutionTask extends lifecycle_1.$Uc {
        static { this.a = 0; }
        get state() { return this.f; }
        constructor(controllerId, h, j) {
            super();
            this.h = h;
            this.j = j;
            this.b = NotebookExecutionTask.a++;
            this.c = new event_1.$le();
            this.onDidChangeState = this.c.event;
            this.f = NotebookExecutionTaskState.Init;
            this.g = this.B(new cancellation_1.$we());
            this.j.$createNotebookExecution(this.b, controllerId, this.h.uri);
        }
        cancel() {
            this.g.cancel();
        }
        asApiObject() {
            const result = {
                start: () => {
                    if (this.f === NotebookExecutionTaskState.Resolved || this.f === NotebookExecutionTaskState.Started) {
                        throw new Error('Cannot call start again');
                    }
                    this.f = NotebookExecutionTaskState.Started;
                    this.c.fire();
                    this.j.$beginNotebookExecution(this.b);
                },
                end: () => {
                    if (this.f === NotebookExecutionTaskState.Resolved) {
                        throw new Error('Cannot call resolve twice');
                    }
                    this.f = NotebookExecutionTaskState.Resolved;
                    this.c.fire();
                    this.j.$completeNotebookExecution(this.b);
                },
            };
            return Object.freeze(result);
        }
    }
    class TimeoutBasedCollector {
        constructor(f, g) {
            this.f = f;
            this.g = g;
            this.a = [];
            this.b = Date.now();
        }
        addItem(item) {
            this.a.push(item);
            if (!this.c) {
                this.c = new async_1.$3h();
                this.b = Date.now();
                (0, async_1.$Gh)(this.f).then(() => {
                    return this.flush();
                });
            }
            // This can be called by the extension repeatedly for a long time before the timeout is able to run.
            // Force a flush after the delay.
            if (Date.now() - this.b > this.f) {
                return this.flush();
            }
            return this.c.p;
        }
        flush() {
            if (this.a.length === 0 || !this.c) {
                return Promise.resolve();
            }
            const deferred = this.c;
            this.c = undefined;
            const batch = this.a;
            this.a = [];
            return this.g(batch)
                .finally(() => deferred.complete());
        }
    }
    function $$qc(extensionIdentifier, id) {
        return `${extensionIdentifier.value}/${id}`;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[56/*vs/workbench/api/common/extHostTerminalService*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,5/*vs/workbench/api/common/extHost.protocol*/,3/*vs/platform/instantiation/common/instantiation*/,2/*vs/base/common/uri*/,16/*vs/workbench/api/common/extHostRpcService*/,4/*vs/base/common/lifecycle*/,7/*vs/workbench/api/common/extHostTypes*/,9/*vs/nls*/,13/*vs/base/common/errors*/,179/*vs/platform/terminal/common/environmentVariableShared*/,21/*vs/base/common/cancellation*/,38/*vs/base/common/uuid*/,180/*vs/platform/terminal/common/terminal*/,181/*vs/platform/terminal/common/terminalDataBuffering*/,34/*vs/base/common/themables*/,10/*vs/base/common/async*/,8/*vs/workbench/api/common/extHostTypeConverters*/,33/*vs/workbench/api/common/extHostCommands*/,37/*vs/base/common/marshallingIds*/]), function (require, exports, event_1, extHost_protocol_1, instantiation_1, uri_1, extHostRpcService_1, lifecycle_1, extHostTypes_1, nls_1, errors_1, environmentVariableShared_1, cancellation_1, uuid_1, terminal_1, terminalDataBuffering_1, themables_1, async_1, extHostTypeConverters_1, extHostCommands_1, marshallingIds_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$fqc = exports.$eqc = exports.$dqc = exports.$cqc = void 0;
    exports.$cqc = (0, instantiation_1.$Fi)('IExtHostTerminalService');
    class $dqc extends lifecycle_1.$Uc {
        constructor(u, _id, w, y) {
            super();
            this.u = u;
            this._id = _id;
            this.w = w;
            this.y = y;
            this.a = false;
            this.m = { isInteractedWith: false };
            this.isOpen = false;
            this.s = this.B(new event_1.$le());
            this.onWillDispose = this.s.event;
            this.w = Object.freeze(this.w);
            this.b = new Promise(c => this.g = c);
            const that = this;
            this.value = {
                get name() {
                    return that.y || '';
                },
                get processId() {
                    return that.b;
                },
                get creationOptions() {
                    return that.w;
                },
                get exitStatus() {
                    return that.j;
                },
                get state() {
                    return that.m;
                },
                get selection() {
                    return that.n;
                },
                get shellIntegration() {
                    return that.shellIntegration;
                },
                sendText(text, shouldExecute = true) {
                    that.C();
                    that.u.$sendText(that._id, text, shouldExecute);
                },
                show(preserveFocus) {
                    that.C();
                    that.u.$show(that._id, preserveFocus);
                },
                hide() {
                    that.C();
                    that.u.$hide(that._id);
                },
                dispose() {
                    if (!that.a) {
                        that.a = true;
                        that.u.$dispose(that._id);
                    }
                },
                get dimensions() {
                    if (that.f === undefined || that.h === undefined) {
                        return undefined;
                    }
                    return {
                        columns: that.f,
                        rows: that.h
                    };
                }
            };
        }
        dispose() {
            this.s.fire();
            super.dispose();
        }
        async create(options, internalOptions) {
            if (typeof this._id !== 'string') {
                throw new Error('Terminal has already been created');
            }
            await this.u.$createTerminal(this._id, {
                name: options.name,
                shellPath: options.shellPath ?? undefined,
                shellArgs: options.shellArgs ?? undefined,
                cwd: options.cwd ?? internalOptions?.cwd ?? undefined,
                env: options.env ?? undefined,
                icon: asTerminalIcon(options.iconPath) ?? undefined,
                color: themables_1.ThemeColor.isThemeColor(options.color) ? options.color.id : undefined,
                initialText: options.message ?? undefined,
                strictEnv: options.strictEnv ?? undefined,
                hideFromUser: options.hideFromUser ?? undefined,
                forceShellIntegration: internalOptions?.forceShellIntegration ?? undefined,
                isFeatureTerminal: internalOptions?.isFeatureTerminal ?? undefined,
                isExtensionOwnedTerminal: true,
                useShellEnvironment: internalOptions?.useShellEnvironment ?? undefined,
                location: internalOptions?.location || this.z(options.location, internalOptions?.resolvedExtHostIdentifier),
                isTransient: options.isTransient ?? undefined,
            });
        }
        async createExtensionTerminal(location, internalOptions, parentTerminal, iconPath, color) {
            if (typeof this._id !== 'string') {
                throw new Error('Terminal has already been created');
            }
            await this.u.$createTerminal(this._id, {
                name: this.y,
                isExtensionCustomPtyTerminal: true,
                icon: iconPath,
                color: themables_1.ThemeColor.isThemeColor(color) ? color.id : undefined,
                location: internalOptions?.location || this.z(location, parentTerminal),
                isTransient: true
            });
            // At this point, the id has been set via `$acceptTerminalOpened`
            if (typeof this._id === 'string') {
                throw new Error('Terminal creation failed');
            }
            return this._id;
        }
        z(location, parentTerminal) {
            if (typeof location === 'object') {
                if ('parentTerminal' in location && location.parentTerminal && parentTerminal) {
                    return { parentTerminal };
                }
                if ('viewColumn' in location) {
                    return { viewColumn: extHostTypeConverters_1.ViewColumn.from(location.viewColumn), preserveFocus: location.preserveFocus };
                }
                return undefined;
            }
            return location;
        }
        C() {
            if (this.a) {
                throw new Error('Terminal has already been disposed');
            }
        }
        set name(name) {
            this.y = name;
        }
        setExitStatus(code, reason) {
            this.j = Object.freeze({ code, reason });
        }
        setDimensions(cols, rows) {
            if (cols === this.f && rows === this.h) {
                // Nothing changed
                return false;
            }
            if (cols === 0 || rows === 0) {
                return false;
            }
            this.f = cols;
            this.h = rows;
            return true;
        }
        setInteractedWith() {
            if (!this.m.isInteractedWith) {
                this.m = { isInteractedWith: true };
                return true;
            }
            return false;
        }
        setSelection(selection) {
            this.n = selection;
        }
        _setProcessId(processId) {
            // The event may fire 2 times when the panel is restored
            if (this.g) {
                this.g(processId);
                this.g = undefined;
            }
            else {
                // Recreate the promise if this is the nth processId set (e.g. reused task terminals)
                this.b.then(pid => {
                    if (pid !== processId) {
                        this.b = Promise.resolve(processId);
                    }
                });
            }
        }
    }
    exports.$dqc = $dqc;
    class ExtHostPseudoterminal {
        get onProcessReady() { return this.b.event; }
        constructor(g) {
            this.g = g;
            this.id = 0;
            this.shouldPersist = false;
            this.a = new event_1.$le();
            this.onProcessData = this.a.event;
            this.b = new event_1.$le();
            this.d = new event_1.$le();
            this.onDidChangeProperty = this.d.event;
            this.f = new event_1.$le();
            this.onProcessExit = this.f.event;
        }
        refreshProperty(property) {
            throw new Error(`refreshProperty is not suppported in extension owned terminals. property: ${property}`);
        }
        updateProperty(property, value) {
            throw new Error(`updateProperty is not suppported in extension owned terminals. property: ${property}, value: ${value}`);
        }
        async start() {
            return undefined;
        }
        shutdown() {
            this.g.close();
        }
        input(data) {
            this.g.handleInput?.(data);
        }
        resize(cols, rows) {
            this.g.setDimensions?.({ columns: cols, rows });
        }
        clearBuffer() {
            // no-op
        }
        async processBinary(data) {
            // No-op, processBinary is not supported in extension owned terminals.
        }
        acknowledgeDataEvent(charCount) {
            // No-op, flow control is not supported in extension owned terminals. If this is ever
            // implemented it will need new pause and resume VS Code APIs.
        }
        async setUnicodeVersion(version) {
            // No-op, xterm-headless isn't used for extension owned terminals.
        }
        getInitialCwd() {
            return Promise.resolve('');
        }
        getCwd() {
            return Promise.resolve('');
        }
        startSendingEvents(initialDimensions) {
            // Attach the listeners
            this.g.onDidWrite(e => this.a.fire(e));
            this.g.onDidClose?.((e = undefined) => {
                this.f.fire(e === void 0 ? undefined : e);
            });
            this.g.onDidOverrideDimensions?.(e => {
                if (e) {
                    this.d.fire({ type: terminal_1.ProcessPropertyType.OverrideDimensions, value: { cols: e.columns, rows: e.rows } });
                }
            });
            this.g.onDidChangeName?.(title => {
                this.d.fire({ type: terminal_1.ProcessPropertyType.Title, value: title });
            });
            this.g.open(initialDimensions ? initialDimensions : undefined);
            if (initialDimensions) {
                this.g.setDimensions?.(initialDimensions);
            }
            this.b.fire({ pid: -1, cwd: '', windowsPty: undefined });
        }
    }
    let nextLinkId = 1;
    let $eqc = class $eqc extends lifecycle_1.$Uc {
        get activeTerminal() { return this.b?.value; }
        get terminals() { return this.f.map(term => term.value); }
        constructor(supportsProcesses, Q, extHostRpc) {
            super();
            this.Q = Q;
            this.f = [];
            this.g = new Map();
            this.h = {};
            this.j = {};
            this.m = {};
            this.n = new Map();
            this.w = this.B(new lifecycle_1.$Vc());
            this.z = new Set();
            this.C = new Map();
            this.D = new Map();
            this.F = new Map();
            this.G = new Map();
            this.H = new event_1.$le();
            this.onDidCloseTerminal = this.H.event;
            this.I = new event_1.$le();
            this.onDidOpenTerminal = this.I.event;
            this.J = new event_1.$le();
            this.onDidChangeActiveTerminal = this.J.event;
            this.L = new event_1.$le();
            this.onDidChangeTerminalDimensions = this.L.event;
            this.M = new event_1.$le();
            this.onDidChangeTerminalState = this.M.event;
            this.N = new event_1.$le();
            this.onDidChangeShell = this.N.event;
            this.O = new event_1.$le({
                onWillAddFirstListener: () => this.a.$startSendingDataEvents(),
                onDidRemoveLastListener: () => this.a.$stopSendingDataEvents()
            });
            this.onDidWriteTerminalData = this.O.event;
            this.P = new event_1.$le({
                onWillAddFirstListener: () => this.a.$startSendingCommandEvents(),
                onDidRemoveLastListener: () => this.a.$stopSendingCommandEvents()
            });
            this.onDidExecuteTerminalCommand = this.P.event;
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadTerminalService);
            this.y = new terminalDataBuffering_1.$Uxb(this.a.$sendProcessData);
            this.a.$registerProcessSupport(supportsProcesses);
            this.Q.registerArgumentProcessor({
                processArgument: arg => {
                    const deserialize = (arg) => {
                        const cast = arg;
                        return this.getTerminalById(cast.instanceId)?.value;
                    };
                    switch (arg?.$mid) {
                        case marshallingIds_1.MarshalledId.TerminalContext: return deserialize(arg);
                        default: {
                            // Do array transformation in place as this is a hot path
                            if (Array.isArray(arg)) {
                                for (let i = 0; i < arg.length; i++) {
                                    if (arg[i].$mid === marshallingIds_1.MarshalledId.TerminalContext) {
                                        arg[i] = deserialize(arg[i]);
                                    }
                                    else {
                                        // Probably something else, so exit early
                                        break;
                                    }
                                }
                            }
                            return arg;
                        }
                    }
                }
            });
            this.B({
                dispose: () => {
                    for (const [_, terminalProcess] of this.g) {
                        terminalProcess.shutdown(true);
                    }
                }
            });
        }
        getDefaultShell(useAutomationShell) {
            const profile = useAutomationShell ? this.u : this.s;
            return profile?.path || '';
        }
        getDefaultShellArgs(useAutomationShell) {
            const profile = useAutomationShell ? this.u : this.s;
            return profile?.args || [];
        }
        createExtensionTerminal(options, internalOptions) {
            const terminal = new $dqc(this.a, (0, uuid_1.$2g)(), options, options.name);
            const p = new ExtHostPseudoterminal(options.pty);
            terminal.createExtensionTerminal(options.location, internalOptions, this.R(options, internalOptions).resolvedExtHostIdentifier, asTerminalIcon(options.iconPath), asTerminalColor(options.color)).then(id => {
                const disposable = this.S(id, p);
                this.h[id] = disposable;
            });
            this.f.push(terminal);
            return terminal.value;
        }
        R(options, internalOptions) {
            internalOptions = internalOptions ? internalOptions : {};
            if (options.location && typeof options.location === 'object' && 'parentTerminal' in options.location) {
                const parentTerminal = options.location.parentTerminal;
                if (parentTerminal) {
                    const parentExtHostTerminal = this.f.find(t => t.value === parentTerminal);
                    if (parentExtHostTerminal) {
                        internalOptions.resolvedExtHostIdentifier = parentExtHostTerminal._id;
                    }
                }
            }
            else if (options.location && typeof options.location !== 'object') {
                internalOptions.location = options.location;
            }
            else if (internalOptions.location && typeof internalOptions.location === 'object' && 'splitActiveTerminal' in internalOptions.location) {
                internalOptions.location = { splitActiveTerminal: true };
            }
            return internalOptions;
        }
        attachPtyToTerminal(id, pty) {
            const terminal = this.getTerminalById(id);
            if (!terminal) {
                throw new Error(`Cannot resolve terminal with id ${id} for virtual process`);
            }
            const p = new ExtHostPseudoterminal(pty);
            const disposable = this.S(id, p);
            this.h[id] = disposable;
        }
        async $acceptActiveTerminalChanged(id) {
            const original = this.b;
            if (id === null) {
                this.b = undefined;
                if (original !== this.b) {
                    this.J.fire(this.b);
                }
                return;
            }
            const terminal = this.getTerminalById(id);
            if (terminal) {
                this.b = terminal;
                if (original !== this.b) {
                    this.J.fire(this.b.value);
                }
            }
        }
        async $acceptTerminalProcessData(id, data) {
            const terminal = this.getTerminalById(id);
            if (terminal) {
                this.O.fire({ terminal: terminal.value, data });
            }
        }
        async $acceptTerminalDimensions(id, cols, rows) {
            const terminal = this.getTerminalById(id);
            if (terminal) {
                if (terminal.setDimensions(cols, rows)) {
                    this.L.fire({
                        terminal: terminal.value,
                        dimensions: terminal.value.dimensions
                    });
                }
            }
        }
        async $acceptDidExecuteCommand(id, command) {
            const terminal = this.getTerminalById(id);
            if (terminal) {
                this.P.fire({ terminal: terminal.value, ...command });
            }
        }
        async $acceptTerminalMaximumDimensions(id, cols, rows) {
            // Extension pty terminal only - when virtual process resize fires it means that the
            // terminal's maximum dimensions changed
            this.g.get(id)?.resize(cols, rows);
        }
        async $acceptTerminalTitleChange(id, name) {
            const terminal = this.getTerminalById(id);
            if (terminal) {
                terminal.name = name;
            }
        }
        async $acceptTerminalClosed(id, exitCode, exitReason) {
            const index = this.X(this.f, id);
            if (index !== null) {
                const terminal = this.f.splice(index, 1)[0];
                terminal.setExitStatus(exitCode, exitReason);
                this.H.fire(terminal.value);
            }
        }
        $acceptTerminalOpened(id, extHostTerminalId, name, shellLaunchConfigDto) {
            if (extHostTerminalId) {
                // Resolve with the renderer generated id
                const index = this.X(this.f, extHostTerminalId);
                if (index !== null) {
                    // The terminal has already been created (via createTerminal*), only fire the event
                    this.f[index]._id = id;
                    this.I.fire(this.terminals[index]);
                    this.f[index].isOpen = true;
                    return;
                }
            }
            const creationOptions = {
                name: shellLaunchConfigDto.name,
                shellPath: shellLaunchConfigDto.executable,
                shellArgs: shellLaunchConfigDto.args,
                cwd: typeof shellLaunchConfigDto.cwd === 'string' ? shellLaunchConfigDto.cwd : uri_1.URI.revive(shellLaunchConfigDto.cwd),
                env: shellLaunchConfigDto.env,
                hideFromUser: shellLaunchConfigDto.hideFromUser
            };
            const terminal = new $dqc(this.a, id, creationOptions, name);
            this.f.push(terminal);
            this.I.fire(terminal.value);
            terminal.isOpen = true;
        }
        async $acceptTerminalProcessId(id, processId) {
            const terminal = this.getTerminalById(id);
            terminal?._setProcessId(processId);
        }
        async $startExtensionTerminal(id, initialDimensions) {
            // Make sure the ExtHostTerminal exists so onDidOpenTerminal has fired before we call
            // Pseudoterminal.start
            const terminal = this.getTerminalById(id);
            if (!terminal) {
                return { message: (0, nls_1.localize)(11250, null, id) };
            }
            // Wait for onDidOpenTerminal to fire
            if (!terminal.isOpen) {
                await new Promise(r => {
                    // Ensure open is called after onDidOpenTerminal
                    const listener = this.onDidOpenTerminal(async (e) => {
                        if (e === terminal.value) {
                            listener.dispose();
                            r();
                        }
                    });
                });
            }
            const terminalProcess = this.g.get(id);
            if (terminalProcess) {
                terminalProcess.startSendingEvents(initialDimensions);
            }
            else {
                // Defer startSendingEvents call to when _setupExtHostProcessListeners is called
                this.j[id] = { initialDimensions };
            }
            return undefined;
        }
        S(id, p) {
            const disposables = new lifecycle_1.$Tc();
            disposables.add(p.onProcessReady(e => this.a.$sendProcessReady(id, e.pid, e.cwd, e.windowsPty)));
            disposables.add(p.onDidChangeProperty(property => this.a.$sendProcessProperty(id, property)));
            // Buffer data events to reduce the amount of messages going to the renderer
            this.y.startBuffering(id, p.onProcessData);
            disposables.add(p.onProcessExit(exitCode => this.U(id, exitCode)));
            this.g.set(id, p);
            const awaitingStart = this.j[id];
            if (awaitingStart && p instanceof ExtHostPseudoterminal) {
                p.startSendingEvents(awaitingStart.initialDimensions);
                delete this.j[id];
            }
            return disposables;
        }
        $acceptProcessAckDataEvent(id, charCount) {
            this.g.get(id)?.acknowledgeDataEvent(charCount);
        }
        $acceptProcessInput(id, data) {
            this.g.get(id)?.input(data);
        }
        $acceptTerminalInteraction(id) {
            const terminal = this.getTerminalById(id);
            if (terminal?.setInteractedWith()) {
                this.M.fire(terminal.value);
            }
        }
        $acceptTerminalSelection(id, selection) {
            this.getTerminalById(id)?.setSelection(selection);
        }
        $acceptProcessResize(id, cols, rows) {
            try {
                this.g.get(id)?.resize(cols, rows);
            }
            catch (error) {
                // We tried to write to a closed pipe / channel.
                if (error.code !== 'EPIPE' && error.code !== 'ERR_IPC_CHANNEL_CLOSED') {
                    throw (error);
                }
            }
        }
        $acceptProcessShutdown(id, immediate) {
            this.g.get(id)?.shutdown(immediate);
        }
        $acceptProcessRequestInitialCwd(id) {
            this.g.get(id)?.getInitialCwd().then(initialCwd => this.a.$sendProcessProperty(id, { type: terminal_1.ProcessPropertyType.InitialCwd, value: initialCwd }));
        }
        $acceptProcessRequestCwd(id) {
            this.g.get(id)?.getCwd().then(cwd => this.a.$sendProcessProperty(id, { type: terminal_1.ProcessPropertyType.Cwd, value: cwd }));
        }
        $acceptProcessRequestLatency(id) {
            return Promise.resolve(id);
        }
        registerLinkProvider(provider) {
            this.z.add(provider);
            if (this.z.size === 1) {
                this.a.$startLinkProvider();
            }
            return new extHostTypes_1.$MN(() => {
                this.z.delete(provider);
                if (this.z.size === 0) {
                    this.a.$stopLinkProvider();
                }
            });
        }
        registerProfileProvider(extension, id, provider) {
            if (this.C.has(id)) {
                throw new Error(`Terminal profile provider "${id}" already registered`);
            }
            this.C.set(id, provider);
            this.a.$registerProfileProvider(id, extension.identifier.value);
            return new extHostTypes_1.$MN(() => {
                this.C.delete(id);
                this.a.$unregisterProfileProvider(id);
            });
        }
        registerTerminalQuickFixProvider(id, extensionId, provider) {
            if (this.D.has(id)) {
                throw new Error(`Terminal quick fix provider "${id}" is already registered`);
            }
            this.D.set(id, provider);
            this.a.$registerQuickFixProvider(id, extensionId);
            return new extHostTypes_1.$MN(() => {
                this.D.delete(id);
                this.a.$unregisterQuickFixProvider(id);
            });
        }
        async $provideTerminalQuickFixes(id, matchResult) {
            const token = new cancellation_1.$we().token;
            if (token.isCancellationRequested) {
                return;
            }
            const provider = this.D.get(id);
            if (!provider) {
                return;
            }
            const quickFixes = await provider.provideTerminalQuickFixes(matchResult, token);
            if (quickFixes === null || (Array.isArray(quickFixes) && quickFixes.length === 0)) {
                return undefined;
            }
            const store = new lifecycle_1.$Tc();
            this.w.value = store;
            // Single
            if (!Array.isArray(quickFixes)) {
                return quickFixes ? extHostTypeConverters_1.TerminalQuickFix.from(quickFixes, this.Q.converter, store) : undefined;
            }
            // Many
            const result = [];
            for (const fix of quickFixes) {
                const converted = extHostTypeConverters_1.TerminalQuickFix.from(fix, this.Q.converter, store);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
        async $createContributedProfileTerminal(id, options) {
            const token = new cancellation_1.$we().token;
            let profile = await this.C.get(id)?.provideTerminalProfile(token);
            if (token.isCancellationRequested) {
                return;
            }
            if (profile && !('options' in profile)) {
                profile = { options: profile };
            }
            if (!profile || !('options' in profile)) {
                throw new Error(`No terminal profile options provided for id "${id}"`);
            }
            if ('pty' in profile.options) {
                this.createExtensionTerminal(profile.options, options);
                return;
            }
            this.createTerminalFromOptions(profile.options, options);
        }
        async $provideLinks(terminalId, line) {
            const terminal = this.getTerminalById(terminalId);
            if (!terminal) {
                return [];
            }
            // Discard any cached links the terminal has been holding, currently all links are released
            // when new links are provided.
            this.F.delete(terminalId);
            const oldToken = this.G.get(terminalId);
            oldToken?.dispose(true);
            const cancellationSource = new cancellation_1.$we();
            this.G.set(terminalId, cancellationSource);
            const result = [];
            const context = { terminal: terminal.value, line };
            const promises = [];
            for (const provider of this.z) {
                promises.push(async_1.Promises.withAsyncBody(async (r) => {
                    cancellationSource.token.onCancellationRequested(() => r({ provider, links: [] }));
                    const links = (await provider.provideTerminalLinks(context, cancellationSource.token)) || [];
                    if (!cancellationSource.token.isCancellationRequested) {
                        r({ provider, links });
                    }
                }));
            }
            const provideResults = await Promise.all(promises);
            if (cancellationSource.token.isCancellationRequested) {
                return [];
            }
            const cacheLinkMap = new Map();
            for (const provideResult of provideResults) {
                if (provideResult && provideResult.links.length > 0) {
                    result.push(...provideResult.links.map(providerLink => {
                        const link = {
                            id: nextLinkId++,
                            startIndex: providerLink.startIndex,
                            length: providerLink.length,
                            label: providerLink.tooltip
                        };
                        cacheLinkMap.set(link.id, {
                            provider: provideResult.provider,
                            link: providerLink
                        });
                        return link;
                    }));
                }
            }
            this.F.set(terminalId, cacheLinkMap);
            return result;
        }
        $activateLink(terminalId, linkId) {
            const cachedLink = this.F.get(terminalId)?.get(linkId);
            if (!cachedLink) {
                return;
            }
            cachedLink.provider.handleTerminalLink(cachedLink.link);
        }
        U(id, exitCode) {
            this.y.stopBuffering(id);
            // Remove process reference
            this.g.delete(id);
            delete this.j[id];
            // Clean up process disposables
            const processDiposable = this.h[id];
            if (processDiposable) {
                processDiposable.dispose();
                delete this.h[id];
            }
            // Send exit event to main side
            this.a.$sendProcessExit(id, exitCode);
        }
        getTerminalById(id) {
            return this.W(this.f, id);
        }
        getTerminalIdByApiObject(terminal) {
            const index = this.f.findIndex(item => {
                return item.value === terminal;
            });
            return index >= 0 ? index : null;
        }
        W(array, id) {
            const index = this.X(array, id);
            return index !== null ? array[index] : null;
        }
        X(array, id) {
            const index = array.findIndex(item => {
                return item._id === id;
            });
            return index >= 0 ? index : null;
        }
        getEnvironmentVariableCollection(extension) {
            let collection = this.n.get(extension.identifier.value);
            if (!collection) {
                collection = this.B(new UnifiedEnvironmentVariableCollection());
                this.Z(extension.identifier.value, collection);
            }
            return collection.getScopedEnvironmentVariableCollection(undefined);
        }
        Y(extensionIdentifier, collection) {
            const serialized = (0, environmentVariableShared_1.$Fs)(collection.map);
            const serializedDescription = (0, environmentVariableShared_1.$Gs)(collection.descriptionMap);
            this.a.$setEnvironmentVariableCollection(extensionIdentifier, collection.persistent, serialized.length === 0 ? undefined : serialized, serializedDescription);
        }
        $initEnvironmentVariableCollections(collections) {
            collections.forEach(entry => {
                const extensionIdentifier = entry[0];
                const collection = this.B(new UnifiedEnvironmentVariableCollection(entry[1]));
                this.Z(extensionIdentifier, collection);
            });
        }
        $acceptDefaultProfile(profile, automationProfile) {
            const oldProfile = this.s;
            this.s = profile;
            this.u = automationProfile;
            if (oldProfile?.path !== profile.path) {
                this.N.fire(profile.path);
            }
        }
        Z(extensionIdentifier, collection) {
            this.n.set(extensionIdentifier, collection);
            this.B(collection.onDidChangeCollection(() => {
                // When any collection value changes send this immediately, this is done to ensure
                // following calls to createTerminal will be created with the new environment. It will
                // result in more noise by sending multiple updates when called but collections are
                // expected to be small.
                this.Y(extensionIdentifier, collection);
            }));
        }
    };
    exports.$eqc = $eqc;
    exports.$eqc = $eqc = __decorate([
        __param(1, extHostCommands_1.$GQ),
        __param(2, extHostRpcService_1.$kQ)
    ], $eqc);
    /**
     * Unified environment variable collection carrying information for all scopes, for a specific extension.
     */
    class UnifiedEnvironmentVariableCollection extends lifecycle_1.$Uc {
        get persistent() { return this.b; }
        set persistent(value) {
            this.b = value;
            this.f.fire();
        }
        get onDidChangeCollection() { return this.f && this.f.event; }
        constructor(serialized) {
            super();
            this.map = new Map();
            this.a = new Map();
            this.descriptionMap = new Map();
            this.b = true;
            this.f = new event_1.$le();
            this.map = new Map(serialized);
        }
        getScopedEnvironmentVariableCollection(scope) {
            const scopedCollectionKey = this.j(scope);
            let scopedCollection = this.a.get(scopedCollectionKey);
            if (!scopedCollection) {
                scopedCollection = new ScopedEnvironmentVariableCollection(this, scope);
                this.a.set(scopedCollectionKey, scopedCollection);
                this.B(scopedCollection.onDidChangeCollection(() => this.f.fire()));
            }
            return scopedCollection;
        }
        replace(variable, value, options, scope) {
            this.g(variable, { value, type: extHostTypes_1.EnvironmentVariableMutatorType.Replace, options: options ?? { applyAtProcessCreation: true }, scope });
        }
        append(variable, value, options, scope) {
            this.g(variable, { value, type: extHostTypes_1.EnvironmentVariableMutatorType.Append, options: options ?? { applyAtProcessCreation: true }, scope });
        }
        prepend(variable, value, options, scope) {
            this.g(variable, { value, type: extHostTypes_1.EnvironmentVariableMutatorType.Prepend, options: options ?? { applyAtProcessCreation: true }, scope });
        }
        g(variable, mutator) {
            if (mutator.options && mutator.options.applyAtProcessCreation === false && !mutator.options.applyAtShellIntegration) {
                throw new Error('EnvironmentVariableMutatorOptions must apply at either process creation or shell integration');
            }
            const key = this.h(variable, mutator.scope);
            const current = this.map.get(key);
            const newOptions = mutator.options ? {
                applyAtProcessCreation: mutator.options.applyAtProcessCreation ?? false,
                applyAtShellIntegration: mutator.options.applyAtShellIntegration ?? false,
            } : {
                applyAtProcessCreation: true
            };
            if (!current ||
                current.value !== mutator.value ||
                current.type !== mutator.type ||
                current.options?.applyAtProcessCreation !== newOptions.applyAtProcessCreation ||
                current.options?.applyAtShellIntegration !== newOptions.applyAtShellIntegration ||
                current.scope?.workspaceFolder?.index !== mutator.scope?.workspaceFolder?.index) {
                const key = this.h(variable, mutator.scope);
                const value = {
                    variable,
                    ...mutator,
                    options: newOptions
                };
                this.map.set(key, value);
                this.f.fire();
            }
        }
        get(variable, scope) {
            const key = this.h(variable, scope);
            const value = this.map.get(key);
            // TODO: Set options to defaults if needed
            return value ? convertMutator(value) : undefined;
        }
        h(variable, scope) {
            const scopeKey = this.j(scope);
            return scopeKey.length ? `${variable}:::${scopeKey}` : variable;
        }
        j(scope) {
            return this.m(scope?.workspaceFolder) ?? '';
        }
        m(workspaceFolder) {
            return workspaceFolder ? workspaceFolder.uri.toString() : undefined;
        }
        getVariableMap(scope) {
            const map = new Map();
            for (const [_, value] of this.map) {
                if (this.j(value.scope) === this.j(scope)) {
                    map.set(value.variable, convertMutator(value));
                }
            }
            return map;
        }
        delete(variable, scope) {
            const key = this.h(variable, scope);
            this.map.delete(key);
            this.f.fire();
        }
        clear(scope) {
            if (scope?.workspaceFolder) {
                for (const [key, mutator] of this.map) {
                    if (mutator.scope?.workspaceFolder?.index === scope.workspaceFolder.index) {
                        this.map.delete(key);
                    }
                }
                this.n(scope);
            }
            else {
                this.map.clear();
                this.descriptionMap.clear();
            }
            this.f.fire();
        }
        setDescription(description, scope) {
            const key = this.j(scope);
            const current = this.descriptionMap.get(key);
            if (!current || current.description !== description) {
                let descriptionStr;
                if (typeof description === 'string') {
                    descriptionStr = description;
                }
                else {
                    // Only take the description before the first `\n\n`, so that the description doesn't mess up the UI
                    descriptionStr = description?.value.split('\n\n')[0];
                }
                const value = { description: descriptionStr, scope };
                this.descriptionMap.set(key, value);
                this.f.fire();
            }
        }
        getDescription(scope) {
            const key = this.j(scope);
            return this.descriptionMap.get(key)?.description;
        }
        n(scope) {
            const key = this.j(scope);
            this.descriptionMap.delete(key);
        }
    }
    class ScopedEnvironmentVariableCollection {
        get persistent() { return this.b.persistent; }
        set persistent(value) {
            this.b.persistent = value;
        }
        get onDidChangeCollection() { return this.a && this.a.event; }
        constructor(b, d) {
            this.b = b;
            this.d = d;
            this.a = new event_1.$le();
        }
        getScoped(scope) {
            return this.b.getScopedEnvironmentVariableCollection(scope);
        }
        replace(variable, value, options) {
            this.b.replace(variable, value, options, this.d);
        }
        append(variable, value, options) {
            this.b.append(variable, value, options, this.d);
        }
        prepend(variable, value, options) {
            this.b.prepend(variable, value, options, this.d);
        }
        get(variable) {
            return this.b.get(variable, this.d);
        }
        forEach(callback, thisArg) {
            this.b.getVariableMap(this.d).forEach((value, variable) => callback.call(thisArg, variable, value, this), this.d);
        }
        [Symbol.iterator]() {
            return this.b.getVariableMap(this.d).entries();
        }
        delete(variable) {
            this.b.delete(variable, this.d);
            this.a.fire(undefined);
        }
        clear() {
            this.b.clear(this.d);
        }
        set description(description) {
            this.b.setDescription(description, this.d);
        }
        get description() {
            return this.b.getDescription(this.d);
        }
    }
    let $fqc = class $fqc extends $eqc {
        constructor(extHostCommands, extHostRpc) {
            super(false, extHostCommands, extHostRpc);
        }
        createTerminal(name, shellPath, shellArgs) {
            throw new errors_1.$$();
        }
        createTerminalFromOptions(options, internalOptions) {
            throw new errors_1.$$();
        }
    };
    exports.$fqc = $fqc;
    exports.$fqc = $fqc = __decorate([
        __param(0, extHostCommands_1.$GQ),
        __param(1, extHostRpcService_1.$kQ)
    ], $fqc);
    function asTerminalIcon(iconPath) {
        if (!iconPath || typeof iconPath === 'string') {
            return undefined;
        }
        if (!('id' in iconPath)) {
            return iconPath;
        }
        return {
            id: iconPath.id,
            color: iconPath.color
        };
    }
    function asTerminalColor(color) {
        return themables_1.ThemeColor.isThemeColor(color) ? color : undefined;
    }
    function convertMutator(mutator) {
        const newMutator = { ...mutator };
        delete newMutator.scope;
        newMutator.options = newMutator.options ?? undefined;
        delete newMutator.variable;
        return newMutator;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[126/*vs/workbench/api/common/extHostTerminalShellIntegration*/], __M([1/*require*/,0/*exports*/,7/*vs/workbench/api/common/extHostTypes*/,4/*vs/base/common/lifecycle*/,3/*vs/platform/instantiation/common/instantiation*/,5/*vs/workbench/api/common/extHost.protocol*/,16/*vs/workbench/api/common/extHostRpcService*/,56/*vs/workbench/api/common/extHostTerminalService*/,6/*vs/base/common/event*/,2/*vs/base/common/uri*/,10/*vs/base/common/async*/]), function (require, exports, extHostTypes_1, lifecycle_1, instantiation_1, extHost_protocol_1, extHostRpcService_1, extHostTerminalService_1, event_1, uri_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$qrc = exports.$prc = void 0;
    exports.$prc = (0, instantiation_1.$Fi)('IExtHostTerminalShellIntegration');
    let $qrc = class $qrc extends lifecycle_1.$Uc {
        constructor(extHostRpc, h) {
            super();
            this.h = h;
            this.b = new Map();
            this.c = new event_1.$le();
            this.onDidChangeTerminalShellIntegration = this.c.event;
            this.f = new event_1.$le();
            this.onDidStartTerminalShellExecution = this.f.event;
            this.g = new event_1.$le();
            this.onDidEndTerminalShellExecution = this.g.event;
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadTerminalShellIntegration);
            // Clean up listeners
            this.B((0, lifecycle_1.$Sc)(() => {
                for (const [_, integration] of this.b) {
                    integration.dispose();
                }
                this.b.clear();
            }));
            // Convenient test code:
            // this.onDidChangeTerminalShellIntegration(e => {
            // 	console.log('*** onDidChangeTerminalShellIntegration', e);
            // });
            // this.onDidStartTerminalShellExecution(async e => {
            // 	console.log('*** onDidStartTerminalShellExecution', e);
            // 	// new Promise<void>(r => {
            // 	// 	(async () => {
            // 	// 		for await (const d of e.execution.read()) {
            // 	// 			console.log('data2', d);
            // 	// 		}
            // 	// 	})();
            // 	// });
            // 	for await (const d of e.execution.read()) {
            // 		console.log('data', d);
            // 	}
            // });
            // this.onDidEndTerminalShellExecution(e => {
            // 	console.log('*** onDidEndTerminalShellExecution', e);
            // });
            // setTimeout(() => {
            // 	console.log('before executeCommand(\"echo hello\")');
            // 	Array.from(this._activeShellIntegrations.values())[0].value.executeCommand('echo hello');
            // 	console.log('after executeCommand(\"echo hello\")');
            // }, 4000);
        }
        $shellIntegrationChange(instanceId) {
            const terminal = this.h.getTerminalById(instanceId);
            if (!terminal) {
                return;
            }
            const apiTerminal = terminal.value;
            let shellIntegration = this.b.get(instanceId);
            if (!shellIntegration) {
                shellIntegration = new InternalTerminalShellIntegration(terminal.value, this.f);
                this.b.set(instanceId, shellIntegration);
                shellIntegration.store.add(terminal.onWillDispose(() => this.b.get(instanceId)?.dispose()));
                shellIntegration.store.add(shellIntegration.onDidRequestShellExecution(commandLine => this.a.$executeCommand(instanceId, commandLine)));
                shellIntegration.store.add(shellIntegration.onDidRequestEndExecution(e => this.g.fire(e)));
                shellIntegration.store.add(shellIntegration.onDidRequestChangeShellIntegration(e => this.c.fire(e)));
                terminal.shellIntegration = shellIntegration.value;
            }
            this.c.fire({
                terminal: apiTerminal,
                shellIntegration: shellIntegration.value
            });
        }
        $shellExecutionStart(instanceId, commandLineValue, commandLineConfidence, isTrusted, cwd) {
            // Force shellIntegration creation if it hasn't been created yet, this could when events
            // don't come through on startup
            if (!this.b.has(instanceId)) {
                this.$shellIntegrationChange(instanceId);
            }
            const commandLine = {
                value: commandLineValue,
                confidence: commandLineConfidence,
                isTrusted
            };
            this.b.get(instanceId)?.startShellExecution(commandLine, uri_1.URI.revive(cwd));
        }
        $shellExecutionEnd(instanceId, commandLineValue, commandLineConfidence, isTrusted, exitCode) {
            const commandLine = {
                value: commandLineValue,
                confidence: commandLineConfidence,
                isTrusted
            };
            this.b.get(instanceId)?.endShellExecution(commandLine, exitCode);
        }
        $shellExecutionData(instanceId, data) {
            this.b.get(instanceId)?.emitData(data);
        }
        $cwdChange(instanceId, cwd) {
            this.b.get(instanceId)?.setCwd(uri_1.URI.revive(cwd));
        }
        $closeTerminal(instanceId) {
            this.b.get(instanceId)?.dispose();
            this.b.delete(instanceId);
        }
    };
    exports.$qrc = $qrc;
    exports.$qrc = $qrc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostTerminalService_1.$cqc)
    ], $qrc);
    class InternalTerminalShellIntegration extends lifecycle_1.$Uc {
        get currentExecution() { return this.a; }
        constructor(j, m) {
            super();
            this.j = j;
            this.m = m;
            this.b = false;
            this.store = this.B(new lifecycle_1.$Tc());
            this.f = this.B(new event_1.$le());
            this.onDidRequestChangeShellIntegration = this.f.event;
            this.g = this.B(new event_1.$le());
            this.onDidRequestShellExecution = this.g.event;
            this.h = this.B(new event_1.$le());
            this.onDidRequestEndExecution = this.h.event;
            const that = this;
            this.value = {
                get cwd() {
                    return that.c;
                },
                // executeCommand(commandLine: string): vscode.TerminalShellExecution;
                // executeCommand(executable: string, args: string[]): vscode.TerminalShellExecution;
                executeCommand(commandLineOrExecutable, args) {
                    let commandLineValue = commandLineOrExecutable;
                    if (args) {
                        commandLineValue += ` "${args.map(e => `${e.replaceAll('"', '\\"')}`).join('" "')}"`;
                    }
                    that.g.fire(commandLineValue);
                    // Fire the event in a microtask to allow the extension to use the execution before
                    // the start event fires
                    const commandLine = {
                        value: commandLineValue,
                        confidence: extHostTypes_1.TerminalShellExecutionCommandLineConfidence.High,
                        isTrusted: true
                    };
                    const execution = that.startShellExecution(commandLine, that.c, true).value;
                    that.b = true;
                    return execution;
                }
            };
        }
        startShellExecution(commandLine, cwd, fireEventInMicrotask) {
            if (this.b && this.a) {
                this.b = false;
            }
            else {
                if (this.a) {
                    this.a.endExecution(undefined);
                    this.h.fire({ terminal: this.j, shellIntegration: this.value, execution: this.a.value, exitCode: undefined });
                }
                // Fallback to the shell integration's cwd as the cwd may not have been restored after a reload
                const currentExecution = this.a = new InternalTerminalShellExecution(commandLine, cwd ?? this.c);
                if (fireEventInMicrotask) {
                    queueMicrotask(() => this.m.fire({ terminal: this.j, shellIntegration: this.value, execution: currentExecution.value }));
                }
                else {
                    this.m.fire({ terminal: this.j, shellIntegration: this.value, execution: this.a.value });
                }
            }
            return this.a;
        }
        emitData(data) {
            this.currentExecution?.emitData(data);
        }
        endShellExecution(commandLine, exitCode) {
            if (this.a) {
                this.a.endExecution(commandLine);
                this.h.fire({ terminal: this.j, shellIntegration: this.value, execution: this.a.value, exitCode });
                this.a = undefined;
            }
        }
        setCwd(cwd) {
            let wasChanged = false;
            if (uri_1.URI.isUri(this.c)) {
                wasChanged = !uri_1.URI.isUri(cwd) || this.c.toString() !== cwd.toString();
            }
            else if (this.c !== cwd) {
                wasChanged = true;
            }
            if (wasChanged) {
                this.c = cwd;
                this.f.fire({ terminal: this.j, shellIntegration: this.value });
            }
        }
    }
    class InternalTerminalShellExecution {
        constructor(c, cwd) {
            this.c = c;
            this.cwd = cwd;
            this.b = false;
            const that = this;
            this.value = {
                get commandLine() {
                    return that.c;
                },
                get cwd() {
                    return that.cwd;
                },
                read() {
                    return that.d();
                }
            };
        }
        d() {
            if (!this.a) {
                if (this.b) {
                    return async_1.$6h.EMPTY;
                }
                this.a = new ShellExecutionDataStream();
            }
            return this.a.createIterable();
        }
        emitData(data) {
            this.a?.emitData(data);
        }
        endExecution(commandLine) {
            if (commandLine) {
                this.c = commandLine;
            }
            this.a?.endExecution();
            this.a = undefined;
            this.b = true;
        }
    }
    class ShellExecutionDataStream extends lifecycle_1.$Uc {
        constructor() {
            super(...arguments);
            this.b = [];
        }
        createIterable() {
            if (!this.a) {
                this.a = new async_1.$Eh();
            }
            const barrier = this.a;
            const iterable = new async_1.$6h(async (emitter) => {
                this.b.push(emitter);
                await barrier.wait();
            });
            return iterable;
        }
        emitData(data) {
            for (const emitter of this.b) {
                emitter.emitOne(data);
            }
        }
        endExecution() {
            this.a?.open();
            this.a = undefined;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[127/*vs/workbench/api/common/extHostTextEditor*/], __M([1/*require*/,0/*exports*/,61/*vs/base/common/assert*/,13/*vs/base/common/errors*/,96/*vs/base/common/idGenerator*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, assert_1, errors_1, idGenerator_1, TypeConverters, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$tQ = exports.$sQ = exports.$rQ = void 0;
    TypeConverters = __importStar(TypeConverters);
    class $rQ {
        static { this.c = new idGenerator_1.$pQ('TextEditorDecorationType'); }
        constructor(proxy, extension, options) {
            const key = $rQ.c.nextId();
            proxy.$registerTextEditorDecorationType(extension.identifier, key, TypeConverters.DecorationRenderOptions.from(options));
            this.value = Object.freeze({
                key,
                dispose() {
                    proxy.$removeTextEditorDecorationType(key);
                }
            });
        }
    }
    exports.$rQ = $rQ;
    class TextEditorEdit {
        constructor(document, options) {
            this.g = [];
            this.h = undefined;
            this.j = false;
            this.c = document;
            this.d = document.version;
            this.e = options.undoStopBefore;
            this.f = options.undoStopAfter;
        }
        finalize() {
            this.j = true;
            return {
                documentVersionId: this.d,
                edits: this.g,
                setEndOfLine: this.h,
                undoStopBefore: this.e,
                undoStopAfter: this.f
            };
        }
        k() {
            if (this.j) {
                throw new Error('Edit is only valid while callback runs');
            }
        }
        replace(location, value) {
            this.k();
            let range = null;
            if (location instanceof extHostTypes_1.$NN) {
                range = new extHostTypes_1.$ON(location, location);
            }
            else if (location instanceof extHostTypes_1.$ON) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this.l(range, value, false);
        }
        insert(location, value) {
            this.k();
            this.l(new extHostTypes_1.$ON(location, location), value, true);
        }
        delete(location) {
            this.k();
            let range = null;
            if (location instanceof extHostTypes_1.$ON) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this.l(range, null, true);
        }
        l(range, text, forceMoveMarkers) {
            const validRange = this.c.validateRange(range);
            this.g.push({
                range: validRange,
                text: text,
                forceMoveMarkers: forceMoveMarkers
            });
        }
        setEndOfLine(endOfLine) {
            this.k();
            if (endOfLine !== extHostTypes_1.EndOfLine.LF && endOfLine !== extHostTypes_1.EndOfLine.CRLF) {
                throw (0, errors_1.$6)('endOfLine');
            }
            this.h = endOfLine;
        }
    }
    class $sQ {
        constructor(proxy, id, source, logService) {
            this.c = proxy;
            this.d = id;
            this._accept(source);
            this.e = logService;
            const that = this;
            this.value = {
                get tabSize() {
                    return that.f;
                },
                set tabSize(value) {
                    that.n(value);
                },
                get indentSize() {
                    return that.g;
                },
                set indentSize(value) {
                    that.p(value);
                },
                get insertSpaces() {
                    return that.j;
                },
                set insertSpaces(value) {
                    that.s(value);
                },
                get cursorStyle() {
                    return that.k;
                },
                set cursorStyle(value) {
                    that.t(value);
                },
                get lineNumbers() {
                    return that.l;
                },
                set lineNumbers(value) {
                    that.u(value);
                }
            };
        }
        _accept(source) {
            this.f = source.tabSize;
            this.g = source.indentSize;
            this.h = source.originalIndentSize;
            this.j = source.insertSpaces;
            this.k = source.cursorStyle;
            this.l = TypeConverters.TextEditorLineNumbersStyle.to(source.lineNumbers);
        }
        // --- internal: tabSize
        m(value) {
            if (value === 'auto') {
                return 'auto';
            }
            if (typeof value === 'number') {
                const r = Math.floor(value);
                return (r > 0 ? r : null);
            }
            if (typeof value === 'string') {
                const r = parseInt(value, 10);
                if (isNaN(r)) {
                    return null;
                }
                return (r > 0 ? r : null);
            }
            return null;
        }
        n(value) {
            const tabSize = this.m(value);
            if (tabSize === null) {
                // ignore invalid call
                return;
            }
            if (typeof tabSize === 'number') {
                if (this.f === tabSize) {
                    // nothing to do
                    return;
                }
                // reflect the new tabSize value immediately
                this.f = tabSize;
            }
            this.v('setTabSize', this.c.$trySetOptions(this.d, {
                tabSize: tabSize
            }));
        }
        // --- internal: indentSize
        o(value) {
            if (value === 'tabSize') {
                return 'tabSize';
            }
            if (typeof value === 'number') {
                const r = Math.floor(value);
                return (r > 0 ? r : null);
            }
            if (typeof value === 'string') {
                const r = parseInt(value, 10);
                if (isNaN(r)) {
                    return null;
                }
                return (r > 0 ? r : null);
            }
            return null;
        }
        p(value) {
            const indentSize = this.o(value);
            if (indentSize === null) {
                // ignore invalid call
                return;
            }
            if (typeof indentSize === 'number') {
                if (this.h === indentSize) {
                    // nothing to do
                    return;
                }
                // reflect the new indentSize value immediately
                this.g = indentSize;
                this.h = indentSize;
            }
            this.v('setIndentSize', this.c.$trySetOptions(this.d, {
                indentSize: indentSize
            }));
        }
        // --- internal: insert spaces
        q(value) {
            if (value === 'auto') {
                return 'auto';
            }
            return (value === 'false' ? false : Boolean(value));
        }
        s(value) {
            const insertSpaces = this.q(value);
            if (typeof insertSpaces === 'boolean') {
                if (this.j === insertSpaces) {
                    // nothing to do
                    return;
                }
                // reflect the new insertSpaces value immediately
                this.j = insertSpaces;
            }
            this.v('setInsertSpaces', this.c.$trySetOptions(this.d, {
                insertSpaces: insertSpaces
            }));
        }
        // --- internal: cursor style
        t(value) {
            if (this.k === value) {
                // nothing to do
                return;
            }
            this.k = value;
            this.v('setCursorStyle', this.c.$trySetOptions(this.d, {
                cursorStyle: value
            }));
        }
        // --- internal: line number
        u(value) {
            if (this.l === value) {
                // nothing to do
                return;
            }
            this.l = value;
            this.v('setLineNumbers', this.c.$trySetOptions(this.d, {
                lineNumbers: TypeConverters.TextEditorLineNumbersStyle.from(value)
            }));
        }
        assign(newOptions) {
            const bulkConfigurationUpdate = {};
            let hasUpdate = false;
            if (typeof newOptions.tabSize !== 'undefined') {
                const tabSize = this.m(newOptions.tabSize);
                if (tabSize === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
                else if (typeof tabSize === 'number' && this.f !== tabSize) {
                    // reflect the new tabSize value immediately
                    this.f = tabSize;
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
            }
            if (typeof newOptions.indentSize !== 'undefined') {
                const indentSize = this.o(newOptions.indentSize);
                if (indentSize === 'tabSize') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.indentSize = indentSize;
                }
                else if (typeof indentSize === 'number' && this.h !== indentSize) {
                    // reflect the new indentSize value immediately
                    this.g = indentSize;
                    this.h = indentSize;
                    hasUpdate = true;
                    bulkConfigurationUpdate.indentSize = indentSize;
                }
            }
            if (typeof newOptions.insertSpaces !== 'undefined') {
                const insertSpaces = this.q(newOptions.insertSpaces);
                if (insertSpaces === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
                else if (this.j !== insertSpaces) {
                    // reflect the new insertSpaces value immediately
                    this.j = insertSpaces;
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
            }
            if (typeof newOptions.cursorStyle !== 'undefined') {
                if (this.k !== newOptions.cursorStyle) {
                    this.k = newOptions.cursorStyle;
                    hasUpdate = true;
                    bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
                }
            }
            if (typeof newOptions.lineNumbers !== 'undefined') {
                if (this.l !== newOptions.lineNumbers) {
                    this.l = newOptions.lineNumbers;
                    hasUpdate = true;
                    bulkConfigurationUpdate.lineNumbers = TypeConverters.TextEditorLineNumbersStyle.from(newOptions.lineNumbers);
                }
            }
            if (hasUpdate) {
                this.v('setOptions', this.c.$trySetOptions(this.d, bulkConfigurationUpdate));
            }
        }
        v(action, promise) {
            promise.catch(err => {
                this.e.warn(`ExtHostTextEditorOptions '${action}' failed:'`);
                this.e.warn(err);
            });
        }
    }
    exports.$sQ = $sQ;
    class $tQ {
        constructor(id, j, k, document, selections, options, visibleRanges, viewColumn) {
            this.id = id;
            this.j = j;
            this.k = k;
            this.g = false;
            this.h = new Set();
            this.c = selections;
            this.d = new $sQ(this.j, this.id, options, k);
            this.e = visibleRanges;
            this.f = viewColumn;
            const that = this;
            this.value = Object.freeze({
                get document() {
                    return document.value;
                },
                set document(_value) {
                    throw new errors_1.$8('document');
                },
                // --- selection
                get selection() {
                    return that.c && that.c[0];
                },
                set selection(value) {
                    if (!(value instanceof extHostTypes_1.$PN)) {
                        throw (0, errors_1.$6)('selection');
                    }
                    that.c = [value];
                    that.l();
                },
                get selections() {
                    return that.c;
                },
                set selections(value) {
                    if (!Array.isArray(value) || value.some(a => !(a instanceof extHostTypes_1.$PN))) {
                        throw (0, errors_1.$6)('selections');
                    }
                    that.c = value;
                    that.l();
                },
                // --- visible ranges
                get visibleRanges() {
                    return that.e;
                },
                set visibleRanges(_value) {
                    throw new errors_1.$8('visibleRanges');
                },
                // --- options
                get options() {
                    return that.d.value;
                },
                set options(value) {
                    if (!that.g) {
                        that.d.assign(value);
                    }
                },
                // --- view column
                get viewColumn() {
                    return that.f;
                },
                set viewColumn(_value) {
                    throw new errors_1.$8('viewColumn');
                },
                // --- edit
                edit(callback, options = { undoStopBefore: true, undoStopAfter: true }) {
                    if (that.g) {
                        return Promise.reject(new Error('TextEditor#edit not possible on closed editors'));
                    }
                    const edit = new TextEditorEdit(document.value, options);
                    callback(edit);
                    return that.m(edit);
                },
                // --- snippet edit
                insertSnippet(snippet, where, options = { undoStopBefore: true, undoStopAfter: true }) {
                    if (that.g) {
                        return Promise.reject(new Error('TextEditor#insertSnippet not possible on closed editors'));
                    }
                    let ranges;
                    if (!where || (Array.isArray(where) && where.length === 0)) {
                        ranges = that.c.map(range => TypeConverters.Range.from(range));
                    }
                    else if (where instanceof extHostTypes_1.$NN) {
                        const { lineNumber, column } = TypeConverters.Position.from(where);
                        ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
                    }
                    else if (where instanceof extHostTypes_1.$ON) {
                        ranges = [TypeConverters.Range.from(where)];
                    }
                    else {
                        ranges = [];
                        for (const posOrRange of where) {
                            if (posOrRange instanceof extHostTypes_1.$ON) {
                                ranges.push(TypeConverters.Range.from(posOrRange));
                            }
                            else {
                                const { lineNumber, column } = TypeConverters.Position.from(posOrRange);
                                ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
                            }
                        }
                    }
                    return j.$tryInsertSnippet(id, document.value.version, snippet.value, ranges, options);
                },
                setDecorations(decorationType, ranges) {
                    const willBeEmpty = (ranges.length === 0);
                    if (willBeEmpty && !that.h.has(decorationType.key)) {
                        // avoid no-op call to the renderer
                        return;
                    }
                    if (willBeEmpty) {
                        that.h.delete(decorationType.key);
                    }
                    else {
                        that.h.add(decorationType.key);
                    }
                    that.n(() => {
                        if (TypeConverters.$hQ(ranges)) {
                            return j.$trySetDecorations(id, decorationType.key, TypeConverters.$iQ(ranges));
                        }
                        else {
                            const _ranges = new Array(4 * ranges.length);
                            for (let i = 0, len = ranges.length; i < len; i++) {
                                const range = ranges[i];
                                _ranges[4 * i] = range.start.line + 1;
                                _ranges[4 * i + 1] = range.start.character + 1;
                                _ranges[4 * i + 2] = range.end.line + 1;
                                _ranges[4 * i + 3] = range.end.character + 1;
                            }
                            return j.$trySetDecorationsFast(id, decorationType.key, _ranges);
                        }
                    });
                },
                revealRange(range, revealType) {
                    that.n(() => j.$tryRevealRange(id, TypeConverters.Range.from(range), (revealType || extHostTypes_1.TextEditorRevealType.Default)));
                },
                show(column) {
                    j.$tryShowEditor(id, TypeConverters.ViewColumn.from(column));
                },
                hide() {
                    j.$tryHideEditor(id);
                },
                [Symbol.for('debug.description')]() {
                    return `TextEditor(${this.document.uri.toString()})`;
                }
            });
        }
        dispose() {
            (0, assert_1.ok)(!this.g);
            this.g = true;
        }
        // --- incoming: extension host MUST accept what the renderer says
        _acceptOptions(options) {
            (0, assert_1.ok)(!this.g);
            this.d._accept(options);
        }
        _acceptVisibleRanges(value) {
            (0, assert_1.ok)(!this.g);
            this.e = value;
        }
        _acceptViewColumn(value) {
            (0, assert_1.ok)(!this.g);
            this.f = value;
        }
        _acceptSelections(selections) {
            (0, assert_1.ok)(!this.g);
            this.c = selections;
        }
        async l() {
            const selection = this.c.map(TypeConverters.Selection.from);
            await this.n(() => this.j.$trySetSelections(this.id, selection));
            return this.value;
        }
        m(editBuilder) {
            const editData = editBuilder.finalize();
            // return when there is nothing to do
            if (editData.edits.length === 0 && !editData.setEndOfLine) {
                return Promise.resolve(true);
            }
            // check that the edits are not overlapping (i.e. illegal)
            const editRanges = editData.edits.map(edit => edit.range);
            // sort ascending (by end and then by start)
            editRanges.sort((a, b) => {
                if (a.end.line === b.end.line) {
                    if (a.end.character === b.end.character) {
                        if (a.start.line === b.start.line) {
                            return a.start.character - b.start.character;
                        }
                        return a.start.line - b.start.line;
                    }
                    return a.end.character - b.end.character;
                }
                return a.end.line - b.end.line;
            });
            // check that no edits are overlapping
            for (let i = 0, count = editRanges.length - 1; i < count; i++) {
                const rangeEnd = editRanges[i].end;
                const nextRangeStart = editRanges[i + 1].start;
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    return Promise.reject(new Error('Overlapping ranges are not allowed!'));
                }
            }
            // prepare data for serialization
            const edits = editData.edits.map((edit) => {
                return {
                    range: TypeConverters.Range.from(edit.range),
                    text: edit.text,
                    forceMoveMarkers: edit.forceMoveMarkers
                };
            });
            return this.j.$tryApplyEdits(this.id, editData.documentVersionId, edits, {
                setEndOfLine: typeof editData.setEndOfLine === 'number' ? TypeConverters.EndOfLine.from(editData.setEndOfLine) : undefined,
                undoStopBefore: editData.undoStopBefore,
                undoStopAfter: editData.undoStopAfter
            });
        }
        n(callback) {
            if (this.g) {
                this.k.warn('TextEditor is closed/disposed');
                return Promise.resolve(undefined);
            }
            return callback().then(() => this, err => {
                if (!(err instanceof Error && err.name === 'DISPOSED')) {
                    this.k.warn(err);
                }
                return null;
            });
        }
    }
    exports.$tQ = $tQ;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[57/*vs/workbench/api/common/extHostDocumentsAndEditors*/], __M([1/*require*/,0/*exports*/,61/*vs/base/common/assert*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,5/*vs/workbench/api/common/extHost.protocol*/,123/*vs/workbench/api/common/extHostDocumentData*/,16/*vs/workbench/api/common/extHostRpcService*/,127/*vs/workbench/api/common/extHostTextEditor*/,8/*vs/workbench/api/common/extHostTypeConverters*/,11/*vs/platform/log/common/log*/,28/*vs/base/common/map*/,15/*vs/base/common/network*/,40/*vs/base/common/iterator*/,48/*vs/base/common/lazy*/]), function (require, exports, assert, event_1, lifecycle_1, uri_1, instantiation_1, extHost_protocol_1, extHostDocumentData_1, extHostRpcService_1, extHostTextEditor_1, typeConverters, log_1, map_1, network_1, iterator_1, lazy_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vQ = exports.$uQ = void 0;
    assert = __importStar(assert);
    typeConverters = __importStar(typeConverters);
    class Reference {
        constructor(value) {
            this.value = value;
            this.a = 0;
        }
        ref() {
            this.a++;
        }
        unref() {
            return --this.a === 0;
        }
    }
    let $uQ = class $uQ {
        constructor(h, i) {
            this.h = h;
            this.i = i;
            this.a = null;
            this.b = new Map();
            this.c = new map_1.$Ac();
            this.d = new event_1.$le();
            this.e = new event_1.$le();
            this.f = new event_1.$le();
            this.g = new event_1.$le();
            this.onDidAddDocuments = this.d.event;
            this.onDidRemoveDocuments = this.e.event;
            this.onDidChangeVisibleTextEditors = this.f.event;
            this.onDidChangeActiveTextEditor = this.g.event;
        }
        $acceptDocumentsAndEditorsDelta(delta) {
            this.acceptDocumentsAndEditorsDelta(delta);
        }
        acceptDocumentsAndEditorsDelta(delta) {
            const removedDocuments = [];
            const addedDocuments = [];
            const removedEditors = [];
            if (delta.removedDocuments) {
                for (const uriComponent of delta.removedDocuments) {
                    const uri = uri_1.URI.revive(uriComponent);
                    const data = this.c.get(uri);
                    if (data?.unref()) {
                        this.c.delete(uri);
                        removedDocuments.push(data.value);
                    }
                }
            }
            if (delta.addedDocuments) {
                for (const data of delta.addedDocuments) {
                    const resource = uri_1.URI.revive(data.uri);
                    let ref = this.c.get(resource);
                    // double check -> only notebook cell documents should be
                    // referenced/opened more than once...
                    if (ref) {
                        if (resource.scheme !== network_1.Schemas.vscodeNotebookCell && resource.scheme !== network_1.Schemas.vscodeInteractiveInput) {
                            throw new Error(`document '${resource} already exists!'`);
                        }
                    }
                    if (!ref) {
                        ref = new Reference(new extHostDocumentData_1.$nQ(this.h.getProxy(extHost_protocol_1.$KN.MainThreadDocuments), resource, data.lines, data.EOL, data.versionId, data.languageId, data.isDirty));
                        this.c.set(resource, ref);
                        addedDocuments.push(ref.value);
                    }
                    ref.ref();
                }
            }
            if (delta.removedEditors) {
                for (const id of delta.removedEditors) {
                    const editor = this.b.get(id);
                    this.b.delete(id);
                    if (editor) {
                        removedEditors.push(editor);
                    }
                }
            }
            if (delta.addedEditors) {
                for (const data of delta.addedEditors) {
                    const resource = uri_1.URI.revive(data.documentUri);
                    assert.ok(this.c.has(resource), `document '${resource}' does not exist`);
                    assert.ok(!this.b.has(data.id), `editor '${data.id}' already exists!`);
                    const documentData = this.c.get(resource).value;
                    const editor = new extHostTextEditor_1.$tQ(data.id, this.h.getProxy(extHost_protocol_1.$KN.MainThreadTextEditors), this.i, new lazy_1.$T(() => documentData.document), data.selections.map(typeConverters.Selection.to), data.options, data.visibleRanges.map(range => typeConverters.Range.to(range)), typeof data.editorPosition === 'number' ? typeConverters.ViewColumn.to(data.editorPosition) : undefined);
                    this.b.set(data.id, editor);
                }
            }
            if (delta.newActiveEditor !== undefined) {
                assert.ok(delta.newActiveEditor === null || this.b.has(delta.newActiveEditor), `active editor '${delta.newActiveEditor}' does not exist`);
                this.a = delta.newActiveEditor;
            }
            (0, lifecycle_1.$Pc)(removedDocuments);
            (0, lifecycle_1.$Pc)(removedEditors);
            // now that the internal state is complete, fire events
            if (delta.removedDocuments) {
                this.e.fire(removedDocuments);
            }
            if (delta.addedDocuments) {
                this.d.fire(addedDocuments);
            }
            if (delta.removedEditors || delta.addedEditors) {
                this.f.fire(this.allEditors().map(editor => editor.value));
            }
            if (delta.newActiveEditor !== undefined) {
                this.g.fire(this.activeEditor());
            }
        }
        getDocument(uri) {
            return this.c.get(uri)?.value;
        }
        allDocuments() {
            return iterator_1.Iterable.map(this.c.values(), ref => ref.value);
        }
        getEditor(id) {
            return this.b.get(id);
        }
        activeEditor(internal) {
            if (!this.a) {
                return undefined;
            }
            const editor = this.b.get(this.a);
            if (internal) {
                return editor;
            }
            else {
                return editor?.value;
            }
        }
        allEditors() {
            return [...this.b.values()];
        }
    };
    exports.$uQ = $uQ;
    exports.$uQ = $uQ = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, log_1.$ak)
    ], $uQ);
    exports.$vQ = (0, instantiation_1.$Fi)('IExtHostDocumentsAndEditors');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[95/*vs/workbench/api/common/extHostTesting*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,22/*vs/base/common/buffer*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,231/*vs/base/common/functional*/,75/*vs/base/common/hash*/,4/*vs/base/common/lifecycle*/,37/*vs/base/common/marshallingIds*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,38/*vs/base/common/uuid*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,5/*vs/workbench/api/common/extHost.protocol*/,33/*vs/workbench/api/common/extHostCommands*/,57/*vs/workbench/api/common/extHostDocumentsAndEditors*/,16/*vs/workbench/api/common/extHostRpcService*/,125/*vs/workbench/api/common/extHostTestItem*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,200/*vs/workbench/contrib/testing/common/constants*/,54/*vs/workbench/contrib/testing/common/testId*/,81/*vs/workbench/contrib/testing/common/testItemCollection*/,55/*vs/workbench/contrib/testing/common/testTypes*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, async_1, buffer_1, cancellation_1, event_1, functional_1, hash_1, lifecycle_1, marshallingIds_1, types_1, uri_1, uuid_1, instantiation_1, log_1, extHost_protocol_1, extHostCommands_1, extHostDocumentsAndEditors_1, extHostRpcService_1, extHostTestItem_1, Convert, extHostTypes_1, constants_1, testId_1, testItemCollection_1, testTypes_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Aqc = exports.$zqc = exports.$yqc = exports.$xqc = exports.$wqc = void 0;
    Convert = __importStar(Convert);
    let followupCounter = 0;
    const testResultInternalIDs = new WeakMap();
    exports.$wqc = (0, instantiation_1.$Fi)('IExtHostTesting');
    let $xqc = class $xqc extends lifecycle_1.$Uc {
        constructor(rpc, C, D, F) {
            super();
            this.C = C;
            this.D = D;
            this.F = F;
            this.f = this.B(new event_1.$le());
            this.g = new Map();
            this.w = this.B(new event_1.$le());
            this.y = new Set();
            this.z = new Map();
            this.onResultsChanged = this.f.event;
            this.results = [];
            this.h = rpc.getProxy(extHost_protocol_1.$KN.MainThreadTesting);
            this.m = new TestObservers(this.h);
            this.j = new $yqc(this.h, C);
            D.registerArgumentProcessor({
                processArgument: arg => {
                    switch (arg?.$mid) {
                        case marshallingIds_1.MarshalledId.TestItemContext: {
                            const cast = arg;
                            const targetTest = cast.tests[cast.tests.length - 1].item.extId;
                            const controller = this.g.get(testId_1.$7I.root(targetTest));
                            return controller?.collection.tree.get(targetTest)?.actual ?? (0, extHostTestItem_1.$wQ)(arg);
                        }
                        case marshallingIds_1.MarshalledId.TestMessageMenuArgs: {
                            const { test, message } = arg;
                            const extId = test.item.extId;
                            return {
                                test: this.g.get(testId_1.$7I.root(extId))?.collection.tree.get(extId)?.actual
                                    ?? (0, extHostTestItem_1.$wQ)({ $mid: marshallingIds_1.MarshalledId.TestItemContext, tests: [test] }),
                                message: Convert.TestMessage.to(message),
                            };
                        }
                        default: return arg;
                    }
                }
            });
            D.registerCommand(false, 'testing.getExplorerSelection', async () => {
                const inner = await D.executeCommand(constants_1.TestCommandId.GetExplorerSelection);
                const lookup = (i) => {
                    const controller = this.g.get(testId_1.$7I.root(i));
                    if (!controller) {
                        return undefined;
                    }
                    return testId_1.$7I.isRoot(i) ? controller.controller : controller.collection.tree.get(i)?.actual;
                };
                return {
                    include: inner?.include.map(lookup).filter(types_1.$mg) || [],
                    exclude: inner?.exclude.map(lookup).filter(types_1.$mg) || [],
                };
            });
        }
        //#region public API
        /**
         * Implements vscode.test.registerTestProvider
         */
        createTestController(extension, controllerId, label, refreshHandler) {
            if (this.g.has(controllerId)) {
                throw new Error(`Attempt to insert a duplicate controller with ID "${controllerId}"`);
            }
            const disposable = new lifecycle_1.$Tc();
            const collection = disposable.add(new extHostTestItem_1.$zQ(controllerId, label, this.F));
            collection.root.label = label;
            const profiles = new Map();
            const activeProfiles = new Set();
            const proxy = this.h;
            const getCapability = () => {
                let cap = 0;
                if (refreshHandler) {
                    cap |= testTypes_1.TestControllerCapability.Refresh;
                }
                const rcp = info.relatedCodeProvider;
                if (rcp) {
                    if (rcp?.provideRelatedTests) {
                        cap |= testTypes_1.TestControllerCapability.TestRelatedToCode;
                    }
                    if (rcp?.provideRelatedCode) {
                        cap |= testTypes_1.TestControllerCapability.CodeRelatedToTest;
                    }
                }
                return cap;
            };
            const controller = {
                items: collection.root.children,
                get label() {
                    return label;
                },
                set label(value) {
                    label = value;
                    collection.root.label = value;
                    proxy.$updateController(controllerId, { label });
                },
                get refreshHandler() {
                    return refreshHandler;
                },
                set refreshHandler(value) {
                    refreshHandler = value;
                    proxy.$updateController(controllerId, { capabilities: getCapability() });
                },
                get id() {
                    return controllerId;
                },
                get relatedCodeProvider() {
                    return info.relatedCodeProvider;
                },
                set relatedCodeProvider(value) {
                    (0, extensions_1.$gH)(extension, 'testRelatedCode');
                    info.relatedCodeProvider = value;
                    proxy.$updateController(controllerId, { capabilities: getCapability() });
                },
                createRunProfile: (label, group, runHandler, isDefault, tag, supportsContinuousRun) => {
                    // Derive the profile ID from a hash so that the same profile will tend
                    // to have the same hashes, allowing re-run requests to work across reloads.
                    let profileId = (0, hash_1.$tj)(label);
                    while (profiles.has(profileId)) {
                        profileId++;
                    }
                    return new $Aqc(this.h, profiles, activeProfiles, this.w.event, controllerId, profileId, label, group, runHandler, isDefault, tag, supportsContinuousRun);
                },
                createTestItem(id, label, uri) {
                    return new extHostTestItem_1.$xQ(controllerId, id, label, uri);
                },
                createTestRun: (request, name, persist = true) => {
                    return this.j.createTestRun(extension, controllerId, collection, request, name, persist);
                },
                invalidateTestResults: items => {
                    if (items === undefined) {
                        this.h.$markTestRetired(undefined);
                    }
                    else {
                        const itemsArr = items instanceof Array ? items : [items];
                        this.h.$markTestRetired(itemsArr.map(i => testId_1.$7I.fromExtHostTestItem(i, controllerId).toString()));
                    }
                },
                set resolveHandler(fn) {
                    collection.resolveHandler = fn;
                },
                get resolveHandler() {
                    return collection.resolveHandler;
                },
                dispose: () => {
                    disposable.dispose();
                },
            };
            const info = { controller, collection, profiles, extension, activeProfiles };
            proxy.$registerTestController(controllerId, label, getCapability());
            disposable.add((0, lifecycle_1.$Sc)(() => proxy.$unregisterTestController(controllerId)));
            this.g.set(controllerId, info);
            disposable.add((0, lifecycle_1.$Sc)(() => this.g.delete(controllerId)));
            disposable.add(collection.onDidGenerateDiff(diff => proxy.$publishDiff(controllerId, diff.map(testTypes_1.TestsDiffOp.serialize))));
            return controller;
        }
        /**
         * Implements vscode.test.createTestObserver
         */
        createTestObserver() {
            return this.m.checkout();
        }
        /**
         * Implements vscode.test.runTests
         */
        async runTests(req, token = cancellation_1.CancellationToken.None) {
            const profile = tryGetProfileFromTestRunReq(req);
            if (!profile) {
                throw new Error('The request passed to `vscode.test.runTests` must include a profile');
            }
            const controller = this.g.get(profile.controllerId);
            if (!controller) {
                throw new Error('Controller not found');
            }
            await this.h.$runTests({
                preserveFocus: req.preserveFocus ?? true,
                group: profileGroupToBitset[profile.kind],
                targets: [{
                        testIds: req.include?.map(t => testId_1.$7I.fromExtHostTestItem(t, controller.collection.root.id).toString()) ?? [controller.collection.root.id],
                        profileId: profile.profileId,
                        controllerId: profile.controllerId,
                    }],
                exclude: req.exclude?.map(t => t.id),
            }, token);
        }
        /**
         * Implements vscode.test.registerTestFollowupProvider
         */
        registerTestFollowupProvider(provider) {
            this.y.add(provider);
            return { dispose: () => { this.y.delete(provider); } };
        }
        //#endregion
        //#region RPC methods
        /**
         * @inheritdoc
         */
        async $getTestsRelatedToCode(uri, _position, token) {
            const doc = this.F.getDocument(uri_1.URI.revive(uri));
            if (!doc) {
                return [];
            }
            const position = Convert.Position.to(_position);
            const related = [];
            await Promise.all([...this.g.values()].map(async (c) => {
                let tests;
                try {
                    tests = await c.relatedCodeProvider?.provideRelatedTests?.(doc.document, position, token);
                }
                catch (e) {
                    if (!token.isCancellationRequested) {
                        this.C.warn(`Error thrown while providing related tests for ${c.controller.label}`, e);
                    }
                }
                if (tests) {
                    for (const test of tests) {
                        related.push(testId_1.$7I.fromExtHostTestItem(test, c.controller.id).toString());
                    }
                    c.collection.flushDiff();
                }
            }));
            return related;
        }
        /**
         * @inheritdoc
         */
        async $getCodeRelatedToTest(testId, token) {
            const controller = this.g.get(testId_1.$7I.root(testId));
            if (!controller) {
                return [];
            }
            const test = controller.collection.tree.get(testId);
            if (!test) {
                return [];
            }
            const locations = await controller.relatedCodeProvider?.provideRelatedCode?.(test.actual, token);
            return locations?.map(Convert.location.from) ?? [];
        }
        /**
         * @inheritdoc
         */
        $syncTests() {
            for (const { collection } of this.g.values()) {
                collection.flushDiff();
            }
            return Promise.resolve();
        }
        /**
         * @inheritdoc
         */
        async $getCoverageDetails(coverageId, testId, token) {
            const details = await this.j.getCoverageDetails(coverageId, testId, token);
            return details?.map(Convert.TestCoverage.fromDetails);
        }
        /**
         * @inheritdoc
         */
        async $disposeRun(runId) {
            this.j.disposeTestRun(runId);
        }
        /** @inheritdoc */
        $configureRunProfile(controllerId, profileId) {
            this.g.get(controllerId)?.profiles.get(profileId)?.configureHandler?.();
        }
        /** @inheritdoc */
        $setDefaultRunProfiles(profiles) {
            const evt = new Map();
            for (const [controllerId, profileIds] of Object.entries(profiles)) {
                const ctrl = this.g.get(controllerId);
                if (!ctrl) {
                    continue;
                }
                const changes = new Map();
                const added = profileIds.filter(id => !ctrl.activeProfiles.has(id));
                const removed = [...ctrl.activeProfiles].filter(id => !profileIds.includes(id));
                for (const id of added) {
                    changes.set(id, true);
                    ctrl.activeProfiles.add(id);
                }
                for (const id of removed) {
                    changes.set(id, false);
                    ctrl.activeProfiles.delete(id);
                }
                if (changes.size) {
                    evt.set(controllerId, changes);
                }
            }
            this.w.fire(evt);
        }
        /** @inheritdoc */
        async $refreshTests(controllerId, token) {
            await this.g.get(controllerId)?.controller.refreshHandler?.(token);
        }
        /**
         * Updates test results shown to extensions.
         * @override
         */
        $publishTestResults(results) {
            this.results = Object.freeze(results
                .map(r => {
                const o = Convert.TestResults.to(r);
                testResultInternalIDs.set(o, r.id);
                return o;
            })
                .concat(this.results)
                .sort((a, b) => b.completedAt - a.completedAt)
                .slice(0, 32));
            this.f.fire();
        }
        /**
         * Expands the nodes in the test tree. If levels is less than zero, it will
         * be treated as infinite.
         */
        async $expandTest(testId, levels) {
            const collection = this.g.get(testId_1.$7I.fromString(testId).controllerId)?.collection;
            if (collection) {
                await collection.expand(testId, levels < 0 ? Infinity : levels);
                collection.flushDiff();
            }
        }
        /**
         * Receives a test update from the main thread. Called (eventually) whenever
         * tests change.
         */
        $acceptDiff(diff) {
            this.m.applyDiff(diff.map(d => testTypes_1.TestsDiffOp.deserialize({ asCanonicalUri: u => u }, d)));
        }
        /**
         * Runs tests with the given set of IDs. Allows for test from multiple
         * providers to be run.
         * @inheritdoc
         */
        async $runControllerTests(reqs, token) {
            return Promise.all(reqs.map(req => this.G(req, false, token)));
        }
        /**
         * Starts continuous test runs with the given set of IDs. Allows for test from
         * multiple providers to be run.
         * @inheritdoc
         */
        async $startContinuousRun(reqs, token) {
            const cts = new cancellation_1.$we(token);
            const res = await Promise.all(reqs.map(req => this.G(req, true, cts.token)));
            // avoid returning until cancellation is requested, otherwise ipc disposes of the token
            if (!token.isCancellationRequested && !res.some(r => r.error)) {
                await new Promise(r => token.onCancellationRequested(r));
            }
            cts.dispose(true);
            return res;
        }
        /** @inheritdoc */
        async $provideTestFollowups(req, token) {
            const results = this.results.find(r => testResultInternalIDs.get(r) === req.resultId);
            const test = results && findTestInResultSnapshot(testId_1.$7I.fromString(req.extId), results?.results);
            if (!test) {
                return [];
            }
            let followups = [];
            await Promise.all([...this.y].map(async (provider) => {
                try {
                    const r = await provider.provideFollowup(results, test, req.taskIndex, req.messageIndex, token);
                    if (r) {
                        followups = followups.concat(r);
                    }
                }
                catch (e) {
                    this.C.error(`Error thrown while providing followup for test message`, e);
                }
            }));
            if (token.isCancellationRequested) {
                return [];
            }
            return followups.map(command => {
                const id = followupCounter++;
                this.z.set(id, command);
                return { title: command.title, id };
            });
        }
        $disposeTestFollowups(id) {
            for (const i of id) {
                this.z.delete(i);
            }
        }
        $executeTestFollowup(id) {
            const command = this.z.get(id);
            if (!command) {
                return Promise.resolve();
            }
            return this.D.executeCommand(command.command, ...(command.arguments || []));
        }
        /**
         * Cancels an ongoing test run.
         */
        $cancelExtensionTestRun(runId) {
            if (runId === undefined) {
                this.j.cancelAllRuns();
            }
            else {
                this.j.cancelRunById(runId);
            }
        }
        //#endregion
        getMetadataForRun(run) {
            for (const tracker of this.j.trackers) {
                const taskId = tracker.getTaskIdForRun(run);
                if (taskId) {
                    return { taskId, runId: tracker.id };
                }
            }
            return undefined;
        }
        async G(req, isContinuous, token) {
            const lookup = this.g.get(req.controllerId);
            if (!lookup) {
                return {};
            }
            const { collection, profiles, extension } = lookup;
            const profile = profiles.get(req.profileId);
            if (!profile) {
                return {};
            }
            const includeTests = req.testIds
                .map((testId) => collection.tree.get(testId))
                .filter(types_1.$mg);
            const excludeTests = req.excludeExtIds
                .map(id => lookup.collection.tree.get(id))
                .filter(types_1.$mg)
                .filter(exclude => includeTests.some(include => include.fullId.compare(exclude.fullId) === testId_1.TestPosition.IsChild));
            if (!includeTests.length) {
                return {};
            }
            const publicReq = new extHostTypes_1.$pP(includeTests.some(i => i.actual instanceof extHostTestItem_1.$yQ) ? undefined : includeTests.map(t => t.actual), excludeTests.map(t => t.actual), profile, isContinuous);
            const tracker = (0, testTypes_1.$0I)(req) && this.j.prepareForMainThreadTestRun(extension, publicReq, $zqc.fromInternal(req, lookup.collection), profile, token);
            try {
                await profile.runHandler(publicReq, token);
                return {};
            }
            catch (e) {
                return { error: String(e) };
            }
            finally {
                if (tracker) {
                    if (tracker.hasRunningTasks && !token.isCancellationRequested) {
                        await event_1.Event.toPromise(tracker.onEnd);
                    }
                }
            }
        }
    };
    exports.$xqc = $xqc;
    exports.$xqc = $xqc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, log_1.$ak),
        __param(2, extHostCommands_1.$GQ),
        __param(3, extHostDocumentsAndEditors_1.$vQ)
    ], $xqc);
    // Deadline after being requested by a user that a test run is forcibly cancelled.
    const RUN_CANCEL_DEADLINE = 10_000;
    var TestRunTrackerState;
    (function (TestRunTrackerState) {
        // Default state
        TestRunTrackerState[TestRunTrackerState["Running"] = 0] = "Running";
        // Cancellation is requested, but the run is still going.
        TestRunTrackerState[TestRunTrackerState["Cancelling"] = 1] = "Cancelling";
        // All tasks have ended
        TestRunTrackerState[TestRunTrackerState["Ended"] = 2] = "Ended";
    })(TestRunTrackerState || (TestRunTrackerState = {}));
    class TestRunTracker extends lifecycle_1.$Uc {
        /**
         * Gets whether there are any tests running.
         */
        get hasRunningTasks() {
            return this.g > 0;
        }
        /**
         * Gets the run ID.
         */
        get id() {
            return this.C.id;
        }
        constructor(C, D, F, G, H, parentToken) {
            super();
            this.C = C;
            this.D = D;
            this.F = F;
            this.G = G;
            this.H = H;
            this.f = TestRunTrackerState.Running;
            this.g = 0;
            this.h = new Map();
            this.j = new Set();
            this.w = this.B(new event_1.$le());
            this.z = new Map();
            /**
             * Fires when a test ends, and no more tests are left running.
             */
            this.onEnd = this.w.event;
            this.m = this.B(new cancellation_1.$we(parentToken));
            const forciblyEnd = this.B(new async_1.$Rh(() => this.I(), RUN_CANCEL_DEADLINE));
            this.B(this.m.token.onCancellationRequested(() => forciblyEnd.schedule()));
            const didDisposeEmitter = new event_1.$le();
            this.y = didDisposeEmitter.event;
            this.B((0, lifecycle_1.$Sc)(() => {
                didDisposeEmitter.fire();
                didDisposeEmitter.dispose();
            }));
        }
        /** Gets the task ID from a test run object. */
        getTaskIdForRun(run) {
            for (const [taskId, { run: r }] of this.h) {
                if (r === run) {
                    return taskId;
                }
            }
            return undefined;
        }
        /** Requests cancellation of the run. On the second call, forces cancellation. */
        cancel() {
            if (this.f === TestRunTrackerState.Running) {
                this.m.cancel();
                this.f = TestRunTrackerState.Cancelling;
            }
            else if (this.f === TestRunTrackerState.Cancelling) {
                this.I();
            }
        }
        /** Gets details for a previously-emitted coverage object. */
        async getCoverageDetails(id, testId, token) {
            const [, taskId] = testId_1.$7I.fromString(id).path; /** runId, taskId, URI */
            const coverage = this.z.get(id);
            if (!coverage) {
                return [];
            }
            const { report, extIds } = coverage;
            const task = this.h.get(taskId);
            if (!task) {
                throw new Error('unreachable: run task was not found');
            }
            let testItem;
            if (testId && report instanceof extHostTypes_1.$vP) {
                const index = extIds.indexOf(testId);
                if (index === -1) {
                    return []; // ??
                }
                testItem = report.fromTests[index];
            }
            const details = testItem
                ? this.G?.loadDetailedCoverageForTest?.(task.run, report, testItem, token)
                : this.G?.loadDetailedCoverage?.(task.run, report, token);
            return (await details) ?? [];
        }
        /** Creates the public test run interface to give to extensions. */
        createRun(name) {
            const runId = this.C.id;
            const ctrlId = this.C.controllerId;
            const taskId = (0, uuid_1.$2g)();
            const guardTestMutation = (fn) => (test, ...args) => {
                if (ended) {
                    this.F.warn(`Setting the state of test "${test.id}" is a no-op after the run ends.`);
                    return;
                }
                this.L(test);
                fn(test, ...args);
            };
            const appendMessages = (test, messages) => {
                const converted = messages instanceof Array
                    ? messages.map(Convert.TestMessage.from)
                    : [Convert.TestMessage.from(messages)];
                if (test.uri && test.range) {
                    const defaultLocation = { range: Convert.Range.from(test.range), uri: test.uri };
                    for (const message of converted) {
                        message.location = message.location || defaultLocation;
                    }
                }
                this.D.$appendTestMessagesInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString(), converted);
            };
            let ended = false;
            // one-off map used to associate test items with incrementing IDs in `addCoverage`.
            // There's no need to include their entire ID, we just want to make sure they're
            // stable and unique. Normal map is okay since TestRun lifetimes are limited.
            const run = {
                isPersisted: this.C.isPersisted,
                token: this.m.token,
                name,
                onDidDispose: this.y,
                addCoverage: (coverage) => {
                    if (ended) {
                        return;
                    }
                    const fromTests = coverage instanceof extHostTypes_1.$vP ? coverage.fromTests : [];
                    if (fromTests.length) {
                        (0, extensions_1.$gH)(this.H, 'attributableCoverage');
                        for (const test of fromTests) {
                            this.L(test);
                        }
                    }
                    const uriStr = coverage.uri.toString();
                    const id = new testId_1.$7I([runId, taskId, uriStr]).toString();
                    // it's a lil funky, but it's possible for a test item's ID to change after
                    // it's been reported if it's rehomed under a different parent. Record its
                    // ID at the time when the coverage report is generated so we can reference
                    // it later if needeed.
                    this.z.set(id, { report: coverage, extIds: fromTests.map(t => testId_1.$7I.fromExtHostTestItem(t, ctrlId).toString()) });
                    this.D.$appendCoverage(runId, taskId, Convert.TestCoverage.fromFile(ctrlId, id, coverage));
                },
                //#region state mutation
                enqueued: guardTestMutation(test => {
                    this.D.$updateTestStateInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString(), testTypes_1.TestResultState.Queued);
                }),
                skipped: guardTestMutation(test => {
                    this.D.$updateTestStateInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString(), testTypes_1.TestResultState.Skipped);
                }),
                started: guardTestMutation(test => {
                    this.D.$updateTestStateInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString(), testTypes_1.TestResultState.Running);
                }),
                errored: guardTestMutation((test, messages, duration) => {
                    appendMessages(test, messages);
                    this.D.$updateTestStateInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString(), testTypes_1.TestResultState.Errored, duration);
                }),
                failed: guardTestMutation((test, messages, duration) => {
                    appendMessages(test, messages);
                    this.D.$updateTestStateInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString(), testTypes_1.TestResultState.Failed, duration);
                }),
                passed: guardTestMutation((test, duration) => {
                    this.D.$updateTestStateInRun(runId, taskId, testId_1.$7I.fromExtHostTestItem(test, this.C.controllerId).toString(), testTypes_1.TestResultState.Passed, duration);
                }),
                //#endregion
                appendOutput: (output, location, test) => {
                    if (ended) {
                        return;
                    }
                    if (test) {
                        this.L(test);
                    }
                    this.D.$appendOutputToRun(runId, taskId, buffer_1.$Ne.fromString(output), location && Convert.location.from(location), test && testId_1.$7I.fromExtHostTestItem(test, ctrlId).toString());
                },
                end: () => {
                    if (ended) {
                        return;
                    }
                    ended = true;
                    this.D.$finishedTestRunTask(runId, taskId);
                    if (!--this.g) {
                        this.J();
                    }
                }
            };
            this.g++;
            this.h.set(taskId, { run });
            this.D.$startedTestRunTask(runId, { id: taskId, ctrlId: this.C.controllerId, name, running: true });
            return run;
        }
        I() {
            for (const { run } of this.h.values()) {
                run.end();
            }
        }
        J() {
            if (this.f !== TestRunTrackerState.Ended) {
                this.f = TestRunTrackerState.Ended;
                this.w.fire();
            }
        }
        L(test) {
            if (!(test instanceof extHostTestItem_1.$xQ)) {
                throw new testItemCollection_1.$cQ(test.id);
            }
            if (this.j.has(testId_1.$7I.fromExtHostTestItem(test, this.C.controllerId).toString())) {
                return;
            }
            const chain = [];
            const root = this.C.colllection.root;
            while (true) {
                const converted = Convert.TestItem.from(test);
                chain.unshift(converted);
                if (this.j.has(converted.extId)) {
                    break;
                }
                this.j.add(converted.extId);
                if (test === root) {
                    break;
                }
                test = test.parent || root;
            }
            this.D.$addTestsToRun(this.C.controllerId, this.C.id, chain);
        }
        dispose() {
            this.J();
            super.dispose();
        }
    }
    /**
     * Queues runs for a single extension and provides the currently-executing
     * run so that `createTestRun` can be properly correlated.
     */
    class $yqc {
        get trackers() {
            return this.f.values();
        }
        constructor(h, j) {
            this.h = h;
            this.j = j;
            this.f = new Map();
            this.g = new Map();
        }
        /**
         * Gets a coverage report for a given run and task ID.
         */
        getCoverageDetails(id, testId, token) {
            const runId = testId_1.$7I.root(id);
            return this.g.get(runId)?.getCoverageDetails(id, testId, token) || [];
        }
        /**
         * Disposes the test run, called when the main thread is no longer interested
         * in associated data.
         */
        disposeTestRun(runId) {
            this.g.get(runId)?.dispose();
            this.g.delete(runId);
            for (const [req, { id }] of this.f) {
                if (id === runId) {
                    this.f.delete(req);
                }
            }
        }
        /**
         * Registers a request as being invoked by the main thread, so
         * `$startedExtensionTestRun` is not invoked. The run must eventually
         * be cancelled manually.
         */
        prepareForMainThreadTestRun(extension, req, dto, profile, token) {
            return this.k(req, dto, profile, extension, token);
        }
        /**
         * Cancels an existing test run via its cancellation token.
         */
        cancelRunById(runId) {
            this.g.get(runId)?.cancel();
        }
        /**
         * Cancels an existing test run via its cancellation token.
         */
        cancelAllRuns() {
            for (const tracker of this.f.values()) {
                tracker.cancel();
            }
        }
        /**
         * Implements the public `createTestRun` API.
         */
        createTestRun(extension, controllerId, collection, request, name, persist) {
            const existing = this.f.get(request);
            if (existing) {
                return existing.createRun(name);
            }
            // If there is not an existing tracked extension for the request, start
            // a new, detached session.
            const dto = $zqc.fromPublic(controllerId, collection, request, persist);
            const profile = tryGetProfileFromTestRunReq(request);
            this.h.$startedExtensionTestRun({
                controllerId,
                continuous: !!request.continuous,
                profile: profile && { group: profileGroupToBitset[profile.kind], id: profile.profileId },
                exclude: request.exclude?.map(t => testId_1.$7I.fromExtHostTestItem(t, collection.root.id).toString()) ?? [],
                id: dto.id,
                include: request.include?.map(t => testId_1.$7I.fromExtHostTestItem(t, collection.root.id).toString()) ?? [collection.root.id],
                preserveFocus: request.preserveFocus ?? true,
                persist
            });
            const tracker = this.k(request, dto, request.profile, extension);
            event_1.Event.once(tracker.onEnd)(() => {
                this.h.$finishedExtensionTestRun(dto.id);
            });
            return tracker.createRun(name);
        }
        k(req, dto, profile, extension, token) {
            const tracker = new TestRunTracker(dto, this.h, this.j, profile, extension, token);
            this.f.set(req, tracker);
            this.g.set(tracker.id, tracker);
            return tracker;
        }
    }
    exports.$yqc = $yqc;
    const tryGetProfileFromTestRunReq = (request) => {
        if (!request.profile) {
            return undefined;
        }
        if (!(request.profile instanceof $Aqc)) {
            throw new Error(`TestRunRequest.profile is not an instance created from TestController.createRunProfile`);
        }
        return request.profile;
    };
    class $zqc {
        static fromPublic(controllerId, collection, request, persist) {
            return new $zqc(controllerId, (0, uuid_1.$2g)(), persist, collection);
        }
        static fromInternal(request, collection) {
            return new $zqc(request.controllerId, request.runId, true, collection);
        }
        constructor(controllerId, id, isPersisted, colllection) {
            this.controllerId = controllerId;
            this.id = id;
            this.isPersisted = isPersisted;
            this.colllection = colllection;
        }
    }
    exports.$zqc = $zqc;
    class MirroredChangeCollector {
        get isEmpty() {
            return this.f.size === 0 && this.h.size === 0 && this.g.size === 0;
        }
        constructor(k) {
            this.k = k;
            this.f = new Set();
            this.g = new Set();
            this.h = new Set();
            this.j = new Set();
        }
        /**
         * @inheritdoc
         */
        add(node) {
            this.f.add(node);
        }
        /**
         * @inheritdoc
         */
        update(node) {
            Object.assign(node.revived, Convert.TestItem.toPlain(node.item));
            if (!this.f.has(node)) {
                this.g.add(node);
            }
        }
        /**
         * @inheritdoc
         */
        remove(node) {
            if (this.f.has(node)) {
                this.f.delete(node);
                return;
            }
            this.g.delete(node);
            const parentId = testId_1.$7I.parentId(node.item.extId);
            if (parentId && this.j.has(parentId.toString())) {
                this.j.add(node.item.extId);
                return;
            }
            this.h.add(node);
        }
        /**
         * @inheritdoc
         */
        getChangeEvent() {
            const { f: added, g: updated, h: removed } = this;
            return {
                get added() { return [...added].map(n => n.revived); },
                get updated() { return [...updated].map(n => n.revived); },
                get removed() { return [...removed].map(n => n.revived); },
            };
        }
        complete() {
            if (!this.isEmpty) {
                this.k.fire(this.getChangeEvent());
            }
        }
    }
    /**
     * Maintains tests in this extension host sent from the main thread.
     * @private
     */
    class MirroredTestCollection extends testTypes_1.$dJ {
        constructor() {
            super(...arguments);
            this.z = new event_1.$le();
            /**
             * Change emitter that fires with the same semantics as `TestObserver.onDidChangeTests`.
             */
            this.onDidChangeTests = this.z.event;
        }
        /**
         * Gets a list of root test items.
         */
        get rootTests() {
            return this.h;
        }
        /**
         *
         * If the test ID exists, returns its underlying ID.
         */
        getMirroredTestDataById(itemId) {
            return this.g.get(itemId);
        }
        /**
         * If the test item is a mirrored test item, returns its underlying ID.
         */
        getMirroredTestDataByReference(item) {
            return this.g.get(item.id);
        }
        /**
         * @override
         */
        y(item, parent) {
            return {
                ...item,
                // todo@connor4312: make this work well again with children
                revived: Convert.TestItem.toPlain(item.item),
                depth: parent ? parent.depth + 1 : 0,
                children: new Set(),
            };
        }
        /**
         * @override
         */
        x() {
            return new MirroredChangeCollector(this.z);
        }
    }
    class TestObservers {
        constructor(g) {
            this.g = g;
        }
        checkout() {
            if (!this.f) {
                this.f = this.h();
            }
            const current = this.f;
            current.observers++;
            return {
                onDidChangeTest: current.tests.onDidChangeTests,
                get tests() { return [...current.tests.rootTests].map(t => t.revived); },
                dispose: (0, functional_1.$cb)(() => {
                    if (--current.observers === 0) {
                        this.g.$unsubscribeFromDiffs();
                        this.f = undefined;
                    }
                }),
            };
        }
        /**
         * Gets the internal test data by its reference.
         */
        getMirroredTestDataByReference(ref) {
            return this.f?.tests.getMirroredTestDataByReference(ref);
        }
        /**
         * Applies test diffs to the current set of observed tests.
         */
        applyDiff(diff) {
            this.f?.tests.apply(diff);
        }
        h() {
            const tests = new MirroredTestCollection({ asCanonicalUri: u => u });
            this.g.$subscribeToDiffs();
            return { observers: 0, tests, };
        }
    }
    const updateProfile = (impl, proxy, initial, update) => {
        if (initial) {
            Object.assign(initial, update);
        }
        else {
            proxy.$updateTestRunConfig(impl.controllerId, impl.profileId, update);
        }
    };
    class $Aqc {
        #proxy;
        #activeProfiles;
        #onDidChangeDefaultProfiles;
        #initialPublish;
        #profiles;
        get label() {
            return this.g;
        }
        set label(label) {
            if (label !== this.g) {
                this.g = label;
                updateProfile(this, this.#proxy, this.#initialPublish, { label });
            }
        }
        get supportsContinuousRun() {
            return this.h;
        }
        set supportsContinuousRun(supports) {
            if (supports !== this.h) {
                this.h = supports;
                updateProfile(this, this.#proxy, this.#initialPublish, { supportsContinuousRun: supports });
            }
        }
        get isDefault() {
            return this.#activeProfiles.has(this.profileId);
        }
        set isDefault(isDefault) {
            if (isDefault !== this.isDefault) {
                // #activeProfiles is synced from the main thread, so we can make
                // provisional changes here that will get confirmed momentarily
                if (isDefault) {
                    this.#activeProfiles.add(this.profileId);
                }
                else {
                    this.#activeProfiles.delete(this.profileId);
                }
                updateProfile(this, this.#proxy, this.#initialPublish, { isDefault });
            }
        }
        get tag() {
            return this._tag;
        }
        set tag(tag) {
            if (tag?.id !== this._tag?.id) {
                this._tag = tag;
                updateProfile(this, this.#proxy, this.#initialPublish, {
                    tag: tag ? Convert.TestTag.namespace(this.controllerId, tag.id) : null,
                });
            }
        }
        get configureHandler() {
            return this.f;
        }
        set configureHandler(handler) {
            if (handler !== this.f) {
                this.f = handler;
                updateProfile(this, this.#proxy, this.#initialPublish, { hasConfigurationHandler: !!handler });
            }
        }
        get onDidChangeDefault() {
            return event_1.Event.chain(this.#onDidChangeDefaultProfiles, $ => $
                .map(ev => ev.get(this.controllerId)?.get(this.profileId))
                .filter(types_1.$mg));
        }
        constructor(proxy, profiles, activeProfiles, onDidChangeActiveProfiles, controllerId, profileId, g, kind, runHandler, _isDefault = false, _tag = undefined, h = false) {
            this.controllerId = controllerId;
            this.profileId = profileId;
            this.g = g;
            this.kind = kind;
            this.runHandler = runHandler;
            this._tag = _tag;
            this.h = h;
            this.#proxy = proxy;
            this.#profiles = profiles;
            this.#activeProfiles = activeProfiles;
            this.#onDidChangeDefaultProfiles = onDidChangeActiveProfiles;
            profiles.set(profileId, this);
            const groupBitset = profileGroupToBitset[kind];
            if (typeof groupBitset !== 'number') {
                throw new Error(`Unknown TestRunProfile.group ${kind}`);
            }
            if (_isDefault) {
                activeProfiles.add(profileId);
            }
            this.#initialPublish = {
                profileId: profileId,
                controllerId,
                tag: _tag ? Convert.TestTag.namespace(this.controllerId, _tag.id) : null,
                label: g,
                group: groupBitset,
                isDefault: _isDefault,
                hasConfigurationHandler: false,
                supportsContinuousRun: h,
            };
            // we send the initial profile publish out on the next microtask so that
            // initially setting the isDefault value doesn't overwrite a user-configured value
            queueMicrotask(() => {
                if (this.#initialPublish) {
                    this.#proxy.$publishTestRunProfile(this.#initialPublish);
                    this.#initialPublish = undefined;
                }
            });
        }
        dispose() {
            if (this.#profiles?.delete(this.profileId)) {
                this.#profiles = undefined;
                this.#proxy.$removeTestProfile(this.controllerId, this.profileId);
            }
            this.#initialPublish = undefined;
        }
    }
    exports.$Aqc = $Aqc;
    const profileGroupToBitset = {
        [extHostTypes_1.TestRunProfileKind.Coverage]: testTypes_1.TestRunProfileBitset.Coverage,
        [extHostTypes_1.TestRunProfileKind.Debug]: testTypes_1.TestRunProfileBitset.Debug,
        [extHostTypes_1.TestRunProfileKind.Run]: testTypes_1.TestRunProfileBitset.Run,
    };
    function findTestInResultSnapshot(extId, snapshot) {
        for (let i = 0; i < extId.path.length; i++) {
            const item = snapshot.find(s => s.id === extId.path[i]);
            if (!item) {
                return undefined;
            }
            if (i === extId.path.length - 1) {
                return item;
            }
            snapshot = item.children;
        }
        return undefined;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[259/*vs/workbench/api/common/extHostTextEditors*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,5/*vs/workbench/api/common/extHost.protocol*/,127/*vs/workbench/api/common/extHostTextEditor*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, arrays, event_1, lifecycle_1, extHost_protocol_1, extHostTextEditor_1, TypeConverters, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Hpc = void 0;
    arrays = __importStar(arrays);
    TypeConverters = __importStar(TypeConverters);
    class $Hpc extends lifecycle_1.$Uc {
        constructor(mainContext, m) {
            super();
            this.m = m;
            this.a = new event_1.$le();
            this.b = new event_1.$le();
            this.c = new event_1.$le();
            this.f = new event_1.$le();
            this.g = new event_1.$le();
            this.h = new event_1.$le();
            this.onDidChangeTextEditorSelection = this.a.event;
            this.onDidChangeTextEditorOptions = this.b.event;
            this.onDidChangeTextEditorVisibleRanges = this.c.event;
            this.onDidChangeTextEditorViewColumn = this.f.event;
            this.onDidChangeActiveTextEditor = this.g.event;
            this.onDidChangeVisibleTextEditors = this.h.event;
            this.j = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadTextEditors);
            this.B(this.m.onDidChangeVisibleTextEditors(e => this.h.fire(e)));
            this.B(this.m.onDidChangeActiveTextEditor(e => this.g.fire(e)));
        }
        getActiveTextEditor() {
            return this.m.activeEditor();
        }
        getVisibleTextEditors(internal) {
            const editors = this.m.allEditors();
            return internal
                ? editors
                : editors.map(editor => editor.value);
        }
        async showTextDocument(document, columnOrOptions, preserveFocus) {
            let options;
            if (typeof columnOrOptions === 'number') {
                options = {
                    position: TypeConverters.ViewColumn.from(columnOrOptions),
                    preserveFocus
                };
            }
            else if (typeof columnOrOptions === 'object') {
                options = {
                    position: TypeConverters.ViewColumn.from(columnOrOptions.viewColumn),
                    preserveFocus: columnOrOptions.preserveFocus,
                    selection: typeof columnOrOptions.selection === 'object' ? TypeConverters.Range.from(columnOrOptions.selection) : undefined,
                    pinned: typeof columnOrOptions.preview === 'boolean' ? !columnOrOptions.preview : undefined
                };
            }
            else {
                options = {
                    preserveFocus: false
                };
            }
            const editorId = await this.j.$tryShowTextDocument(document.uri, options);
            const editor = editorId && this.m.getEditor(editorId);
            if (editor) {
                return editor.value;
            }
            // we have no editor... having an id means that we had an editor
            // on the main side and that it isn't the current editor anymore...
            if (editorId) {
                throw new Error(`Could NOT open editor for "${document.uri.toString()}" because another editor opened in the meantime.`);
            }
            else {
                throw new Error(`Could NOT open editor for "${document.uri.toString()}".`);
            }
        }
        createTextEditorDecorationType(extension, options) {
            return new extHostTextEditor_1.$rQ(this.j, extension, options).value;
        }
        // --- called from main thread
        $acceptEditorPropertiesChanged(id, data) {
            const textEditor = this.m.getEditor(id);
            if (!textEditor) {
                throw new Error('unknown text editor');
            }
            // (1) set all properties
            if (data.options) {
                textEditor._acceptOptions(data.options);
            }
            if (data.selections) {
                const selections = data.selections.selections.map(TypeConverters.Selection.to);
                textEditor._acceptSelections(selections);
            }
            if (data.visibleRanges) {
                const visibleRanges = arrays.$Gb(data.visibleRanges.map(TypeConverters.Range.to));
                textEditor._acceptVisibleRanges(visibleRanges);
            }
            // (2) fire change events
            if (data.options) {
                this.b.fire({
                    textEditor: textEditor.value,
                    options: { ...data.options, lineNumbers: TypeConverters.TextEditorLineNumbersStyle.to(data.options.lineNumbers) }
                });
            }
            if (data.selections) {
                const kind = extHostTypes_1.TextEditorSelectionChangeKind.fromValue(data.selections.source);
                const selections = data.selections.selections.map(TypeConverters.Selection.to);
                this.a.fire({
                    textEditor: textEditor.value,
                    selections,
                    kind
                });
            }
            if (data.visibleRanges) {
                const visibleRanges = arrays.$Gb(data.visibleRanges.map(TypeConverters.Range.to));
                this.c.fire({
                    textEditor: textEditor.value,
                    visibleRanges
                });
            }
        }
        $acceptEditorPositionData(data) {
            for (const id in data) {
                const textEditor = this.m.getEditor(id);
                if (!textEditor) {
                    throw new Error('Unknown text editor');
                }
                const viewColumn = TypeConverters.ViewColumn.to(data[id]);
                if (textEditor.value.viewColumn !== viewColumn) {
                    textEditor._acceptViewColumn(viewColumn);
                    this.f.fire({ textEditor: textEditor.value, viewColumn });
                }
            }
        }
        getDiffInformation(id) {
            return Promise.resolve(this.j.$getDiffInformation(id));
        }
    }
    exports.$Hpc = $Hpc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[260/*vs/workbench/api/common/extHostTimeline*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,5/*vs/workbench/api/common/extHost.protocol*/,4/*vs/base/common/lifecycle*/,7/*vs/workbench/api/common/extHostTypes*/,8/*vs/workbench/api/common/extHostTypeConverters*/,18/*vs/platform/extensions/common/extensions*/,37/*vs/base/common/marshallingIds*/,14/*vs/base/common/types*/]), function (require, exports, uri_1, instantiation_1, extHost_protocol_1, lifecycle_1, extHostTypes_1, extHostTypeConverters_1, extensions_1, marshallingIds_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$trc = exports.$src = void 0;
    exports.$src = (0, instantiation_1.$Fi)('IExtHostTimeline');
    class $trc {
        constructor(mainContext, commands) {
            this.b = new Map();
            this.c = new Map();
            this.a = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadTimeline);
            commands.registerArgumentProcessor({
                processArgument: (arg, extension) => {
                    if (arg && arg.$mid === marshallingIds_1.MarshalledId.TimelineActionContext) {
                        if (this.b.get(arg.source) && extensions_1.$rn.equals(extension, this.b.get(arg.source)?.extension)) {
                            const uri = arg.uri === undefined ? undefined : uri_1.URI.revive(arg.uri);
                            return this.c.get(arg.source)?.get(getUriKey(uri))?.get(arg.handle);
                        }
                        else {
                            return undefined;
                        }
                    }
                    return arg;
                }
            });
        }
        async $getTimeline(id, uri, options, token) {
            const item = this.b.get(id);
            return item?.provider.provideTimeline(uri_1.URI.revive(uri), options, token);
        }
        registerTimelineProvider(scheme, provider, extensionId, commandConverter) {
            const timelineDisposables = new lifecycle_1.$Tc();
            const convertTimelineItem = this.d(provider.id, commandConverter, timelineDisposables).bind(this);
            let disposable;
            if (provider.onDidChange) {
                disposable = provider.onDidChange(e => this.a.$emitTimelineChangeEvent({ uri: undefined, reset: true, ...e, id: provider.id }), this);
            }
            const itemsBySourceAndUriMap = this.c;
            return this.f({
                ...provider,
                scheme: scheme,
                onDidChange: undefined,
                async provideTimeline(uri, options, token) {
                    if (options?.resetCache) {
                        timelineDisposables.clear();
                        // For now, only allow the caching of a single Uri
                        // itemsBySourceAndUriMap.get(provider.id)?.get(getUriKey(uri))?.clear();
                        itemsBySourceAndUriMap.get(provider.id)?.clear();
                    }
                    const result = await provider.provideTimeline(uri, options, token);
                    if (result === undefined || result === null) {
                        return undefined;
                    }
                    // TODO: Should we bother converting all the data if we aren't caching? Meaning it is being requested by an extension?
                    const convertItem = convertTimelineItem(uri, options);
                    return {
                        ...result,
                        source: provider.id,
                        items: result.items.map(convertItem)
                    };
                },
                dispose() {
                    for (const sourceMap of itemsBySourceAndUriMap.values()) {
                        sourceMap.get(provider.id)?.clear();
                    }
                    disposable?.dispose();
                    timelineDisposables.dispose();
                }
            }, extensionId);
        }
        d(source, commandConverter, disposables) {
            return (uri, options) => {
                let items;
                if (options?.cacheResults) {
                    let itemsByUri = this.c.get(source);
                    if (itemsByUri === undefined) {
                        itemsByUri = new Map();
                        this.c.set(source, itemsByUri);
                    }
                    const uriKey = getUriKey(uri);
                    items = itemsByUri.get(uriKey);
                    if (items === undefined) {
                        items = new Map();
                        itemsByUri.set(uriKey, items);
                    }
                }
                return (item) => {
                    const { iconPath, ...props } = item;
                    const handle = `${source}|${item.id ?? item.timestamp}`;
                    items?.set(handle, item);
                    let icon;
                    let iconDark;
                    let themeIcon;
                    if (item.iconPath) {
                        if (iconPath instanceof extHostTypes_1.$LO) {
                            themeIcon = { id: iconPath.id, color: iconPath.color };
                        }
                        else if (uri_1.URI.isUri(iconPath)) {
                            icon = iconPath;
                            iconDark = iconPath;
                        }
                        else {
                            ({ light: icon, dark: iconDark } = iconPath);
                        }
                    }
                    let tooltip;
                    if (extHostTypes_1.$eO.isMarkdownString(props.tooltip)) {
                        tooltip = extHostTypeConverters_1.MarkdownString.from(props.tooltip);
                    }
                    else if ((0, types_1.$eg)(props.tooltip)) {
                        tooltip = props.tooltip;
                    }
                    // TODO @jkearl, remove once migration complete.
                    else if (extHostTypes_1.$eO.isMarkdownString(props.detail)) {
                        console.warn('Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip');
                        tooltip = extHostTypeConverters_1.MarkdownString.from(props.detail);
                    }
                    else if ((0, types_1.$eg)(props.detail)) {
                        console.warn('Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip');
                        tooltip = props.detail;
                    }
                    return {
                        ...props,
                        id: props.id ?? undefined,
                        handle: handle,
                        source: source,
                        command: item.command ? commandConverter.toInternal(item.command, disposables) : undefined,
                        icon: icon,
                        iconDark: iconDark,
                        themeIcon: themeIcon,
                        tooltip,
                        accessibilityInformation: item.accessibilityInformation
                    };
                };
            };
        }
        f(provider, extension) {
            // console.log(`ExtHostTimeline#registerTimelineProvider: id=${provider.id}`);
            const existing = this.b.get(provider.id);
            if (existing) {
                throw new Error(`Timeline Provider ${provider.id} already exists.`);
            }
            this.a.$registerTimelineProvider({
                id: provider.id,
                label: provider.label,
                scheme: provider.scheme
            });
            this.b.set(provider.id, { provider, extension });
            return (0, lifecycle_1.$Sc)(() => {
                for (const sourceMap of this.c.values()) {
                    sourceMap.get(provider.id)?.clear();
                }
                this.b.delete(provider.id);
                this.a.$unregisterTimelineProvider(provider.id);
                provider.dispose();
            });
        }
    }
    exports.$trc = $trc;
    function getUriKey(uri) {
        return uri?.toString();
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[261/*vs/workbench/api/common/extHostTreeViews*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,192/*vs/workbench/common/views*/,10/*vs/base/common/async*/,7/*vs/workbench/api/common/extHostTypes*/,14/*vs/base/common/types*/,17/*vs/base/common/arrays*/,8/*vs/workbench/api/common/extHostTypeConverters*/,59/*vs/base/common/htmlContent*/,21/*vs/base/common/cancellation*/,163/*vs/editor/common/services/treeViewsDnd*/,24/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, nls_1, resources_1, uri_1, event_1, lifecycle_1, views_1, async_1, extHostTypes, types_1, arrays_1, extHostTypeConverters_1, htmlContent_1, cancellation_1, treeViewsDnd_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$urc = void 0;
    extHostTypes = __importStar(extHostTypes);
    function toTreeItemLabel(label, extension) {
        if ((0, types_1.$eg)(label)) {
            return { label };
        }
        if (label
            && typeof label === 'object'
            && typeof label.label === 'string') {
            let highlights = undefined;
            if (Array.isArray(label.highlights)) {
                highlights = label.highlights.filter((highlight => highlight.length === 2 && typeof highlight[0] === 'number' && typeof highlight[1] === 'number'));
                highlights = highlights.length ? highlights : undefined;
            }
            return { label: label.label, highlights };
        }
        return undefined;
    }
    class $urc extends lifecycle_1.$Uc {
        constructor(f, g, h) {
            super();
            this.f = f;
            this.g = g;
            this.h = h;
            this.a = new Map();
            this.b = new treeViewsDnd_1.$r_();
            function isTreeViewConvertableItem(arg) {
                return arg && arg.$treeViewId && (arg.$treeItemHandle || arg.$selectedTreeItems || arg.$focusedTreeItem);
            }
            g.registerArgumentProcessor({
                processArgument: arg => {
                    if (isTreeViewConvertableItem(arg)) {
                        return this.r(arg);
                    }
                    else if (Array.isArray(arg) && (arg.length > 0)) {
                        return arg.map(item => {
                            if (isTreeViewConvertableItem(item)) {
                                return this.r(item);
                            }
                            return item;
                        });
                    }
                    return arg;
                }
            });
        }
        registerTreeDataProvider(id, treeDataProvider, extension) {
            const treeView = this.createTreeView(id, { treeDataProvider }, extension);
            return { dispose: () => treeView.dispose() };
        }
        createTreeView(viewId, options, extension) {
            if (!options || !options.treeDataProvider) {
                throw new Error('Options with treeDataProvider is mandatory');
            }
            const dropMimeTypes = options.dragAndDropController?.dropMimeTypes ?? [];
            const dragMimeTypes = options.dragAndDropController?.dragMimeTypes ?? [];
            const hasHandleDrag = !!options.dragAndDropController?.handleDrag;
            const hasHandleDrop = !!options.dragAndDropController?.handleDrop;
            const treeView = this.m(viewId, options, extension);
            const proxyOptions = { showCollapseAll: !!options.showCollapseAll, canSelectMany: !!options.canSelectMany, dropMimeTypes, dragMimeTypes, hasHandleDrag, hasHandleDrop, manuallyManageCheckboxes: !!options.manageCheckboxStateManually };
            const registerPromise = this.f.$registerTreeViewDataProvider(viewId, proxyOptions);
            const view = {
                get onDidCollapseElement() { return treeView.onDidCollapseElement; },
                get onDidExpandElement() { return treeView.onDidExpandElement; },
                get selection() { return treeView.selectedElements; },
                get onDidChangeSelection() { return treeView.onDidChangeSelection; },
                get activeItem() {
                    (0, extensions_1.$gH)(extension, 'treeViewActiveItem');
                    return treeView.focusedElement;
                },
                get onDidChangeActiveItem() {
                    (0, extensions_1.$gH)(extension, 'treeViewActiveItem');
                    return treeView.onDidChangeActiveItem;
                },
                get visible() { return treeView.visible; },
                get onDidChangeVisibility() { return treeView.onDidChangeVisibility; },
                get onDidChangeCheckboxState() {
                    return treeView.onDidChangeCheckboxState;
                },
                get message() { return treeView.message; },
                set message(message) {
                    if ((0, htmlContent_1.$6k)(message)) {
                        (0, extensions_1.$gH)(extension, 'treeViewMarkdownMessage');
                    }
                    treeView.message = message;
                },
                get title() { return treeView.title; },
                set title(title) {
                    treeView.title = title;
                },
                get description() {
                    return treeView.description;
                },
                set description(description) {
                    treeView.description = description;
                },
                get badge() {
                    return treeView.badge;
                },
                set badge(badge) {
                    if ((badge !== undefined) && extHostTypes.ViewBadge.isViewBadge(badge)) {
                        treeView.badge = {
                            value: Math.floor(Math.abs(badge.value)),
                            tooltip: badge.tooltip
                        };
                    }
                    else if (badge === undefined) {
                        treeView.badge = undefined;
                    }
                },
                reveal: (element, options) => {
                    return treeView.reveal(element, options);
                },
                dispose: async () => {
                    // Wait for the registration promise to finish before doing the dispose.
                    await registerPromise;
                    this.a.delete(viewId);
                    treeView.dispose();
                }
            };
            this.B(view);
            return view;
        }
        $getChildren(treeViewId, treeItemHandle) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                return Promise.reject(new views_1.$CG(treeViewId));
            }
            return treeView.getChildren(treeItemHandle);
        }
        async $handleDrop(destinationViewId, requestId, treeDataTransferDTO, targetItemHandle, token, operationUuid, sourceViewId, sourceTreeItemHandles) {
            const treeView = this.a.get(destinationViewId);
            if (!treeView) {
                return Promise.reject(new views_1.$CG(destinationViewId));
            }
            const treeDataTransfer = extHostTypeConverters_1.DataTransfer.toDataTransfer(treeDataTransferDTO, async (dataItemIndex) => {
                return (await this.f.$resolveDropFileData(destinationViewId, requestId, dataItemIndex)).buffer;
            });
            if ((sourceViewId === destinationViewId) && sourceTreeItemHandles) {
                await this.j(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid);
            }
            return treeView.onDrop(treeDataTransfer, targetItemHandle, token);
        }
        async j(treeDataTransfer, treeView, sourceTreeItemHandles, token, operationUuid) {
            const existingTransferOperation = this.b.removeDragOperationTransfer(operationUuid);
            if (existingTransferOperation) {
                (await existingTransferOperation)?.forEach((value, key) => {
                    if (value) {
                        treeDataTransfer.set(key, value);
                    }
                });
            }
            else if (operationUuid && treeView.handleDrag) {
                const willDropPromise = treeView.handleDrag(sourceTreeItemHandles, treeDataTransfer, token);
                this.b.addDragOperationTransfer(operationUuid, willDropPromise);
                await willDropPromise;
            }
            return treeDataTransfer;
        }
        async $handleDrag(sourceViewId, sourceTreeItemHandles, operationUuid, token) {
            const treeView = this.a.get(sourceViewId);
            if (!treeView) {
                return Promise.reject(new views_1.$CG(sourceViewId));
            }
            const treeDataTransfer = await this.j(new extHostTypes.$HO(), treeView, sourceTreeItemHandles, token, operationUuid);
            if (!treeDataTransfer || token.isCancellationRequested) {
                return;
            }
            return extHostTypeConverters_1.DataTransfer.from(treeDataTransfer);
        }
        async $hasResolve(treeViewId) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                throw new views_1.$CG(treeViewId);
            }
            return treeView.hasResolve;
        }
        $resolve(treeViewId, treeItemHandle, token) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                throw new views_1.$CG(treeViewId);
            }
            return treeView.resolveTreeItem(treeItemHandle, token);
        }
        $setExpanded(treeViewId, treeItemHandle, expanded) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                throw new views_1.$CG(treeViewId);
            }
            treeView.setExpanded(treeItemHandle, expanded);
        }
        $setSelectionAndFocus(treeViewId, selectedHandles, focusedHandle) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                throw new views_1.$CG(treeViewId);
            }
            treeView.setSelectionAndFocus(selectedHandles, focusedHandle);
        }
        $setVisible(treeViewId, isVisible) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                if (!isVisible) {
                    return;
                }
                throw new views_1.$CG(treeViewId);
            }
            treeView.setVisible(isVisible);
        }
        $changeCheckboxState(treeViewId, checkboxUpdate) {
            const treeView = this.a.get(treeViewId);
            if (!treeView) {
                throw new views_1.$CG(treeViewId);
            }
            treeView.setCheckboxState(checkboxUpdate);
        }
        m(id, options, extension) {
            const treeView = this.B(new ExtHostTreeView(id, options, this.f, this.g.converter, this.h, extension));
            this.a.set(id, treeView);
            return treeView;
        }
        r(arg) {
            const treeView = this.a.get(arg.$treeViewId);
            if (treeView && '$treeItemHandle' in arg) {
                return treeView.getExtensionElement(arg.$treeItemHandle);
            }
            if (treeView && '$focusedTreeItem' in arg && arg.$focusedTreeItem) {
                return treeView.focusedElement;
            }
            return null;
        }
    }
    exports.$urc = $urc;
    class ExtHostTreeView extends lifecycle_1.$Uc {
        static { this.a = '0'; }
        static { this.b = '1'; }
        get visible() { return this.r; }
        get selectedElements() { return this.s.map(handle => this.getExtensionElement(handle)).filter(element => !(0, types_1.$ng)(element)); }
        get focusedElement() { return (this.t ? this.getExtensionElement(this.t) : undefined); }
        constructor(I, options, J, L, M, N) {
            super();
            this.I = I;
            this.J = J;
            this.L = L;
            this.M = M;
            this.N = N;
            this.h = undefined;
            this.j = new Map();
            this.m = new Map();
            this.r = false;
            this.s = [];
            this.t = undefined;
            this.u = this.B(new event_1.$le());
            this.onDidExpandElement = this.u.event;
            this.w = this.B(new event_1.$le());
            this.onDidCollapseElement = this.w.event;
            this.y = this.B(new event_1.$le());
            this.onDidChangeSelection = this.y.event;
            this.z = this.B(new event_1.$le());
            this.onDidChangeActiveItem = this.z.event;
            this.C = this.B(new event_1.$le());
            this.onDidChangeVisibility = this.C.event;
            this.D = this.B(new event_1.$le());
            this.onDidChangeCheckboxState = this.D.event;
            this.F = this.B(new event_1.$le());
            this.G = Promise.resolve();
            this.H = Promise.resolve();
            this.O = '';
            this.P = '';
            this.Z = new cancellation_1.$we();
            if (N.contributes && N.contributes.views) {
                for (const location in N.contributes.views) {
                    for (const view of N.contributes.views[location]) {
                        if (view.id === I) {
                            this.P = view.name;
                        }
                    }
                }
            }
            this.f = options.treeDataProvider;
            this.g = options.dragAndDropController;
            if (this.f.onDidChangeTreeData) {
                this.B(this.f.onDidChangeTreeData(elementOrElements => {
                    if (Array.isArray(elementOrElements) && elementOrElements.length === 0) {
                        return;
                    }
                    this.F.fire({ message: false, element: elementOrElements });
                }));
            }
            let refreshingPromise;
            let promiseCallback;
            const onDidChangeData = event_1.Event.debounce(this.F.event, (result, current) => {
                if (!result) {
                    result = { message: false, elements: [] };
                }
                if (current.element !== false) {
                    if (!refreshingPromise) {
                        // New refresh has started
                        refreshingPromise = new Promise(c => promiseCallback = c);
                        this.G = this.G.then(() => refreshingPromise);
                    }
                    if (Array.isArray(current.element)) {
                        result.elements.push(...current.element);
                    }
                    else {
                        result.elements.push(current.element);
                    }
                }
                if (current.message) {
                    result.message = true;
                }
                return result;
            }, 200, true);
            this.B(onDidChangeData(({ message, elements }) => {
                if (elements.length) {
                    this.H = this.H.then(() => {
                        const _promiseCallback = promiseCallback;
                        refreshingPromise = null;
                        return this.$(elements).then(() => _promiseCallback());
                    });
                }
                if (message) {
                    this.J.$setMessage(this.I, extHostTypeConverters_1.MarkdownString.fromStrict(this.O) ?? '');
                }
            }));
        }
        async getChildren(parentHandle) {
            const parentElement = parentHandle ? this.getExtensionElement(parentHandle) : undefined;
            if (parentHandle && !parentElement) {
                this.M.error(`No tree item with id \'${parentHandle}\' found.`);
                return Promise.resolve([]);
            }
            let childrenNodes = this.X(parentHandle); // Get it from cache
            if (!childrenNodes) {
                childrenNodes = await this.Y(parentElement);
            }
            return childrenNodes ? childrenNodes.map(n => n.item) : undefined;
        }
        getExtensionElement(treeItemHandle) {
            return this.j.get(treeItemHandle);
        }
        reveal(element, options) {
            options = options ? options : { select: true, focus: false };
            const select = (0, types_1.$ng)(options.select) ? true : options.select;
            const focus = (0, types_1.$ng)(options.focus) ? false : options.focus;
            const expand = (0, types_1.$ng)(options.expand) ? false : options.expand;
            if (typeof this.f.getParent !== 'function') {
                return Promise.reject(new Error(`Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method`));
            }
            if (element) {
                return this.G
                    .then(() => this.S(element))
                    .then(parentChain => this.W(element, parentChain[parentChain.length - 1])
                    .then(treeNode => this.J.$reveal(this.I, { item: treeNode.item, parentChain: parentChain.map(p => p.item) }, { select, focus, expand })), error => this.M.error(error));
            }
            else {
                return this.J.$reveal(this.I, undefined, { select, focus, expand });
            }
        }
        get message() {
            return this.O;
        }
        set message(message) {
            this.O = message;
            this.F.fire({ message: true, element: false });
        }
        get title() {
            return this.P;
        }
        set title(title) {
            this.P = title;
            this.J.$setTitle(this.I, title, this.Q);
        }
        get description() {
            return this.Q;
        }
        set description(description) {
            this.Q = description;
            this.J.$setTitle(this.I, this.P, description);
        }
        get badge() {
            return this.R;
        }
        set badge(badge) {
            if (this.R?.value === badge?.value &&
                this.R?.tooltip === badge?.tooltip) {
                return;
            }
            this.R = extHostTypeConverters_1.ViewBadge.from(badge);
            this.J.$setBadge(this.I, badge);
        }
        setExpanded(treeItemHandle, expanded) {
            const element = this.getExtensionElement(treeItemHandle);
            if (element) {
                if (expanded) {
                    this.u.fire(Object.freeze({ element }));
                }
                else {
                    this.w.fire(Object.freeze({ element }));
                }
            }
        }
        setSelectionAndFocus(selectedHandles, focusedHandle) {
            const changedSelection = !(0, arrays_1.$tb)(this.s, selectedHandles);
            this.s = selectedHandles;
            const changedFocus = this.t !== focusedHandle;
            this.t = focusedHandle;
            if (changedSelection) {
                this.y.fire(Object.freeze({ selection: this.selectedElements }));
            }
            if (changedFocus) {
                this.z.fire(Object.freeze({ activeItem: this.focusedElement }));
            }
        }
        setVisible(visible) {
            if (visible !== this.r) {
                this.r = visible;
                this.C.fire(Object.freeze({ visible: this.r }));
            }
        }
        async setCheckboxState(checkboxUpdates) {
            const items = (await Promise.all(checkboxUpdates.map(async (checkboxUpdate) => {
                const extensionItem = this.getExtensionElement(checkboxUpdate.treeItemHandle);
                if (extensionItem) {
                    return {
                        extensionItem: extensionItem,
                        treeItem: await this.f.getTreeItem(extensionItem),
                        newState: checkboxUpdate.newState ? extHostTypes.TreeItemCheckboxState.Checked : extHostTypes.TreeItemCheckboxState.Unchecked
                    };
                }
                return Promise.resolve(undefined);
            }))).filter((item) => item !== undefined);
            items.forEach(item => {
                item.treeItem.checkboxState = item.newState ? extHostTypes.TreeItemCheckboxState.Checked : extHostTypes.TreeItemCheckboxState.Unchecked;
            });
            this.D.fire({ items: items.map(item => [item.extensionItem, item.newState]) });
        }
        async handleDrag(sourceTreeItemHandles, treeDataTransfer, token) {
            const extensionTreeItems = [];
            for (const sourceHandle of sourceTreeItemHandles) {
                const extensionItem = this.getExtensionElement(sourceHandle);
                if (extensionItem) {
                    extensionTreeItems.push(extensionItem);
                }
            }
            if (!this.g?.handleDrag || (extensionTreeItems.length === 0)) {
                return;
            }
            await this.g.handleDrag(extensionTreeItems, treeDataTransfer, token);
            return treeDataTransfer;
        }
        get hasHandleDrag() {
            return !!this.g?.handleDrag;
        }
        async onDrop(treeDataTransfer, targetHandleOrNode, token) {
            const target = targetHandleOrNode ? this.getExtensionElement(targetHandleOrNode) : undefined;
            if ((!target && targetHandleOrNode) || !this.g?.handleDrop) {
                return;
            }
            return (0, async_1.$xh)(() => this.g?.handleDrop
                ? this.g.handleDrop(target, treeDataTransfer, token)
                : undefined);
        }
        get hasResolve() {
            return !!this.f.resolveTreeItem;
        }
        async resolveTreeItem(treeItemHandle, token) {
            if (!this.f.resolveTreeItem) {
                return;
            }
            const element = this.j.get(treeItemHandle);
            if (element) {
                const node = this.m.get(element);
                if (node) {
                    const resolve = await this.f.resolveTreeItem(node.extensionItem, element, token) ?? node.extensionItem;
                    this.hb(resolve);
                    // Resolvable elements. Currently only tooltip and command.
                    node.item.tooltip = this.eb(resolve.tooltip);
                    node.item.command = this.fb(node.disposableStore, resolve.command);
                    return node.item;
                }
            }
            return;
        }
        S(element) {
            return this.U(element)
                .then((parent) => {
                if (!parent) {
                    return Promise.resolve([]);
                }
                return this.S(parent)
                    .then(result => this.W(parent, result[result.length - 1])
                    .then(parentNode => {
                    result.push(parentNode);
                    return result;
                }));
            });
        }
        U(element) {
            const node = this.m.get(element);
            if (node) {
                return Promise.resolve(node.parent ? this.j.get(node.parent.item.handle) : undefined);
            }
            return (0, async_1.$xh)(() => this.f.getParent(element));
        }
        W(element, parent) {
            const node = this.m.get(element);
            if (node) {
                return Promise.resolve(node);
            }
            return (0, async_1.$xh)(() => this.f.getTreeItem(element))
                .then(extTreeItem => this.kb(element, extTreeItem, parent, true))
                .then(handle => this.getChildren(parent ? parent.item.handle : undefined)
                .then(() => {
                const cachedElement = this.getExtensionElement(handle);
                if (cachedElement) {
                    const node = this.m.get(cachedElement);
                    if (node) {
                        return Promise.resolve(node);
                    }
                }
                throw new Error(`Cannot resolve tree item for element ${handle} from extension ${this.N.identifier.value}`);
            }));
        }
        X(parentNodeOrHandle) {
            if (parentNodeOrHandle) {
                let parentNode;
                if (typeof parentNodeOrHandle === 'string') {
                    const parentElement = this.getExtensionElement(parentNodeOrHandle);
                    parentNode = parentElement ? this.m.get(parentElement) : undefined;
                }
                else {
                    parentNode = parentNodeOrHandle;
                }
                return parentNode ? parentNode.children || undefined : undefined;
            }
            return this.h;
        }
        async Y(parentElement) {
            // clear children cache
            this.rb(parentElement);
            const cts = new cancellation_1.$we(this.Z.token);
            try {
                const parentNode = parentElement ? this.m.get(parentElement) : undefined;
                const elements = await this.f.getChildren(parentElement);
                if (cts.token.isCancellationRequested) {
                    return undefined;
                }
                const coalescedElements = (0, arrays_1.$Gb)(elements || []);
                const treeItems = await Promise.all((0, arrays_1.$Gb)(coalescedElements).map(element => {
                    return this.f.getTreeItem(element);
                }));
                if (cts.token.isCancellationRequested) {
                    return undefined;
                }
                // createAndRegisterTreeNodes adds the nodes to a cache. This must be done sync so that they get added in the correct order.
                const items = treeItems.map((item, index) => item ? this.db(coalescedElements[index], item, parentNode) : null);
                return (0, arrays_1.$Gb)(items);
            }
            finally {
                cts.dispose();
            }
        }
        $(elements) {
            const hasRoot = elements.some(element => !element);
            if (hasRoot) {
                // Cancel any pending children fetches
                this.Z.dispose(true);
                this.Z = new cancellation_1.$we();
                this.tb(); // clear cache
                return this.J.$refresh(this.I);
            }
            else {
                const handlesToRefresh = this.ab(elements);
                if (handlesToRefresh.length) {
                    return this.bb(handlesToRefresh);
                }
            }
            return Promise.resolve(undefined);
        }
        ab(elements) {
            const elementsToUpdate = new Set();
            const elementNodes = elements.map(element => this.m.get(element));
            for (const elementNode of elementNodes) {
                if (elementNode && !elementsToUpdate.has(elementNode.item.handle)) {
                    // check if an ancestor of extElement is already in the elements list
                    let currentNode = elementNode;
                    while (currentNode && currentNode.parent && elementNodes.findIndex(node => currentNode && currentNode.parent && node && node.item.handle === currentNode.parent.item.handle) === -1) {
                        const parentElement = this.j.get(currentNode.parent.item.handle);
                        currentNode = parentElement ? this.m.get(parentElement) : undefined;
                    }
                    if (currentNode && !currentNode.parent) {
                        elementsToUpdate.add(elementNode.item.handle);
                    }
                }
            }
            const handlesToUpdate = [];
            // Take only top level elements
            elementsToUpdate.forEach((handle) => {
                const element = this.j.get(handle);
                if (element) {
                    const node = this.m.get(element);
                    if (node && (!node.parent || !elementsToUpdate.has(node.parent.item.handle))) {
                        handlesToUpdate.push(handle);
                    }
                }
            });
            return handlesToUpdate;
        }
        bb(itemHandles) {
            const itemsToRefresh = {};
            return Promise.all(itemHandles.map(treeItemHandle => this.cb(treeItemHandle)
                .then(node => {
                if (node) {
                    itemsToRefresh[treeItemHandle] = node.item;
                }
            })))
                .then(() => Object.keys(itemsToRefresh).length ? this.J.$refresh(this.I, itemsToRefresh) : undefined);
        }
        cb(treeItemHandle) {
            const extElement = this.getExtensionElement(treeItemHandle);
            if (extElement) {
                const existing = this.m.get(extElement);
                if (existing) {
                    this.rb(extElement); // clear children cache
                    return (0, async_1.$xh)(() => this.f.getTreeItem(extElement))
                        .then(extTreeItem => {
                        if (extTreeItem) {
                            const newNode = this.ib(extElement, extTreeItem, existing.parent);
                            this.pb(extElement, newNode, existing, existing.parent);
                            existing.dispose();
                            return newNode;
                        }
                        return null;
                    });
                }
            }
            return Promise.resolve(null);
        }
        db(element, extTreeItem, parentNode) {
            const node = this.ib(element, extTreeItem, parentNode);
            if (extTreeItem.id && this.j.has(node.item.handle)) {
                throw new Error((0, nls_1.localize)(11249, null, extTreeItem.id));
            }
            this.ob(element, node);
            this.qb(node, parentNode);
            return node;
        }
        eb(tooltip) {
            if (extHostTypes.$eO.isMarkdownString(tooltip)) {
                return extHostTypeConverters_1.MarkdownString.from(tooltip);
            }
            return tooltip;
        }
        fb(disposable, command) {
            return command ? { ...this.L.toInternal(command, disposable), originalId: command.command } : undefined;
        }
        gb(extensionTreeItem) {
            if (extensionTreeItem.checkboxState === undefined) {
                return undefined;
            }
            let checkboxState;
            let tooltip = undefined;
            let accessibilityInformation = undefined;
            if (typeof extensionTreeItem.checkboxState === 'number') {
                checkboxState = extensionTreeItem.checkboxState;
            }
            else {
                checkboxState = extensionTreeItem.checkboxState.state;
                tooltip = extensionTreeItem.checkboxState.tooltip;
                accessibilityInformation = extensionTreeItem.checkboxState.accessibilityInformation;
            }
            return { isChecked: checkboxState === extHostTypes.TreeItemCheckboxState.Checked, tooltip, accessibilityInformation };
        }
        hb(extensionTreeItem) {
            if (!extHostTypes.$CO.isTreeItem(extensionTreeItem, this.N)) {
                throw new Error(`Extension ${this.N.identifier.value} has provided an invalid tree item.`);
            }
        }
        ib(element, extensionTreeItem, parent) {
            this.hb(extensionTreeItem);
            const disposableStore = this.B(new lifecycle_1.$Tc());
            const handle = this.kb(element, extensionTreeItem, parent);
            const icon = this.lb(extensionTreeItem);
            const item = {
                handle,
                parentHandle: parent ? parent.item.handle : undefined,
                label: toTreeItemLabel(extensionTreeItem.label, this.N),
                description: extensionTreeItem.description,
                resourceUri: extensionTreeItem.resourceUri,
                tooltip: this.eb(extensionTreeItem.tooltip),
                command: this.fb(disposableStore, extensionTreeItem.command),
                contextValue: extensionTreeItem.contextValue,
                icon,
                iconDark: this.mb(extensionTreeItem) || icon,
                themeIcon: this.jb(extensionTreeItem),
                collapsibleState: (0, types_1.$ng)(extensionTreeItem.collapsibleState) ? extHostTypes.TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState,
                accessibilityInformation: extensionTreeItem.accessibilityInformation,
                checkbox: this.gb(extensionTreeItem),
            };
            return {
                item,
                extensionItem: extensionTreeItem,
                parent,
                children: undefined,
                disposableStore,
                dispose() { disposableStore.dispose(); }
            };
        }
        jb(extensionTreeItem) {
            return extensionTreeItem.iconPath instanceof extHostTypes.$LO ? extensionTreeItem.iconPath : undefined;
        }
        kb(element, { id, label, resourceUri }, parent, returnFirst) {
            if (id) {
                return `${ExtHostTreeView.b}/${id}`;
            }
            const treeItemLabel = toTreeItemLabel(label, this.N);
            const prefix = parent ? parent.item.handle : ExtHostTreeView.a;
            let elementId = treeItemLabel ? treeItemLabel.label : resourceUri ? (0, resources_1.$dh)(resourceUri) : '';
            elementId = elementId.indexOf('/') !== -1 ? elementId.replace('/', '//') : elementId;
            const existingHandle = this.m.has(element) ? this.m.get(element).item.handle : undefined;
            const childrenNodes = (this.X(parent) || []);
            let handle;
            let counter = 0;
            do {
                handle = `${prefix}/${counter}:${elementId}`;
                if (returnFirst || !this.j.has(handle) || existingHandle === handle) {
                    // Return first if asked for or
                    // Return if handle does not exist or
                    // Return if handle is being reused
                    break;
                }
                counter++;
            } while (counter <= childrenNodes.length);
            return handle;
        }
        lb(extensionTreeItem) {
            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes.$LO)) {
                if (typeof extensionTreeItem.iconPath === 'string'
                    || uri_1.URI.isUri(extensionTreeItem.iconPath)) {
                    return this.nb(extensionTreeItem.iconPath);
                }
                return this.nb(extensionTreeItem.iconPath.light);
            }
            return undefined;
        }
        mb(extensionTreeItem) {
            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes.$LO) && extensionTreeItem.iconPath.dark) {
                return this.nb(extensionTreeItem.iconPath.dark);
            }
            return undefined;
        }
        nb(iconPath) {
            if (uri_1.URI.isUri(iconPath)) {
                return iconPath;
            }
            return uri_1.URI.file(iconPath);
        }
        ob(element, node) {
            this.j.set(node.item.handle, element);
            this.m.set(element, node);
        }
        pb(element, newNode, existing, parentNode) {
            // Remove from the cache
            this.j.delete(newNode.item.handle);
            this.m.delete(element);
            if (newNode.item.handle !== existing.item.handle) {
                this.j.delete(existing.item.handle);
            }
            // Add the new node to the cache
            this.ob(element, newNode);
            // Replace the node in parent's children nodes
            const childrenNodes = (this.X(parentNode) || []);
            const childNode = childrenNodes.filter(c => c.item.handle === existing.item.handle)[0];
            if (childNode) {
                childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);
            }
        }
        qb(node, parentNode) {
            if (parentNode) {
                if (!parentNode.children) {
                    parentNode.children = [];
                }
                parentNode.children.push(node);
            }
            else {
                if (!this.h) {
                    this.h = [];
                }
                this.h.push(node);
            }
        }
        rb(parentElement) {
            if (parentElement) {
                const node = this.m.get(parentElement);
                if (node) {
                    if (node.children) {
                        for (const child of node.children) {
                            const childElement = this.j.get(child.item.handle);
                            if (childElement) {
                                this.sb(childElement);
                            }
                        }
                    }
                    node.children = undefined;
                }
            }
            else {
                this.tb();
            }
        }
        sb(element) {
            const node = this.m.get(element);
            if (node) {
                if (node.children) {
                    for (const child of node.children) {
                        const childElement = this.j.get(child.item.handle);
                        if (childElement) {
                            this.sb(childElement);
                        }
                    }
                }
                this.m.delete(element);
                this.j.delete(node.item.handle);
                node.dispose();
            }
        }
        tb() {
            this.h = undefined;
            this.j.clear();
            this.m.forEach(node => node.dispose());
            this.m.clear();
        }
        dispose() {
            super.dispose();
            this.Z.dispose();
            this.tb();
            this.J.$disposeTree(this.I);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[262/*vs/workbench/api/common/extHostWebviewPanels*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,38/*vs/base/common/uuid*/,8/*vs/workbench/api/common/extHostTypeConverters*/,67/*vs/workbench/api/common/extHostWebview*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, event_1, lifecycle_1, uri_1, uuid_1, typeConverters, extHostWebview_1, extHostProtocol, extHostTypes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$1pc = void 0;
    typeConverters = __importStar(typeConverters);
    extHostProtocol = __importStar(extHostProtocol);
    extHostTypes = __importStar(extHostTypes);
    class ExtHostWebviewPanel extends lifecycle_1.$Uc {
        #handle;
        #proxy;
        #viewType;
        #webview;
        #options;
        #title;
        #iconPath;
        #viewColumn;
        #visible;
        #active;
        #isDisposed;
        #onDidDispose;
        #onDidChangeViewState;
        constructor(handle, proxy, webview, params) {
            super();
            this.#viewColumn = undefined;
            this.#visible = true;
            this.#isDisposed = false;
            this.#onDidDispose = this.B(new event_1.$le());
            this.onDidDispose = this.#onDidDispose.event;
            this.#onDidChangeViewState = this.B(new event_1.$le());
            this.onDidChangeViewState = this.#onDidChangeViewState.event;
            this.#handle = handle;
            this.#proxy = proxy;
            this.#webview = webview;
            this.#viewType = params.viewType;
            this.#options = params.panelOptions;
            this.#viewColumn = params.viewColumn;
            this.#title = params.title;
            this.#active = params.active;
        }
        dispose() {
            if (this.#isDisposed) {
                return;
            }
            this.#isDisposed = true;
            this.#onDidDispose.fire();
            this.#proxy.$disposeWebview(this.#handle);
            this.#webview.dispose();
            super.dispose();
        }
        get webview() {
            this.c();
            return this.#webview;
        }
        get viewType() {
            this.c();
            return this.#viewType;
        }
        get title() {
            this.c();
            return this.#title;
        }
        set title(value) {
            this.c();
            if (this.#title !== value) {
                this.#title = value;
                this.#proxy.$setTitle(this.#handle, value);
            }
        }
        get iconPath() {
            this.c();
            return this.#iconPath;
        }
        set iconPath(value) {
            this.c();
            if (this.#iconPath !== value) {
                this.#iconPath = value;
                this.#proxy.$setIconPath(this.#handle, uri_1.URI.isUri(value) ? { light: value, dark: value } : value);
            }
        }
        get options() {
            return this.#options;
        }
        get viewColumn() {
            this.c();
            if (typeof this.#viewColumn === 'number' && this.#viewColumn < 0) {
                // We are using a symbolic view column
                // Return undefined instead to indicate that the real view column is currently unknown but will be resolved.
                return undefined;
            }
            return this.#viewColumn;
        }
        get active() {
            this.c();
            return this.#active;
        }
        get visible() {
            this.c();
            return this.#visible;
        }
        _updateViewState(newState) {
            if (this.#isDisposed) {
                return;
            }
            if (this.active !== newState.active || this.visible !== newState.visible || this.viewColumn !== newState.viewColumn) {
                this.#active = newState.active;
                this.#visible = newState.visible;
                this.#viewColumn = newState.viewColumn;
                this.#onDidChangeViewState.fire({ webviewPanel: this });
            }
        }
        reveal(viewColumn, preserveFocus) {
            this.c();
            this.#proxy.$reveal(this.#handle, {
                viewColumn: typeof viewColumn === 'undefined' ? undefined : typeConverters.ViewColumn.from(viewColumn),
                preserveFocus: !!preserveFocus
            });
        }
        c() {
            if (this.#isDisposed) {
                throw new Error('Webview is disposed');
            }
        }
    }
    class $1pc extends lifecycle_1.$Uc {
        static c() {
            return (0, uuid_1.$2g)();
        }
        constructor(mainContext, j, m) {
            super();
            this.j = j;
            this.m = m;
            this.g = new Map();
            this.h = new Map();
            this.f = mainContext.getProxy(extHostProtocol.$KN.MainThreadWebviewPanels);
        }
        dispose() {
            super.dispose();
            this.g.forEach(value => value.dispose());
            this.g.clear();
        }
        createWebviewPanel(extension, viewType, title, showOptions, options = {}) {
            const viewColumn = typeof showOptions === 'object' ? showOptions.viewColumn : showOptions;
            const webviewShowOptions = {
                viewColumn: typeConverters.ViewColumn.from(viewColumn),
                preserveFocus: typeof showOptions === 'object' && !!showOptions.preserveFocus
            };
            const serializeBuffersForPostMessage = (0, extHostWebview_1.$Wpc)(extension);
            const handle = $1pc.c();
            this.f.$createWebviewPanel((0, extHostWebview_1.$Ypc)(extension), handle, viewType, {
                title,
                panelOptions: serializeWebviewPanelOptions(options),
                webviewOptions: (0, extHostWebview_1.$Zpc)(extension, this.m, options),
                serializeBuffersForPostMessage,
            }, webviewShowOptions);
            const webview = this.j.createNewWebview(handle, options, extension);
            const panel = this.createNewWebviewPanel(handle, viewType, title, viewColumn, options, webview, true);
            return panel;
        }
        $onDidChangeWebviewPanelViewStates(newStates) {
            const handles = Object.keys(newStates);
            // Notify webviews of state changes in the following order:
            // - Non-visible
            // - Visible
            // - Active
            handles.sort((a, b) => {
                const stateA = newStates[a];
                const stateB = newStates[b];
                if (stateA.active) {
                    return 1;
                }
                if (stateB.active) {
                    return -1;
                }
                return (+stateA.visible) - (+stateB.visible);
            });
            for (const handle of handles) {
                const panel = this.getWebviewPanel(handle);
                if (!panel) {
                    continue;
                }
                const newState = newStates[handle];
                panel._updateViewState({
                    active: newState.active,
                    visible: newState.visible,
                    viewColumn: typeConverters.ViewColumn.to(newState.position),
                });
            }
        }
        async $onDidDisposeWebviewPanel(handle) {
            const panel = this.getWebviewPanel(handle);
            panel?.dispose();
            this.g.delete(handle);
            this.j.deleteWebview(handle);
        }
        registerWebviewPanelSerializer(extension, viewType, serializer) {
            if (this.h.has(viewType)) {
                throw new Error(`Serializer for '${viewType}' already registered`);
            }
            this.h.set(viewType, { serializer, extension });
            this.f.$registerSerializer(viewType, {
                serializeBuffersForPostMessage: (0, extHostWebview_1.$Wpc)(extension)
            });
            return new extHostTypes.$MN(() => {
                this.h.delete(viewType);
                this.f.$unregisterSerializer(viewType);
            });
        }
        async $deserializeWebviewPanel(webviewHandle, viewType, initData, position) {
            const entry = this.h.get(viewType);
            if (!entry) {
                throw new Error(`No serializer found for '${viewType}'`);
            }
            const { serializer, extension } = entry;
            const webview = this.j.createNewWebview(webviewHandle, initData.webviewOptions, extension);
            const revivedPanel = this.createNewWebviewPanel(webviewHandle, viewType, initData.title, position, initData.panelOptions, webview, initData.active);
            await serializer.deserializeWebviewPanel(revivedPanel, initData.state);
        }
        createNewWebviewPanel(webviewHandle, viewType, title, position, options, webview, active) {
            const panel = new ExtHostWebviewPanel(webviewHandle, this.f, webview, { viewType, title, viewColumn: position, panelOptions: options, active });
            this.g.set(webviewHandle, panel);
            return panel;
        }
        getWebviewPanel(handle) {
            return this.g.get(handle);
        }
    }
    exports.$1pc = $1pc;
    function serializeWebviewPanelOptions(options) {
        return {
            enableFindWidget: options.enableFindWidget,
            retainContextWhenHidden: options.retainContextWhenHidden,
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[263/*vs/workbench/api/common/extHostWebviewView*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,67/*vs/workbench/api/common/extHostWebview*/,8/*vs/workbench/api/common/extHostTypeConverters*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/]), function (require, exports, event_1, lifecycle_1, extHostWebview_1, extHostTypeConverters_1, extHostProtocol, extHostTypes) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$xrc = void 0;
    extHostProtocol = __importStar(extHostProtocol);
    extHostTypes = __importStar(extHostTypes);
    /* eslint-disable local/code-no-native-private */
    class ExtHostWebviewView extends lifecycle_1.$Uc {
        #handle;
        #proxy;
        #viewType;
        #webview;
        #isDisposed;
        #isVisible;
        #title;
        #description;
        #badge;
        constructor(handle, proxy, viewType, title, webview, isVisible) {
            super();
            this.#isDisposed = false;
            this.#onDidChangeVisibility = this.B(new event_1.$le());
            this.onDidChangeVisibility = this.#onDidChangeVisibility.event;
            this.#onDidDispose = this.B(new event_1.$le());
            this.onDidDispose = this.#onDidDispose.event;
            this.#viewType = viewType;
            this.#title = title;
            this.#handle = handle;
            this.#proxy = proxy;
            this.#webview = webview;
            this.#isVisible = isVisible;
        }
        dispose() {
            if (this.#isDisposed) {
                return;
            }
            this.#isDisposed = true;
            this.#onDidDispose.fire();
            this.#webview.dispose();
            super.dispose();
        }
        #onDidChangeVisibility;
        #onDidDispose;
        get title() {
            this.a();
            return this.#title;
        }
        set title(value) {
            this.a();
            if (this.#title !== value) {
                this.#title = value;
                this.#proxy.$setWebviewViewTitle(this.#handle, value);
            }
        }
        get description() {
            this.a();
            return this.#description;
        }
        set description(value) {
            this.a();
            if (this.#description !== value) {
                this.#description = value;
                this.#proxy.$setWebviewViewDescription(this.#handle, value);
            }
        }
        get visible() { return this.#isVisible; }
        get webview() { return this.#webview; }
        get viewType() { return this.#viewType; }
        /* internal */ _setVisible(visible) {
            if (visible === this.#isVisible || this.#isDisposed) {
                return;
            }
            this.#isVisible = visible;
            this.#onDidChangeVisibility.fire();
        }
        get badge() {
            this.a();
            return this.#badge;
        }
        set badge(badge) {
            this.a();
            if (badge?.value === this.#badge?.value &&
                badge?.tooltip === this.#badge?.tooltip) {
                return;
            }
            this.#badge = extHostTypeConverters_1.ViewBadge.from(badge);
            this.#proxy.$setWebviewViewBadge(this.#handle, badge);
        }
        show(preserveFocus) {
            this.a();
            this.#proxy.$show(this.#handle, !!preserveFocus);
        }
        a() {
            if (this.#isDisposed) {
                throw new Error('Webview is disposed');
            }
        }
    }
    class $xrc {
        constructor(mainContext, d) {
            this.d = d;
            this.b = new Map();
            this.c = new Map();
            this.a = mainContext.getProxy(extHostProtocol.$KN.MainThreadWebviewViews);
        }
        registerWebviewViewProvider(extension, viewType, provider, webviewOptions) {
            if (this.b.has(viewType)) {
                throw new Error(`View provider for '${viewType}' already registered`);
            }
            this.b.set(viewType, { provider, extension });
            this.a.$registerWebviewViewProvider((0, extHostWebview_1.$Ypc)(extension), viewType, {
                retainContextWhenHidden: webviewOptions?.retainContextWhenHidden,
                serializeBuffersForPostMessage: (0, extHostWebview_1.$Wpc)(extension),
            });
            return new extHostTypes.$MN(() => {
                this.b.delete(viewType);
                this.a.$unregisterWebviewViewProvider(viewType);
            });
        }
        async $resolveWebviewView(webviewHandle, viewType, title, state, cancellation) {
            const entry = this.b.get(viewType);
            if (!entry) {
                throw new Error(`No view provider found for '${viewType}'`);
            }
            const { provider, extension } = entry;
            const webview = this.d.createNewWebview(webviewHandle, { /* todo */}, extension);
            const revivedView = new ExtHostWebviewView(webviewHandle, this.a, viewType, title, webview, true);
            this.c.set(webviewHandle, revivedView);
            await provider.resolveWebviewView(revivedView, { state }, cancellation);
        }
        async $onDidChangeWebviewViewVisibility(webviewHandle, visible) {
            const webviewView = this.e(webviewHandle);
            webviewView._setVisible(visible);
        }
        async $disposeWebviewView(webviewHandle) {
            const webviewView = this.e(webviewHandle);
            this.c.delete(webviewHandle);
            webviewView.dispose();
            this.d.deleteWebview(webviewHandle);
        }
        e(handle) {
            const entry = this.c.get(handle);
            if (!entry) {
                throw new Error('No webview found');
            }
            return entry;
        }
    }
    exports.$xrc = $xrc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[264/*vs/workbench/services/output/common/output*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/event*/,30/*vs/platform/registry/common/platform*/,31/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, event_1, platform_1, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$7M = exports.$6M = exports.OutputChannelUpdateMode = exports.$5M = exports.$4M = exports.$3M = exports.$2M = exports.$1M = exports.$ZM = exports.$YM = exports.$XM = exports.$WM = exports.$VM = exports.$UM = exports.$TM = exports.$SM = void 0;
    /**
     * Mime type used by the output editor.
     */
    exports.$SM = 'text/x-code-output';
    /**
     * Output resource scheme.
     */
    exports.$TM = 'output';
    /**
     * Id used by the output editor.
     */
    exports.$UM = 'Log';
    /**
     * Mime type used by the log output editor.
     */
    exports.$VM = 'text/x-code-log-output';
    /**
     * Id used by the log output editor.
     */
    exports.$WM = 'log';
    /**
     * Output view id
     */
    exports.$XM = 'workbench.panel.output';
    exports.$YM = new contextkey_1.$Wj('inOutput', false);
    exports.$ZM = new contextkey_1.$Wj('activeLogOutput', false);
    exports.$1M = new contextkey_1.$Wj('activeLogOutput.levelSettable', false);
    exports.$2M = new contextkey_1.$Wj('activeLogOutput.level', '');
    exports.$3M = new contextkey_1.$Wj('activeLogOutput.levelIsDefault', false);
    exports.$4M = new contextkey_1.$Wj(`outputView.scrollLock`, false);
    exports.$5M = (0, instantiation_1.$Fi)('outputService');
    var OutputChannelUpdateMode;
    (function (OutputChannelUpdateMode) {
        OutputChannelUpdateMode[OutputChannelUpdateMode["Append"] = 1] = "Append";
        OutputChannelUpdateMode[OutputChannelUpdateMode["Replace"] = 2] = "Replace";
        OutputChannelUpdateMode[OutputChannelUpdateMode["Clear"] = 3] = "Clear";
    })(OutputChannelUpdateMode || (exports.OutputChannelUpdateMode = OutputChannelUpdateMode = {}));
    exports.$6M = {
        OutputChannels: 'workbench.contributions.outputChannels'
    };
    class OutputChannelRegistry {
        constructor() {
            this.a = new Map();
            this.b = new event_1.$le();
            this.onDidRegisterChannel = this.b.event;
            this.c = new event_1.$le();
            this.onDidRemoveChannel = this.c.event;
        }
        registerChannel(descriptor) {
            if (!this.a.has(descriptor.id)) {
                this.a.set(descriptor.id, descriptor);
                this.b.fire(descriptor.id);
            }
        }
        getChannels() {
            const result = [];
            this.a.forEach(value => result.push(value));
            return result;
        }
        getChannel(id) {
            return this.a.get(id);
        }
        removeChannel(id) {
            this.a.delete(id);
            this.c.fire(id);
        }
    }
    platform_1.$ro.add(exports.$6M.OutputChannels, new OutputChannelRegistry());
    exports.$7M = new contextkey_1.$Wj('activeOutputChannel', '');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[128/*vs/workbench/api/common/extHostOutput*/], __M([1/*require*/,0/*exports*/,5/*vs/workbench/api/common/extHost.protocol*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/,18/*vs/platform/extensions/common/extensions*/,11/*vs/platform/log/common/log*/,264/*vs/workbench/services/output/common/output*/,68/*vs/workbench/api/common/extHostFileSystemConsumer*/,26/*vs/workbench/api/common/extHostInitDataService*/,50/*vs/workbench/api/common/extHostFileSystemInfo*/,165/*vs/base/common/date*/,22/*vs/base/common/buffer*/,14/*vs/base/common/types*/,29/*vs/platform/files/common/files*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/]), function (require, exports, extHost_protocol_1, instantiation_1, extHostRpcService_1, extensions_1, log_1, output_1, extHostFileSystemConsumer_1, extHostInitDataService_1, extHostFileSystemInfo_1, date_1, buffer_1, types_1, files_1, event_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$brc = exports.$arc = void 0;
    class ExtHostOutputChannel extends log_1.$gk {
        get disposed() { return this.n; }
        constructor(id, name, r, s, extension) {
            super();
            this.id = id;
            this.name = name;
            this.r = r;
            this.s = s;
            this.extension = extension;
            this.m = 0;
            this.n = false;
            this.visible = false;
            this.setLevel(r.getLevel());
            this.B(r.onDidChangeLogLevel(level => this.setLevel(level)));
        }
        get logLevel() {
            return this.getLevel();
        }
        appendLine(value) {
            this.append(value + '\n');
        }
        append(value) {
            this.info(value);
        }
        clear() {
            const till = this.m;
            this.r.flush();
            this.s.$update(this.id, output_1.OutputChannelUpdateMode.Clear, till);
        }
        replace(value) {
            const till = this.m;
            this.info(value);
            this.s.$update(this.id, output_1.OutputChannelUpdateMode.Replace, till);
            if (this.visible) {
                this.r.flush();
            }
        }
        show(columnOrPreserveFocus, preserveFocus) {
            this.r.flush();
            this.s.$reveal(this.id, !!(typeof columnOrPreserveFocus === 'boolean' ? columnOrPreserveFocus : preserveFocus));
        }
        hide() {
            this.s.$close(this.id);
        }
        g(level, message) {
            this.m += buffer_1.$Ne.fromString(message).byteLength;
            (0, log_1.log)(this.r, level, message);
            if (this.visible) {
                this.r.flush();
                this.s.$update(this.id, output_1.OutputChannelUpdateMode.Append);
            }
        }
        dispose() {
            super.dispose();
            if (!this.n) {
                this.s.$dispose(this.id);
                this.n = true;
            }
        }
    }
    class ExtHostLogOutputChannel extends ExtHostOutputChannel {
        appendLine(value) {
            this.append(value);
        }
    }
    let $arc = class $arc {
        constructor(extHostRpc, i, j, k, l, m) {
            this.i = i;
            this.j = j;
            this.k = k;
            this.l = l;
            this.m = m;
            this.d = new Map();
            this.f = 1;
            this.g = new Map();
            this.h = null;
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadOutputService);
            this.b = this.k.extUri.joinPath(i.logsLocation, `output_logging_${(0, date_1.$4m)(new Date()).replace(/-|:|\.\d+Z$/g, '')}`);
        }
        $setVisibleChannel(visibleChannelId) {
            this.h = visibleChannelId;
            for (const [id, channel] of this.g) {
                channel.visible = id === this.h;
            }
        }
        createOutputChannel(name, options, extension) {
            name = name.trim();
            if (!name) {
                throw new Error('illegal argument `name`. must not be falsy');
            }
            const log = typeof options === 'object' && options.log;
            const languageId = (0, types_1.$eg)(options) ? options : undefined;
            if ((0, types_1.$eg)(languageId) && !languageId.trim()) {
                throw new Error('illegal argument `languageId`. must not be empty');
            }
            let logLevel;
            const logLevelValue = this.i.environment.extensionLogLevel?.find(([identifier]) => extensions_1.$rn.equals(extension.identifier, identifier))?.[1];
            if (logLevelValue) {
                logLevel = (0, log_1.$rk)(logLevelValue);
            }
            const extHostOutputChannel = log ? this.o(name, logLevel, extension) : this.n(name, languageId, extension);
            extHostOutputChannel.then(channel => {
                this.g.set(channel.id, channel);
                channel.visible = channel.id === this.h;
            });
            return log ? this.r(name, logLevel ?? this.m.getLevel(), extHostOutputChannel) : this.q(name, extHostOutputChannel);
        }
        async n(name, languageId, extension) {
            if (!this.c) {
                this.c = this.j.value.createDirectory(this.b).then(() => this.b);
            }
            const outputDir = await this.c;
            const file = this.k.extUri.joinPath(outputDir, `${this.f++}-${name.replace(/[\\/:\*\?"<>\|]/g, '')}.log`);
            const logger = this.l.createLogger(file, { logLevel: 'always', donotRotate: true, donotUseFormatters: true, hidden: true });
            const id = await this.a.$register(name, file, languageId, extension.identifier.value);
            return new ExtHostOutputChannel(id, name, logger, this.a, extension);
        }
        async o(name, logLevel, extension) {
            const extensionLogDir = await this.p(extension);
            const fileName = name.replace(/[\\/:\*\?"<>\|]/g, '');
            const file = this.k.extUri.joinPath(extensionLogDir, `${fileName}.log`);
            const id = `${extension.identifier.value}.${fileName}`;
            const logger = this.l.createLogger(file, { id, name, logLevel, extensionId: extension.identifier.value });
            return new ExtHostLogOutputChannel(id, name, logger, this.a, extension);
        }
        p(extension) {
            let extensionLogDirectoryPromise = this.d.get(extension.identifier.value);
            if (!extensionLogDirectoryPromise) {
                const extensionLogDirectory = this.k.extUri.joinPath(this.i.logsLocation, extension.identifier.value);
                this.d.set(extension.identifier.value, extensionLogDirectoryPromise = (async () => {
                    try {
                        await this.j.value.createDirectory(extensionLogDirectory);
                    }
                    catch (err) {
                        if ((0, files_1.$ql)(err) !== files_1.FileSystemProviderErrorCode.FileExists) {
                            throw err;
                        }
                    }
                    return extensionLogDirectory;
                })());
            }
            return extensionLogDirectoryPromise;
        }
        q(name, channelPromise) {
            let disposed = false;
            const validate = () => {
                if (disposed) {
                    throw new Error('Channel has been closed');
                }
            };
            return {
                get name() { return name; },
                append(value) {
                    validate();
                    channelPromise.then(channel => channel.append(value));
                },
                appendLine(value) {
                    validate();
                    channelPromise.then(channel => channel.appendLine(value));
                },
                clear() {
                    validate();
                    channelPromise.then(channel => channel.clear());
                },
                replace(value) {
                    validate();
                    channelPromise.then(channel => channel.replace(value));
                },
                show(columnOrPreserveFocus, preserveFocus) {
                    validate();
                    channelPromise.then(channel => channel.show(columnOrPreserveFocus, preserveFocus));
                },
                hide() {
                    validate();
                    channelPromise.then(channel => channel.hide());
                },
                dispose() {
                    disposed = true;
                    channelPromise.then(channel => channel.dispose());
                }
            };
        }
        r(name, logLevel, channelPromise) {
            const disposables = new lifecycle_1.$Tc();
            const validate = () => {
                if (disposables.isDisposed) {
                    throw new Error('Channel has been closed');
                }
            };
            const onDidChangeLogLevel = disposables.add(new event_1.$le());
            function setLogLevel(newLogLevel) {
                logLevel = newLogLevel;
                onDidChangeLogLevel.fire(newLogLevel);
            }
            channelPromise.then(channel => {
                disposables.add(channel);
                if (channel.logLevel !== logLevel) {
                    setLogLevel(channel.logLevel);
                }
                disposables.add(channel.onDidChangeLogLevel(e => setLogLevel(e)));
            });
            return {
                ...this.q(name, channelPromise),
                get logLevel() { return logLevel; },
                onDidChangeLogLevel: onDidChangeLogLevel.event,
                trace(value, ...args) {
                    validate();
                    channelPromise.then(channel => channel.trace(value, ...args));
                },
                debug(value, ...args) {
                    validate();
                    channelPromise.then(channel => channel.debug(value, ...args));
                },
                info(value, ...args) {
                    validate();
                    channelPromise.then(channel => channel.info(value, ...args));
                },
                warn(value, ...args) {
                    validate();
                    channelPromise.then(channel => channel.warn(value, ...args));
                },
                error(value, ...args) {
                    validate();
                    channelPromise.then(channel => channel.error(value, ...args));
                },
                dispose() {
                    disposables.dispose();
                }
            };
        }
    };
    exports.$arc = $arc;
    exports.$arc = $arc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ),
        __param(2, extHostFileSystemConsumer_1.$Spc),
        __param(3, extHostFileSystemInfo_1.$vpc),
        __param(4, log_1.$bk),
        __param(5, log_1.$ak)
    ], $arc);
    exports.$brc = (0, instantiation_1.$Fi)('IExtHostOutputService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[129/*vs/workbench/services/remote/common/remoteAgentService*/], __M([1/*require*/,0/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/base/common/async*/]), function (require, exports, instantiation_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Xm = exports.$Wm = void 0;
    exports.$Wm = (0, instantiation_1.$Fi)('remoteAgentService');
    exports.$Xm = new class {
        constructor() {
            this.maxSampleCount = 5;
            this.sampleDelay = 2000;
            this.initial = [];
            this.maxInitialCount = 3;
            this.average = [];
            this.maxAverageCount = 100;
            this.highLatencyMultiple = 2;
            this.highLatencyMinThreshold = 500;
            this.highLatencyMaxThreshold = 1500;
            this.lastMeasurement = undefined;
        }
        get latency() { return this.lastMeasurement; }
        async measure(remoteAgentService) {
            let currentLatency = Infinity;
            // Measure up to samples count
            for (let i = 0; i < this.maxSampleCount; i++) {
                const rtt = await remoteAgentService.getRoundTripTime();
                if (rtt === undefined) {
                    return undefined;
                }
                currentLatency = Math.min(currentLatency, rtt / 2 /* we want just one way, not round trip time */);
                await (0, async_1.$Gh)(this.sampleDelay);
            }
            // Keep track of average latency
            this.average.push(currentLatency);
            if (this.average.length > this.maxAverageCount) {
                this.average.shift();
            }
            // Keep track of initial latency
            let initialLatency = undefined;
            if (this.initial.length < this.maxInitialCount) {
                this.initial.push(currentLatency);
            }
            else {
                initialLatency = this.initial.reduce((sum, value) => sum + value, 0) / this.initial.length;
            }
            // Remember as last measurement
            this.lastMeasurement = {
                initial: initialLatency,
                current: currentLatency,
                average: this.average.reduce((sum, value) => sum + value, 0) / this.average.length,
                high: (() => {
                    // based on the initial, average and current latency, try to decide
                    // if the connection has high latency
                    // Some rules:
                    // - we require the initial latency to be computed
                    // - we only consider latency above highLatencyMinThreshold as potentially high
                    // - we require the current latency to be above the average latency by a factor of highLatencyMultiple
                    // - but not if the latency is actually above highLatencyMaxThreshold
                    if (typeof initialLatency === 'undefined') {
                        return false;
                    }
                    if (currentLatency > this.highLatencyMaxThreshold) {
                        return true;
                    }
                    if (currentLatency > this.highLatencyMinThreshold && currentLatency > initialLatency * this.highLatencyMultiple) {
                        return true;
                    }
                    return false;
                })()
            };
            return this.lastMeasurement;
        }
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[265/*vs/workbench/common/configuration*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,53/*vs/platform/configuration/common/configurationRegistry*/,30/*vs/platform/registry/common/platform*/,49/*vs/platform/workspace/common/workspace*/,43/*vs/platform/configuration/common/configuration*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,129/*vs/workbench/services/remote/common/remoteAgentService*/,20/*vs/base/common/platform*/,25/*vs/base/common/objects*/,10/*vs/base/common/async*/,113/*vs/platform/userDataProfile/common/userDataProfile*/]), function (require, exports, nls_1, configurationRegistry_1, platform_1, workspace_1, configuration_1, lifecycle_1, event_1, remoteAgentService_1, platform_2, objects_1, async_1, userDataProfile_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$mL = exports.$lL = exports.$kL = exports.$jL = exports.$iL = exports.$hL = exports.$gL = exports.$fL = exports.$eL = exports.$dL = void 0;
    exports.$dL = Object.freeze({
        'id': 'application',
        'order': 100,
        'title': (0, nls_1.localize)(12547, null),
        'type': 'object'
    });
    exports.$eL = Object.freeze({
        'id': 'workbench',
        'order': 7,
        'title': (0, nls_1.localize)(12548, null),
        'type': 'object',
    });
    exports.$fL = Object.freeze({
        'id': 'security',
        'scope': configurationRegistry_1.ConfigurationScope.APPLICATION,
        'title': (0, nls_1.localize)(12549, null),
        'type': 'object',
        'order': 7
    });
    exports.$gL = Object.freeze({
        'id': 'problems',
        'title': (0, nls_1.localize)(12550, null),
        'type': 'object',
        'order': 101
    });
    exports.$hL = Object.freeze({
        'id': 'window',
        'order': 8,
        'title': (0, nls_1.localize)(12551, null),
        'type': 'object',
    });
    exports.$iL = {
        ConfigurationMigration: 'base.contributions.configuration.migration'
    };
    class ConfigurationMigrationRegistry {
        constructor() {
            this.migrations = [];
            this.a = new event_1.$le();
            this.onDidRegisterConfigurationMigration = this.a.event;
        }
        registerConfigurationMigrations(configurationMigrations) {
            this.migrations.push(...configurationMigrations);
        }
    }
    const configurationMigrationRegistry = new ConfigurationMigrationRegistry();
    platform_1.$ro.add(exports.$iL.ConfigurationMigration, configurationMigrationRegistry);
    let $jL = class $jL extends lifecycle_1.$Uc {
        static { this.ID = 'workbench.contrib.configurationMigration'; }
        constructor(a, b) {
            super();
            this.a = a;
            this.b = b;
            this.B(this.b.onDidChangeWorkspaceFolders(async (e) => {
                for (const folder of e.added) {
                    await this.f(folder, configurationMigrationRegistry.migrations);
                }
            }));
            this.c(configurationMigrationRegistry.migrations);
            this.B(configurationMigrationRegistry.onDidRegisterConfigurationMigration(migration => this.c(migration)));
        }
        async c(migrations) {
            await this.f(undefined, migrations);
            for (const folder of this.b.getWorkspace().folders) {
                await this.f(folder, migrations);
            }
        }
        async f(folder, migrations) {
            await Promise.all([migrations.map(migration => this.g(migration, folder?.uri))]);
        }
        async g(migration, resource) {
            const inspectData = this.a.inspect(migration.key, { resource });
            const targetPairs = this.b.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE ? [
                ['user', configuration_1.ConfigurationTarget.USER],
                ['userLocal', configuration_1.ConfigurationTarget.USER_LOCAL],
                ['userRemote', configuration_1.ConfigurationTarget.USER_REMOTE],
                ['workspace', configuration_1.ConfigurationTarget.WORKSPACE],
                ['workspaceFolder', configuration_1.ConfigurationTarget.WORKSPACE_FOLDER],
            ] : [
                ['user', configuration_1.ConfigurationTarget.USER],
                ['userLocal', configuration_1.ConfigurationTarget.USER_LOCAL],
                ['userRemote', configuration_1.ConfigurationTarget.USER_REMOTE],
                ['workspace', configuration_1.ConfigurationTarget.WORKSPACE],
            ];
            for (const [dataKey, target] of targetPairs) {
                const inspectValue = inspectData[dataKey];
                if (!inspectValue) {
                    continue;
                }
                const migrationValues = [];
                if (inspectValue.value !== undefined) {
                    const keyValuePairs = await this.h(migration, dataKey, inspectValue.value, resource, undefined);
                    for (const keyValuePair of keyValuePairs ?? []) {
                        migrationValues.push([keyValuePair, []]);
                    }
                }
                for (const { identifiers, value } of inspectValue.overrides ?? []) {
                    if (value !== undefined) {
                        const keyValuePairs = await this.h(migration, dataKey, value, resource, identifiers);
                        for (const keyValuePair of keyValuePairs ?? []) {
                            migrationValues.push([keyValuePair, identifiers]);
                        }
                    }
                }
                if (migrationValues.length) {
                    // apply migrations
                    await Promise.allSettled(migrationValues.map(async ([[key, value], overrideIdentifiers]) => this.a.updateValue(key, value.value, { resource, overrideIdentifiers }, target)));
                }
            }
        }
        async h(migration, dataKey, value, resource, overrideIdentifiers) {
            const valueAccessor = (key) => {
                const inspectData = this.a.inspect(key, { resource });
                const inspectValue = inspectData[dataKey];
                if (!inspectValue) {
                    return undefined;
                }
                if (!overrideIdentifiers) {
                    return inspectValue.value;
                }
                return inspectValue.overrides?.find(({ identifiers }) => (0, objects_1.$io)(identifiers, overrideIdentifiers))?.value;
            };
            const result = await migration.migrateFn(value, valueAccessor);
            return Array.isArray(result) ? result : [[migration.key, result]];
        }
    };
    exports.$jL = $jL;
    exports.$jL = $jL = __decorate([
        __param(0, configuration_1.$_i),
        __param(1, workspace_1.$Oi)
    ], $jL);
    let $kL = class $kL extends lifecycle_1.$Uc {
        static { this.ID = 'workbench.contrib.dynamicWorkbenchSecurityConfiguration'; }
        constructor(b) {
            super();
            this.b = b;
            this.a = new async_1.$3h();
            this.ready = this.a.p;
            this.c();
        }
        async c() {
            try {
                await this.f();
            }
            finally {
                this.a.complete();
            }
        }
        async f() {
            if (!platform_2.$j) {
                const remoteEnvironment = await this.b.getEnvironment();
                if (remoteEnvironment?.os !== platform_2.OperatingSystem.Windows) {
                    return;
                }
            }
            // Windows: UNC allow list security configuration
            const registry = platform_1.$ro.as(configurationRegistry_1.$wo.Configuration);
            registry.registerConfiguration({
                ...exports.$fL,
                'properties': {
                    'security.allowedUNCHosts': {
                        'type': 'array',
                        'items': {
                            'type': 'string',
                            'pattern': '^[^\\\\]+$',
                            'patternErrorMessage': (0, nls_1.localize)(12552, null)
                        },
                        'default': [],
                        'markdownDescription': (0, nls_1.localize)(12553, null),
                        'scope': configurationRegistry_1.ConfigurationScope.MACHINE
                    },
                    'security.restrictUNCAccess': {
                        'type': 'boolean',
                        'default': true,
                        'markdownDescription': (0, nls_1.localize)(12554, null),
                        'scope': configurationRegistry_1.ConfigurationScope.MACHINE
                    }
                }
            });
        }
    };
    exports.$kL = $kL;
    exports.$kL = $kL = __decorate([
        __param(0, remoteAgentService_1.$Wm)
    ], $kL);
    exports.$lL = 'window.newWindowProfile';
    let $mL = class $mL extends lifecycle_1.$Uc {
        static { this.ID = 'workbench.contrib.dynamicWindowConfiguration'; }
        constructor(c, f) {
            super();
            this.c = c;
            this.f = f;
            this.g();
            this.B(this.c.onDidChangeProfiles((e) => this.g()));
            this.h();
            this.j();
            this.B(f.onDidChangeConfiguration(e => {
                if (e.source !== configuration_1.ConfigurationTarget.DEFAULT && e.affectsConfiguration(exports.$lL)) {
                    this.h();
                }
            }));
            this.B(this.c.onDidChangeProfiles(() => this.j()));
        }
        g() {
            const registry = platform_1.$ro.as(configurationRegistry_1.$wo.Configuration);
            const configurationNode = {
                ...exports.$hL,
                'properties': {
                    [exports.$lL]: {
                        'type': ['string', 'null'],
                        'default': null,
                        'enum': [...this.c.profiles.map(profile => profile.name), null],
                        'enumItemLabels': [...this.c.profiles.map(p => ''), (0, nls_1.localize)(12555, null)],
                        'description': (0, nls_1.localize)(12556, null),
                        'scope': configurationRegistry_1.ConfigurationScope.APPLICATION,
                    }
                }
            };
            if (this.a) {
                registry.updateConfigurations({ add: [configurationNode], remove: [this.a] });
            }
            else {
                registry.registerConfiguration(configurationNode);
            }
            this.a = configurationNode;
        }
        h() {
            const newWindowProfileName = this.f.getValue(exports.$lL);
            this.b = newWindowProfileName ? this.c.profiles.find(profile => profile.name === newWindowProfileName) : undefined;
        }
        j() {
            const newWindowProfileName = this.f.getValue(exports.$lL);
            if (!newWindowProfileName) {
                return;
            }
            const profile = this.b ? this.c.profiles.find(profile => profile.id === this.b.id) : undefined;
            if (newWindowProfileName === profile?.name) {
                return;
            }
            this.f.updateValue(exports.$lL, profile?.name);
        }
    };
    exports.$mL = $mL;
    exports.$mL = $mL = __decorate([
        __param(0, userDataProfile_1.$Ml),
        __param(1, configuration_1.$_i)
    ], $mL);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[266/*vs/workbench/services/editor/common/editorResolverService*/], __M([1/*require*/,0/*exports*/,41/*vs/base/common/glob*/,15/*vs/base/common/network*/,19/*vs/base/common/path*/,23/*vs/base/common/resources*/,9/*vs/nls*/,265/*vs/workbench/common/configuration*/,53/*vs/platform/configuration/common/configurationRegistry*/,3/*vs/platform/instantiation/common/instantiation*/,30/*vs/platform/registry/common/platform*/]), function (require, exports, glob, network_1, path_1, resources_1, nls_1, configuration_1, configurationRegistry_1, instantiation_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResolvedStatus = exports.RegisteredEditorPriority = exports.$oL = exports.$nL = void 0;
    exports.$pL = $pL;
    exports.$qL = $qL;
    glob = __importStar(glob);
    exports.$nL = (0, instantiation_1.$Fi)('editorResolverService');
    exports.$oL = 'workbench.editorAssociations';
    const configurationRegistry = platform_1.$ro.as(configurationRegistry_1.$wo.Configuration);
    const editorAssociationsConfigurationNode = {
        ...configuration_1.$eL,
        properties: {
            'workbench.editorAssociations': {
                type: 'object',
                markdownDescription: (0, nls_1.localize)(2258, null),
                additionalProperties: {
                    type: 'string'
                }
            }
        }
    };
    configurationRegistry.registerConfiguration(editorAssociationsConfigurationNode);
    //#endregion
    //#region EditorResolverService types
    var RegisteredEditorPriority;
    (function (RegisteredEditorPriority) {
        RegisteredEditorPriority["builtin"] = "builtin";
        RegisteredEditorPriority["option"] = "option";
        RegisteredEditorPriority["exclusive"] = "exclusive";
        RegisteredEditorPriority["default"] = "default";
    })(RegisteredEditorPriority || (exports.RegisteredEditorPriority = RegisteredEditorPriority = {}));
    /**
     * If we didn't resolve an editor dictates what to do with the opening state
     * ABORT = Do not continue with opening the editor
     * NONE = Continue as if the resolution has been disabled as the service could not resolve one
     */
    var ResolvedStatus;
    (function (ResolvedStatus) {
        ResolvedStatus[ResolvedStatus["ABORT"] = 1] = "ABORT";
        ResolvedStatus[ResolvedStatus["NONE"] = 2] = "NONE";
    })(ResolvedStatus || (exports.ResolvedStatus = ResolvedStatus = {}));
    //#endregion
    //#region Util functions
    function $pL(priority) {
        switch (priority) {
            case RegisteredEditorPriority.exclusive:
                return 5;
            case RegisteredEditorPriority.default:
                return 4;
            case RegisteredEditorPriority.builtin:
                return 3;
            // Text editor is priority 2
            case RegisteredEditorPriority.option:
            default:
                return 1;
        }
    }
    function $qL(globPattern, resource) {
        const excludedSchemes = new Set([
            network_1.Schemas.extension,
            network_1.Schemas.webviewPanel,
            network_1.Schemas.vscodeWorkspaceTrust,
            network_1.Schemas.vscodeSettings
        ]);
        // We want to say that the above schemes match no glob patterns
        if (excludedSchemes.has(resource.scheme)) {
            return false;
        }
        const matchOnPath = typeof globPattern === 'string' && globPattern.indexOf(path_1.$gc.sep) >= 0;
        const target = matchOnPath ? `${resource.scheme}:${resource.path}` : (0, resources_1.$dh)(resource);
        return glob.$zk(typeof globPattern === 'string' ? globPattern.toLowerCase() : globPattern, target.toLowerCase());
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[267/*vs/workbench/services/path/common/pathService*/], __M([1/*require*/,0/*exports*/,51/*vs/base/common/extpath*/,15/*vs/base/common/network*/,19/*vs/base/common/path*/,20/*vs/base/common/platform*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,186/*vs/platform/workspace/common/virtualWorkspace*/,49/*vs/platform/workspace/common/workspace*/,205/*vs/workbench/services/environment/common/environmentService*/,129/*vs/workbench/services/remote/common/remoteAgentService*/]), function (require, exports, extpath_1, network_1, path_1, platform_1, resources_1, uri_1, instantiation_1, virtualWorkspace_1, workspace_1, environmentService_1, remoteAgentService_1) {
    "use strict";
    var $nN_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$nN = exports.$mN = void 0;
    exports.$mN = (0, instantiation_1.$Fi)('pathService');
    let $nN = $nN_1 = class $nN {
        constructor(d, e, f, g) {
            this.d = d;
            this.e = e;
            this.f = f;
            this.g = g;
            // OS
            this.a = (async () => {
                const env = await this.e.getEnvironment();
                return env?.os || platform_1.OS;
            })();
            // User Home
            this.b = (async () => {
                const env = await this.e.getEnvironment();
                const userHome = this.c = env?.userHome ?? d;
                return userHome;
            })();
        }
        hasValidBasename(resource, arg2, basename) {
            // async version
            if (typeof arg2 === 'string' || typeof arg2 === 'undefined') {
                return this.a.then(os => this.h(resource, os, arg2));
            }
            // sync version
            return this.h(resource, arg2, basename);
        }
        h(resource, os, name) {
            // Our `isValidBasename` method only works with our
            // standard schemes for files on disk, either locally
            // or remote.
            if (resource.scheme === network_1.Schemas.file || resource.scheme === network_1.Schemas.vscodeRemote) {
                return (0, extpath_1.$Cg)(name ?? (0, resources_1.$dh)(resource), os === platform_1.OperatingSystem.Windows);
            }
            return true;
        }
        get defaultUriScheme() {
            return $nN_1.findDefaultUriScheme(this.f, this.g);
        }
        static findDefaultUriScheme(environmentService, contextService) {
            if (environmentService.remoteAuthority) {
                return network_1.Schemas.vscodeRemote;
            }
            const virtualWorkspace = (0, virtualWorkspace_1.$jN)(contextService.getWorkspace());
            if (virtualWorkspace) {
                return virtualWorkspace;
            }
            const firstFolder = contextService.getWorkspace().folders[0];
            if (firstFolder) {
                return firstFolder.uri.scheme;
            }
            const configuration = contextService.getWorkspace().configuration;
            if (configuration) {
                return configuration.scheme;
            }
            return network_1.Schemas.file;
        }
        userHome(options) {
            return options?.preferLocal ? this.d : this.b;
        }
        get resolvedUserHome() {
            return this.c;
        }
        get path() {
            return this.a.then(os => {
                return os === platform_1.OperatingSystem.Windows ?
                    path_1.$fc :
                    path_1.$gc;
            });
        }
        async fileURI(_path) {
            let authority = '';
            // normalize to fwd-slashes on windows,
            // on other systems bwd-slashes are valid
            // filename character, eg /f\oo/ba\r.txt
            const os = await this.a;
            if (os === platform_1.OperatingSystem.Windows) {
                _path = _path.replace(/\\/g, '/');
            }
            // check for authority as used in UNC shares
            // or use the path as given
            if (_path[0] === '/' && _path[1] === '/') {
                const idx = _path.indexOf('/', 2);
                if (idx === -1) {
                    authority = _path.substring(2);
                    _path = '/';
                }
                else {
                    authority = _path.substring(2, idx);
                    _path = _path.substring(idx) || '/';
                }
            }
            return uri_1.URI.from({
                scheme: network_1.Schemas.file,
                authority,
                path: _path,
                query: '',
                fragment: ''
            });
        }
    };
    exports.$nN = $nN;
    exports.$nN = $nN = $nN_1 = __decorate([
        __param(1, remoteAgentService_1.$Wm),
        __param(2, environmentService_1.$8M),
        __param(3, workspace_1.$Oi)
    ], $nN);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[130/*vs/workbench/services/search/common/searchExtTypes*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/]), function (require, exports, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextSearchCompleteMessageTypeNew = exports.ExcludeSettingOptions = exports.$ZL = exports.$YL = exports.TextSearchCompleteMessageType = exports.$XL = exports.$WL = void 0;
    exports.$1L = $1L;
    class $WL {
        constructor(line, character) {
            this.line = line;
            this.character = character;
        }
        isBefore(other) { return false; }
        isBeforeOrEqual(other) { return false; }
        isAfter(other) { return false; }
        isAfterOrEqual(other) { return false; }
        isEqual(other) { return false; }
        compareTo(other) { return 0; }
        translate(_, _2) { return new $WL(0, 0); }
        with(_) { return new $WL(0, 0); }
    }
    exports.$WL = $WL;
    class $XL {
        constructor(startLine, startCol, endLine, endCol) {
            this.isEmpty = false;
            this.isSingleLine = false;
            this.start = new $WL(startLine, startCol);
            this.end = new $WL(endLine, endCol);
        }
        contains(positionOrRange) { return false; }
        isEqual(other) { return false; }
        intersection(range) { return undefined; }
        union(other) { return new $XL(0, 0, 0, 0); }
        with(_) { return new $XL(0, 0, 0, 0); }
    }
    exports.$XL = $XL;
    /**
     * Represents the severity of a TextSearchComplete message.
     */
    var TextSearchCompleteMessageType;
    (function (TextSearchCompleteMessageType) {
        TextSearchCompleteMessageType[TextSearchCompleteMessageType["Information"] = 1] = "Information";
        TextSearchCompleteMessageType[TextSearchCompleteMessageType["Warning"] = 2] = "Warning";
    })(TextSearchCompleteMessageType || (exports.TextSearchCompleteMessageType = TextSearchCompleteMessageType = {}));
    /**
     * The main match information for a {@link TextSearchResultNew}.
     */
    class $YL {
        /**
         * @param uri The uri for the matching document.
         * @param ranges The ranges associated with this match.
         * @param previewText The text that is used to preview the match. The highlighted range in `previewText` is specified in `ranges`.
         */
        constructor(uri, ranges, previewText) {
            this.uri = uri;
            this.ranges = ranges;
            this.previewText = previewText;
        }
    }
    exports.$YL = $YL;
    /**
     * The potential context information for a {@link TextSearchResultNew}.
     */
    class $ZL {
        /**
         * @param uri The uri for the matching document.
         * @param text The line of context text.
         * @param lineNumber The line number of this line of context.
         */
        constructor(uri, text, lineNumber) {
            this.uri = uri;
            this.text = text;
            this.lineNumber = lineNumber;
        }
    }
    exports.$ZL = $ZL;
    var ExcludeSettingOptions;
    (function (ExcludeSettingOptions) {
        /*
         * Don't use any exclude settings.
         */
        ExcludeSettingOptions[ExcludeSettingOptions["none"] = 1] = "none";
        /*
         * Use:
         * - files.exclude setting
         */
        ExcludeSettingOptions[ExcludeSettingOptions["filesExclude"] = 2] = "filesExclude";
        /*
         * Use:
         * - files.exclude setting
         * - search.exclude setting
         */
        ExcludeSettingOptions[ExcludeSettingOptions["searchAndFilesExclude"] = 3] = "searchAndFilesExclude";
    })(ExcludeSettingOptions || (exports.ExcludeSettingOptions = ExcludeSettingOptions = {}));
    var TextSearchCompleteMessageTypeNew;
    (function (TextSearchCompleteMessageTypeNew) {
        TextSearchCompleteMessageTypeNew[TextSearchCompleteMessageTypeNew["Information"] = 1] = "Information";
        TextSearchCompleteMessageTypeNew[TextSearchCompleteMessageTypeNew["Warning"] = 2] = "Warning";
    })(TextSearchCompleteMessageTypeNew || (exports.TextSearchCompleteMessageTypeNew = TextSearchCompleteMessageTypeNew = {}));
    function isTextSearchMatch(object) {
        return 'uri' in object && 'ranges' in object && 'preview' in object;
    }
    function $1L(result) {
        if (isTextSearchMatch(result)) {
            const ranges = (0, arrays_1.$1b)(result.ranges).map(r => ({ sourceRange: r, previewRange: r }));
            return new $YL(result.uri, ranges, result.preview.text);
        }
        else {
            return new $ZL(result.uri, result.text, result.lineNumber);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[44/*vs/workbench/services/search/common/search*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,41/*vs/base/common/glob*/,25/*vs/base/common/objects*/,51/*vs/base/common/extpath*/,12/*vs/base/common/strings*/,3/*vs/platform/instantiation/common/instantiation*/,19/*vs/base/common/path*/,13/*vs/base/common/errors*/,130/*vs/workbench/services/search/common/searchExtTypes*/,10/*vs/base/common/async*/]), function (require, exports, arrays_1, glob, objects, extpath, strings_1, instantiation_1, paths, errors_1, searchExtTypes_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oM = exports.$mM = exports.$fM = exports.SearchErrorCode = exports.SearchSortOrder = exports.ViewMode = exports.$cM = exports.$bM = exports.$aM = exports.$_L = exports.SearchCompletionExitCode = exports.QueryType = exports.SearchProviderType = exports.$8L = exports.$7L = exports.$6L = exports.$5L = exports.$4L = exports.$3L = exports.$2L = exports.TextSearchCompleteMessageType = void 0;
    exports.$9L = $9L;
    exports.$0L = $0L;
    exports.$$L = $$L;
    exports.$dM = $dM;
    exports.$eM = $eM;
    exports.$gM = $gM;
    exports.$hM = $hM;
    exports.$iM = $iM;
    exports.$jM = $jM;
    exports.$kM = $kM;
    exports.$lM = $lM;
    exports.$nM = $nM;
    exports.$pM = $pM;
    exports.$qM = $qM;
    glob = __importStar(glob);
    objects = __importStar(objects);
    extpath = __importStar(extpath);
    paths = __importStar(paths);
    Object.defineProperty(exports, "TextSearchCompleteMessageType", { enumerable: true, get: function () { return searchExtTypes_1.TextSearchCompleteMessageType; } });
    exports.$2L = 'workbench.view.search';
    exports.$3L = 'workbench.panel.search';
    exports.$4L = 'workbench.view.search';
    exports.$5L = 'search-result';
    exports.$6L = 'search.exclude';
    exports.$7L = 20000;
    // Warning: this pattern is used in the search editor to detect offsets. If you
    // change this, also change the search-result built-in extension
    const SEARCH_ELIDED_PREFIX = '⟪ ';
    const SEARCH_ELIDED_SUFFIX = ' characters skipped ⟫';
    const SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;
    exports.$8L = (0, instantiation_1.$Fi)('searchService');
    /**
     * TODO@roblou - split text from file search entirely, or share code in a more natural way.
     */
    var SearchProviderType;
    (function (SearchProviderType) {
        SearchProviderType[SearchProviderType["file"] = 0] = "file";
        SearchProviderType[SearchProviderType["text"] = 1] = "text";
        SearchProviderType[SearchProviderType["aiText"] = 2] = "aiText";
    })(SearchProviderType || (exports.SearchProviderType = SearchProviderType = {}));
    var QueryType;
    (function (QueryType) {
        QueryType[QueryType["File"] = 1] = "File";
        QueryType[QueryType["Text"] = 2] = "Text";
        QueryType[QueryType["aiText"] = 3] = "aiText";
    })(QueryType || (exports.QueryType = QueryType = {}));
    function $9L(result) {
        return !!result.preview;
    }
    function $0L(p) {
        return !!p.resource;
    }
    function $$L(p) {
        return !!p.message;
    }
    var SearchCompletionExitCode;
    (function (SearchCompletionExitCode) {
        SearchCompletionExitCode[SearchCompletionExitCode["Normal"] = 0] = "Normal";
        SearchCompletionExitCode[SearchCompletionExitCode["NewSearchStarted"] = 1] = "NewSearchStarted";
    })(SearchCompletionExitCode || (exports.SearchCompletionExitCode = SearchCompletionExitCode = {}));
    class $_L {
        constructor(resource) {
            this.resource = resource;
            this.results = [];
            // empty
        }
    }
    exports.$_L = $_L;
    class $aM {
        constructor(text, range, previewOptions, webviewIndex) {
            this.ranges = range;
            this.webviewIndex = webviewIndex;
            // Trim preview if this is one match and a single-line match with a preview requested.
            // Otherwise send the full text, like for replace or for showing multiple previews.
            // TODO this is fishy.
            const ranges = Array.isArray(range) ? range : [range];
            if (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(ranges)) {
                // 1 line preview requested
                text = (0, strings_1.$0f)(text, previewOptions.matchLines);
                let result = '';
                let shift = 0;
                let lastEnd = 0;
                const leadingChars = Math.floor(previewOptions.charsPerLine / 5);
                const matches = [];
                for (const range of ranges) {
                    const previewStart = Math.max(range.startColumn - leadingChars, 0);
                    const previewEnd = range.startColumn + previewOptions.charsPerLine;
                    if (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {
                        const elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;
                        result += elision + text.slice(previewStart, previewEnd);
                        shift += previewStart - (lastEnd + elision.length);
                    }
                    else {
                        result += text.slice(lastEnd, previewEnd);
                    }
                    matches.push(new $cM(0, range.startColumn - shift, range.endColumn - shift));
                    lastEnd = previewEnd;
                }
                this.preview = { text: result, matches: Array.isArray(this.ranges) ? matches : matches[0] };
            }
            else {
                const firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;
                this.preview = {
                    text,
                    matches: (0, arrays_1.$Zb)(range, r => new $bM(r.startLineNumber - firstMatchLine, r.startColumn, r.endLineNumber - firstMatchLine, r.endColumn))
                };
            }
        }
    }
    exports.$aM = $aM;
    function isSingleLineRangeList(ranges) {
        const line = ranges[0].startLineNumber;
        for (const r of ranges) {
            if (r.startLineNumber !== line || r.endLineNumber !== line) {
                return false;
            }
        }
        return true;
    }
    class $bM {
        constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
        }
    }
    exports.$bM = $bM;
    class $cM extends $bM {
        constructor(lineNumber, startColumn, endColumn) {
            super(lineNumber, startColumn, lineNumber, endColumn);
        }
    }
    exports.$cM = $cM;
    var ViewMode;
    (function (ViewMode) {
        ViewMode["List"] = "list";
        ViewMode["Tree"] = "tree";
    })(ViewMode || (exports.ViewMode = ViewMode = {}));
    var SearchSortOrder;
    (function (SearchSortOrder) {
        SearchSortOrder["Default"] = "default";
        SearchSortOrder["FileNames"] = "fileNames";
        SearchSortOrder["Type"] = "type";
        SearchSortOrder["Modified"] = "modified";
        SearchSortOrder["CountDescending"] = "countDescending";
        SearchSortOrder["CountAscending"] = "countAscending";
    })(SearchSortOrder || (exports.SearchSortOrder = SearchSortOrder = {}));
    function $dM(configuration, includeSearchExcludes = true) {
        const fileExcludes = configuration && configuration.files && configuration.files.exclude;
        const searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;
        if (!fileExcludes && !searchExcludes) {
            return undefined;
        }
        if (!fileExcludes || !searchExcludes) {
            return fileExcludes || searchExcludes || undefined;
        }
        let allExcludes = Object.create(null);
        // clone the config as it could be frozen
        allExcludes = objects.$ho(allExcludes, objects.$eo(fileExcludes));
        allExcludes = objects.$ho(allExcludes, objects.$eo(searchExcludes), true);
        return allExcludes;
    }
    function $eM(queryProps, fsPath) {
        if (queryProps.excludePattern && glob.$zk(queryProps.excludePattern, fsPath)) {
            return false;
        }
        if (queryProps.includePattern || queryProps.usingSearchPaths) {
            if (queryProps.includePattern && glob.$zk(queryProps.includePattern, fsPath)) {
                return true;
            }
            // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present
            if (queryProps.usingSearchPaths) {
                return !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {
                    const searchPath = fq.folder.fsPath;
                    if (extpath.$Eg(fsPath, searchPath)) {
                        const relPath = paths.$lc(searchPath, fsPath);
                        return !fq.includePattern || !!glob.$zk(fq.includePattern, relPath);
                    }
                    else {
                        return false;
                    }
                });
            }
            return false;
        }
        return true;
    }
    var SearchErrorCode;
    (function (SearchErrorCode) {
        SearchErrorCode[SearchErrorCode["unknownEncoding"] = 1] = "unknownEncoding";
        SearchErrorCode[SearchErrorCode["regexParseError"] = 2] = "regexParseError";
        SearchErrorCode[SearchErrorCode["globParseError"] = 3] = "globParseError";
        SearchErrorCode[SearchErrorCode["invalidLiteral"] = 4] = "invalidLiteral";
        SearchErrorCode[SearchErrorCode["rgProcessError"] = 5] = "rgProcessError";
        SearchErrorCode[SearchErrorCode["other"] = 6] = "other";
        SearchErrorCode[SearchErrorCode["canceled"] = 7] = "canceled";
    })(SearchErrorCode || (exports.SearchErrorCode = SearchErrorCode = {}));
    class $fM extends Error {
        constructor(message, code) {
            super(message);
            this.code = code;
        }
    }
    exports.$fM = $fM;
    function $gM(error) {
        const errorMsg = error.message;
        if ((0, errors_1.$3)(error)) {
            return new $fM(errorMsg, SearchErrorCode.canceled);
        }
        try {
            const details = JSON.parse(errorMsg);
            return new $fM(details.message, details.code);
        }
        catch (e) {
            return new $fM(errorMsg, SearchErrorCode.other);
        }
    }
    function $hM(searchError) {
        const details = { message: searchError.message, code: searchError.code };
        return new Error(JSON.stringify(details));
    }
    function $iM(arg) {
        if (arg.type === 'error') {
            return true;
        }
        else if (arg.type === 'success') {
            return true;
        }
        else {
            return false;
        }
    }
    function $jM(arg) {
        return arg.type === 'success';
    }
    function $kM(arg) {
        return !!arg.path;
    }
    function $lM(candidate, filePatternToUse, fuzzy = true) {
        const pathToMatch = candidate.searchPath ? candidate.searchPath : candidate.relativePath;
        return fuzzy ?
            (0, strings_1.$7f)(pathToMatch, filePatternToUse) :
            glob.$zk(filePatternToUse, pathToMatch);
    }
    class $mM {
        constructor(path) {
            this.path = path;
            this.results = [];
        }
        addMatch(match) {
            this.results.push(match);
        }
        serialize() {
            return {
                path: this.path,
                results: this.results,
                numMatches: this.results.length
            };
        }
    }
    exports.$mM = $mM;
    /**
     *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns
     */
    function $nM(globalPattern, folderPattern) {
        const merged = {
            ...(globalPattern || {}),
            ...(folderPattern || {})
        };
        return Object.keys(merged)
            .filter(key => {
            const value = merged[key];
            return typeof value === 'boolean' && value;
        });
    }
    class $oM {
        constructor(config, folderQuery) {
            this.c = null;
            this.a = {
                ...(config.excludePattern || {}),
                ...(folderQuery.excludePattern || {})
            };
            this.b = glob.$Ak(this.a);
            // Empty includeExpression means include nothing, so no {} shortcuts
            let includeExpression = config.includePattern;
            if (folderQuery.includePattern) {
                if (includeExpression) {
                    includeExpression = {
                        ...includeExpression,
                        ...folderQuery.includePattern
                    };
                }
                else {
                    includeExpression = folderQuery.includePattern;
                }
            }
            if (includeExpression) {
                this.c = glob.$Ak(includeExpression);
            }
        }
        matchesExcludesSync(testPath, basename, hasSibling) {
            if (this.b && this.b(testPath, basename, hasSibling)) {
                return true;
            }
            return false;
        }
        /**
         * Guaranteed sync - siblingsFn should not return a promise.
         */
        includedInQuerySync(testPath, basename, hasSibling) {
            if (this.b && this.b(testPath, basename, hasSibling)) {
                return false;
            }
            if (this.c && !this.c(testPath, basename, hasSibling)) {
                return false;
            }
            return true;
        }
        /**
         * Evaluating the exclude expression is only async if it includes sibling clauses. As an optimization, avoid doing anything with Promises
         * unless the expression is async.
         */
        includedInQuery(testPath, basename, hasSibling) {
            const excluded = this.b(testPath, basename, hasSibling);
            const isIncluded = () => {
                return this.c ?
                    !!(this.c(testPath, basename, hasSibling)) :
                    true;
            };
            if ((0, async_1.$rh)(excluded)) {
                return excluded.then(excluded => {
                    if (excluded) {
                        return false;
                    }
                    return isIncluded();
                });
            }
            return isIncluded();
        }
        hasSiblingExcludeClauses() {
            return hasSiblingClauses(this.a);
        }
    }
    exports.$oM = $oM;
    function hasSiblingClauses(pattern) {
        for (const key in pattern) {
            if (typeof pattern[key] !== 'boolean') {
                return true;
            }
        }
        return false;
    }
    function $pM(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        let siblings;
        return (name) => {
            if (!siblings) {
                siblings = (siblingsFn() || Promise.resolve([]))
                    .then(list => list ? listToMap(list) : {});
            }
            return siblings.then(map => !!map[name]);
        };
    }
    function $qM(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        let siblings;
        return (name) => {
            if (!siblings) {
                const list = siblingsFn();
                siblings = list ? listToMap(list) : {};
            }
            return !!siblings[name];
        };
    }
    function listToMap(list) {
        const map = {};
        for (const key of list) {
            map[key] = true;
        }
        return map;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[45/*vs/workbench/api/common/extHostWorkspace*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,58/*vs/base/common/ternarySearchTree*/,15/*vs/base/common/network*/,140/*vs/base/common/numbers*/,23/*vs/base/common/resources*/,12/*vs/base/common/strings*/,2/*vs/base/common/uri*/,9/*vs/nls*/,29/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,11/*vs/platform/log/common/log*/,173/*vs/platform/notification/common/notification*/,49/*vs/platform/workspace/common/workspace*/,50/*vs/workbench/api/common/extHostFileSystemInfo*/,26/*vs/workbench/api/common/extHostInitDataService*/,16/*vs/workbench/api/common/extHostRpcService*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,65/*vs/workbench/api/common/extHostUriTransformerService*/,44/*vs/workbench/services/search/common/search*/,5/*vs/workbench/api/common/extHost.protocol*/,36/*vs/base/common/marshalling*/]), function (require, exports, arrays_1, async_1, cancellation_1, event_1, lifecycle_1, ternarySearchTree_1, network_1, numbers_1, resources_1, strings_1, uri_1, nls_1, files_1, instantiation_1, log_1, notification_1, workspace_1, extHostFileSystemInfo_1, extHostInitDataService_1, extHostRpcService_1, extHostTypeConverters_1, extHostTypes_1, extHostUriTransformerService_1, search_1, extHost_protocol_1, marshalling_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Npc = exports.$Mpc = void 0;
    function isFolderEqual(folderA, folderB, extHostFileSystemInfo) {
        return new resources_1.$8g(uri => ignorePathCasing(uri, extHostFileSystemInfo)).isEqual(folderA, folderB);
    }
    function compareWorkspaceFolderByUri(a, b, extHostFileSystemInfo) {
        return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? 0 : (0, strings_1.$yf)(a.uri.toString(), b.uri.toString());
    }
    function compareWorkspaceFolderByUriAndNameAndIndex(a, b, extHostFileSystemInfo) {
        if (a.index !== b.index) {
            return a.index < b.index ? -1 : 1;
        }
        return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? (0, strings_1.$yf)(a.name, b.name) : (0, strings_1.$yf)(a.uri.toString(), b.uri.toString());
    }
    function delta(oldFolders, newFolders, compare, extHostFileSystemInfo) {
        const oldSortedFolders = oldFolders.slice(0).sort((a, b) => compare(a, b, extHostFileSystemInfo));
        const newSortedFolders = newFolders.slice(0).sort((a, b) => compare(a, b, extHostFileSystemInfo));
        return (0, arrays_1.$Db)(oldSortedFolders, newSortedFolders, (a, b) => compare(a, b, extHostFileSystemInfo));
    }
    function ignorePathCasing(uri, extHostFileSystemInfo) {
        const capabilities = extHostFileSystemInfo.getCapabilities(uri.scheme);
        return !(capabilities && (capabilities & files_1.FileSystemProviderCapabilities.PathCaseSensitive));
    }
    class ExtHostWorkspaceImpl extends workspace_1.$Yi {
        static toExtHostWorkspace(data, previousConfirmedWorkspace, previousUnconfirmedWorkspace, extHostFileSystemInfo) {
            if (!data) {
                return { workspace: null, added: [], removed: [] };
            }
            const { id, name, folders, configuration, transient, isUntitled } = data;
            const newWorkspaceFolders = [];
            // If we have an existing workspace, we try to find the folders that match our
            // data and update their properties. It could be that an extension stored them
            // for later use and we want to keep them "live" if they are still present.
            const oldWorkspace = previousConfirmedWorkspace;
            if (previousConfirmedWorkspace) {
                folders.forEach((folderData, index) => {
                    const folderUri = uri_1.URI.revive(folderData.uri);
                    const existingFolder = ExtHostWorkspaceImpl.o(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri, extHostFileSystemInfo);
                    if (existingFolder) {
                        existingFolder.name = folderData.name;
                        existingFolder.index = folderData.index;
                        newWorkspaceFolders.push(existingFolder);
                    }
                    else {
                        newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index });
                    }
                });
            }
            else {
                newWorkspaceFolders.push(...folders.map(({ uri, name, index }) => ({ uri: uri_1.URI.revive(uri), name, index })));
            }
            // make sure to restore sort order based on index
            newWorkspaceFolders.sort((f1, f2) => f1.index < f2.index ? -1 : 1);
            const workspace = new ExtHostWorkspaceImpl(id, name, newWorkspaceFolders, !!transient, configuration ? uri_1.URI.revive(configuration) : null, !!isUntitled, uri => ignorePathCasing(uri, extHostFileSystemInfo));
            const { added, removed } = delta(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri, extHostFileSystemInfo);
            return { workspace, added, removed };
        }
        static o(workspace, folderUriToFind, extHostFileSystemInfo) {
            for (let i = 0; i < workspace.folders.length; i++) {
                const folder = workspace.workspaceFolders[i];
                if (isFolderEqual(folder.uri, folderUriToFind, extHostFileSystemInfo)) {
                    return folder;
                }
            }
            return undefined;
        }
        constructor(id, t, folders, transient, configuration, u, ignorePathCasing) {
            super(id, folders.map(f => new workspace_1.$Zi(f)), transient, configuration, ignorePathCasing);
            this.t = t;
            this.u = u;
            this.q = [];
            this.s = ternarySearchTree_1.$Li.forUris(ignorePathCasing, () => true);
            // setup the workspace folder data structure
            folders.forEach(folder => {
                this.q.push(folder);
                this.s.set(folder.uri, folder);
            });
        }
        get name() {
            return this.t;
        }
        get isUntitled() {
            return this.u;
        }
        get workspaceFolders() {
            return this.q.slice(0);
        }
        getWorkspaceFolder(uri, resolveParent) {
            if (resolveParent && this.s.get(uri)) {
                // `uri` is a workspace folder so we check for its parent
                uri = (0, resources_1.$fh)(uri);
            }
            return this.s.findSubstr(uri);
        }
        resolveWorkspaceFolder(uri) {
            return this.s.get(uri);
        }
    }
    let $Mpc = class $Mpc {
        constructor(extHostRpc, initData, extHostFileSystemInfo, logService, uriTransformerService) {
            this.c = new event_1.$le();
            this.onDidChangeWorkspace = this.c.event;
            this.g = new event_1.$le();
            this.onDidGrantWorkspaceTrust = this.g.event;
            this.u = [];
            this.v = false;
            this.w = new Map();
            // --- edit sessions ---
            this.A = 0;
            this.B = new event_1.$ne();
            // --- canonical uri identity ---
            this.C = new Map();
            this.h = logService;
            this.s = extHostFileSystemInfo;
            this.t = uriTransformerService;
            this.j = new numbers_1.$Nm();
            this.k = new async_1.$Eh();
            this.o = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadWorkspace);
            this.q = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadMessageService);
            const data = initData.workspace;
            this.l = data ? new ExtHostWorkspaceImpl(data.id, data.name, [], !!data.transient, data.configuration ? uri_1.URI.revive(data.configuration) : null, !!data.isUntitled, uri => ignorePathCasing(uri, extHostFileSystemInfo)) : undefined;
        }
        $initializeWorkspace(data, trusted) {
            this.v = trusted;
            this.$acceptWorkspaceData(data);
            this.k.open();
        }
        waitForInitializeCall() {
            return this.k.wait();
        }
        // --- workspace ---
        get workspace() {
            return this.x;
        }
        get name() {
            return this.x ? this.x.name : undefined;
        }
        get workspaceFile() {
            if (this.x) {
                if (this.x.configuration) {
                    if (this.x.isUntitled) {
                        return uri_1.URI.from({ scheme: network_1.Schemas.untitled, path: (0, resources_1.$dh)((0, resources_1.$fh)(this.x.configuration)) }); // Untitled Workspace: return untitled URI
                    }
                    return this.x.configuration; // Workspace: return the configuration location
                }
            }
            return undefined;
        }
        get x() {
            return this.n || this.l;
        }
        getWorkspaceFolders() {
            if (!this.x) {
                return undefined;
            }
            return this.x.workspaceFolders.slice(0);
        }
        async getWorkspaceFolders2() {
            await this.k.wait();
            if (!this.x) {
                return undefined;
            }
            return this.x.workspaceFolders.slice(0);
        }
        updateWorkspaceFolders(extension, index, deleteCount, ...workspaceFoldersToAdd) {
            const validatedDistinctWorkspaceFoldersToAdd = [];
            if (Array.isArray(workspaceFoldersToAdd)) {
                workspaceFoldersToAdd.forEach(folderToAdd => {
                    if (uri_1.URI.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some(f => isFolderEqual(f.uri, folderToAdd.uri, this.s))) {
                        validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || (0, resources_1.$ch)(folderToAdd.uri) });
                    }
                });
            }
            if (!!this.n) {
                return false; // prevent accumulated calls without a confirmed workspace
            }
            if ([index, deleteCount].some(i => typeof i !== 'number' || i < 0)) {
                return false; // validate numbers
            }
            if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {
                return false; // nothing to delete or add
            }
            const currentWorkspaceFolders = this.x ? this.x.workspaceFolders : [];
            if (index + deleteCount > currentWorkspaceFolders.length) {
                return false; // cannot delete more than we have
            }
            // Simulate the updateWorkspaceFolders method on our data to do more validation
            const newWorkspaceFolders = currentWorkspaceFolders.slice(0);
            newWorkspaceFolders.splice(index, deleteCount, ...validatedDistinctWorkspaceFoldersToAdd.map(f => ({ uri: f.uri, name: f.name || (0, resources_1.$ch)(f.uri), index: undefined /* fixed later */ })));
            for (let i = 0; i < newWorkspaceFolders.length; i++) {
                const folder = newWorkspaceFolders[i];
                if (newWorkspaceFolders.some((otherFolder, index) => index !== i && isFolderEqual(folder.uri, otherFolder.uri, this.s))) {
                    return false; // cannot add the same folder multiple times
                }
            }
            newWorkspaceFolders.forEach((f, index) => f.index = index); // fix index
            const { added, removed } = delta(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex, this.s);
            if (added.length === 0 && removed.length === 0) {
                return false; // nothing actually changed
            }
            // Trigger on main side
            if (this.o) {
                const extName = extension.displayName || extension.name;
                this.o.$updateWorkspaceFolders(extName, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(undefined, error => {
                    // in case of an error, make sure to clear out the unconfirmed workspace
                    // because we cannot expect the acknowledgement from the main side for this
                    this.n = undefined;
                    // show error to user
                    const options = { source: { identifier: extension.identifier, label: extension.displayName || extension.name } };
                    this.q.$showMessage(notification_1.Severity.Error, (0, nls_1.localize)(11246, null, extName, error.toString()), options, []);
                });
            }
            // Try to accept directly
            this.y(newWorkspaceFolders);
            return true;
        }
        getWorkspaceFolder(uri, resolveParent) {
            if (!this.x) {
                return undefined;
            }
            return this.x.getWorkspaceFolder(uri, resolveParent);
        }
        async getWorkspaceFolder2(uri, resolveParent) {
            await this.k.wait();
            if (!this.x) {
                return undefined;
            }
            return this.x.getWorkspaceFolder(uri, resolveParent);
        }
        async resolveWorkspaceFolder(uri) {
            await this.k.wait();
            if (!this.x) {
                return undefined;
            }
            return this.x.resolveWorkspaceFolder(uri);
        }
        getPath() {
            // this is legacy from the days before having
            // multi-root and we keep it only alive if there
            // is just one workspace folder.
            if (!this.x) {
                return undefined;
            }
            const { folders } = this.x;
            if (folders.length === 0) {
                return undefined;
            }
            // #54483 @Joh Why are we still using fsPath?
            return folders[0].uri.fsPath;
        }
        getRelativePath(pathOrUri, includeWorkspace) {
            let resource;
            let path = '';
            if (typeof pathOrUri === 'string') {
                resource = uri_1.URI.file(pathOrUri);
                path = pathOrUri;
            }
            else if (typeof pathOrUri !== 'undefined') {
                resource = pathOrUri;
                path = pathOrUri.fsPath;
            }
            if (!resource) {
                return path;
            }
            const folder = this.getWorkspaceFolder(resource, true);
            if (!folder) {
                return path;
            }
            if (typeof includeWorkspace === 'undefined' && this.x) {
                includeWorkspace = this.x.folders.length > 1;
            }
            let result = (0, resources_1.$ih)(folder.uri, resource);
            if (includeWorkspace && folder.name) {
                result = `${folder.name}/${result}`;
            }
            return result;
        }
        y(folders) {
            // Update directly here. The workspace is unconfirmed as long as we did not get an
            // acknowledgement from the main side (via $acceptWorkspaceData)
            if (this.x) {
                this.n = ExtHostWorkspaceImpl.toExtHostWorkspace({
                    id: this.x.id,
                    name: this.x.name,
                    configuration: this.x.configuration,
                    folders,
                    isUntitled: this.x.isUntitled
                }, this.x, undefined, this.s).workspace || undefined;
            }
        }
        $acceptWorkspaceData(data) {
            const { workspace, added, removed } = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this.l, this.n, this.s);
            // Update our workspace object. We have a confirmed workspace, so we drop our
            // unconfirmed workspace.
            this.l = workspace || undefined;
            this.n = undefined;
            // Events
            this.c.fire(Object.freeze({
                added,
                removed,
            }));
        }
        // --- search ---
        /**
         * Note, null/undefined have different and important meanings for "exclude"
         */
        findFiles(include, exclude, maxResults, extensionId, token = cancellation_1.CancellationToken.None) {
            this.h.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles`);
            let excludeString = '';
            let useFileExcludes = true;
            if (exclude === null) {
                useFileExcludes = false;
            }
            else if (exclude !== undefined) {
                if (typeof exclude === 'string') {
                    excludeString = exclude;
                }
                else {
                    excludeString = exclude.pattern;
                }
            }
            return this.z(include, undefined, {
                exclude: excludeString,
                maxResults,
                useDefaultExcludes: useFileExcludes,
                useDefaultSearchExcludes: false,
                useIgnoreFiles: false
            }, token);
        }
        findFiles2(filePattern, options = {}, extensionId, token = cancellation_1.CancellationToken.None) {
            this.h.trace(`extHostWorkspace#findFiles2: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles2`);
            return this.z(undefined, filePattern, options, token);
        }
        async z(
        // the old `findFiles` used `include` to query, but the new `findFiles2` uses `filePattern` to query.
        // `filePattern` is the proper way to handle this, since it takes less precedence than the ignore files.
        include, filePattern, options, token = cancellation_1.CancellationToken.None) {
            if (token && token.isCancellationRequested) {
                return Promise.resolve([]);
            }
            const excludePattern = (typeof options.exclude === 'string') ? options.exclude :
                options.exclude ? options.exclude.pattern : undefined;
            const fileQueries = {
                ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,
                disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,
                disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === 'boolean' ? !options.useGlobalIgnoreFiles : undefined,
                disregardParentIgnoreFiles: typeof options.useParentIgnoreFiles === 'boolean' ? !options.useParentIgnoreFiles : undefined,
                disregardExcludeSettings: typeof options.useDefaultExcludes === 'boolean' ? !options.useDefaultExcludes : false,
                disregardSearchExcludeSettings: typeof options.useDefaultSearchExcludes === 'boolean' ? !options.useDefaultSearchExcludes : false,
                maxResults: options.maxResults,
                excludePattern: excludePattern,
                shouldGlobSearch: typeof options.fuzzy === 'boolean' ? !options.fuzzy : true,
                _reason: 'startFileSearch'
            };
            let folderToUse;
            if (include) {
                const { includePattern, folder } = parseSearchInclude(extHostTypeConverters_1.GlobPattern.from(include));
                folderToUse = folder;
                fileQueries.includePattern = includePattern;
            }
            else {
                const { includePattern, folder } = parseSearchInclude(extHostTypeConverters_1.GlobPattern.from(filePattern));
                folderToUse = folder;
                fileQueries.filePattern = includePattern;
            }
            return this.o.$startFileSearch(folderToUse ?? null, fileQueries, token)
                .then(data => Array.isArray(data) ? data.map(d => uri_1.URI.revive(d)) : []);
        }
        async findTextInFiles(query, options, callback, extensionId, token = cancellation_1.CancellationToken.None) {
            this.h.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles`);
            const requestId = this.j.getNext();
            const previewOptions = typeof options.previewOptions === 'undefined' ?
                {
                    matchLines: 100,
                    charsPerLine: 10000
                } :
                options.previewOptions;
            const { includePattern, folder } = parseSearchInclude(extHostTypeConverters_1.GlobPattern.from(options.include));
            const excludePattern = (typeof options.exclude === 'string') ? options.exclude :
                options.exclude ? options.exclude.pattern : undefined;
            const queryOptions = {
                ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,
                disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,
                disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === 'boolean' ? !options.useGlobalIgnoreFiles : undefined,
                disregardParentIgnoreFiles: typeof options.useParentIgnoreFiles === 'boolean' ? !options.useParentIgnoreFiles : undefined,
                disregardExcludeSettings: typeof options.useDefaultExcludes === 'boolean' ? !options.useDefaultExcludes : true,
                disregardSearchExcludeSettings: typeof options.useSearchExclude === 'boolean' ? !options.useSearchExclude : true,
                fileEncoding: options.encoding,
                maxResults: options.maxResults,
                previewOptions,
                afterContext: options.afterContext,
                beforeContext: options.beforeContext,
                includePattern: includePattern,
                excludePattern: excludePattern
            };
            const isCanceled = false;
            this.u[requestId] = p => {
                if (isCanceled) {
                    return;
                }
                const uri = uri_1.URI.revive(p.resource);
                p.results.forEach(rawResult => {
                    const result = (0, marshalling_1.$ci)(rawResult);
                    if ((0, search_1.$9L)(result)) {
                        callback({
                            uri,
                            preview: {
                                text: result.preview.text,
                                matches: (0, arrays_1.$Zb)(result.preview.matches, m => new extHostTypes_1.$ON(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn))
                            },
                            ranges: (0, arrays_1.$Zb)(result.ranges, r => new extHostTypes_1.$ON(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn))
                        });
                    }
                    else {
                        callback({
                            uri,
                            text: result.text,
                            lineNumber: result.lineNumber
                        });
                    }
                });
            };
            if (token.isCancellationRequested) {
                return {};
            }
            try {
                const result = await this.o.$startTextSearch(query, folder ?? null, queryOptions, requestId, token);
                delete this.u[requestId];
                return result || {};
            }
            catch (err) {
                delete this.u[requestId];
                throw err;
            }
        }
        $handleTextSearchResult(result, requestId) {
            this.u[requestId]?.(result);
        }
        async save(uri) {
            const result = await this.o.$save(uri, { saveAs: false });
            return uri_1.URI.revive(result);
        }
        async saveAs(uri) {
            const result = await this.o.$save(uri, { saveAs: true });
            return uri_1.URI.revive(result);
        }
        saveAll(includeUntitled) {
            return this.o.$saveAll(includeUntitled);
        }
        resolveProxy(url) {
            return this.o.$resolveProxy(url);
        }
        lookupAuthorization(authInfo) {
            return this.o.$lookupAuthorization(authInfo);
        }
        lookupKerberosAuthorization(url) {
            return this.o.$lookupKerberosAuthorization(url);
        }
        loadCertificates() {
            return this.o.$loadCertificates();
        }
        // --- trust ---
        get trusted() {
            return this.v;
        }
        requestWorkspaceTrust(options) {
            return this.o.$requestWorkspaceTrust(options);
        }
        $onDidGrantWorkspaceTrust() {
            if (!this.v) {
                this.v = true;
                this.g.fire();
            }
        }
        // called by ext host
        registerEditSessionIdentityProvider(scheme, provider) {
            if (this.w.has(scheme)) {
                throw new Error(`A provider has already been registered for scheme ${scheme}`);
            }
            this.w.set(scheme, provider);
            const outgoingScheme = this.t.transformOutgoingScheme(scheme);
            const handle = this.A++;
            this.o.$registerEditSessionIdentityProvider(handle, outgoingScheme);
            return (0, lifecycle_1.$Sc)(() => {
                this.w.delete(scheme);
                this.o.$unregisterEditSessionIdentityProvider(handle);
            });
        }
        // called by main thread
        async $getEditSessionIdentifier(workspaceFolder, cancellationToken) {
            this.h.info('Getting edit session identifier for workspaceFolder', workspaceFolder);
            const folder = await this.resolveWorkspaceFolder(uri_1.URI.revive(workspaceFolder));
            if (!folder) {
                this.h.warn('Unable to resolve workspace folder');
                return undefined;
            }
            this.h.info('Invoking #provideEditSessionIdentity for workspaceFolder', folder);
            const provider = this.w.get(folder.uri.scheme);
            this.h.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
            if (!provider) {
                return undefined;
            }
            const result = await provider.provideEditSessionIdentity(folder, cancellationToken);
            this.h.info('Provider returned edit session identifier: ', result);
            if (!result) {
                return undefined;
            }
            return result;
        }
        async $provideEditSessionIdentityMatch(workspaceFolder, identity1, identity2, cancellationToken) {
            this.h.info('Getting edit session identifier for workspaceFolder', workspaceFolder);
            const folder = await this.resolveWorkspaceFolder(uri_1.URI.revive(workspaceFolder));
            if (!folder) {
                this.h.warn('Unable to resolve workspace folder');
                return undefined;
            }
            this.h.info('Invoking #provideEditSessionIdentity for workspaceFolder', folder);
            const provider = this.w.get(folder.uri.scheme);
            this.h.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
            if (!provider) {
                return undefined;
            }
            const result = await provider.provideEditSessionIdentityMatch?.(identity1, identity2, cancellationToken);
            this.h.info('Provider returned edit session identifier match result: ', result);
            if (!result) {
                return undefined;
            }
            return result;
        }
        getOnWillCreateEditSessionIdentityEvent(extension) {
            return (listener, thisArg, disposables) => {
                const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };
                wrappedListener.extension = extension;
                return this.B.event(wrappedListener, undefined, disposables);
            };
        }
        // main thread calls this to trigger participants
        async $onWillCreateEditSessionIdentity(workspaceFolder, token, timeout) {
            const folder = await this.resolveWorkspaceFolder(uri_1.URI.revive(workspaceFolder));
            if (folder === undefined) {
                throw new Error('Unable to resolve workspace folder');
            }
            await this.B.fireAsync({ workspaceFolder: folder }, token, async (thenable, listener) => {
                const now = Date.now();
                await Promise.resolve(thenable);
                if (Date.now() - now > timeout) {
                    this.h.warn('SLOW edit session create-participant', listener.extension.identifier);
                }
            });
            if (token.isCancellationRequested) {
                return undefined;
            }
        }
        // called by ext host
        registerCanonicalUriProvider(scheme, provider) {
            if (this.C.has(scheme)) {
                throw new Error(`A provider has already been registered for scheme ${scheme}`);
            }
            this.C.set(scheme, provider);
            const outgoingScheme = this.t.transformOutgoingScheme(scheme);
            const handle = this.A++;
            this.o.$registerCanonicalUriProvider(handle, outgoingScheme);
            return (0, lifecycle_1.$Sc)(() => {
                this.C.delete(scheme);
                this.o.$unregisterCanonicalUriProvider(handle);
            });
        }
        async provideCanonicalUri(uri, options, cancellationToken) {
            const provider = this.C.get(uri.scheme);
            if (!provider) {
                return undefined;
            }
            const result = await provider.provideCanonicalUri?.(uri_1.URI.revive(uri), options, cancellationToken);
            if (!result) {
                return undefined;
            }
            return result;
        }
        // called by main thread
        async $provideCanonicalUri(uri, targetScheme, cancellationToken) {
            return this.provideCanonicalUri(uri_1.URI.revive(uri), { targetScheme }, cancellationToken);
        }
    };
    exports.$Mpc = $Mpc;
    exports.$Mpc = $Mpc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ),
        __param(2, extHostFileSystemInfo_1.$vpc),
        __param(3, log_1.$ak),
        __param(4, extHostUriTransformerService_1.$Kpc)
    ], $Mpc);
    exports.$Npc = (0, instantiation_1.$Fi)('IExtHostWorkspace');
    function parseSearchInclude(include) {
        let includePattern;
        let includeFolder;
        if (include) {
            if (typeof include === 'string') {
                includePattern = include;
            }
            else {
                includePattern = include.pattern;
                includeFolder = uri_1.URI.revive(include.baseUri);
            }
        }
        return {
            includePattern,
            folder: includeFolder
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[46/*vs/workbench/api/common/extHostConfiguration*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/objects*/,6/*vs/base/common/event*/,45/*vs/workbench/api/common/extHostWorkspace*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/,43/*vs/platform/configuration/common/configuration*/,174/*vs/platform/configuration/common/configurationModels*/,53/*vs/platform/configuration/common/configurationRegistry*/,14/*vs/base/common/types*/,10/*vs/base/common/async*/,3/*vs/platform/instantiation/common/instantiation*/,16/*vs/workbench/api/common/extHostRpcService*/,11/*vs/platform/log/common/log*/,2/*vs/base/common/uri*/]), function (require, exports, objects_1, event_1, extHostWorkspace_1, extHost_protocol_1, extHostTypes_1, configuration_1, configurationModels_1, configurationRegistry_1, types_1, async_1, instantiation_1, extHostRpcService_1, log_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Qpc = exports.$Ppc = exports.$Opc = void 0;
    function lookUp(tree, key) {
        if (key) {
            const parts = key.split('.');
            let node = tree;
            for (let i = 0; node && i < parts.length; i++) {
                node = node[parts[i]];
            }
            return node;
        }
    }
    function isUri(thing) {
        return thing instanceof uri_1.URI;
    }
    function isResourceLanguage(thing) {
        return thing
            && thing.uri instanceof uri_1.URI
            && (thing.languageId && typeof thing.languageId === 'string');
    }
    function isLanguage(thing) {
        return thing
            && !thing.uri
            && (thing.languageId && typeof thing.languageId === 'string');
    }
    function isWorkspaceFolder(thing) {
        return thing
            && thing.uri instanceof uri_1.URI
            && (!thing.name || typeof thing.name === 'string')
            && (!thing.index || typeof thing.index === 'number');
    }
    function scopeToOverrides(scope) {
        if (isUri(scope)) {
            return { resource: scope };
        }
        if (isResourceLanguage(scope)) {
            return { resource: scope.uri, overrideIdentifier: scope.languageId };
        }
        if (isLanguage(scope)) {
            return { overrideIdentifier: scope.languageId };
        }
        if (isWorkspaceFolder(scope)) {
            return { resource: scope.uri };
        }
        if (scope === null) {
            return { resource: null };
        }
        return undefined;
    }
    let $Opc = class $Opc {
        constructor(extHostRpc, extHostWorkspace, logService) {
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadConfiguration);
            this.c = extHostWorkspace;
            this.b = logService;
            this.d = new async_1.$Eh();
            this.e = null;
        }
        getConfigProvider() {
            return this.d.wait().then(_ => this.e);
        }
        $initializeConfiguration(data) {
            this.e = new $Ppc(this.a, this.c, data, this.b);
            this.d.open();
        }
        $acceptConfigurationChanged(data, change) {
            this.getConfigProvider().then(provider => provider.$acceptConfigurationChanged(data, change));
        }
    };
    exports.$Opc = $Opc;
    exports.$Opc = $Opc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostWorkspace_1.$Npc),
        __param(2, log_1.$ak)
    ], $Opc);
    class $Ppc {
        constructor(proxy, extHostWorkspace, data, logService) {
            this.a = new event_1.$le();
            this.b = proxy;
            this.f = logService;
            this.c = extHostWorkspace;
            this.e = configurationModels_1.$Ro.parse(data, logService);
            this.d = this.k(data.configurationScopes);
        }
        get onDidChangeConfiguration() {
            return this.a && this.a.event;
        }
        $acceptConfigurationChanged(data, change) {
            const previous = { data: this.e.toData(), workspace: this.c.workspace };
            this.e = configurationModels_1.$Ro.parse(data, this.f);
            this.d = this.k(data.configurationScopes);
            this.a.fire(this.j(change, previous));
        }
        getConfiguration(section, scope, extensionDescription) {
            const overrides = scopeToOverrides(scope) || {};
            const config = this.g(section
                ? lookUp(this.e.getValue(undefined, overrides, this.c.workspace), section)
                : this.e.getValue(undefined, overrides, this.c.workspace));
            if (section) {
                this.h(section, overrides, extensionDescription?.identifier);
            }
            function parseConfigurationTarget(arg) {
                if (arg === undefined || arg === null) {
                    return null;
                }
                if (typeof arg === 'boolean') {
                    return arg ? configuration_1.ConfigurationTarget.USER : configuration_1.ConfigurationTarget.WORKSPACE;
                }
                switch (arg) {
                    case extHostTypes_1.ConfigurationTarget.Global: return configuration_1.ConfigurationTarget.USER;
                    case extHostTypes_1.ConfigurationTarget.Workspace: return configuration_1.ConfigurationTarget.WORKSPACE;
                    case extHostTypes_1.ConfigurationTarget.WorkspaceFolder: return configuration_1.ConfigurationTarget.WORKSPACE_FOLDER;
                }
            }
            const result = {
                has(key) {
                    return typeof lookUp(config, key) !== 'undefined';
                },
                get: (key, defaultValue) => {
                    this.h(section ? `${section}.${key}` : key, overrides, extensionDescription?.identifier);
                    let result = lookUp(config, key);
                    if (typeof result === 'undefined') {
                        result = defaultValue;
                    }
                    else {
                        let clonedConfig = undefined;
                        const cloneOnWriteProxy = (target, accessor) => {
                            if ((0, types_1.$gg)(target)) {
                                let clonedTarget = undefined;
                                const cloneTarget = () => {
                                    clonedConfig = clonedConfig ? clonedConfig : (0, objects_1.$eo)(config);
                                    clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                                };
                                return new Proxy(target, {
                                    get: (target, property) => {
                                        if (typeof property === 'string' && property.toLowerCase() === 'tojson') {
                                            cloneTarget();
                                            return () => clonedTarget;
                                        }
                                        if (clonedConfig) {
                                            clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                                            return clonedTarget[property];
                                        }
                                        const result = target[property];
                                        if (typeof property === 'string') {
                                            return cloneOnWriteProxy(result, `${accessor}.${property}`);
                                        }
                                        return result;
                                    },
                                    set: (_target, property, value) => {
                                        cloneTarget();
                                        if (clonedTarget) {
                                            clonedTarget[property] = value;
                                        }
                                        return true;
                                    },
                                    deleteProperty: (_target, property) => {
                                        cloneTarget();
                                        if (clonedTarget) {
                                            delete clonedTarget[property];
                                        }
                                        return true;
                                    },
                                    defineProperty: (_target, property, descriptor) => {
                                        cloneTarget();
                                        if (clonedTarget) {
                                            Object.defineProperty(clonedTarget, property, descriptor);
                                        }
                                        return true;
                                    }
                                });
                            }
                            if (Array.isArray(target)) {
                                return (0, objects_1.$eo)(target);
                            }
                            return target;
                        };
                        result = cloneOnWriteProxy(result, key);
                    }
                    return result;
                },
                update: (key, value, extHostConfigurationTarget, scopeToLanguage) => {
                    key = section ? `${section}.${key}` : key;
                    const target = parseConfigurationTarget(extHostConfigurationTarget);
                    if (value !== undefined) {
                        return this.b.$updateConfigurationOption(target, key, value, overrides, scopeToLanguage);
                    }
                    else {
                        return this.b.$removeConfigurationOption(target, key, overrides, scopeToLanguage);
                    }
                },
                inspect: (key) => {
                    key = section ? `${section}.${key}` : key;
                    const config = this.e.inspect(key, overrides, this.c.workspace);
                    if (config) {
                        return {
                            key,
                            defaultValue: (0, objects_1.$eo)(config.policy?.value ?? config.default?.value),
                            globalValue: (0, objects_1.$eo)(config.user?.value ?? config.application?.value),
                            workspaceValue: (0, objects_1.$eo)(config.workspace?.value),
                            workspaceFolderValue: (0, objects_1.$eo)(config.workspaceFolder?.value),
                            defaultLanguageValue: (0, objects_1.$eo)(config.default?.override),
                            globalLanguageValue: (0, objects_1.$eo)(config.user?.override ?? config.application?.override),
                            workspaceLanguageValue: (0, objects_1.$eo)(config.workspace?.override),
                            workspaceFolderLanguageValue: (0, objects_1.$eo)(config.workspaceFolder?.override),
                            languageIds: (0, objects_1.$eo)(config.overrideIdentifiers)
                        };
                    }
                    return undefined;
                }
            };
            if (typeof config === 'object') {
                (0, objects_1.$ho)(result, config, false);
            }
            return Object.freeze(result);
        }
        g(result) {
            const readonlyProxy = (target) => {
                return (0, types_1.$gg)(target) ?
                    new Proxy(target, {
                        get: (target, property) => readonlyProxy(target[property]),
                        set: (_target, property, _value) => { throw new Error(`TypeError: Cannot assign to read only property '${String(property)}' of object`); },
                        deleteProperty: (_target, property) => { throw new Error(`TypeError: Cannot delete read only property '${String(property)}' of object`); },
                        defineProperty: (_target, property) => { throw new Error(`TypeError: Cannot define property '${String(property)}' for a readonly object`); },
                        setPrototypeOf: (_target) => { throw new Error(`TypeError: Cannot set prototype for a readonly object`); },
                        isExtensible: () => false,
                        preventExtensions: () => true
                    }) : target;
            };
            return readonlyProxy(result);
        }
        h(key, overrides, extensionId) {
            const scope = configurationRegistry_1.$Go.test(key) ? configurationRegistry_1.ConfigurationScope.RESOURCE : this.d.get(key);
            const extensionIdText = extensionId ? `[${extensionId.value}] ` : '';
            if (configurationRegistry_1.ConfigurationScope.RESOURCE === scope) {
                if (typeof overrides?.resource === 'undefined') {
                    this.f.warn(`${extensionIdText}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${key}', provide the URI of a resource or 'null' for any resource.`);
                }
                return;
            }
            if (configurationRegistry_1.ConfigurationScope.WINDOW === scope) {
                if (overrides?.resource) {
                    this.f.warn(`${extensionIdText}Accessing a window scoped configuration for a resource is not expected. To associate '${key}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);
                }
                return;
            }
        }
        j(change, previous) {
            const event = new configurationModels_1.$To(change, previous, this.e, this.c.workspace, this.f);
            return Object.freeze({
                affectsConfiguration: (section, scope) => event.affectsConfiguration(section, scopeToOverrides(scope))
            });
        }
        k(scopes) {
            return scopes.reduce((result, scope) => { result.set(scope[0], scope[1]); return result; }, new Map());
        }
    }
    exports.$Ppc = $Ppc;
    exports.$Qpc = (0, instantiation_1.$Fi)('IExtHostConfiguration');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[131/*vs/workbench/api/common/extHostTask*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,10/*vs/base/common/async*/,6/*vs/base/common/event*/,5/*vs/workbench/api/common/extHost.protocol*/,7/*vs/workbench/api/common/extHostTypes*/,45/*vs/workbench/api/common/extHostWorkspace*/,57/*vs/workbench/api/common/extHostDocumentsAndEditors*/,46/*vs/workbench/api/common/extHostConfiguration*/,21/*vs/base/common/cancellation*/,56/*vs/workbench/api/common/extHostTerminalService*/,16/*vs/workbench/api/common/extHostRpcService*/,26/*vs/workbench/api/common/extHostInitDataService*/,3/*vs/platform/instantiation/common/instantiation*/,15/*vs/base/common/network*/,20/*vs/base/common/platform*/,11/*vs/platform/log/common/log*/,84/*vs/workbench/api/common/extHostApiDeprecationService*/,209/*vs/workbench/contrib/tasks/common/tasks*/,13/*vs/base/common/errors*/]), function (require, exports, uri_1, async_1, event_1, extHost_protocol_1, types, extHostWorkspace_1, extHostDocumentsAndEditors_1, extHostConfiguration_1, cancellation_1, extHostTerminalService_1, extHostRpcService_1, extHostInitDataService_1, instantiation_1, network_1, Platform, log_1, extHostApiDeprecationService_1, tasks_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$orc = exports.$nrc = exports.$mrc = exports.TaskDTO = exports.TaskHandleDTO = exports.CustomExecutionDTO = void 0;
    types = __importStar(types);
    Platform = __importStar(Platform);
    var TaskDefinitionDTO;
    (function (TaskDefinitionDTO) {
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        TaskDefinitionDTO.from = from;
        function to(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        TaskDefinitionDTO.to = to;
    })(TaskDefinitionDTO || (TaskDefinitionDTO = {}));
    var TaskPresentationOptionsDTO;
    (function (TaskPresentationOptionsDTO) {
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        TaskPresentationOptionsDTO.from = from;
        function to(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        TaskPresentationOptionsDTO.to = to;
    })(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {}));
    var ProcessExecutionOptionsDTO;
    (function (ProcessExecutionOptionsDTO) {
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        ProcessExecutionOptionsDTO.from = from;
        function to(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        ProcessExecutionOptionsDTO.to = to;
    })(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {}));
    var ProcessExecutionDTO;
    (function (ProcessExecutionDTO) {
        function is(value) {
            if (value) {
                const candidate = value;
                return candidate && !!candidate.process;
            }
            else {
                return false;
            }
        }
        ProcessExecutionDTO.is = is;
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            const result = {
                process: value.process,
                args: value.args
            };
            if (value.options) {
                result.options = ProcessExecutionOptionsDTO.from(value.options);
            }
            return result;
        }
        ProcessExecutionDTO.from = from;
        function to(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return new types.$yO(value.process, value.args, value.options);
        }
        ProcessExecutionDTO.to = to;
    })(ProcessExecutionDTO || (ProcessExecutionDTO = {}));
    var ShellExecutionOptionsDTO;
    (function (ShellExecutionOptionsDTO) {
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        ShellExecutionOptionsDTO.from = from;
        function to(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return value;
        }
        ShellExecutionOptionsDTO.to = to;
    })(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {}));
    var ShellExecutionDTO;
    (function (ShellExecutionDTO) {
        function is(value) {
            if (value) {
                const candidate = value;
                return candidate && (!!candidate.commandLine || !!candidate.command);
            }
            else {
                return false;
            }
        }
        ShellExecutionDTO.is = is;
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            const result = {};
            if (value.commandLine !== undefined) {
                result.commandLine = value.commandLine;
            }
            else {
                result.command = value.command;
                result.args = value.args;
            }
            if (value.options) {
                result.options = ShellExecutionOptionsDTO.from(value.options);
            }
            return result;
        }
        ShellExecutionDTO.from = from;
        function to(value) {
            if (value === undefined || value === null || (value.command === undefined && value.commandLine === undefined)) {
                return undefined;
            }
            if (value.commandLine) {
                return new types.$zO(value.commandLine, value.options);
            }
            else {
                return new types.$zO(value.command, value.args ? value.args : [], value.options);
            }
        }
        ShellExecutionDTO.to = to;
    })(ShellExecutionDTO || (ShellExecutionDTO = {}));
    var CustomExecutionDTO;
    (function (CustomExecutionDTO) {
        function is(value) {
            if (value) {
                const candidate = value;
                return candidate && candidate.customExecution === 'customExecution';
            }
            else {
                return false;
            }
        }
        CustomExecutionDTO.is = is;
        function from(value) {
            return {
                customExecution: 'customExecution'
            };
        }
        CustomExecutionDTO.from = from;
        function to(taskId, providedCustomExeutions) {
            return providedCustomExeutions.get(taskId);
        }
        CustomExecutionDTO.to = to;
    })(CustomExecutionDTO || (exports.CustomExecutionDTO = CustomExecutionDTO = {}));
    var TaskHandleDTO;
    (function (TaskHandleDTO) {
        function from(value, workspaceService) {
            let folder;
            if (value.scope !== undefined && typeof value.scope !== 'number') {
                folder = value.scope.uri;
            }
            else if (value.scope !== undefined && typeof value.scope === 'number') {
                if ((value.scope === types.TaskScope.Workspace) && workspaceService && workspaceService.workspaceFile) {
                    folder = workspaceService.workspaceFile;
                }
                else {
                    folder = tasks_1.$VI;
                }
            }
            return {
                id: value._id,
                workspaceFolder: folder
            };
        }
        TaskHandleDTO.from = from;
    })(TaskHandleDTO || (exports.TaskHandleDTO = TaskHandleDTO = {}));
    var TaskGroupDTO;
    (function (TaskGroupDTO) {
        function from(value) {
            if (value === undefined || value === null) {
                return undefined;
            }
            return { _id: value.id, isDefault: value.isDefault };
        }
        TaskGroupDTO.from = from;
    })(TaskGroupDTO || (TaskGroupDTO = {}));
    var TaskDTO;
    (function (TaskDTO) {
        function fromMany(tasks, extension) {
            if (tasks === undefined || tasks === null) {
                return [];
            }
            const result = [];
            for (const task of tasks) {
                const converted = from(task, extension);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
        TaskDTO.fromMany = fromMany;
        function from(value, extension) {
            if (value === undefined || value === null) {
                return undefined;
            }
            let execution;
            if (value.execution instanceof types.$yO) {
                execution = ProcessExecutionDTO.from(value.execution);
            }
            else if (value.execution instanceof types.$zO) {
                execution = ShellExecutionDTO.from(value.execution);
            }
            else if (value.execution && value.execution instanceof types.$AO) {
                execution = CustomExecutionDTO.from(value.execution);
            }
            const definition = TaskDefinitionDTO.from(value.definition);
            let scope;
            if (value.scope) {
                if (typeof value.scope === 'number') {
                    scope = value.scope;
                }
                else {
                    scope = value.scope.uri;
                }
            }
            else {
                // To continue to support the deprecated task constructor that doesn't take a scope, we must add a scope here:
                scope = types.TaskScope.Workspace;
            }
            if (!definition || !scope) {
                return undefined;
            }
            const result = {
                _id: value._id,
                definition,
                name: value.name,
                source: {
                    extensionId: extension.identifier.value,
                    label: value.source,
                    scope: scope
                },
                execution: execution,
                isBackground: value.isBackground,
                group: TaskGroupDTO.from(value.group),
                presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),
                problemMatchers: value.problemMatchers,
                hasDefinedMatchers: value.hasDefinedMatchers,
                runOptions: value.runOptions ? value.runOptions : { reevaluateOnRerun: true },
                detail: value.detail
            };
            return result;
        }
        TaskDTO.from = from;
        async function to(value, workspace, providedCustomExeutions) {
            if (value === undefined || value === null) {
                return undefined;
            }
            let execution;
            if (ProcessExecutionDTO.is(value.execution)) {
                execution = ProcessExecutionDTO.to(value.execution);
            }
            else if (ShellExecutionDTO.is(value.execution)) {
                execution = ShellExecutionDTO.to(value.execution);
            }
            else if (CustomExecutionDTO.is(value.execution)) {
                execution = CustomExecutionDTO.to(value._id, providedCustomExeutions);
            }
            const definition = TaskDefinitionDTO.to(value.definition);
            let scope;
            if (value.source) {
                if (value.source.scope !== undefined) {
                    if (typeof value.source.scope === 'number') {
                        scope = value.source.scope;
                    }
                    else {
                        scope = await workspace.resolveWorkspaceFolder(uri_1.URI.revive(value.source.scope));
                    }
                }
                else {
                    scope = types.TaskScope.Workspace;
                }
            }
            if (!definition || !scope) {
                return undefined;
            }
            const result = new types.$BO(definition, scope, value.name, value.source.label, execution, value.problemMatchers);
            if (value.isBackground !== undefined) {
                result.isBackground = value.isBackground;
            }
            if (value.group !== undefined) {
                result.group = types.$xO.from(value.group._id);
                if (result.group && value.group.isDefault) {
                    result.group = new types.$xO(result.group.id, result.group.label);
                    if (value.group.isDefault === true) {
                        result.group.isDefault = value.group.isDefault;
                    }
                }
            }
            if (value.presentationOptions) {
                result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);
            }
            if (value._id) {
                result._id = value._id;
            }
            if (value.detail) {
                result.detail = value.detail;
            }
            return result;
        }
        TaskDTO.to = to;
    })(TaskDTO || (exports.TaskDTO = TaskDTO = {}));
    var TaskFilterDTO;
    (function (TaskFilterDTO) {
        function from(value) {
            return value;
        }
        TaskFilterDTO.from = from;
        function to(value) {
            if (!value) {
                return undefined;
            }
            return Object.assign(Object.create(null), value);
        }
        TaskFilterDTO.to = to;
    })(TaskFilterDTO || (TaskFilterDTO = {}));
    class TaskExecutionImpl {
        #tasks;
        constructor(tasks, _id, a) {
            this._id = _id;
            this.a = a;
            this.#tasks = tasks;
        }
        get task() {
            return this.a;
        }
        terminate() {
            this.#tasks.terminateTask(this);
        }
        fireDidStartProcess(value) {
        }
        fireDidEndProcess(value) {
        }
    }
    let $mrc = class $mrc {
        constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {
            this.q = new event_1.$le();
            this.r = new event_1.$le();
            this.s = new event_1.$le();
            this.u = new event_1.$le();
            this.a = extHostRpc.getProxy(extHost_protocol_1.$KN.MainThreadTask);
            this.b = workspaceService;
            this.c = editorService;
            this.d = configurationService;
            this.e = extHostTerminalService;
            this.h = 0;
            this.j = new Map();
            this.k = new Map();
            this.l = new Map();
            this.m = new Map();
            this.n = new Set();
            this.o = new Map();
            this.f = logService;
            this.g = deprecationService;
            this.a.$registerSupportedExecutions(true);
        }
        registerTaskProvider(extension, type, provider) {
            if (!provider) {
                return new types.$MN(() => { });
            }
            const handle = this.x();
            this.j.set(handle, { type, provider, extension });
            this.a.$registerTaskProvider(handle, type);
            return new types.$MN(() => {
                this.j.delete(handle);
                this.a.$unregisterTaskProvider(handle);
            });
        }
        registerTaskSystem(scheme, info) {
            this.a.$registerTaskSystem(scheme, info);
        }
        fetchTasks(filter) {
            return this.a.$fetchTasks(TaskFilterDTO.from(filter)).then(async (values) => {
                const result = [];
                for (const value of values) {
                    const task = await TaskDTO.to(value, this.b, this.m);
                    if (task) {
                        result.push(task);
                    }
                }
                return result;
            });
        }
        get taskExecutions() {
            const result = [];
            this.k.forEach(value => result.push(value));
            return result;
        }
        terminateTask(execution) {
            if (!(execution instanceof TaskExecutionImpl)) {
                throw new Error('No valid task execution provided');
            }
            return this.a.$terminateTask(execution._id);
        }
        get onDidStartTask() {
            return this.q.event;
        }
        async $onDidStartTask(execution, terminalId, resolvedDefinition) {
            const customExecution = this.m.get(execution.id);
            if (customExecution) {
                // Clone the custom execution to keep the original untouched. This is important for multiple runs of the same task.
                this.o.set(execution.id, customExecution);
                this.e.attachPtyToTerminal(terminalId, await customExecution.callback(resolvedDefinition));
            }
            this.p = execution.id;
            this.q.fire({
                execution: await this.z(execution)
            });
        }
        get onDidEndTask() {
            return this.r.event;
        }
        async $OnDidEndTask(execution) {
            if (!this.l.has(execution.id)) {
                // Event already fired by the main thread
                // See https://github.com/microsoft/vscode/commit/aaf73920aeae171096d205efb2c58804a32b6846
                return;
            }
            const _execution = await this.z(execution);
            this.l.delete(execution.id);
            this.k.delete(execution.id);
            this.B(execution);
            this.r.fire({
                execution: _execution
            });
        }
        get onDidStartTaskProcess() {
            return this.s.event;
        }
        async $onDidStartTaskProcess(value) {
            const execution = await this.z(value.id);
            this.s.fire({
                execution: execution,
                processId: value.processId
            });
        }
        get onDidEndTaskProcess() {
            return this.u.event;
        }
        async $onDidEndTaskProcess(value) {
            const execution = await this.z(value.id);
            this.u.fire({
                execution: execution,
                exitCode: value.exitCode
            });
        }
        $provideTasks(handle, validTypes) {
            const handler = this.j.get(handle);
            if (!handler) {
                return Promise.reject(new Error('no handler found'));
            }
            // Set up a list of task ID promises that we can wait on
            // before returning the provided tasks. The ensures that
            // our task IDs are calculated for any custom execution tasks.
            // Knowing this ID ahead of time is needed because when a task
            // start event is fired this is when the custom execution is called.
            // The task start event is also the first time we see the ID from the main
            // thread, which is too late for us because we need to save an map
            // from an ID to the custom execution function. (Kind of a cart before the horse problem).
            const taskIdPromises = [];
            const fetchPromise = (0, async_1.$xh)(() => handler.provider.provideTasks(cancellation_1.CancellationToken.None)).then(value => {
                return this.v(validTypes, taskIdPromises, handler, value);
            });
            return new Promise((resolve) => {
                fetchPromise.then((result) => {
                    Promise.all(taskIdPromises).then(() => {
                        resolve(result);
                    });
                });
            });
        }
        async $resolveTask(handle, taskDTO) {
            const handler = this.j.get(handle);
            if (!handler) {
                return Promise.reject(new Error('no handler found'));
            }
            if (taskDTO.definition.type !== handler.type) {
                throw new Error(`Unexpected: Task of type [${taskDTO.definition.type}] cannot be resolved by provider of type [${handler.type}].`);
            }
            const task = await TaskDTO.to(taskDTO, this.b, this.m);
            if (!task) {
                throw new Error('Unexpected: Task cannot be resolved.');
            }
            const resolvedTask = await handler.provider.resolveTask(task, cancellation_1.CancellationToken.None);
            if (!resolvedTask) {
                return;
            }
            this.A(resolvedTask, handler);
            const resolvedTaskDTO = TaskDTO.from(resolvedTask, handler.extension);
            if (!resolvedTaskDTO) {
                throw new Error('Unexpected: Task cannot be resolved.');
            }
            if (resolvedTask.definition !== task.definition) {
                throw new Error('Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.');
            }
            if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {
                await this.y(resolvedTaskDTO, resolvedTask, true);
            }
            return await this.w(resolvedTaskDTO);
        }
        x() {
            return this.h++;
        }
        async y(taskDTO, task, isProvided) {
            const taskId = await this.a.$createTaskId(taskDTO);
            if (!isProvided && !this.m.has(taskId)) {
                this.n.add(taskId);
                // Also add to active executions when not coming from a provider to prevent timing issue.
                this.o.set(taskId, task.execution);
            }
            this.m.set(taskId, task.execution);
        }
        async z(execution, task) {
            if (typeof execution === 'string') {
                const taskExecution = this.l.get(execution);
                if (!taskExecution) {
                    throw new errors_1.$ab('Unexpected: The specified task is missing an execution');
                }
                return taskExecution;
            }
            const result = this.l.get(execution.id);
            if (result) {
                return result;
            }
            let executionPromise;
            if (!task) {
                executionPromise = TaskDTO.to(execution.task, this.b, this.m).then(t => {
                    if (!t) {
                        throw new errors_1.$ab('Unexpected: Task does not exist.');
                    }
                    return new TaskExecutionImpl(this, execution.id, t);
                });
            }
            else {
                executionPromise = Promise.resolve(new TaskExecutionImpl(this, execution.id, task));
            }
            this.l.set(execution.id, executionPromise);
            return executionPromise.then(taskExecution => {
                this.k.set(execution.id, taskExecution);
                return taskExecution;
            });
        }
        A(task, handler) {
            const tTask = task;
            if (tTask._deprecated) {
                this.g.report('Task.constructor', handler.extension, 'Use the Task constructor that takes a `scope` instead.');
            }
        }
        B(execution) {
            const extensionCallback2 = this.o.get(execution.id);
            if (extensionCallback2) {
                this.o.delete(execution.id);
            }
            // Technically we don't really need to do this, however, if an extension
            // is executing a task through "executeTask" over and over again
            // with different properties in the task definition, then the map of executions
            // could grow indefinitely, something we don't want.
            if (this.n.has(execution.id) && (this.p !== execution.id)) {
                this.m.delete(execution.id);
                this.n.delete(execution.id);
            }
            const iterator = this.n.values();
            let iteratorResult = iterator.next();
            while (!iteratorResult.done) {
                if (!this.o.has(iteratorResult.value) && (this.p !== iteratorResult.value)) {
                    this.m.delete(iteratorResult.value);
                    this.n.delete(iteratorResult.value);
                }
                iteratorResult = iterator.next();
            }
        }
    };
    exports.$mrc = $mrc;
    exports.$mrc = $mrc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ),
        __param(2, extHostWorkspace_1.$Npc),
        __param(3, extHostDocumentsAndEditors_1.$vQ),
        __param(4, extHostConfiguration_1.$Qpc),
        __param(5, extHostTerminalService_1.$cqc),
        __param(6, log_1.$ak),
        __param(7, extHostApiDeprecationService_1.$rpc)
    ], $mrc);
    let $nrc = class $nrc extends $mrc {
        constructor(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService) {
            super(extHostRpc, initData, workspaceService, editorService, configurationService, extHostTerminalService, logService, deprecationService);
            this.registerTaskSystem(network_1.Schemas.vscodeRemote, {
                scheme: network_1.Schemas.vscodeRemote,
                authority: '',
                platform: Platform.$i(Platform.Platform.Web)
            });
        }
        async executeTask(extension, task) {
            if (!task.execution) {
                throw new Error('Tasks to execute must include an execution');
            }
            const dto = TaskDTO.from(task, extension);
            if (dto === undefined) {
                throw new Error('Task is not valid');
            }
            // If this task is a custom execution, then we need to save it away
            // in the provided custom execution map that is cleaned up after the
            // task is executed.
            if (CustomExecutionDTO.is(dto.execution)) {
                await this.y(dto, task, false);
            }
            else {
                throw new errors_1.$$();
            }
            // Always get the task execution first to prevent timing issues when retrieving it later
            const execution = await this.z(await this.a.$getTaskExecution(dto), task);
            this.a.$executeTask(dto).catch(error => { throw new Error(error); });
            return execution;
        }
        v(validTypes, taskIdPromises, handler, value) {
            const taskDTOs = [];
            if (value) {
                for (const task of value) {
                    this.A(task, handler);
                    if (!task.definition || !validTypes[task.definition.type]) {
                        const source = task.source ? task.source : 'No task source';
                        this.f.warn(`The task [${source}, ${task.name}] uses an undefined task type. The task will be ignored in the future.`);
                    }
                    const taskDTO = TaskDTO.from(task, handler.extension);
                    if (taskDTO && CustomExecutionDTO.is(taskDTO.execution)) {
                        taskDTOs.push(taskDTO);
                        // The ID is calculated on the main thread task side, so, let's call into it here.
                        // We need the task id's pre-computed for custom task executions because when OnDidStartTask
                        // is invoked, we have to be able to map it back to our data.
                        taskIdPromises.push(this.y(taskDTO, task, true));
                    }
                    else {
                        this.f.warn('Only custom execution tasks supported.');
                    }
                }
            }
            return {
                tasks: taskDTOs,
                extension: handler.extension
            };
        }
        async w(resolvedTaskDTO) {
            if (CustomExecutionDTO.is(resolvedTaskDTO.execution)) {
                return resolvedTaskDTO;
            }
            else {
                this.f.warn('Only custom execution tasks supported.');
            }
            return undefined;
        }
        async $resolveVariables(uriComponents, toResolve) {
            const result = {
                process: undefined,
                variables: Object.create(null)
            };
            return result;
        }
        async $jsonTasksSupported() {
            return false;
        }
        async $findExecutable(command, cwd, paths) {
            return undefined;
        }
    };
    exports.$nrc = $nrc;
    exports.$nrc = $nrc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostInitDataService_1.$AQ),
        __param(2, extHostWorkspace_1.$Npc),
        __param(3, extHostDocumentsAndEditors_1.$vQ),
        __param(4, extHostConfiguration_1.$Qpc),
        __param(5, extHostTerminalService_1.$cqc),
        __param(6, log_1.$ak),
        __param(7, extHostApiDeprecationService_1.$rpc)
    ], $nrc);
    exports.$orc = (0, instantiation_1.$Fi)('IExtHostTask');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[268/*vs/workbench/contrib/search/common/searchNotebookHelpers*/], __M([1/*require*/,0/*exports*/,44/*vs/workbench/services/search/common/search*/,32/*vs/editor/common/core/range*/]), function (require, exports, search_1, range_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$xM = void 0;
    exports.$wM = $wM;
    exports.$yM = $yM;
    function $wM(object) {
        return 'cellResults' in object;
    }
    exports.$xM = 'rawCell#';
    function $yM(contentMatches, buffer) {
        let previousEndLine = -1;
        const contextGroupings = [];
        let currentContextGrouping = [];
        contentMatches.forEach((match) => {
            if (match.range.startLineNumber !== previousEndLine) {
                if (currentContextGrouping.length > 0) {
                    contextGroupings.push([...currentContextGrouping]);
                    currentContextGrouping = [];
                }
            }
            currentContextGrouping.push(match);
            previousEndLine = match.range.endLineNumber;
        });
        if (currentContextGrouping.length > 0) {
            contextGroupings.push([...currentContextGrouping]);
        }
        const textSearchResults = contextGroupings.map((grouping) => {
            const lineTexts = [];
            const firstLine = grouping[0].range.startLineNumber;
            const lastLine = grouping[grouping.length - 1].range.endLineNumber;
            for (let i = firstLine; i <= lastLine; i++) {
                lineTexts.push(buffer.getLineContent(i));
            }
            return new search_1.$aM(lineTexts.join('\n') + '\n', grouping.map(m => new range_1.$Ot(m.range.startLineNumber - 1, m.range.startColumn - 1, m.range.endLineNumber - 1, m.range.endColumn - 1)));
        });
        return textSearchResults;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[269/*vs/workbench/api/common/extHostNotebook*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,22/*vs/base/common/buffer*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,28/*vs/base/common/map*/,37/*vs/base/common/marshallingIds*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,29/*vs/platform/files/common/files*/,79/*vs/workbench/api/common/cache*/,5/*vs/workbench/api/common/extHost.protocol*/,33/*vs/workbench/api/common/extHostCommands*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,39/*vs/workbench/services/extensions/common/proxyIdentifier*/,246/*vs/workbench/api/common/extHostNotebookDocument*/,124/*vs/workbench/api/common/extHostNotebookEditor*/,25/*vs/base/common/objects*/,15/*vs/base/common/network*/,44/*vs/workbench/services/search/common/search*/,199/*vs/workbench/contrib/search/common/cellSearchModel*/,268/*vs/workbench/contrib/search/common/searchNotebookHelpers*/,266/*vs/workbench/services/editor/common/editorResolverService*/]), function (require, exports, nls_1, buffer_1, event_1, lifecycle_1, map_1, marshallingIds_1, strings_1, types_1, uri_1, files, cache_1, extHost_protocol_1, extHostCommands_1, typeConverters, extHostTypes, proxyIdentifier_1, extHostNotebookDocument_1, extHostNotebookEditor_1, objects_1, network_1, search_1, cellSearchModel_1, searchNotebookHelpers_1, editorResolverService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$1qc = void 0;
    files = __importStar(files);
    typeConverters = __importStar(typeConverters);
    extHostTypes = __importStar(extHostTypes);
    class $1qc {
        static { this.a = 0; }
        get activeNotebookEditor() {
            return this.k?.apiEditor;
        }
        get visibleNotebookEditors() {
            return this.l.map(editor => editor.apiEditor);
        }
        constructor(mainContext, commands, q, r, s, t, u) {
            this.q = q;
            this.r = r;
            this.s = s;
            this.t = t;
            this.u = u;
            this.f = new Map();
            this.g = new map_1.$Ac();
            this.h = new Map();
            this.j = new event_1.$le();
            this.onDidChangeActiveNotebookEditor = this.j.event;
            this.l = [];
            this.m = new event_1.$le();
            this.onDidOpenNotebookDocument = this.m.event;
            this.n = new event_1.$le();
            this.onDidCloseNotebookDocument = this.n.event;
            this.o = new event_1.$le();
            this.onDidChangeVisibleNotebookEditors = this.o.event;
            this.p = new cache_1.$ppc('NotebookCellStatusBarCache');
            // --- serialize/deserialize
            this.x = 0;
            this.y = new Map();
            this.b = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadNotebook);
            this.c = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadNotebookDocuments);
            this.d = mainContext.getProxy(extHost_protocol_1.$KN.MainThreadNotebookEditors);
            this.i = commands.converter;
            commands.registerArgumentProcessor({
                // Serialized INotebookCellActionContext
                processArgument: (arg) => {
                    if (arg && arg.$mid === marshallingIds_1.MarshalledId.NotebookCellActionContext) {
                        const notebookUri = arg.notebookEditor?.notebookUri;
                        const cellHandle = arg.cell.handle;
                        const data = this.g.get(notebookUri);
                        const cell = data?.getCell(cellHandle);
                        if (cell) {
                            return cell.apiCell;
                        }
                    }
                    if (arg && arg.$mid === marshallingIds_1.MarshalledId.NotebookActionContext) {
                        const notebookUri = arg.uri;
                        const data = this.g.get(notebookUri);
                        if (data) {
                            return data.apiNotebook;
                        }
                    }
                    return arg;
                }
            });
            $1qc.C(commands);
        }
        getEditorById(editorId) {
            const editor = this.h.get(editorId);
            if (!editor) {
                throw new Error(`unknown text editor: ${editorId}. known editors: ${[...this.h.keys()]} `);
            }
            return editor;
        }
        getIdByEditor(editor) {
            for (const [id, candidate] of this.h) {
                if (candidate.apiEditor === editor) {
                    return id;
                }
            }
            return undefined;
        }
        get notebookDocuments() {
            return [...this.g.values()];
        }
        getNotebookDocument(uri, relaxed) {
            const result = this.g.get(uri);
            if (!result && !relaxed) {
                throw new Error(`NO notebook document for '${uri}'`);
            }
            return result;
        }
        static w(extension, registration) {
            if (!registration) {
                return;
            }
            const viewOptionsFilenamePattern = registration.filenamePattern
                .map(pattern => typeConverters.NotebookExclusiveDocumentPattern.from(pattern))
                .filter(pattern => pattern !== undefined);
            if (registration.filenamePattern && !viewOptionsFilenamePattern) {
                console.warn(`Notebook content provider view options file name pattern is invalid ${registration.filenamePattern}`);
                return undefined;
            }
            return {
                extension: extension.identifier,
                providerDisplayName: extension.displayName || extension.name,
                displayName: registration.displayName,
                filenamePattern: viewOptionsFilenamePattern,
                priority: registration.exclusive ? editorResolverService_1.RegisteredEditorPriority.exclusive : undefined
            };
        }
        registerNotebookCellStatusBarItemProvider(extension, notebookType, provider) {
            const handle = $1qc.a++;
            const eventHandle = typeof provider.onDidChangeCellStatusBarItems === 'function' ? $1qc.a++ : undefined;
            this.f.set(handle, provider);
            this.b.$registerNotebookCellStatusBarItemProvider(handle, eventHandle, notebookType);
            let subscription;
            if (eventHandle !== undefined) {
                subscription = provider.onDidChangeCellStatusBarItems(_ => this.b.$emitCellStatusBarEvent(eventHandle));
            }
            return new extHostTypes.$MN(() => {
                this.f.delete(handle);
                this.b.$unregisterNotebookCellStatusBarItemProvider(handle, eventHandle);
                subscription?.dispose();
            });
        }
        async createNotebookDocument(options) {
            const canonicalUri = await this.c.$tryCreateNotebook({
                viewType: options.viewType,
                content: options.content && typeConverters.NotebookData.from(options.content)
            });
            return uri_1.URI.revive(canonicalUri);
        }
        async openNotebookDocument(uri) {
            const cached = this.g.get(uri);
            if (cached) {
                return cached.apiNotebook;
            }
            const canonicalUri = await this.c.$tryOpenNotebook(uri);
            const document = this.g.get(uri_1.URI.revive(canonicalUri));
            return (0, types_1.$pg)(document?.apiNotebook);
        }
        async showNotebookDocument(notebookOrUri, options) {
            if (uri_1.URI.isUri(notebookOrUri)) {
                notebookOrUri = await this.openNotebookDocument(notebookOrUri);
            }
            let resolvedOptions;
            if (typeof options === 'object') {
                resolvedOptions = {
                    position: typeConverters.ViewColumn.from(options.viewColumn),
                    preserveFocus: options.preserveFocus,
                    selections: options.selections && options.selections.map(typeConverters.NotebookRange.from),
                    pinned: typeof options.preview === 'boolean' ? !options.preview : undefined
                };
            }
            else {
                resolvedOptions = {
                    preserveFocus: false
                };
            }
            const editorId = await this.d.$tryShowNotebookDocument(notebookOrUri.uri, notebookOrUri.notebookType, resolvedOptions);
            const editor = editorId && this.h.get(editorId)?.apiEditor;
            if (editor) {
                return editor;
            }
            if (editorId) {
                throw new Error(`Could NOT open editor for "${notebookOrUri.uri.toString()}" because another editor opened in the meantime.`);
            }
            else {
                throw new Error(`Could NOT open editor for "${notebookOrUri.uri.toString()}".`);
            }
        }
        async $provideNotebookCellStatusBarItems(handle, uri, index, token) {
            const provider = this.f.get(handle);
            const revivedUri = uri_1.URI.revive(uri);
            const document = this.g.get(revivedUri);
            if (!document || !provider) {
                return;
            }
            const cell = document.getCellFromIndex(index);
            if (!cell) {
                return;
            }
            const result = await provider.provideCellStatusBarItems(cell.apiCell, token);
            if (!result) {
                return undefined;
            }
            const disposables = new lifecycle_1.$Tc();
            const cacheId = this.p.add([disposables]);
            const resultArr = Array.isArray(result) ? result : [result];
            const items = resultArr.map(item => typeConverters.NotebookStatusBarItem.from(item, this.i, disposables));
            return {
                cacheId,
                items
            };
        }
        $releaseNotebookCellStatusBarItems(cacheId) {
            this.p.delete(cacheId);
        }
        registerNotebookSerializer(extension, viewType, serializer, options, registration) {
            if ((0, strings_1.$cf)(viewType)) {
                throw new Error(`viewType cannot be empty or just whitespace`);
            }
            const handle = this.x++;
            this.y.set(handle, { viewType, serializer, options });
            this.b.$registerNotebookSerializer(handle, { id: extension.identifier, location: extension.extensionLocation }, viewType, typeConverters.NotebookDocumentContentOptions.from(options), $1qc.w(extension, registration));
            return (0, lifecycle_1.$Sc)(() => {
                this.b.$unregisterNotebookSerializer(handle);
            });
        }
        async $dataToNotebook(handle, bytes, token) {
            const serializer = this.y.get(handle);
            if (!serializer) {
                throw new Error('NO serializer found');
            }
            const data = await serializer.serializer.deserializeNotebook(bytes.buffer, token);
            return new proxyIdentifier_1.$Xw(typeConverters.NotebookData.from(data));
        }
        async $notebookToData(handle, data, token) {
            const serializer = this.y.get(handle);
            if (!serializer) {
                throw new Error('NO serializer found');
            }
            const bytes = await serializer.serializer.serializeNotebook(typeConverters.NotebookData.to(data.value), token);
            return buffer_1.$Ne.wrap(bytes);
        }
        async $saveNotebook(handle, uriComponents, versionId, options, token) {
            const uri = uri_1.URI.revive(uriComponents);
            const serializer = this.y.get(handle);
            this.D(`enter saveNotebook(versionId: ${versionId}, ${uri.toString()})`);
            if (!serializer) {
                throw new Error('NO serializer found');
            }
            const document = this.g.get(uri);
            if (!document) {
                throw new Error('Document NOT found');
            }
            if (document.versionId !== versionId) {
                throw new Error('Document version mismatch');
            }
            if (!this.s.value.isWritableFileSystem(uri.scheme)) {
                throw new files.$vl((0, nls_1.localize)(11254, null, this.A(uri)), files.FileOperationResult.FILE_PERMISSION_DENIED);
            }
            const data = {
                metadata: (0, objects_1.$mo)(document.apiNotebook.metadata, key => !(serializer.options?.transientDocumentMetadata ?? {})[key]),
                cells: [],
            };
            // this data must be retrieved before any async calls to ensure the data is for the correct version
            for (const cell of document.apiNotebook.getCells()) {
                const cellData = new extHostTypes.$fP(cell.kind, cell.document.getText(), cell.document.languageId, cell.mime, !(serializer.options?.transientOutputs) ? [...cell.outputs] : [], cell.metadata, cell.executionSummary);
                cellData.metadata = (0, objects_1.$mo)(cell.metadata, key => !(serializer.options?.transientCellMetadata ?? {})[key]);
                data.cells.push(cellData);
            }
            // validate write
            await this.z(uri, options);
            if (token.isCancellationRequested) {
                throw new Error('canceled');
            }
            const bytes = await serializer.serializer.serializeNotebook(data, token);
            if (token.isCancellationRequested) {
                throw new Error('canceled');
            }
            // Don't accept any cancellation beyond this point, we need to report the result of the file write
            this.D(`serialized versionId: ${versionId} ${uri.toString()}`);
            await this.s.value.writeFile(uri, bytes);
            this.D(`Finished write versionId: ${versionId} ${uri.toString()}`);
            const providerExtUri = this.s.getFileSystemProviderExtUri(uri.scheme);
            const stat = await this.s.value.stat(uri);
            const fileStats = {
                name: providerExtUri.basename(uri),
                isFile: (stat.type & files.FileType.File) !== 0,
                isDirectory: (stat.type & files.FileType.Directory) !== 0,
                isSymbolicLink: (stat.type & files.FileType.SymbolicLink) !== 0,
                mtime: stat.mtime,
                ctime: stat.ctime,
                size: stat.size,
                readonly: Boolean((stat.permissions ?? 0) & files.FilePermission.Readonly) || !this.s.value.isWritableFileSystem(uri.scheme),
                locked: Boolean((stat.permissions ?? 0) & files.FilePermission.Locked),
                etag: files.$Gl({ mtime: stat.mtime, size: stat.size }),
                children: undefined
            };
            this.D(`exit saveNotebook(versionId: ${versionId}, ${uri.toString()})`);
            return fileStats;
        }
        /**
         * Search for query in all notebooks that can be deserialized by the serializer fetched by `handle`.
         *
         * @param handle used to get notebook serializer
         * @param textQuery the text query to search using
         * @param viewTypeFileTargets the globs (and associated ranks) that are targetting for opening this type of notebook
         * @param otherViewTypeFileTargets ranked globs for other editors that we should consider when deciding whether it will open as this notebook
         * @param token cancellation token
         * @returns `IRawClosedNotebookFileMatch` for every file. Files without matches will just have a `IRawClosedNotebookFileMatch`
         * 	with no `cellResults`. This allows the caller to know what was searched in already, even if it did not yield results.
         */
        async $searchInNotebooks(handle, textQuery, viewTypeFileTargets, otherViewTypeFileTargets, token) {
            const serializer = this.y.get(handle)?.serializer;
            if (!serializer) {
                return {
                    limitHit: false,
                    results: []
                };
            }
            const finalMatchedTargets = new map_1.$Bc();
            const runFileQueries = async (includes, token, textQuery) => {
                await Promise.all(includes.map(async (include) => await Promise.all(include.filenamePatterns.map(filePattern => {
                    const query = {
                        _reason: textQuery._reason,
                        folderQueries: textQuery.folderQueries,
                        includePattern: textQuery.includePattern,
                        excludePattern: textQuery.excludePattern,
                        maxResults: textQuery.maxResults,
                        type: search_1.QueryType.File,
                        filePattern
                    };
                    // use priority info to exclude info from other globs
                    return this.t.doInternalFileSearchWithCustomCallback(query, token, (data) => {
                        data.forEach(uri => {
                            if (finalMatchedTargets.has(uri)) {
                                return;
                            }
                            const hasOtherMatches = otherViewTypeFileTargets.some(target => {
                                // use the same strategy that the editor service uses to open editors
                                // https://github.com/microsoft/vscode/blob/ac1631528e67637da65ec994c6dc35d73f6e33cc/src/vs/workbench/services/editor/browser/editorResolverService.ts#L359-L366
                                if (include.isFromSettings && !target.isFromSettings) {
                                    // if the include is from the settings and target isn't, even if it matches, it's still overridden.
                                    return false;
                                }
                                else {
                                    // longer filePatterns are considered more specifc, so they always have precedence the shorter patterns
                                    return target.filenamePatterns.some(targetFilePattern => (0, editorResolverService_1.$qL)(targetFilePattern, uri));
                                }
                            });
                            if (hasOtherMatches) {
                                return;
                            }
                            finalMatchedTargets.add(uri);
                        });
                    }).catch(err => {
                        // temporary fix for https://github.com/microsoft/vscode/issues/205044: don't show notebook results for remotehub repos.
                        if (err.code === 'ENOENT') {
                            console.warn(`Could not find notebook search results, ignoring notebook results.`);
                            return {
                                limitHit: false,
                                messages: [],
                            };
                        }
                        else {
                            throw err;
                        }
                    });
                }))));
                return;
            };
            await runFileQueries(viewTypeFileTargets, token, textQuery);
            const results = new map_1.$Ac();
            let limitHit = false;
            const promises = Array.from(finalMatchedTargets).map(async (uri) => {
                const cellMatches = [];
                try {
                    if (token.isCancellationRequested) {
                        return;
                    }
                    if (textQuery.maxResults && [...results.values()].reduce((acc, value) => acc + value.cellResults.length, 0) > textQuery.maxResults) {
                        limitHit = true;
                        return;
                    }
                    const simpleCells = [];
                    const notebook = this.g.get(uri);
                    if (notebook) {
                        const cells = notebook.apiNotebook.getCells();
                        cells.forEach(e => simpleCells.push({
                            input: e.document.getText(),
                            outputs: e.outputs.flatMap(value => value.items.map(output => output.data.toString()))
                        }));
                    }
                    else {
                        const fileContent = await this.s.value.readFile(uri);
                        const bytes = buffer_1.$Ne.fromString(fileContent.toString());
                        const notebook = await serializer.deserializeNotebook(bytes.buffer, token);
                        if (token.isCancellationRequested) {
                            return;
                        }
                        const data = typeConverters.NotebookData.from(notebook);
                        data.cells.forEach(cell => simpleCells.push({
                            input: cell.source,
                            outputs: cell.outputs.flatMap(value => value.items.map(output => output.valueBytes.toString()))
                        }));
                    }
                    if (token.isCancellationRequested) {
                        return;
                    }
                    simpleCells.forEach((cell, index) => {
                        const target = textQuery.contentPattern.pattern;
                        const cellModel = new cellSearchModel_1.$j1b(cell.input, undefined, cell.outputs);
                        const inputMatches = cellModel.findInInputs(target);
                        const outputMatches = cellModel.findInOutputs(target);
                        const webviewResults = outputMatches
                            .flatMap(outputMatch => (0, searchNotebookHelpers_1.$yM)(outputMatch.matches, outputMatch.textBuffer))
                            .map((textMatch, index) => {
                            textMatch.webviewIndex = index;
                            return textMatch;
                        });
                        if (inputMatches.length > 0 || outputMatches.length > 0) {
                            const cellMatch = {
                                index: index,
                                contentResults: (0, searchNotebookHelpers_1.$yM)(inputMatches, cellModel.inputTextBuffer),
                                webviewResults
                            };
                            cellMatches.push(cellMatch);
                        }
                    });
                    const fileMatch = {
                        resource: uri, cellResults: cellMatches
                    };
                    results.set(uri, fileMatch);
                    return;
                }
                catch (e) {
                    return;
                }
            });
            await Promise.all(promises);
            return {
                limitHit,
                results: [...results.values()]
            };
        }
        async z(uri, options) {
            const stat = await this.s.value.stat(uri);
            // Dirty write prevention
            if (typeof options?.mtime === 'number' && typeof options.etag === 'string' && options.etag !== files.$Fl &&
                typeof stat.mtime === 'number' && typeof stat.size === 'number' &&
                options.mtime < stat.mtime && options.etag !== files.$Gl({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size })) {
                throw new files.$vl((0, nls_1.localize)(11255, null), files.FileOperationResult.FILE_MODIFIED_SINCE, options);
            }
            return;
        }
        A(uri) {
            return uri.scheme === network_1.Schemas.file ? uri.fsPath : uri.toString();
        }
        // --- open, save, saveAs, backup
        B(document, editorId, data) {
            if (this.h.has(editorId)) {
                throw new Error(`editor with id ALREADY EXSIST: ${editorId}`);
            }
            const editor = new extHostNotebookEditor_1.$Rqc(editorId, this.d, document, data.visibleRanges.map(typeConverters.NotebookRange.to), data.selections.map(typeConverters.NotebookRange.to), typeof data.viewColumn === 'number' ? typeConverters.ViewColumn.to(data.viewColumn) : undefined);
            this.h.set(editorId, editor);
        }
        $acceptDocumentAndEditorsDelta(delta) {
            if (delta.value.removedDocuments) {
                for (const uri of delta.value.removedDocuments) {
                    const revivedUri = uri_1.URI.revive(uri);
                    const document = this.g.get(revivedUri);
                    if (document) {
                        document.dispose();
                        this.g.delete(revivedUri);
                        this.q.$acceptDocumentsAndEditorsDelta({ removedDocuments: document.apiNotebook.getCells().map(cell => cell.document.uri) });
                        this.n.fire(document.apiNotebook);
                    }
                    for (const editor of this.h.values()) {
                        if (editor.notebookData.uri.toString() === revivedUri.toString()) {
                            this.h.delete(editor.id);
                        }
                    }
                }
            }
            if (delta.value.addedDocuments) {
                const addedCellDocuments = [];
                for (const modelData of delta.value.addedDocuments) {
                    const uri = uri_1.URI.revive(modelData.uri);
                    if (this.g.has(uri)) {
                        throw new Error(`adding EXISTING notebook ${uri} `);
                    }
                    const document = new extHostNotebookDocument_1.$Qqc(this.c, this.q, this.r, uri, modelData);
                    // add cell document as vscode.TextDocument
                    addedCellDocuments.push(...modelData.cells.map(cell => extHostNotebookDocument_1.$Pqc.asModelAddData(cell)));
                    this.g.get(uri)?.dispose();
                    this.g.set(uri, document);
                    this.q.$acceptDocumentsAndEditorsDelta({ addedDocuments: addedCellDocuments });
                    this.m.fire(document.apiNotebook);
                }
            }
            if (delta.value.addedEditors) {
                for (const editorModelData of delta.value.addedEditors) {
                    if (this.h.has(editorModelData.id)) {
                        return;
                    }
                    const revivedUri = uri_1.URI.revive(editorModelData.documentUri);
                    const document = this.g.get(revivedUri);
                    if (document) {
                        this.B(document, editorModelData.id, editorModelData);
                    }
                }
            }
            const removedEditors = [];
            if (delta.value.removedEditors) {
                for (const editorid of delta.value.removedEditors) {
                    const editor = this.h.get(editorid);
                    if (editor) {
                        this.h.delete(editorid);
                        if (this.k?.id === editor.id) {
                            this.k = undefined;
                        }
                        removedEditors.push(editor);
                    }
                }
            }
            if (delta.value.visibleEditors) {
                this.l = delta.value.visibleEditors.map(id => this.h.get(id)).filter(editor => !!editor);
                const visibleEditorsSet = new Set();
                this.l.forEach(editor => visibleEditorsSet.add(editor.id));
                for (const editor of this.h.values()) {
                    const newValue = visibleEditorsSet.has(editor.id);
                    editor._acceptVisibility(newValue);
                }
                this.l = [...this.h.values()].map(e => e).filter(e => e.visible);
                this.o.fire(this.visibleNotebookEditors);
            }
            if (delta.value.newActiveEditor === null) {
                // clear active notebook as current active editor is non-notebook editor
                this.k = undefined;
            }
            else if (delta.value.newActiveEditor) {
                const activeEditor = this.h.get(delta.value.newActiveEditor);
                if (!activeEditor) {
                    console.error(`FAILED to find active notebook editor ${delta.value.newActiveEditor}`);
                }
                this.k = this.h.get(delta.value.newActiveEditor);
            }
            if (delta.value.newActiveEditor !== undefined) {
                this.j.fire(this.k?.apiEditor);
            }
        }
        static C(extHostCommands) {
            const notebookTypeArg = extHostCommands_1.$IQ.String.with('notebookType', 'A notebook type');
            const commandDataToNotebook = new extHostCommands_1.$KQ('vscode.executeDataToNotebook', '_executeDataToNotebook', 'Invoke notebook serializer', [notebookTypeArg, new extHostCommands_1.$IQ('data', 'Bytes to convert to data', v => v instanceof Uint8Array, v => buffer_1.$Ne.wrap(v))], new extHostCommands_1.$JQ('Notebook Data', data => typeConverters.NotebookData.to(data.value)));
            const commandNotebookToData = new extHostCommands_1.$KQ('vscode.executeNotebookToData', '_executeNotebookToData', 'Invoke notebook serializer', [notebookTypeArg, new extHostCommands_1.$IQ('NotebookData', 'Notebook data to convert to bytes', v => true, v => new proxyIdentifier_1.$Xw(typeConverters.NotebookData.from(v)))], new extHostCommands_1.$JQ('Bytes', dto => dto.buffer));
            extHostCommands.registerApiCommand(commandDataToNotebook);
            extHostCommands.registerApiCommand(commandNotebookToData);
        }
        D(msg) {
            this.u.trace(`[Extension Host Notebook] ${msg}`);
        }
    }
    exports.$1qc = $1qc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[270/*vs/workbench/services/search/common/fileSearchManager*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/path*/,21/*vs/base/common/cancellation*/,42/*vs/base/common/errorMessage*/,41/*vs/base/common/glob*/,23/*vs/base/common/resources*/,69/*vs/base/common/stopwatch*/,44/*vs/workbench/services/search/common/search*/]), function (require, exports, path, cancellation_1, errorMessage_1, glob, resources, stopwatch_1, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Sqc = void 0;
    path = __importStar(path);
    glob = __importStar(glob);
    resources = __importStar(resources);
    class FileSearchEngine {
        constructor(k, l, o) {
            this.k = k;
            this.l = l;
            this.o = o;
            this.e = false;
            this.f = 0;
            this.g = false;
            this.a = k.filePattern;
            this.b = k.includePattern && glob.$Ak(k.includePattern);
            this.c = k.maxResults || undefined;
            this.d = k.exists;
            this.h = new Set();
            this.j = k.excludePattern && glob.$Ak(k.excludePattern);
        }
        cancel() {
            this.g = true;
            this.h.forEach(t => t.cancel());
            this.h = new Set();
        }
        search(_onResult) {
            const folderQueries = this.k.folderQueries || [];
            return new Promise((resolve, reject) => {
                const onResult = (match) => {
                    this.f++;
                    _onResult(match);
                };
                // Support that the file pattern is a full path to a file that exists
                if (this.g) {
                    return resolve({ limitHit: this.e });
                }
                // For each extra file
                if (this.k.extraFileResources) {
                    this.k.extraFileResources
                        .forEach(extraFile => {
                        const extraFileStr = extraFile.toString(); // ?
                        const basename = path.$nc(extraFileStr);
                        if (this.j && this.j(extraFileStr, basename)) {
                            return; // excluded
                        }
                        // File: Check for match on file pattern and include pattern
                        this.v(onResult, { base: extraFile, basename });
                    });
                }
                // For each root folder
                Promise.all(folderQueries.map(fq => {
                    return this.p(fq, onResult);
                })).then(stats => {
                    resolve({
                        limitHit: this.e,
                        stats: stats[0] || undefined // Only looking at single-folder workspace stats...
                    });
                }, (err) => {
                    reject(new Error((0, errorMessage_1.$qj)(err)));
                });
            });
        }
        async p(fq, onResult) {
            const cancellation = new cancellation_1.$we();
            const options = this.q(fq);
            const tree = this.r();
            const queryTester = new search_1.$oM(this.k, fq);
            const noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
            let providerSW;
            try {
                this.h.add(cancellation);
                providerSW = stopwatch_1.$fe.create();
                const results = await this.l.provideFileSearchResults({
                    pattern: this.k.filePattern || ''
                }, options, cancellation.token);
                const providerTime = providerSW.elapsed();
                const postProcessSW = stopwatch_1.$fe.create();
                if (this.g && !this.e) {
                    return null;
                }
                if (results) {
                    results.forEach(result => {
                        const relativePath = path.$gc.relative(fq.folder.path, result.path);
                        if (noSiblingsClauses) {
                            const basename = path.$nc(result.path);
                            this.v(onResult, { base: fq.folder, relativePath, basename });
                            return;
                        }
                        // TODO: Optimize siblings clauses with ripgrep here.
                        this.s(tree, fq.folder, relativePath, onResult);
                    });
                }
                if (this.g && !this.e) {
                    return null;
                }
                this.u(tree, queryTester, onResult);
                return {
                    providerTime,
                    postProcessTime: postProcessSW.elapsed()
                };
            }
            finally {
                cancellation.dispose();
                this.h.delete(cancellation);
            }
        }
        q(fq) {
            const includes = (0, search_1.$nM)(this.k.includePattern, fq.includePattern);
            const excludes = (0, search_1.$nM)(this.k.excludePattern, fq.excludePattern);
            return {
                folder: fq.folder,
                excludes,
                includes,
                useIgnoreFiles: !fq.disregardIgnoreFiles,
                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
                useParentIgnoreFiles: !fq.disregardParentIgnoreFiles,
                followSymlinks: !fq.ignoreSymlinks,
                maxResults: this.k.maxResults,
                session: this.o
            };
        }
        r() {
            const tree = {
                rootEntries: [],
                pathToEntries: Object.create(null)
            };
            tree.pathToEntries['.'] = tree.rootEntries;
            return tree;
        }
        s({ pathToEntries }, base, relativeFile, onResult) {
            // Support relative paths to files from a root resource (ignores excludes)
            if (relativeFile === this.a) {
                const basename = path.$nc(this.a);
                this.v(onResult, { base: base, relativePath: this.a, basename });
            }
            function add(relativePath) {
                const basename = path.$nc(relativePath);
                const dirname = path.$mc(relativePath);
                let entries = pathToEntries[dirname];
                if (!entries) {
                    entries = pathToEntries[dirname] = [];
                    add(dirname);
                }
                entries.push({
                    base,
                    relativePath,
                    basename
                });
            }
            add(relativeFile);
        }
        u({ rootEntries, pathToEntries }, queryTester, onResult) {
            const self = this;
            const filePattern = this.a;
            function matchDirectory(entries) {
                const hasSibling = (0, search_1.$qM)(() => entries.map(entry => entry.basename));
                for (let i = 0, n = entries.length; i < n; i++) {
                    const entry = entries[i];
                    const { relativePath, basename } = entry;
                    // Check exclude pattern
                    // If the user searches for the exact file name, we adjust the glob matching
                    // to ignore filtering by siblings because the user seems to know what they
                    // are searching for and we want to include the result in that case anyway
                    if (queryTester.matchesExcludesSync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {
                        continue;
                    }
                    const sub = pathToEntries[relativePath];
                    if (sub) {
                        matchDirectory(sub);
                    }
                    else {
                        if (relativePath === filePattern) {
                            continue; // ignore file if its path matches with the file pattern because that is already matched above
                        }
                        self.v(onResult, entry);
                    }
                    if (self.e) {
                        break;
                    }
                }
            }
            matchDirectory(rootEntries);
        }
        v(onResult, candidate) {
            if (!this.b || (candidate.relativePath && this.b(candidate.relativePath, candidate.basename))) {
                if (this.d || (this.c && this.f >= this.c)) {
                    this.e = true;
                    this.cancel();
                }
                if (!this.e) {
                    onResult(candidate);
                }
            }
        }
    }
    class $Sqc {
        constructor() {
            this.b = new Map();
        }
        static { this.a = 512; }
        fileSearch(config, provider, onBatch, token) {
            const sessionTokenSource = this.c(config.cacheKey);
            const engine = new FileSearchEngine(config, provider, sessionTokenSource && sessionTokenSource.token);
            let resultCount = 0;
            const onInternalResult = (batch) => {
                resultCount += batch.length;
                onBatch(batch.map(m => this.d(m)));
            };
            return this.e(engine, $Sqc.a, onInternalResult, token).then(result => {
                return {
                    limitHit: result.limitHit,
                    stats: result.stats ? {
                        fromCache: false,
                        type: 'fileSearchProvider',
                        resultCount,
                        detailStats: result.stats
                    } : undefined,
                    messages: []
                };
            });
        }
        clearCache(cacheKey) {
            const sessionTokenSource = this.c(cacheKey);
            sessionTokenSource?.cancel();
        }
        c(cacheKey) {
            if (!cacheKey) {
                return undefined;
            }
            if (!this.b.has(cacheKey)) {
                this.b.set(cacheKey, new cancellation_1.$we());
            }
            return this.b.get(cacheKey);
        }
        d(match) {
            if (match.relativePath) {
                return {
                    resource: resources.$gh(match.base, match.relativePath)
                };
            }
            else {
                // extraFileResources
                return {
                    resource: match.base
                };
            }
        }
        e(engine, batchSize, onResultBatch, token) {
            const listener = token.onCancellationRequested(() => {
                engine.cancel();
            });
            const _onResult = (match) => {
                if (match) {
                    batch.push(match);
                    if (batchSize > 0 && batch.length >= batchSize) {
                        onResultBatch(batch);
                        batch = [];
                    }
                }
            };
            let batch = [];
            return engine.search(_onResult).then(result => {
                if (batch.length) {
                    onResultBatch(batch);
                }
                listener.dispose();
                return result;
            }, error => {
                if (batch.length) {
                    onResultBatch(batch);
                }
                listener.dispose();
                return Promise.reject(error);
            });
        }
    }
    exports.$Sqc = $Sqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[271/*vs/workbench/services/search/common/queryBuilder*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,240/*vs/base/common/collections*/,41/*vs/base/common/glob*/,99/*vs/base/common/labels*/,28/*vs/base/common/map*/,15/*vs/base/common/network*/,19/*vs/base/common/path*/,23/*vs/base/common/resources*/,12/*vs/base/common/strings*/,14/*vs/base/common/types*/,2/*vs/base/common/uri*/,102/*vs/editor/common/model/textModelSearch*/,9/*vs/nls*/,43/*vs/platform/configuration/common/configuration*/,11/*vs/platform/log/common/log*/,49/*vs/platform/workspace/common/workspace*/,118/*vs/workbench/services/editor/common/editorGroupsService*/,267/*vs/workbench/services/path/common/pathService*/,44/*vs/workbench/services/search/common/search*/]), function (require, exports, arrays, collections, glob, labels_1, map_1, network_1, path, resources_1, strings, types_1, uri_1, textModelSearch_1, nls, configuration_1, log_1, workspace_1, editorGroupsService_1, pathService_1, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$oN = void 0;
    exports.$pN = $pN;
    arrays = __importStar(arrays);
    collections = __importStar(collections);
    glob = __importStar(glob);
    path = __importStar(path);
    strings = __importStar(strings);
    nls = __importStar(nls);
    let $oN = class $oN {
        constructor(a, b, c, d, e) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.e = e;
        }
        text(contentPattern, folderResources, options = {}) {
            contentPattern = this.f(contentPattern, options);
            const searchConfig = this.a.getValue();
            const fallbackToPCRE = folderResources && folderResources.some(folder => {
                const folderConfig = this.a.getValue({ resource: folder });
                return !folderConfig.search.useRipgrep;
            });
            const commonQuery = this.h(folderResources?.map(workspace_1.$1i), options);
            return {
                ...commonQuery,
                type: search_1.QueryType.Text,
                contentPattern,
                previewOptions: options.previewOptions,
                maxFileSize: options.maxFileSize,
                usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,
                beforeContext: options.beforeContext,
                afterContext: options.afterContext,
                userDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles,
            };
        }
        /**
         * Adjusts input pattern for config
         */
        f(inputPattern, options) {
            const searchConfig = this.a.getValue();
            if (inputPattern.isRegExp) {
                inputPattern.pattern = inputPattern.pattern.replace(/\r?\n/g, '\\n');
            }
            const newPattern = {
                ...inputPattern,
                wordSeparators: searchConfig.editor.wordSeparators
            };
            if (this.j(inputPattern, options)) {
                newPattern.isCaseSensitive = true;
            }
            if (this.k(inputPattern)) {
                newPattern.isMultiline = true;
            }
            if (options.notebookSearchConfig?.includeMarkupInput) {
                if (!newPattern.notebookInfo) {
                    newPattern.notebookInfo = {};
                }
                newPattern.notebookInfo.isInNotebookMarkdownInput = options.notebookSearchConfig.includeMarkupInput;
            }
            if (options.notebookSearchConfig?.includeMarkupPreview) {
                if (!newPattern.notebookInfo) {
                    newPattern.notebookInfo = {};
                }
                newPattern.notebookInfo.isInNotebookMarkdownPreview = options.notebookSearchConfig.includeMarkupPreview;
            }
            if (options.notebookSearchConfig?.includeCodeInput) {
                if (!newPattern.notebookInfo) {
                    newPattern.notebookInfo = {};
                }
                newPattern.notebookInfo.isInNotebookCellInput = options.notebookSearchConfig.includeCodeInput;
            }
            if (options.notebookSearchConfig?.includeOutput) {
                if (!newPattern.notebookInfo) {
                    newPattern.notebookInfo = {};
                }
                newPattern.notebookInfo.isInNotebookCellOutput = options.notebookSearchConfig.includeOutput;
            }
            return newPattern;
        }
        file(folders, options = {}) {
            const commonQuery = this.h(folders, options);
            return {
                ...commonQuery,
                type: search_1.QueryType.File,
                filePattern: options.filePattern
                    ? options.filePattern.trim()
                    : options.filePattern,
                exists: options.exists,
                sortByScore: options.sortByScore,
                cacheKey: options.cacheKey,
                shouldGlobMatchFilePattern: options.shouldGlobSearch
            };
        }
        g(pattern, expandPatterns) {
            if (!pattern) {
                return {};
            }
            pattern = Array.isArray(pattern) ? pattern.map(normalizeSlashes) : normalizeSlashes(pattern);
            return expandPatterns
                ? this.parseSearchPaths(pattern)
                : { pattern: patternListToIExpression(...(Array.isArray(pattern) ? pattern : [pattern])) };
        }
        h(folderResources = [], options = {}) {
            const includeSearchPathsInfo = this.g(options.includePattern, options.expandPatterns);
            const excludeSearchPathsInfo = this.g(options.excludePattern, options.expandPatterns);
            // Build folderQueries from searchPaths, if given, otherwise folderResources
            const includeFolderName = folderResources.length > 1;
            const folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?
                includeSearchPathsInfo.searchPaths.map(searchPath => this.q(searchPath, options, excludeSearchPathsInfo)) :
                folderResources.map(folder => this.r(folder, options, excludeSearchPathsInfo, includeFolderName)))
                .filter(query => !!query);
            const queryProps = {
                _reason: options._reason,
                folderQueries,
                usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),
                extraFileResources: options.extraFileResources,
                excludePattern: excludeSearchPathsInfo.pattern,
                includePattern: includeSearchPathsInfo.pattern,
                onlyOpenEditors: options.onlyOpenEditors,
                maxResults: options.maxResults
            };
            if (options.onlyOpenEditors) {
                const openEditors = arrays.$Gb(this.c.groups.flatMap(group => group.editors.map(editor => editor.resource)));
                this.d.trace('QueryBuilder#commonQuery - openEditor URIs', JSON.stringify(openEditors));
                const openEditorsInQuery = openEditors.filter(editor => (0, search_1.$eM)(queryProps, editor.fsPath));
                const openEditorsQueryProps = this.i(openEditorsInQuery);
                this.d.trace('QueryBuilder#commonQuery - openEditor Query', JSON.stringify(openEditorsQueryProps));
                return { ...queryProps, ...openEditorsQueryProps };
            }
            // Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace
            const extraFileResources = options.extraFileResources && options.extraFileResources.filter(extraFile => (0, search_1.$eM)(queryProps, extraFile.fsPath));
            queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;
            return queryProps;
        }
        i(files) {
            const folderQueries = [];
            const foldersToSearch = new map_1.$Ac();
            const includePattern = {};
            let hasIncludedFile = false;
            files.forEach(file => {
                if (file.scheme === network_1.Schemas.walkThrough) {
                    return;
                }
                const providerExists = (0, resources_1.$kh)(file);
                // Special case userdata as we don't have a search provider for it, but it can be searched.
                if (providerExists) {
                    const searchRoot = this.b.getWorkspaceFolder(file)?.uri ?? file.with({ path: path.$mc(file.fsPath) });
                    let folderQuery = foldersToSearch.get(searchRoot);
                    if (!folderQuery) {
                        hasIncludedFile = true;
                        folderQuery = { folder: searchRoot, includePattern: {} };
                        folderQueries.push(folderQuery);
                        foldersToSearch.set(searchRoot, folderQuery);
                    }
                    const relPath = path.$lc(searchRoot.fsPath, file.fsPath);
                    (0, types_1.$pg)(folderQuery.includePattern)[relPath.replace(/\\/g, '/')] = true;
                }
                else {
                    if (file.fsPath) {
                        hasIncludedFile = true;
                        includePattern[file.fsPath] = true;
                    }
                }
            });
            return {
                folderQueries,
                includePattern,
                usingSearchPaths: true,
                excludePattern: hasIncludedFile ? undefined : { '**/*': true }
            };
        }
        /**
         * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.
         */
        j(contentPattern, options) {
            if (options.isSmartCase) {
                if (contentPattern.isRegExp) {
                    // Consider it case sensitive if it contains an unescaped capital letter
                    if (strings.$8f(contentPattern.pattern, true)) {
                        return true;
                    }
                }
                else if (strings.$8f(contentPattern.pattern)) {
                    return true;
                }
            }
            return !!contentPattern.isCaseSensitive;
        }
        k(contentPattern) {
            if (contentPattern.isMultiline) {
                return true;
            }
            if (contentPattern.isRegExp && (0, textModelSearch_1.$lD)(contentPattern.pattern)) {
                return true;
            }
            if (contentPattern.pattern.indexOf('\n') >= 0) {
                return true;
            }
            return !!contentPattern.isMultiline;
        }
        /**
         * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and
         * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\/foo/bar}.
         *
         * Public for test.
         */
        parseSearchPaths(pattern) {
            const isSearchPath = (segment) => {
                // A segment is a search path if it is an absolute path or starts with ./, ../, .\, or ..\
                return path.$ic(segment) || /^\.\.?([\/\\]|$)/.test(segment);
            };
            const patterns = Array.isArray(pattern) ? pattern : splitGlobPattern(pattern);
            const segments = patterns
                .map(segment => {
                const userHome = this.e.resolvedUserHome;
                if (userHome) {
                    return (0, labels_1.$3w)(segment, userHome.scheme === network_1.Schemas.file ? userHome.fsPath : userHome.path);
                }
                return segment;
            });
            const groups = collections.$c(segments, segment => isSearchPath(segment) ? 'searchPaths' : 'exprSegments');
            const expandedExprSegments = (groups.exprSegments || [])
                .map(s => strings.$nf(s, '/'))
                .map(s => strings.$nf(s, '\\'))
                .map(p => {
                if (p[0] === '.') {
                    p = '*' + p; // convert ".js" to "*.js"
                }
                return expandGlobalGlob(p);
            });
            const result = {};
            const searchPaths = this.m(groups.searchPaths || []);
            if (searchPaths && searchPaths.length) {
                result.searchPaths = searchPaths;
            }
            const exprSegments = expandedExprSegments.flat();
            const includePattern = patternListToIExpression(...exprSegments);
            if (includePattern) {
                result.pattern = includePattern;
            }
            return result;
        }
        l(folderConfig, options) {
            return options.disregardExcludeSettings ?
                undefined :
                (0, search_1.$dM)(folderConfig, !options.disregardSearchExcludeSettings);
        }
        /**
         * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths
         */
        m(searchPaths) {
            if (!searchPaths || !searchPaths.length) {
                // No workspace => ignore search paths
                return [];
            }
            const expandedSearchPaths = searchPaths.flatMap(searchPath => {
                // 1 open folder => just resolve the search paths to absolute paths
                let { pathPortion, globPortion } = splitGlobFromPath(searchPath);
                if (globPortion) {
                    globPortion = normalizeGlobPattern(globPortion);
                }
                // One pathPortion to multiple expanded search paths (e.g. duplicate matching workspace folders)
                const oneExpanded = this.n(pathPortion);
                // Expanded search paths to multiple resolved patterns (with ** and without)
                return oneExpanded.flatMap(oneExpandedResult => this.o(oneExpandedResult, globPortion));
            });
            const searchPathPatternMap = new Map();
            expandedSearchPaths.forEach(oneSearchPathPattern => {
                const key = oneSearchPathPattern.searchPath.toString();
                const existing = searchPathPatternMap.get(key);
                if (existing) {
                    if (oneSearchPathPattern.pattern) {
                        existing.pattern = existing.pattern || {};
                        existing.pattern[oneSearchPathPattern.pattern] = true;
                    }
                }
                else {
                    searchPathPatternMap.set(key, {
                        searchPath: oneSearchPathPattern.searchPath,
                        pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined
                    });
                }
            });
            return Array.from(searchPathPatternMap.values());
        }
        /**
         * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.
         */
        n(searchPath) {
            if (path.$ic(searchPath)) {
                const workspaceFolders = this.b.getWorkspace().folders;
                if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== network_1.Schemas.file) {
                    return [{
                            searchPath: workspaceFolders[0].uri.with({ path: searchPath })
                        }];
                }
                // Currently only local resources can be searched for with absolute search paths.
                // TODO convert this to a workspace folder + pattern, so excludes will be resolved properly for an absolute path inside a workspace folder
                return [{
                        searchPath: uri_1.URI.file(path.$hc(searchPath))
                    }];
            }
            if (this.b.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {
                const workspaceUri = this.b.getWorkspace().folders[0].uri;
                searchPath = normalizeSlashes(searchPath);
                if (searchPath.startsWith('../') || searchPath === '..') {
                    const resolvedPath = path.$gc.resolve(workspaceUri.path, searchPath);
                    return [{
                            searchPath: workspaceUri.with({ path: resolvedPath })
                        }];
                }
                const cleanedPattern = normalizeGlobPattern(searchPath);
                return [{
                        searchPath: workspaceUri,
                        pattern: cleanedPattern
                    }];
            }
            else if (searchPath === './' || searchPath === '.\\') {
                return []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces
            }
            else {
                const searchPathWithoutDotSlash = searchPath.replace(/^\.[\/\\]/, '');
                const folders = this.b.getWorkspace().folders;
                const folderMatches = folders.map(folder => {
                    const match = searchPathWithoutDotSlash.match(new RegExp(`^${strings.$hf(folder.name)}(?:/(.*)|$)`));
                    return match ? {
                        match,
                        folder
                    } : null;
                }).filter(types_1.$mg);
                if (folderMatches.length) {
                    return folderMatches.map(match => {
                        const patternMatch = match.match[1];
                        return {
                            searchPath: match.folder.uri,
                            pattern: patternMatch && normalizeGlobPattern(patternMatch)
                        };
                    });
                }
                else {
                    const probableWorkspaceFolderNameMatch = searchPath.match(/\.[\/\\](.+)[\/\\]?/);
                    const probableWorkspaceFolderName = probableWorkspaceFolderNameMatch ? probableWorkspaceFolderNameMatch[1] : searchPath;
                    // No root folder with name
                    const searchPathNotFoundError = nls.localize(1866, null, probableWorkspaceFolderName);
                    throw new Error(searchPathNotFoundError);
                }
            }
        }
        o(oneExpandedResult, globPortion) {
            const pattern = oneExpandedResult.pattern && globPortion ?
                `${oneExpandedResult.pattern}/${globPortion}` :
                oneExpandedResult.pattern || globPortion;
            const results = [
                {
                    searchPath: oneExpandedResult.searchPath,
                    pattern
                }
            ];
            if (pattern && !pattern.endsWith('**')) {
                results.push({
                    searchPath: oneExpandedResult.searchPath,
                    pattern: pattern + '/**'
                });
            }
            return results;
        }
        q(searchPath, options, searchPathExcludes) {
            const rootConfig = this.r((0, workspace_1.$1i)(searchPath.searchPath), options, searchPathExcludes, false);
            if (!rootConfig) {
                return null;
            }
            return {
                ...rootConfig,
                ...{
                    includePattern: searchPath.pattern
                }
            };
        }
        r(folder, options, searchPathExcludes, includeFolderName) {
            let thisFolderExcludeSearchPathPattern;
            const folderUri = uri_1.URI.isUri(folder) ? folder : folder.uri;
            if (searchPathExcludes.searchPaths) {
                const thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(sp => (0, resources_1.$_g)(sp.searchPath, folderUri))[0];
                if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {
                    // entire folder is excluded
                    return null;
                }
                else if (thisFolderExcludeSearchPath) {
                    thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;
                }
            }
            const folderConfig = this.a.getValue({ resource: folderUri });
            const settingExcludes = this.l(folderConfig, options);
            const excludePattern = {
                ...(settingExcludes || {}),
                ...(thisFolderExcludeSearchPathPattern || {})
            };
            const folderName = uri_1.URI.isUri(folder) ? (0, resources_1.$dh)(folder) : folder.name;
            return {
                folder: folderUri,
                folderName: includeFolderName ? folderName : undefined,
                excludePattern: Object.keys(excludePattern).length > 0 ? excludePattern : undefined,
                fileEncoding: folderConfig.files && folderConfig.files.encoding,
                disregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,
                disregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,
                disregardParentIgnoreFiles: typeof options.disregardParentIgnoreFiles === 'boolean' ? options.disregardParentIgnoreFiles : !folderConfig.search.useParentIgnoreFiles,
                ignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search.followSymlinks,
            };
        }
    };
    exports.$oN = $oN;
    exports.$oN = $oN = __decorate([
        __param(0, configuration_1.$_i),
        __param(1, workspace_1.$Oi),
        __param(2, editorGroupsService_1.$tE),
        __param(3, log_1.$ak),
        __param(4, pathService_1.$mN)
    ], $oN);
    function splitGlobFromPath(searchPath) {
        const globCharMatch = searchPath.match(/[\*\{\}\(\)\[\]\?]/);
        if (globCharMatch) {
            const globCharIdx = globCharMatch.index;
            const lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\][^/\\]*$/);
            if (lastSlashMatch) {
                let pathPortion = searchPath.substr(0, lastSlashMatch.index);
                if (!pathPortion.match(/[/\\]/)) {
                    // If the last slash was the only slash, then we now have '' or 'C:' or '.'. Append a slash.
                    pathPortion += '/';
                }
                return {
                    pathPortion,
                    globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)
                };
            }
        }
        // No glob char, or malformed
        return {
            pathPortion: searchPath
        };
    }
    function patternListToIExpression(...patterns) {
        return patterns.length ?
            patterns.reduce((glob, cur) => { glob[cur] = true; return glob; }, Object.create(null)) :
            undefined;
    }
    function splitGlobPattern(pattern) {
        return glob.$yk(pattern, ',')
            .map(s => s.trim())
            .filter(s => !!s.length);
    }
    /**
     * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/microsoft/vscode/issues/32761
     */
    function expandGlobalGlob(pattern) {
        const patterns = [
            `**/${pattern}/**`,
            `**/${pattern}`
        ];
        return patterns.map(p => p.replace(/\*\*\/\*\*/g, '**'));
    }
    function normalizeSlashes(pattern) {
        return pattern.replace(/\\/g, '/');
    }
    /**
     * Normalize slashes, remove `./` and trailing slashes
     */
    function normalizeGlobPattern(pattern) {
        return normalizeSlashes(pattern)
            .replace(/^\.\//, '')
            .replace(/\/+$/g, '');
    }
    /**
     * Escapes a path for use as a glob pattern that would match the input precisely.
     * Characters '?', '*', '[', and ']' are escaped into character range glob syntax
     * (for example, '?' becomes '[?]').
     * NOTE: This implementation makes no special cases for UNC paths. For example,
     * given the input "//?/C:/A?.txt", this would produce output '//[?]/C:/A[?].txt',
     * which may not be desirable in some cases. Use with caution if UNC paths could be expected.
     */
    function escapeGlobPattern(path) {
        return path.replace(/([?*[\]])/g, '[$1]');
    }
    /**
     * Construct an include pattern from a list of folders uris to search in.
     */
    function $pN(resources, contextService) {
        resources = arrays.$Lb(resources, resource => resource.toString());
        const folderPaths = [];
        const workspace = contextService.getWorkspace();
        if (resources) {
            resources.forEach(resource => {
                let folderPath;
                if (contextService.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {
                    // Show relative path from the root for single-root mode
                    folderPath = (0, resources_1.$ih)(workspace.folders[0].uri, resource); // always uses forward slashes
                    if (folderPath && folderPath !== '.') {
                        folderPath = './' + folderPath;
                    }
                }
                else {
                    const owningFolder = contextService.getWorkspaceFolder(resource);
                    if (owningFolder) {
                        const owningRootName = owningFolder.name;
                        // If this root is the only one with its basename, use a relative ./ path. If there is another, use an absolute path
                        const isUniqueFolder = workspace.folders.filter(folder => folder.name === owningRootName).length === 1;
                        if (isUniqueFolder) {
                            const relPath = (0, resources_1.$ih)(owningFolder.uri, resource); // always uses forward slashes
                            if (relPath === '') {
                                folderPath = `./${owningFolder.name}`;
                            }
                            else {
                                folderPath = `./${owningFolder.name}/${relPath}`;
                            }
                        }
                        else {
                            folderPath = resource.fsPath; // TODO rob: handle non-file URIs
                        }
                    }
                }
                if (folderPath) {
                    folderPaths.push(escapeGlobPattern(folderPath));
                }
            });
        }
        return folderPaths;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[272/*vs/workbench/services/extensions/common/workspaceContains*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,21/*vs/base/common/cancellation*/,13/*vs/base/common/errors*/,3/*vs/platform/instantiation/common/instantiation*/,271/*vs/workbench/services/search/common/queryBuilder*/,44/*vs/workbench/services/search/common/search*/,49/*vs/platform/workspace/common/workspace*/,10/*vs/base/common/async*/]), function (require, exports, resources, uri_1, cancellation_1, errors, instantiation_1, queryBuilder_1, search_1, workspace_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Ayb = $Ayb;
    exports.$Byb = $Byb;
    resources = __importStar(resources);
    errors = __importStar(errors);
    const WORKSPACE_CONTAINS_TIMEOUT = 7000;
    function $Ayb(host, desc) {
        const activationEvents = desc.activationEvents;
        if (!activationEvents) {
            return Promise.resolve(undefined);
        }
        const fileNames = [];
        const globPatterns = [];
        for (const activationEvent of activationEvents) {
            if (/^workspaceContains:/.test(activationEvent)) {
                const fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);
                if (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0 || host.forceUsingSearch) {
                    globPatterns.push(fileNameOrGlob);
                }
                else {
                    fileNames.push(fileNameOrGlob);
                }
            }
        }
        if (fileNames.length === 0 && globPatterns.length === 0) {
            return Promise.resolve(undefined);
        }
        const { promise, resolve } = (0, async_1.$yh)();
        const activate = (activationEvent) => resolve({ activationEvent });
        const fileNamePromise = Promise.all(fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))).then(() => { });
        const globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);
        Promise.all([fileNamePromise, globPatternPromise]).then(() => {
            // when all are done, resolve with undefined (relevant only if it was not activated so far)
            resolve(undefined);
        });
        return promise;
    }
    async function _activateIfFileName(host, fileName, activate) {
        // find exact path
        for (const uri of host.folders) {
            if (await host.exists(resources.$gh(uri_1.URI.revive(uri), fileName))) {
                // the file was found
                activate(`workspaceContains:${fileName}`);
                return;
            }
        }
    }
    async function _activateIfGlobPatterns(host, extensionId, globPatterns, activate) {
        if (globPatterns.length === 0) {
            return Promise.resolve(undefined);
        }
        const tokenSource = new cancellation_1.$we();
        const searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);
        const timer = setTimeout(async () => {
            tokenSource.cancel();
            host.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(',')}`);
        }, WORKSPACE_CONTAINS_TIMEOUT);
        let exists = false;
        try {
            exists = await searchP;
        }
        catch (err) {
            if (!errors.$3(err)) {
                errors.$Y(err);
            }
        }
        tokenSource.dispose();
        clearTimeout(timer);
        if (exists) {
            // a file was found matching one of the glob patterns
            activate(`workspaceContains:${globPatterns.join(',')}`);
        }
    }
    function $Byb(accessor, folders, includes, token) {
        const instantiationService = accessor.get(instantiation_1.$Ei);
        const searchService = accessor.get(search_1.$8L);
        const queryBuilder = instantiationService.createInstance(queryBuilder_1.$oN);
        const query = queryBuilder.file(folders.map(folder => (0, workspace_1.$1i)(uri_1.URI.revive(folder))), {
            _reason: 'checkExists',
            includePattern: includes,
            exists: true
        });
        return searchService.fileSearch(query, token).then(result => {
            return !!result.limitHit;
        }, err => {
            if (!errors.$3(err)) {
                return Promise.reject(err);
            }
            return false;
        });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[47/*vs/workbench/api/common/extHostExtensionService*/], __M([1/*require*/,0/*exports*/,9/*vs/nls*/,19/*vs/base/common/path*/,64/*vs/base/common/performance*/,23/*vs/base/common/resources*/,10/*vs/base/common/async*/,4/*vs/base/common/lifecycle*/,58/*vs/base/common/ternarySearchTree*/,2/*vs/base/common/uri*/,11/*vs/platform/log/common/log*/,5/*vs/workbench/api/common/extHost.protocol*/,46/*vs/workbench/api/common/extHostConfiguration*/,206/*vs/workbench/api/common/extHostExtensionActivator*/,88/*vs/workbench/api/common/extHostStorage*/,45/*vs/workbench/api/common/extHostWorkspace*/,24/*vs/workbench/services/extensions/common/extensions*/,119/*vs/workbench/services/extensions/common/extensionDescriptionRegistry*/,13/*vs/base/common/errors*/,18/*vs/platform/extensions/common/extensions*/,22/*vs/base/common/buffer*/,189/*vs/workbench/api/common/extHostMemento*/,7/*vs/workbench/api/common/extHostTypes*/,109/*vs/platform/remote/common/remoteAuthorityResolver*/,3/*vs/platform/instantiation/common/instantiation*/,26/*vs/workbench/api/common/extHostInitDataService*/,91/*vs/workbench/api/common/extHostStoragePaths*/,16/*vs/workbench/api/common/extHostRpcService*/,74/*vs/platform/instantiation/common/serviceCollection*/,92/*vs/workbench/api/common/extHostTunnelService*/,56/*vs/workbench/api/common/extHostTerminalService*/,94/*vs/workbench/api/common/extHostLanguageModels*/,6/*vs/base/common/event*/,272/*vs/workbench/services/extensions/common/workspaceContains*/,87/*vs/workbench/api/common/extHostSecretState*/,191/*vs/workbench/api/common/extHostSecrets*/,15/*vs/base/common/network*/,85/*vs/workbench/api/common/extHostLocalizationService*/,69/*vs/base/common/stopwatch*/,20/*vs/base/common/platform*/,86/*vs/workbench/api/common/extHostManagedSockets*/]), function (require, exports, nls, path, performance, resources_1, async_1, lifecycle_1, ternarySearchTree_1, uri_1, log_1, extHost_protocol_1, extHostConfiguration_1, extHostExtensionActivator_1, extHostStorage_1, extHostWorkspace_1, extensions_1, extensionDescriptionRegistry_1, errors, extensions_2, buffer_1, extHostMemento_1, extHostTypes_1, remoteAuthorityResolver_1, instantiation_1, extHostInitDataService_1, extHostStoragePaths_1, extHostRpcService_1, serviceCollection_1, extHostTunnelService_1, extHostTerminalService_1, extHostLanguageModels_1, event_1, workspaceContains_1, extHostSecretState_1, extHostSecrets_1, network_1, extHostLocalizationService_1, stopwatch_1, platform_1, extHostManagedSockets_1) {
    "use strict";
    var $qqc_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$tqc = exports.$sqc = exports.$rqc = exports.$qqc = exports.$pqc = void 0;
    nls = __importStar(nls);
    path = __importStar(path);
    performance = __importStar(performance);
    errors = __importStar(errors);
    exports.$pqc = (0, instantiation_1.$Fi)('IHostUtils');
    let $qqc = $qqc_1 = class $qqc extends lifecycle_1.$Uc {
        constructor(instaService, hostUtils, extHostContext, extHostWorkspace, extHostConfiguration, logService, initData, storagePath, extHostTunnelService, extHostTerminalService, extHostLocalizationService, Y, Z) {
            super();
            this.Y = Y;
            this.Z = Z;
            this.a = this.B(new event_1.$le());
            this.onDidChangeRemoteConnectionData = this.a.event;
            this.R = new Map();
            this.W = false;
            this.c = hostUtils;
            this.g = extHostContext;
            this.f = initData;
            this.j = extHostWorkspace;
            this.m = extHostConfiguration;
            this.s = logService;
            this.t = extHostTunnelService;
            this.u = extHostTerminalService;
            this.w = extHostLocalizationService;
            this.y = this.g.getProxy(extHost_protocol_1.$KN.MainThreadWorkspace);
            this.z = this.g.getProxy(extHost_protocol_1.$KN.MainThreadTelemetry);
            this.C = this.g.getProxy(extHost_protocol_1.$KN.MainThreadExtensionService);
            this.D = new async_1.$Eh();
            this.F = new async_1.$Eh();
            this.G = new async_1.$Eh();
            this.H = new async_1.$Eh();
            this.I = new SyncedActivationEventsReader(this.f.extensions.activationEvents);
            this.L = new extensionDescriptionRegistry_1.$Mdc(this.I, this.f.extensions.allExtensions);
            const myExtensionsSet = new extensions_2.$sn(this.f.extensions.myExtensions);
            this.J = new extensionDescriptionRegistry_1.$Mdc(this.I, filterExtensions(this.L, myExtensionsSet));
            if (platform_1.$u) {
                this.s.info(`Creating extension host with the following global extensions: ${printExtIds(this.L)}`);
                this.s.info(`Creating extension host with the following local extensions: ${printExtIds(this.J)}`);
            }
            this.M = new extHostStorage_1.$$pc(this.g, this.s);
            this.N = new extHostSecretState_1.$iqc(this.g);
            this.O = storagePath;
            this.h = this.q.add(instaService.createChild(new serviceCollection_1.$Di([extHostStorage_1.$_pc, this.M], [extHostSecretState_1.$jqc, this.N])));
            this.P = this.B(new extHostExtensionActivator_1.$0pc(this.J, this.L, {
                onExtensionActivationError: (extensionId, error, missingExtensionDependency) => {
                    this.C.$onExtensionActivationError(extensionId, errors.$1(error), missingExtensionDependency);
                },
                actualActivateExtension: async (extensionId, reason) => {
                    if (extensionDescriptionRegistry_1.$Mdc.isHostExtension(extensionId, this.J, this.L)) {
                        await this.C.$activateExtension(extensionId, reason);
                        return new extHostExtensionActivator_1.$9pc();
                    }
                    const extensionDescription = this.J.getExtensionDescription(extensionId);
                    return this.fb(extensionDescription, reason);
                }
            }, this.s));
            this.Q = null;
            this.S = Object.create(null);
            this.U = false;
            this.X = this.f.remote.connectionData;
        }
        getRemoteConnectionData() {
            return this.X;
        }
        async initialize() {
            try {
                await this.vb();
                this.D.open();
                await this.j.waitForInitializeCall();
                performance.mark('code/extHost/ready');
                this.F.open();
                if (this.f.autoStart) {
                    this.tb();
                }
            }
            catch (err) {
                errors.$Y(err);
            }
        }
        async $() {
            this.O.onWillDeactivateAll();
            let allPromises = [];
            try {
                const allExtensions = this.J.getAllExtensionDescriptions();
                const allExtensionsIds = allExtensions.map(ext => ext.identifier);
                const activatedExtensions = allExtensionsIds.filter(id => this.isActivated(id));
                allPromises = activatedExtensions.map((extensionId) => {
                    return this.eb(extensionId);
                });
            }
            catch (err) {
                // TODO: write to log once we have one
            }
            await Promise.all(allPromises);
        }
        terminate(reason, code = 0) {
            if (this.W) {
                // we are already shutting down...
                return;
            }
            this.W = true;
            this.s.info(`Extension host terminating: ${reason}`);
            this.s.flush();
            this.u.dispose();
            this.P.dispose();
            errors.setUnexpectedErrorHandler((err) => {
                this.s.error(err);
            });
            // Invalidate all proxies
            this.g.dispose();
            const extensionsDeactivated = this.$();
            // Give extensions at most 5 seconds to wrap up any async deactivate, then exit
            Promise.race([(0, async_1.$Gh)(5000), extensionsDeactivated]).finally(() => {
                if (this.c.pid) {
                    this.s.info(`Extension host with pid ${this.c.pid} exiting with code ${code}`);
                }
                else {
                    this.s.info(`Extension host exiting with code ${code}`);
                }
                this.s.flush();
                this.s.dispose();
                this.c.exit(code);
            });
        }
        isActivated(extensionId) {
            if (this.G.isOpen()) {
                return this.P.isActivated(extensionId);
            }
            return false;
        }
        async getExtension(extensionId) {
            const ext = await this.C.$getExtension(extensionId);
            return ext && {
                ...ext,
                identifier: new extensions_2.$rn(ext.identifier.value),
                extensionLocation: uri_1.URI.revive(ext.extensionLocation)
            };
        }
        ab(activationEvent, startup) {
            return this.P.activateByEvent(activationEvent, startup);
        }
        bb(extensionId, reason) {
            return this.P.activateById(extensionId, reason);
        }
        activateByIdWithErrors(extensionId, reason) {
            return this.bb(extensionId, reason).then(() => {
                const extension = this.P.getActivatedExtension(extensionId);
                if (extension.activationFailed) {
                    // activation failed => bubble up the error as the promise result
                    return Promise.reject(extension.activationFailedError);
                }
                return undefined;
            });
        }
        getExtensionRegistry() {
            return this.G.wait().then(_ => this.J);
        }
        getExtensionExports(extensionId) {
            if (this.G.isOpen()) {
                return this.P.getActivatedExtension(extensionId).exports;
            }
            else {
                try {
                    return this.P.getActivatedExtension(extensionId).exports;
                }
                catch (err) {
                    return null;
                }
            }
        }
        /**
         * Applies realpath to file-uris and returns all others uris unmodified.
         * The real path is cached for the lifetime of the extension host.
         */
        async cb(uri) {
            if (uri.scheme === network_1.Schemas.file && this.c.fsRealpath) {
                const fsPath = uri.fsPath;
                if (!this.R.has(fsPath)) {
                    this.R.set(fsPath, this.c.fsRealpath(fsPath));
                }
                const realpathValue = await this.R.get(fsPath);
                return uri_1.URI.file(realpathValue);
            }
            return uri;
        }
        // create trie to enable fast 'filename -> extension id' look up
        async getExtensionPathIndex() {
            if (!this.Q) {
                this.Q = this.db(this.J.getAllExtensionDescriptions()).then((searchTree) => {
                    return new $tqc(searchTree);
                });
            }
            return this.Q;
        }
        /**
         * create trie to enable fast 'filename -> extension id' look up
         */
        async db(extensions) {
            const tst = ternarySearchTree_1.$Li.forUris(key => {
                // using the default/biased extUri-util because the IExtHostFileSystemInfo-service
                // isn't ready to be used yet, e.g the knowledge about `file` protocol and others
                // comes in while this code runs
                return resources_1.$0g.ignorePathCasing(key);
            });
            // const tst = TernarySearchTree.forUris<IExtensionDescription>(key => true);
            await Promise.all(extensions.map(async (ext) => {
                if (this.wb(ext)) {
                    const uri = await this.cb(ext.extensionLocation);
                    tst.set(uri, ext);
                }
            }));
            return tst;
        }
        eb(extensionId) {
            let result = Promise.resolve(undefined);
            if (!this.G.isOpen()) {
                return result;
            }
            if (!this.P.isActivated(extensionId)) {
                return result;
            }
            const extension = this.P.getActivatedExtension(extensionId);
            if (!extension) {
                return result;
            }
            // call deactivate if available
            try {
                if (typeof extension.module.deactivate === 'function') {
                    result = Promise.resolve(extension.module.deactivate()).then(undefined, (err) => {
                        this.s.error(err);
                        return Promise.resolve(undefined);
                    });
                }
            }
            catch (err) {
                this.s.error(`An error occurred when deactivating the extension '${extensionId.value}':`);
                this.s.error(err);
            }
            // clean up subscriptions
            try {
                extension.disposable.dispose();
            }
            catch (err) {
                this.s.error(`An error occurred when disposing the subscriptions for extension '${extensionId.value}':`);
                this.s.error(err);
            }
            return result;
        }
        // --- impl
        async fb(extensionDescription, reason) {
            if (!this.f.remote.isRemote) {
                // local extension host process
                await this.C.$onWillActivateExtension(extensionDescription.identifier);
            }
            else {
                // remote extension host process
                // do not wait for renderer confirmation
                this.C.$onWillActivateExtension(extensionDescription.identifier);
            }
            return this.hb(extensionDescription, reason).then((activatedExtension) => {
                const activationTimes = activatedExtension.activationTimes;
                this.C.$onDidActivateExtension(extensionDescription.identifier, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, reason);
                this.gb(extensionDescription, reason, 'success', activationTimes);
                return activatedExtension;
            }, (err) => {
                this.gb(extensionDescription, reason, 'failure');
                throw err;
            });
        }
        gb(extensionDescription, reason, outcome, activationTimes) {
            const event = getTelemetryActivationEvent(extensionDescription, reason);
            this.z.$publicLog2('extensionActivationTimes', {
                ...event,
                ...(activationTimes || {}),
                outcome
            });
        }
        hb(extensionDescription, reason) {
            const event = getTelemetryActivationEvent(extensionDescription, reason);
            this.z.$publicLog2('activatePlugin', event);
            const entryPoint = this.wb(extensionDescription);
            if (!entryPoint) {
                // Treat the extension as being empty => NOT AN ERROR CASE
                return Promise.resolve(new extHostExtensionActivator_1.$8pc(extHostExtensionActivator_1.$5pc.NONE));
            }
            this.s.info(`ExtensionService#_doActivateExtension ${extensionDescription.identifier.value}, startup: ${reason.startup}, activationEvent: '${reason.activationEvent}'${extensionDescription.identifier.value !== reason.extensionId.value ? `, root cause: ${reason.extensionId.value}` : ``}`);
            this.s.flush();
            const extensionInternalStore = new lifecycle_1.$Tc(); // disposables that follow the extension lifecycle
            const activationTimesBuilder = new extHostExtensionActivator_1.$6pc(reason.startup);
            return Promise.all([
                this.xb(extensionDescription, (0, resources_1.$gh)(extensionDescription.extensionLocation, entryPoint), activationTimesBuilder),
                this.ib(extensionDescription, extensionInternalStore)
            ]).then(values => {
                performance.mark(`code/extHost/willActivateExtension/${extensionDescription.identifier.value}`);
                return $qqc_1.jb(this.s, extensionDescription.identifier, values[0], values[1], extensionInternalStore, activationTimesBuilder);
            }).then((activatedExtension) => {
                performance.mark(`code/extHost/didActivateExtension/${extensionDescription.identifier.value}`);
                return activatedExtension;
            });
        }
        ib(extensionDescription, extensionInternalStore) {
            const lanuageModelAccessInformation = this.Z.createLanguageModelAccessInformation(extensionDescription);
            const globalState = extensionInternalStore.add(new extHostMemento_1.$bqc(extensionDescription, this.M));
            const workspaceState = extensionInternalStore.add(new extHostMemento_1.$aqc(extensionDescription.identifier.value, false, this.M));
            const secrets = extensionInternalStore.add(new extHostSecrets_1.$kqc(extensionDescription, this.N));
            const extensionMode = extensionDescription.isUnderDevelopment
                ? (this.f.environment.extensionTestsLocationURI ? extHostTypes_1.ExtensionMode.Test : extHostTypes_1.ExtensionMode.Development)
                : extHostTypes_1.ExtensionMode.Production;
            const extensionKind = this.f.remote.isRemote ? extHostTypes_1.ExtensionKind.Workspace : extHostTypes_1.ExtensionKind.UI;
            this.s.trace(`ExtensionService#loadExtensionContext ${extensionDescription.identifier.value}`);
            return Promise.all([
                globalState.whenReady,
                workspaceState.whenReady,
                this.O.whenReady
            ]).then(() => {
                const that = this;
                let extension;
                let messagePassingProtocol;
                const messagePort = (0, extensions_1.$fH)(extensionDescription, 'ipc')
                    ? this.f.messagePorts?.get(extensions_2.$rn.toKey(extensionDescription.identifier))
                    : undefined;
                return Object.freeze({
                    globalState,
                    workspaceState,
                    secrets,
                    subscriptions: [],
                    get languageModelAccessInformation() { return lanuageModelAccessInformation; },
                    get extensionUri() { return extensionDescription.extensionLocation; },
                    get extensionPath() { return extensionDescription.extensionLocation.fsPath; },
                    asAbsolutePath(relativePath) { return path.$jc(extensionDescription.extensionLocation.fsPath, relativePath); },
                    get storagePath() { return that.O.workspaceValue(extensionDescription)?.fsPath; },
                    get globalStoragePath() { return that.O.globalValue(extensionDescription).fsPath; },
                    get logPath() { return path.$jc(that.f.logsLocation.fsPath, extensionDescription.identifier.value); },
                    get logUri() { return uri_1.URI.joinPath(that.f.logsLocation, extensionDescription.identifier.value); },
                    get storageUri() { return that.O.workspaceValue(extensionDescription); },
                    get globalStorageUri() { return that.O.globalValue(extensionDescription); },
                    get extensionMode() { return extensionMode; },
                    get extension() {
                        if (extension === undefined) {
                            extension = new $sqc(that, extensionDescription.identifier, extensionDescription, extensionKind, false);
                        }
                        return extension;
                    },
                    get extensionRuntime() {
                        (0, extensions_1.$gH)(extensionDescription, 'extensionRuntime');
                        return that.extensionRuntime;
                    },
                    get environmentVariableCollection() { return that.u.getEnvironmentVariableCollection(extensionDescription); },
                    get messagePassingProtocol() {
                        if (!messagePassingProtocol) {
                            if (!messagePort) {
                                return undefined;
                            }
                            const onDidReceiveMessage = event_1.Event.buffer(event_1.Event.fromDOMEventEmitter(messagePort, 'message', e => e.data));
                            messagePort.start();
                            messagePassingProtocol = {
                                onDidReceiveMessage,
                                postMessage: messagePort.postMessage.bind(messagePort)
                            };
                        }
                        return messagePassingProtocol;
                    }
                });
            });
        }
        static jb(logService, extensionId, extensionModule, context, extensionInternalStore, activationTimesBuilder) {
            // Make sure the extension's surface is not undefined
            extensionModule = extensionModule || {
                activate: undefined,
                deactivate: undefined
            };
            return this.kb(logService, extensionId, extensionModule, context, activationTimesBuilder).then((extensionExports) => {
                return new extHostExtensionActivator_1.$7pc(false, null, activationTimesBuilder.build(), extensionModule, extensionExports, (0, lifecycle_1.$Sc)(() => {
                    extensionInternalStore.dispose();
                    (0, lifecycle_1.$Pc)(context.subscriptions);
                }));
            });
        }
        static kb(logService, extensionId, extensionModule, context, activationTimesBuilder) {
            if (typeof extensionModule.activate === 'function') {
                try {
                    activationTimesBuilder.activateCallStart();
                    logService.trace(`ExtensionService#_callActivateOptional ${extensionId.value}`);
                    const scope = typeof global === 'object' ? global : self; // `global` is nodejs while `self` is for workers
                    const activateResult = extensionModule.activate.apply(scope, [context]);
                    activationTimesBuilder.activateCallStop();
                    activationTimesBuilder.activateResolveStart();
                    return Promise.resolve(activateResult).then((value) => {
                        activationTimesBuilder.activateResolveStop();
                        return value;
                    });
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
            else {
                // No activate found => the module is the extension's exports
                return Promise.resolve(extensionModule);
            }
        }
        // -- eager activation
        lb(desc, activationEvent) {
            this.bb(desc.identifier, {
                startup: false,
                extensionId: desc.identifier,
                activationEvent: activationEvent
            }).then(undefined, (err) => {
                this.s.error(err);
            });
        }
        mb(extensions, start = 0) {
            const timeBudget = 50; // 50 milliseconds
            const startTime = Date.now();
            (0, platform_1.$C)(() => {
                for (let i = start; i < extensions.length; i += 1) {
                    const desc = extensions[i];
                    for (const activationEvent of (desc.activationEvents ?? [])) {
                        if (activationEvent === 'onStartupFinished') {
                            if (Date.now() - startTime > timeBudget) {
                                // time budget for current task has been exceeded
                                // set a new task to activate current and remaining extensions
                                this.mb(extensions, i);
                                break;
                            }
                            else {
                                this.lb(desc, activationEvent);
                            }
                        }
                    }
                }
            });
        }
        nb() {
            // startup is considered finished
            this.C.$setPerformanceMarks(performance.getMarks());
            this.m.getConfigProvider().then((configProvider) => {
                const shouldDeferActivation = configProvider.getConfiguration('extensions.experimental').get('deferredStartupFinishedActivation');
                const allExtensionDescriptions = this.J.getAllExtensionDescriptions();
                if (shouldDeferActivation) {
                    this.mb(allExtensionDescriptions);
                }
                else {
                    for (const desc of allExtensionDescriptions) {
                        if (desc.activationEvents) {
                            for (const activationEvent of desc.activationEvents) {
                                if (activationEvent === 'onStartupFinished') {
                                    this.lb(desc, activationEvent);
                                }
                            }
                        }
                    }
                }
            });
        }
        // Handle "eager" activation extensions
        ob() {
            const starActivation = this.ab('*', true).then(undefined, (err) => {
                this.s.error(err);
            });
            this.B(this.j.onDidChangeWorkspace((e) => this.pb(e.added)));
            const folders = this.j.workspace ? this.j.workspace.folders : [];
            const workspaceContainsActivation = this.pb(folders);
            const remoteResolverActivation = this.rb();
            const eagerExtensionsActivation = Promise.all([remoteResolverActivation, starActivation, workspaceContainsActivation]).then(() => { });
            Promise.race([eagerExtensionsActivation, (0, async_1.$Gh)(10000)]).then(() => {
                this.nb();
            });
            return eagerExtensionsActivation;
        }
        pb(folders) {
            if (folders.length === 0) {
                return Promise.resolve(undefined);
            }
            return Promise.all(this.J.getAllExtensionDescriptions().map((desc) => {
                return this.qb(folders, desc);
            })).then(() => { });
        }
        async qb(folders, desc) {
            if (this.isActivated(desc.identifier)) {
                return;
            }
            const localWithRemote = !this.f.remote.isRemote && !!this.f.remote.authority;
            const host = {
                logService: this.s,
                folders: folders.map(folder => folder.uri),
                forceUsingSearch: localWithRemote || !this.c.fsExists,
                exists: (uri) => this.c.fsExists(uri.fsPath),
                checkExists: (folders, includes, token) => this.y.$checkExists(folders, includes, token)
            };
            const result = await (0, workspaceContains_1.$Ayb)(host, desc);
            if (!result) {
                return;
            }
            return (this.bb(desc.identifier, { startup: true, extensionId: desc.identifier, activationEvent: result.activationEvent })
                .then(undefined, err => this.s.error(err)));
        }
        async rb() {
            if (this.f.remote.authority) {
                return this.ab(`onResolveRemoteAuthority:${this.f.remote.authority}`, false);
            }
        }
        async $extensionTestsExecute() {
            await this.H.wait();
            try {
                return await this.sb();
            }
            catch (error) {
                console.error(error); // ensure any error message makes it onto the console
                throw error;
            }
        }
        async sb() {
            const { extensionDevelopmentLocationURI, extensionTestsLocationURI } = this.f.environment;
            if (!extensionDevelopmentLocationURI || !extensionTestsLocationURI) {
                throw new Error(nls.localize(11262, null));
            }
            // Require the test runner via node require from the provided path
            const testRunner = await this.xb(null, extensionTestsLocationURI, new extHostExtensionActivator_1.$6pc(false));
            if (!testRunner || typeof testRunner.run !== 'function') {
                throw new Error(nls.localize(11263, null, extensionTestsLocationURI.toString()));
            }
            // Execute the runner if it follows the old `run` spec
            return new Promise((resolve, reject) => {
                const oldTestRunnerCallback = (error, failures) => {
                    if (error) {
                        if (platform_1.$u) {
                            this.s.error(`Test runner called back with error`, error);
                        }
                        reject(error);
                    }
                    else {
                        if (platform_1.$u) {
                            if (failures) {
                                this.s.info(`Test runner called back with ${failures} failures.`);
                            }
                            else {
                                this.s.info(`Test runner called back with successful outcome.`);
                            }
                        }
                        resolve((typeof failures === 'number' && failures > 0) ? 1 /* ERROR */ : 0 /* OK */);
                    }
                };
                const extensionTestsPath = (0, resources_1.$7g)(extensionTestsLocationURI); // for the old test runner API
                const runResult = testRunner.run(extensionTestsPath, oldTestRunnerCallback);
                // Using the new API `run(): Promise<void>`
                if (runResult && runResult.then) {
                    runResult
                        .then(() => {
                        if (platform_1.$u) {
                            this.s.info(`Test runner finished successfully.`);
                        }
                        resolve(0);
                    })
                        .catch((err) => {
                        if (platform_1.$u) {
                            this.s.error(`Test runner finished with error`, err);
                        }
                        reject(err instanceof Error && err.stack ? err.stack : String(err));
                    });
                }
            });
        }
        tb() {
            if (this.U) {
                throw new Error(`Extension host is already started!`);
            }
            this.U = true;
            return this.F.wait()
                .then(() => this.G.open())
                .then(() => {
                // wait for all activation events that came in during workbench startup, but at maximum 1s
                return Promise.race([this.P.waitForActivatingExtensions(), (0, async_1.$Gh)(1000)]);
            })
                .then(() => this.ob())
                .then(() => {
                this.H.open();
                this.s.info(`Eager extensions activated`);
            });
        }
        // -- called by extensions
        registerRemoteAuthorityResolver(authorityPrefix, resolver) {
            this.S[authorityPrefix] = resolver;
            return (0, lifecycle_1.$Sc)(() => {
                delete this.S[authorityPrefix];
            });
        }
        async getRemoteExecServer(remoteAuthority) {
            const { resolver } = await this.ub(remoteAuthority);
            return resolver?.resolveExecServer?.(remoteAuthority, { resolveAttempt: 0 });
        }
        // -- called by main thread
        async ub(remoteAuthority) {
            const authorityPlusIndex = remoteAuthority.indexOf('+');
            if (authorityPlusIndex === -1) {
                throw new extHostTypes_1.$UN(`Not an authority that can be resolved!`, remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.InvalidAuthority);
            }
            const authorityPrefix = remoteAuthority.substr(0, authorityPlusIndex);
            await this.D.wait();
            await this.ab(`onResolveRemoteAuthority:${authorityPrefix}`, false);
            return { authorityPrefix, resolver: this.S[authorityPrefix] };
        }
        async $resolveAuthority(remoteAuthorityChain, resolveAttempt) {
            const sw = stopwatch_1.$fe.create(false);
            const prefix = () => `[resolveAuthority(${(0, remoteAuthorityResolver_1.$Vl)(remoteAuthorityChain)},${resolveAttempt})][${sw.elapsed()}ms] `;
            const logInfo = (msg) => this.s.info(`${prefix()}${msg}`);
            const logWarning = (msg) => this.s.warn(`${prefix()}${msg}`);
            const logError = (msg, err = undefined) => this.s.error(`${prefix()}${msg}`, err);
            const normalizeError = (err) => {
                if (err instanceof extHostTypes_1.$UN) {
                    return {
                        type: 'error',
                        error: {
                            code: err._code,
                            message: err._message,
                            detail: err._detail
                        }
                    };
                }
                throw err;
            };
            const getResolver = async (remoteAuthority) => {
                logInfo(`activating resolver for ${remoteAuthority}...`);
                const { resolver, authorityPrefix } = await this.ub(remoteAuthority);
                if (!resolver) {
                    logError(`no resolver for ${authorityPrefix}`);
                    throw new extHostTypes_1.$UN(`No remote extension installed to resolve ${authorityPrefix}.`, remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.NoResolverFound);
                }
                return { resolver, authorityPrefix, remoteAuthority };
            };
            const chain = remoteAuthorityChain.split(/@|%40/g).reverse();
            logInfo(`activating remote resolvers ${chain.join(' -> ')}`);
            let resolvers;
            try {
                resolvers = await Promise.all(chain.map(getResolver)).catch(async (e) => {
                    if (!(e instanceof extHostTypes_1.$UN) || e._code !== remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.InvalidAuthority) {
                        throw e;
                    }
                    logWarning(`resolving nested authorities failed: ${e.message}`);
                    return [await getResolver(remoteAuthorityChain)];
                });
            }
            catch (e) {
                return normalizeError(e);
            }
            const intervalLogger = new async_1.$Qh();
            intervalLogger.cancelAndSet(() => logInfo('waiting...'), 1000);
            let result;
            let execServer;
            for (const [i, { authorityPrefix, resolver, remoteAuthority }] of resolvers.entries()) {
                try {
                    if (i === resolvers.length - 1) {
                        logInfo(`invoking final resolve()...`);
                        performance.mark(`code/extHost/willResolveAuthority/${authorityPrefix}`);
                        result = await resolver.resolve(remoteAuthority, { resolveAttempt, execServer });
                        performance.mark(`code/extHost/didResolveAuthorityOK/${authorityPrefix}`);
                        logInfo(`setting tunnel factory...`);
                        this.B(await this.t.setTunnelFactory(resolver, extHostTypes_1.$TN.isManagedResolvedAuthority(result) ? result : undefined));
                    }
                    else {
                        logInfo(`invoking resolveExecServer() for ${remoteAuthority}`);
                        performance.mark(`code/extHost/willResolveExecServer/${authorityPrefix}`);
                        execServer = await resolver.resolveExecServer?.(remoteAuthority, { resolveAttempt, execServer });
                        if (!execServer) {
                            throw new extHostTypes_1.$UN(`Exec server was not available for ${remoteAuthority}`, remoteAuthorityResolver_1.RemoteAuthorityResolverErrorCode.NoResolverFound); // we did, in fact, break the chain :(
                        }
                        performance.mark(`code/extHost/didResolveExecServerOK/${authorityPrefix}`);
                    }
                }
                catch (e) {
                    performance.mark(`code/extHost/didResolveAuthorityError/${authorityPrefix}`);
                    logError(`returned an error`, e);
                    intervalLogger.dispose();
                    return normalizeError(e);
                }
            }
            intervalLogger.dispose();
            const tunnelInformation = {
                environmentTunnels: result.environmentTunnels,
                features: result.tunnelFeatures ? {
                    elevation: result.tunnelFeatures.elevation,
                    privacyOptions: result.tunnelFeatures.privacyOptions,
                    protocol: result.tunnelFeatures.protocol === undefined ? true : result.tunnelFeatures.protocol,
                } : undefined
            };
            // Split merged API result into separate authority/options
            const options = {
                extensionHostEnv: result.extensionHostEnv,
                isTrusted: result.isTrusted,
                authenticationSession: result.authenticationSessionForInitializingExtensions ? { id: result.authenticationSessionForInitializingExtensions.id, providerId: result.authenticationSessionForInitializingExtensions.providerId } : undefined
            };
            // extension are not required to return an instance of ResolvedAuthority or ManagedResolvedAuthority, so don't use `instanceof`
            logInfo(`returned ${extHostTypes_1.$TN.isManagedResolvedAuthority(result) ? 'managed authority' : `${result.host}:${result.port}`}`);
            let authority;
            if (extHostTypes_1.$TN.isManagedResolvedAuthority(result)) {
                // The socket factory is identified by the `resolveAttempt`, since that is a number which
                // always increments and is unique over all resolve() calls in a workbench session.
                const socketFactoryId = resolveAttempt;
                // There is only on managed socket factory at a time, so we can just overwrite the old one.
                this.Y.setFactory(socketFactoryId, result.makeConnection);
                authority = {
                    authority: remoteAuthorityChain,
                    connectTo: new remoteAuthorityResolver_1.$Sl(socketFactoryId),
                    connectionToken: result.connectionToken
                };
            }
            else {
                authority = {
                    authority: remoteAuthorityChain,
                    connectTo: new remoteAuthorityResolver_1.$Tl(result.host, result.port),
                    connectionToken: result.connectionToken
                };
            }
            return {
                type: 'ok',
                value: {
                    authority: authority,
                    options,
                    tunnelInformation,
                }
            };
        }
        async $getCanonicalURI(remoteAuthority, uriComponents) {
            this.s.info(`$getCanonicalURI invoked for authority (${(0, remoteAuthorityResolver_1.$Vl)(remoteAuthority)})`);
            const { resolver } = await this.ub(remoteAuthority);
            if (!resolver) {
                // Return `null` if no resolver for `remoteAuthority` is found.
                return null;
            }
            const uri = uri_1.URI.revive(uriComponents);
            if (typeof resolver.getCanonicalURI === 'undefined') {
                // resolver cannot compute canonical URI
                return uri;
            }
            const result = await (0, async_1.$xh)(() => resolver.getCanonicalURI(uri));
            if (!result) {
                return uri;
            }
            return result;
        }
        async $startExtensionHost(extensionsDelta) {
            extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = uri_1.URI.revive(extension.extensionLocation));
            const { globalRegistry, myExtensions } = applyExtensionsDelta(this.I, this.L, this.J, extensionsDelta);
            const newSearchTree = await this.db(myExtensions);
            const extensionsPaths = await this.getExtensionPathIndex();
            extensionsPaths.setSearchTree(newSearchTree);
            this.L.set(globalRegistry.getAllExtensionDescriptions());
            this.J.set(myExtensions);
            if (platform_1.$u) {
                this.s.info(`$startExtensionHost: global extensions: ${printExtIds(this.L)}`);
                this.s.info(`$startExtensionHost: local extensions: ${printExtIds(this.J)}`);
            }
            return this.tb();
        }
        $activateByEvent(activationEvent, activationKind) {
            if (activationKind === extensions_1.ActivationKind.Immediate) {
                return this.D.wait()
                    .then(_ => this.ab(activationEvent, false));
            }
            return (this.G.wait()
                .then(_ => this.ab(activationEvent, false)));
        }
        async $activate(extensionId, reason) {
            await this.G.wait();
            if (!this.J.getExtensionDescription(extensionId)) {
                // unknown extension => ignore
                return false;
            }
            await this.bb(extensionId, reason);
            return true;
        }
        async $deltaExtensions(extensionsDelta) {
            extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = uri_1.URI.revive(extension.extensionLocation));
            // First build up and update the trie and only afterwards apply the delta
            const { globalRegistry, myExtensions } = applyExtensionsDelta(this.I, this.L, this.J, extensionsDelta);
            const newSearchTree = await this.db(myExtensions);
            const extensionsPaths = await this.getExtensionPathIndex();
            extensionsPaths.setSearchTree(newSearchTree);
            this.L.set(globalRegistry.getAllExtensionDescriptions());
            this.J.set(myExtensions);
            if (platform_1.$u) {
                this.s.info(`$deltaExtensions: global extensions: ${printExtIds(this.L)}`);
                this.s.info(`$deltaExtensions: local extensions: ${printExtIds(this.J)}`);
            }
            return Promise.resolve(undefined);
        }
        async $test_latency(n) {
            return n;
        }
        async $test_up(b) {
            return b.byteLength;
        }
        async $test_down(size) {
            const buff = buffer_1.$Ne.alloc(size);
            const value = Math.random() % 256;
            for (let i = 0; i < size; i++) {
                buff.writeUInt8(value, i);
            }
            return buff;
        }
        async $updateRemoteConnectionData(connectionData) {
            this.X = connectionData;
            this.a.fire();
        }
    };
    exports.$qqc = $qqc;
    exports.$qqc = $qqc = $qqc_1 = __decorate([
        __param(0, instantiation_1.$Ei),
        __param(1, exports.$pqc),
        __param(2, extHostRpcService_1.$kQ),
        __param(3, extHostWorkspace_1.$Npc),
        __param(4, extHostConfiguration_1.$Qpc),
        __param(5, log_1.$ak),
        __param(6, extHostInitDataService_1.$AQ),
        __param(7, extHostStoragePaths_1.$Tpc),
        __param(8, extHostTunnelService_1.$gGb),
        __param(9, extHostTerminalService_1.$cqc),
        __param(10, extHostLocalizationService_1.$mqc),
        __param(11, extHostManagedSockets_1.$nqc),
        __param(12, extHostLanguageModels_1.$gqc)
    ], $qqc);
    function applyExtensionsDelta(activationEventsReader, oldGlobalRegistry, oldMyRegistry, extensionsDelta) {
        activationEventsReader.addActivationEvents(extensionsDelta.addActivationEvents);
        const globalRegistry = new extensionDescriptionRegistry_1.$Mdc(activationEventsReader, oldGlobalRegistry.getAllExtensionDescriptions());
        globalRegistry.deltaExtensions(extensionsDelta.toAdd, extensionsDelta.toRemove);
        const myExtensionsSet = new extensions_2.$sn(oldMyRegistry.getAllExtensionDescriptions().map(extension => extension.identifier));
        for (const extensionId of extensionsDelta.myToRemove) {
            myExtensionsSet.delete(extensionId);
        }
        for (const extensionId of extensionsDelta.myToAdd) {
            myExtensionsSet.add(extensionId);
        }
        const myExtensions = filterExtensions(globalRegistry, myExtensionsSet);
        return { globalRegistry, myExtensions };
    }
    function getTelemetryActivationEvent(extensionDescription, reason) {
        const event = {
            id: extensionDescription.identifier.value,
            name: extensionDescription.name,
            extensionVersion: extensionDescription.version,
            publisherDisplayName: extensionDescription.publisher,
            activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,
            isBuiltin: extensionDescription.isBuiltin,
            reason: reason.activationEvent,
            reasonId: reason.extensionId.value,
        };
        return event;
    }
    function printExtIds(registry) {
        return registry.getAllExtensionDescriptions().map(ext => ext.identifier.value).join(',');
    }
    exports.$rqc = (0, instantiation_1.$Fi)('IExtHostExtensionService');
    class $sqc {
        #extensionService;
        #originExtensionId;
        #identifier;
        constructor(extensionService, originExtensionId, description, kind, isFromDifferentExtensionHost) {
            this.#extensionService = extensionService;
            this.#originExtensionId = originExtensionId;
            this.#identifier = description.identifier;
            this.id = description.identifier.value;
            this.extensionUri = description.extensionLocation;
            this.extensionPath = path.$hc((0, resources_1.$7g)(description.extensionLocation));
            this.packageJSON = description;
            this.extensionKind = kind;
            this.isFromDifferentExtensionHost = isFromDifferentExtensionHost;
        }
        get isActive() {
            // TODO@alexdima support this
            return this.#extensionService.isActivated(this.#identifier);
        }
        get exports() {
            if (this.packageJSON.api === 'none' || this.isFromDifferentExtensionHost) {
                return undefined; // Strict nulloverride - Public api
            }
            return this.#extensionService.getExtensionExports(this.#identifier);
        }
        async activate() {
            if (this.isFromDifferentExtensionHost) {
                throw new Error('Cannot activate foreign extension'); // TODO@alexdima support this
            }
            await this.#extensionService.activateByIdWithErrors(this.#identifier, { startup: false, extensionId: this.#originExtensionId, activationEvent: 'api' });
            return this.exports;
        }
    }
    exports.$sqc = $sqc;
    function filterExtensions(globalRegistry, desiredExtensions) {
        return globalRegistry.getAllExtensionDescriptions().filter(extension => desiredExtensions.has(extension.identifier));
    }
    class $tqc {
        constructor(a) {
            this.a = a;
        }
        setSearchTree(searchTree) {
            this.a = searchTree;
        }
        findSubstr(key) {
            return this.a.findSubstr(key);
        }
        forEach(callback) {
            return this.a.forEach(callback);
        }
    }
    exports.$tqc = $tqc;
    /**
     * This mirrors the activation events as seen by the renderer. The renderer
     * is the only one which can have a reliable view of activation events because
     * implicit activation events are generated via extension points, and they
     * are registered only on the renderer side.
     */
    class SyncedActivationEventsReader {
        constructor(activationEvents) {
            this.a = new extensions_2.$tn();
            this.addActivationEvents(activationEvents);
        }
        readActivationEvents(extensionDescription) {
            return this.a.get(extensionDescription.identifier) ?? [];
        }
        addActivationEvents(activationEvents) {
            for (const extensionId of Object.keys(activationEvents)) {
                this.a.set(extensionId, activationEvents[extensionId]);
            }
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[273/*vs/workbench/api/common/extHostRequireInterceptor*/], __M([1/*require*/,0/*exports*/,64/*vs/base/common/performance*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,46/*vs/workbench/api/common/extHostConfiguration*/,24/*vs/workbench/services/extensions/common/extensions*/,18/*vs/platform/extensions/common/extensions*/,16/*vs/workbench/api/common/extHostRpcService*/,26/*vs/workbench/api/common/extHostInitDataService*/,3/*vs/platform/instantiation/common/instantiation*/,47/*vs/workbench/api/common/extHostExtensionService*/,11/*vs/platform/log/common/log*/,12/*vs/base/common/strings*/]), function (require, exports, performance, uri_1, extHost_protocol_1, extHostConfiguration_1, extensions_1, extensions_2, extHostRpcService_1, extHostInitDataService_1, instantiation_1, extHostExtensionService_1, log_1, strings_1) {
    "use strict";
    var NodeModuleAliasingModuleFactory_1;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Erc = void 0;
    performance = __importStar(performance);
    let $Erc = class $Erc {
        constructor(c, d, e, f, g, h, i) {
            this.c = c;
            this.d = d;
            this.e = e;
            this.f = f;
            this.g = g;
            this.h = h;
            this.i = i;
            this.a = new Map();
            this.b = [];
        }
        async install() {
            this.j();
            performance.mark('code/extHost/willWaitForConfig');
            const configProvider = await this.f.getConfigProvider();
            performance.mark('code/extHost/didWaitForConfig');
            const extensionPaths = await this.g.getExtensionPathIndex();
            this.register(new VSCodeNodeModuleFactory(this.c, extensionPaths, this.d, configProvider, this.i));
            this.register(this.e.createInstance(NodeModuleAliasingModuleFactory));
            if (this.h.remote.isRemote) {
                this.register(this.e.createInstance(OpenNodeModuleFactory, extensionPaths, this.h.environment.appUriScheme));
            }
        }
        register(interceptor) {
            if ('nodeModuleName' in interceptor) {
                if (Array.isArray(interceptor.nodeModuleName)) {
                    for (const moduleName of interceptor.nodeModuleName) {
                        this.a.set(moduleName, interceptor);
                    }
                }
                else {
                    this.a.set(interceptor.nodeModuleName, interceptor);
                }
            }
            if (typeof interceptor.alternativeModuleName === 'function') {
                this.b.push((moduleName) => {
                    return interceptor.alternativeModuleName(moduleName);
                });
            }
        }
    };
    exports.$Erc = $Erc;
    exports.$Erc = $Erc = __decorate([
        __param(2, instantiation_1.$Ei),
        __param(3, extHostConfiguration_1.$Qpc),
        __param(4, extHostExtensionService_1.$rqc),
        __param(5, extHostInitDataService_1.$AQ),
        __param(6, log_1.$ak)
    ], $Erc);
    //#region --- module renames
    let NodeModuleAliasingModuleFactory = class NodeModuleAliasingModuleFactory {
        static { NodeModuleAliasingModuleFactory_1 = this; }
        /**
         * Map of aliased internal node_modules, used to allow for modules to be
         * renamed without breaking extensions. In the form "original -> new name".
         */
        static { this.a = new Map([
            ['vscode-ripgrep', '@vscode/ripgrep'],
            ['vscode-windows-registry', '@vscode/windows-registry'],
        ]); }
        constructor(initData) {
            if (initData.environment.appRoot && NodeModuleAliasingModuleFactory_1.a.size) {
                const root = (0, strings_1.$hf)(this.c(initData.environment.appRoot.fsPath));
                // decompose ${appRoot}/node_modules/foo/bin to ['${appRoot}/node_modules/', 'foo', '/bin'],
                // and likewise the more complex form ${appRoot}/node_modules.asar.unpacked/@vcode/foo/bin
                // to ['${appRoot}/node_modules.asar.unpacked/',' @vscode/foo', '/bin'].
                const npmIdChrs = `[a-z0-9_.-]`;
                const npmModuleName = `@${npmIdChrs}+\\/${npmIdChrs}+|${npmIdChrs}+`;
                const moduleFolders = 'node_modules|node_modules\\.asar(?:\\.unpacked)?';
                this.b = new RegExp(`^(${root}/${moduleFolders}\\/)(${npmModuleName})(.*)$`, 'i');
            }
        }
        alternativeModuleName(name) {
            if (!this.b) {
                return;
            }
            const result = this.b.exec(this.c(name));
            if (!result) {
                return;
            }
            const [, prefix, moduleName, suffix] = result;
            const dealiased = NodeModuleAliasingModuleFactory_1.a.get(moduleName);
            if (dealiased === undefined) {
                return;
            }
            console.warn(`${moduleName} as been renamed to ${dealiased}, please update your imports`);
            return prefix + dealiased + suffix;
        }
        c(str) {
            return str.replace(/\\/g, '/');
        }
    };
    NodeModuleAliasingModuleFactory = NodeModuleAliasingModuleFactory_1 = __decorate([
        __param(0, extHostInitDataService_1.$AQ)
    ], NodeModuleAliasingModuleFactory);
    //#endregion
    //#region --- vscode-module
    class VSCodeNodeModuleFactory {
        constructor(c, d, e, f, g) {
            this.c = c;
            this.d = d;
            this.e = e;
            this.f = f;
            this.g = g;
            this.nodeModuleName = 'vscode';
            this.a = new extensions_2.$tn();
        }
        load(_request, parent) {
            // get extension id from filename and api for extension
            const ext = this.d.findSubstr(parent);
            if (ext) {
                let apiImpl = this.a.get(ext.identifier);
                if (!apiImpl) {
                    apiImpl = this.c(ext, this.e, this.f);
                    this.a.set(ext.identifier, apiImpl);
                }
                return apiImpl;
            }
            // fall back to a default implementation
            if (!this.b) {
                let extensionPathsPretty = '';
                this.d.forEach((value, index) => extensionPathsPretty += `\t${index} -> ${value.identifier.value}\n`);
                this.g.warn(`Could not identify extension for 'vscode' require call from ${parent}. These are the extension path mappings: \n${extensionPathsPretty}`);
                this.b = this.c(extensions_1.$aH, this.e, this.f);
            }
            return this.b;
        }
    }
    let OpenNodeModuleFactory = class OpenNodeModuleFactory {
        constructor(e, f, rpcService) {
            this.e = e;
            this.f = f;
            this.nodeModuleName = ['open', 'opn'];
            this.d = rpcService.getProxy(extHost_protocol_1.$KN.MainThreadTelemetry);
            const mainThreadWindow = rpcService.getProxy(extHost_protocol_1.$KN.MainThreadWindow);
            this.c = (target, options) => {
                const uri = uri_1.URI.parse(target);
                // If we have options use the original method.
                if (options) {
                    return this.g(target, options);
                }
                if (uri.scheme === 'http' || uri.scheme === 'https') {
                    return mainThreadWindow.$openUri(uri, target, { allowTunneling: true });
                }
                else if (uri.scheme === 'mailto' || uri.scheme === this.f) {
                    return mainThreadWindow.$openUri(uri, target, {});
                }
                return this.g(target, options);
            };
        }
        load(request, parent, original) {
            // get extension id from filename and api for extension
            const extension = this.e.findSubstr(parent);
            if (extension) {
                this.a = extension.identifier.value;
                this.h();
            }
            this.b = original(request);
            return this.c;
        }
        g(target, options) {
            this.i();
            return this.b(target, options);
        }
        h() {
            if (!this.a) {
                return;
            }
            this.d.$publicLog2('shimming.open', { extension: this.a });
        }
        i() {
            if (!this.a) {
                return;
            }
            this.d.$publicLog2('shimming.open.call.noForward', { extension: this.a });
        }
    };
    OpenNodeModuleFactory = __decorate([
        __param(2, extHostRpcService_1.$kQ)
    ], OpenNodeModuleFactory);
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[132/*vs/workbench/api/common/extHostVariableResolverService*/], __M([1/*require*/,0/*exports*/,48/*vs/base/common/lazy*/,4/*vs/base/common/lifecycle*/,19/*vs/base/common/path*/,78/*vs/base/common/process*/,3/*vs/platform/instantiation/common/instantiation*/,57/*vs/workbench/api/common/extHostDocumentsAndEditors*/,70/*vs/workbench/api/common/extHostEditorTabs*/,47/*vs/workbench/api/common/extHostExtensionService*/,7/*vs/workbench/api/common/extHostTypes*/,45/*vs/workbench/api/common/extHostWorkspace*/,203/*vs/workbench/services/configurationResolver/common/variableResolver*/,46/*vs/workbench/api/common/extHostConfiguration*/]), function (require, exports, lazy_1, lifecycle_1, path, process, instantiation_1, extHostDocumentsAndEditors_1, extHostEditorTabs_1, extHostExtensionService_1, extHostTypes_1, extHostWorkspace_1, variableResolver_1, extHostConfiguration_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$vqc = exports.$uqc = void 0;
    path = __importStar(path);
    process = __importStar(process);
    exports.$uqc = (0, instantiation_1.$Fi)('IExtHostVariableResolverProvider');
    class ExtHostVariableResolverService extends variableResolver_1.$oR {
        constructor(extensionService, workspaceService, editorService, editorTabs, configProvider, context, homeDir) {
            function getActiveUri() {
                if (editorService) {
                    const activeEditor = editorService.activeEditor();
                    if (activeEditor) {
                        return activeEditor.document.uri;
                    }
                    const activeTab = editorTabs.tabGroups.all.find(group => group.isActive)?.activeTab;
                    if (activeTab !== undefined) {
                        // Resolve a resource from the tab
                        if (activeTab.input instanceof extHostTypes_1.$BP || activeTab.input instanceof extHostTypes_1.$GP) {
                            return activeTab.input.modified;
                        }
                        else if (activeTab.input instanceof extHostTypes_1.$AP || activeTab.input instanceof extHostTypes_1.$FP || activeTab.input instanceof extHostTypes_1.$DP) {
                            return activeTab.input.uri;
                        }
                    }
                }
                return undefined;
            }
            super({
                getFolderUri: (folderName) => {
                    const found = context.folders.filter(f => f.name === folderName);
                    if (found && found.length > 0) {
                        return found[0].uri;
                    }
                    return undefined;
                },
                getWorkspaceFolderCount: () => {
                    return context.folders.length;
                },
                getConfigurationValue: (folderUri, section) => {
                    return configProvider.getConfiguration(undefined, folderUri).get(section);
                },
                getAppRoot: () => {
                    return process.cwd();
                },
                getExecPath: () => {
                    return process.env['VSCODE_EXEC_PATH'];
                },
                getFilePath: () => {
                    const activeUri = getActiveUri();
                    if (activeUri) {
                        return path.$hc(activeUri.fsPath);
                    }
                    return undefined;
                },
                getWorkspaceFolderPathForFile: () => {
                    if (workspaceService) {
                        const activeUri = getActiveUri();
                        if (activeUri) {
                            const ws = workspaceService.getWorkspaceFolder(activeUri);
                            if (ws) {
                                return path.$hc(ws.uri.fsPath);
                            }
                        }
                    }
                    return undefined;
                },
                getSelectedText: () => {
                    if (editorService) {
                        const activeEditor = editorService.activeEditor();
                        if (activeEditor && !activeEditor.selection.isEmpty) {
                            return activeEditor.document.getText(activeEditor.selection);
                        }
                    }
                    return undefined;
                },
                getLineNumber: () => {
                    if (editorService) {
                        const activeEditor = editorService.activeEditor();
                        if (activeEditor) {
                            return String(activeEditor.selection.end.line + 1);
                        }
                    }
                    return undefined;
                },
                getExtension: (id) => {
                    return extensionService.getExtension(id);
                },
            }, undefined, homeDir ? Promise.resolve(homeDir) : undefined, Promise.resolve(process.env));
        }
    }
    let $vqc = class $vqc extends lifecycle_1.$Uc {
        constructor(b, c, g, h, j) {
            super();
            this.b = b;
            this.c = c;
            this.g = g;
            this.h = h;
            this.j = j;
            this.a = new lazy_1.$T(async () => {
                const configProvider = await this.h.getConfigProvider();
                const folders = await this.c.getWorkspaceFolders2() || [];
                const dynamic = { folders };
                this.B(this.c.onDidChangeWorkspace(async (e) => {
                    dynamic.folders = await this.c.getWorkspaceFolders2() || [];
                }));
                return new ExtHostVariableResolverService(this.b, this.c, this.g, this.j, configProvider, dynamic, this.m());
            });
        }
        getResolver() {
            return this.a.value;
        }
        m() {
            return undefined;
        }
    };
    exports.$vqc = $vqc;
    exports.$vqc = $vqc = __decorate([
        __param(0, extHostExtensionService_1.$rqc),
        __param(1, extHostWorkspace_1.$Npc),
        __param(2, extHostDocumentsAndEditors_1.$vQ),
        __param(3, extHostConfiguration_1.$Qpc),
        __param(4, extHostEditorTabs_1.$3pc)
    ], $vqc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
































define(__m[133/*vs/workbench/api/common/extHostDebugService*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,6/*vs/base/common/event*/,2/*vs/base/common/uri*/,4/*vs/base/common/lifecycle*/,18/*vs/platform/extensions/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/,5/*vs/workbench/api/common/extHost.protocol*/,70/*vs/workbench/api/common/extHostEditorTabs*/,47/*vs/workbench/api/common/extHostExtensionService*/,16/*vs/workbench/api/common/extHostRpcService*/,7/*vs/workbench/api/common/extHostTypes*/,45/*vs/workbench/api/common/extHostWorkspace*/,195/*vs/workbench/contrib/debug/common/abstractDebugAdapter*/,80/*vs/workbench/contrib/debug/common/debug*/,196/*vs/workbench/contrib/debug/common/debugUtils*/,46/*vs/workbench/api/common/extHostConfiguration*/,132/*vs/workbench/api/common/extHostVariableResolverService*/,34/*vs/base/common/themables*/,33/*vs/workbench/api/common/extHostCommands*/,8/*vs/workbench/api/common/extHostTypeConverters*/,17/*vs/base/common/arrays*/,95/*vs/workbench/api/common/extHostTesting*/]), function (require, exports, async_1, event_1, uri_1, lifecycle_1, extensions_1, instantiation_1, extHost_protocol_1, extHostEditorTabs_1, extHostExtensionService_1, extHostRpcService_1, extHostTypes_1, extHostWorkspace_1, abstractDebugAdapter_1, debug_1, debugUtils_1, extHostConfiguration_1, extHostVariableResolverService_1, themables_1, extHostCommands_1, Convert, arrays_1, extHostTesting_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Fqc = exports.$Eqc = exports.$Dqc = exports.$Cqc = exports.$Bqc = void 0;
    Convert = __importStar(Convert);
    exports.$Bqc = (0, instantiation_1.$Fi)('IExtHostDebugService');
    let $Cqc = class $Cqc extends lifecycle_1.$Uc {
        get onDidStartDebugSession() { return this.y.event; }
        get onDidTerminateDebugSession() { return this.z.event; }
        get onDidChangeActiveDebugSession() { return this.C.event; }
        get activeDebugSession() { return this.D?.api; }
        get onDidReceiveDebugSessionCustomEvent() { return this.F.event; }
        get activeDebugConsole() { return this.G.value; }
        constructor(extHostRpcService, Y, Z, $, ab, bb, cb, db) {
            super();
            this.Y = Y;
            this.Z = Z;
            this.$ = $;
            this.ab = ab;
            this.bb = bb;
            this.cb = cb;
            this.db = db;
            this.w = new Map();
            this.O = 0;
            this.P = new Map();
            this.Q = new Map();
            this.R = new WeakMap();
            this.S = new Map();
            this.W = new Map();
            this.X = 0;
            this.f = 0;
            this.g = [];
            this.h = 0;
            this.j = [];
            this.m = 0;
            this.n = [];
            this.M = new Map();
            this.N = new Map();
            this.y = this.B(new event_1.$le());
            this.z = this.B(new event_1.$le());
            this.C = this.B(new event_1.$le());
            this.F = this.B(new event_1.$le());
            this.u = extHostRpcService.getProxy(extHost_protocol_1.$KN.MainThreadDebugService);
            this.I = this.B(new event_1.$le());
            this.L = this.B(new event_1.$le());
            this.G = new $Eqc(this.u);
            this.H = new Map();
            this.Z.getExtensionRegistry().then((extensionRegistry) => {
                this.B(extensionRegistry.onDidChange(_ => {
                    this.fb(extensionRegistry);
                }));
                this.fb(extensionRegistry);
            });
        }
        async $getVisualizerTreeItem(treeId, element) {
            const context = this.gb(element);
            if (!context) {
                return undefined;
            }
            const item = await this.Q.get(treeId)?.getTreeItem?.(context);
            return item ? this.eb(treeId, item) : undefined;
        }
        registerDebugVisualizationTree(manifest, id, provider) {
            const extensionId = extensions_1.$rn.toKey(manifest.identifier);
            const key = this.ub(extensionId, id);
            if (this.P.has(key)) {
                throw new Error(`A debug visualization provider with id '${id}' is already registered`);
            }
            this.Q.set(key, provider);
            this.u.$registerDebugVisualizerTree(key, !!provider.editItem);
            return (0, lifecycle_1.$Sc)(() => {
                this.u.$unregisterDebugVisualizerTree(key);
                this.Q.delete(id);
            });
        }
        async $getVisualizerTreeItemChildren(treeId, element) {
            const item = this.S.get(element)?.item;
            if (!item) {
                return [];
            }
            const children = await this.Q.get(treeId)?.getChildren?.(item);
            return children?.map(i => this.eb(treeId, i)) || [];
        }
        async $editVisualizerTreeItem(element, value) {
            const e = this.S.get(element);
            if (!e) {
                return undefined;
            }
            const r = await this.Q.get(e.provider)?.editItem?.(e.item, value);
            return this.eb(e.provider, r || e.item);
        }
        $disposeVisualizedTree(element) {
            const root = this.S.get(element);
            if (!root) {
                return;
            }
            const queue = [root.children];
            for (const children of queue) {
                if (children) {
                    for (const child of children) {
                        queue.push(this.S.get(child)?.children);
                        this.S.delete(child);
                    }
                }
            }
        }
        eb(treeId, item) {
            let id = this.R.get(item);
            if (!id) {
                id = this.O++;
                this.R.set(item, id);
                this.S.set(id, { provider: treeId, item });
            }
            return Convert.DebugTreeItem.from(item, id);
        }
        asDebugSourceUri(src, session) {
            const source = src;
            if (typeof source.sourceReference === 'number' && source.sourceReference > 0) {
                // src can be retrieved via DAP's "source" request
                let debug = `debug:${encodeURIComponent(source.path || '')}`;
                let sep = '?';
                if (session) {
                    debug += `${sep}session=${encodeURIComponent(session.id)}`;
                    sep = '&';
                }
                debug += `${sep}ref=${source.sourceReference}`;
                return uri_1.URI.parse(debug);
            }
            else if (source.path) {
                // src is just a local file path
                return uri_1.URI.file(source.path);
            }
            else {
                throw new Error(`cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.`);
            }
        }
        fb(extensionRegistry) {
            const debugTypes = [];
            for (const ed of extensionRegistry.getAllExtensionDescriptions()) {
                if (ed.contributes) {
                    const debuggers = ed.contributes['debuggers'];
                    if (debuggers && debuggers.length > 0) {
                        for (const dbg of debuggers) {
                            if ((0, debugUtils_1.$_H)(dbg)) {
                                debugTypes.push(dbg.type);
                            }
                        }
                    }
                }
            }
            this.u.$registerDebugTypes(debugTypes);
        }
        // extension debug API
        get activeStackItem() {
            return this.J;
        }
        get onDidChangeActiveStackItem() {
            return this.L.event;
        }
        get onDidChangeBreakpoints() {
            return this.I.event;
        }
        get breakpoints() {
            const result = [];
            this.H.forEach(bp => result.push(bp));
            return result;
        }
        async $resolveDebugVisualizer(id, token) {
            const visualizer = this.W.get(id);
            if (!visualizer) {
                throw new Error(`No debug visualizer found with id '${id}'`);
            }
            let { v, provider, extensionId } = visualizer;
            if (!v.visualization) {
                v = await provider.resolveDebugVisualization?.(v, token) || v;
                visualizer.v = v;
            }
            if (!v.visualization) {
                throw new Error(`No visualization returned from resolveDebugVisualization in '${provider}'`);
            }
            return this.vb(extensionId, v.visualization);
        }
        async $executeDebugVisualizerCommand(id) {
            const visualizer = this.W.get(id);
            if (!visualizer) {
                throw new Error(`No debug visualizer found with id '${id}'`);
            }
            const command = visualizer.v.visualization;
            if (command && 'command' in command) {
                this.cb.executeCommand(command.command, ...(command.arguments || []));
            }
        }
        gb(context) {
            const session = this.w.get(context.sessionId);
            return session && {
                session: session.api,
                variable: context.variable,
                containerId: context.containerId,
                frameId: context.frameId,
                threadId: context.threadId,
            };
        }
        async $provideDebugVisualizers(extensionId, id, context, token) {
            const contextHydrated = this.gb(context);
            const key = this.ub(extensionId, id);
            const provider = this.P.get(key);
            if (!contextHydrated || !provider) {
                return []; // probably ended in the meantime
            }
            const visualizations = await provider.provideDebugVisualization(contextHydrated, token);
            if (!visualizations) {
                return [];
            }
            return visualizations.map(v => {
                const id = ++this.X;
                this.W.set(id, { v, provider, extensionId });
                const icon = v.iconPath ? this.wb(v.iconPath) : undefined;
                return {
                    id,
                    name: v.name,
                    iconClass: icon?.iconClass,
                    iconPath: icon?.iconPath,
                    visualization: this.vb(extensionId, v.visualization),
                };
            });
        }
        $disposeDebugVisualizers(ids) {
            for (const id of ids) {
                this.W.delete(id);
            }
        }
        registerDebugVisualizationProvider(manifest, id, provider) {
            if (!manifest.contributes?.debugVisualizers?.some(r => r.id === id)) {
                throw new Error(`Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${id})`);
            }
            const extensionId = extensions_1.$rn.toKey(manifest.identifier);
            const key = this.ub(extensionId, id);
            if (this.P.has(key)) {
                throw new Error(`A debug visualization provider with id '${id}' is already registered`);
            }
            this.P.set(key, provider);
            this.u.$registerDebugVisualizer(extensionId, id);
            return (0, lifecycle_1.$Sc)(() => {
                this.u.$unregisterDebugVisualizer(extensionId, id);
                this.P.delete(id);
            });
        }
        addBreakpoints(breakpoints0) {
            // filter only new breakpoints
            const breakpoints = breakpoints0.filter(bp => {
                const id = bp.id;
                if (!this.H.has(id)) {
                    this.H.set(id, bp);
                    return true;
                }
                return false;
            });
            // send notification for added breakpoints
            this.rb(breakpoints, [], []);
            // convert added breakpoints to DTOs
            const dtos = [];
            const map = new Map();
            for (const bp of breakpoints) {
                if (bp instanceof extHostTypes_1.$QO) {
                    let dto = map.get(bp.location.uri.toString());
                    if (!dto) {
                        dto = {
                            type: 'sourceMulti',
                            uri: bp.location.uri,
                            lines: []
                        };
                        map.set(bp.location.uri.toString(), dto);
                        dtos.push(dto);
                    }
                    dto.lines.push({
                        id: bp.id,
                        enabled: bp.enabled,
                        condition: bp.condition,
                        hitCondition: bp.hitCondition,
                        logMessage: bp.logMessage,
                        line: bp.location.range.start.line,
                        character: bp.location.range.start.character,
                        mode: bp.mode,
                    });
                }
                else if (bp instanceof extHostTypes_1.$RO) {
                    dtos.push({
                        type: 'function',
                        id: bp.id,
                        enabled: bp.enabled,
                        hitCondition: bp.hitCondition,
                        logMessage: bp.logMessage,
                        condition: bp.condition,
                        functionName: bp.functionName,
                        mode: bp.mode,
                    });
                }
            }
            // send DTOs to VS Code
            return this.u.$registerBreakpoints(dtos);
        }
        removeBreakpoints(breakpoints0) {
            // remove from array
            const breakpoints = breakpoints0.filter(b => this.H.delete(b.id));
            // send notification
            this.rb([], breakpoints, []);
            // unregister with VS Code
            const ids = breakpoints.filter(bp => bp instanceof extHostTypes_1.$QO).map(bp => bp.id);
            const fids = breakpoints.filter(bp => bp instanceof extHostTypes_1.$RO).map(bp => bp.id);
            const dids = breakpoints.filter(bp => bp instanceof extHostTypes_1.$SO).map(bp => bp.id);
            return this.u.$unregisterBreakpoints(ids, fids, dids);
        }
        startDebugging(folder, nameOrConfig, options) {
            const testRunMeta = options.testRun && this.db.getMetadataForRun(options.testRun);
            return this.u.$startDebugging(folder ? folder.uri : undefined, nameOrConfig, {
                parentSessionID: options.parentSession ? options.parentSession.id : undefined,
                lifecycleManagedByParent: options.lifecycleManagedByParent,
                repl: options.consoleMode === extHostTypes_1.DebugConsoleMode.MergeWithParent ? 'mergeWithParent' : 'separate',
                noDebug: options.noDebug,
                compact: options.compact,
                suppressSaveBeforeStart: options.suppressSaveBeforeStart,
                testRun: testRunMeta && {
                    runId: testRunMeta.runId,
                    taskId: testRunMeta.taskId,
                },
                // Check debugUI for back-compat, #147264
                suppressDebugStatusbar: options.suppressDebugStatusbar ?? options.debugUI?.simple,
                suppressDebugToolbar: options.suppressDebugToolbar ?? options.debugUI?.simple,
                suppressDebugView: options.suppressDebugView ?? options.debugUI?.simple,
            });
        }
        stopDebugging(session) {
            return this.u.$stopDebugging(session ? session.id : undefined);
        }
        registerDebugConfigurationProvider(type, provider, trigger) {
            if (!provider) {
                return new extHostTypes_1.$MN(() => { });
            }
            const handle = this.f++;
            this.g.push({ type, handle, provider });
            this.u.$registerDebugConfigurationProvider(type, trigger, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.resolveDebugConfigurationWithSubstitutedVariables, handle);
            return new extHostTypes_1.$MN(() => {
                this.g = this.g.filter(p => p.provider !== provider); // remove
                this.u.$unregisterDebugConfigurationProvider(handle);
            });
        }
        registerDebugAdapterDescriptorFactory(extension, type, factory) {
            if (!factory) {
                return new extHostTypes_1.$MN(() => { });
            }
            // a DebugAdapterDescriptorFactory can only be registered in the extension that contributes the debugger
            if (!this.nb(extension, type)) {
                throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`);
            }
            // make sure that only one factory for this type is registered
            if (this.kb(type)) {
                throw new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`);
            }
            const handle = this.h++;
            this.j.push({ type, handle, factory });
            this.u.$registerDebugAdapterDescriptorFactory(type, handle);
            return new extHostTypes_1.$MN(() => {
                this.j = this.j.filter(p => p.factory !== factory); // remove
                this.u.$unregisterDebugAdapterDescriptorFactory(handle);
            });
        }
        registerDebugAdapterTrackerFactory(type, factory) {
            if (!factory) {
                return new extHostTypes_1.$MN(() => { });
            }
            const handle = this.m++;
            this.n.push({ type, handle, factory });
            return new extHostTypes_1.$MN(() => {
                this.n = this.n.filter(p => p.factory !== factory); // remove
            });
        }
        // RPC methods (ExtHostDebugServiceShape)
        async $runInTerminal(args, sessionId) {
            return Promise.resolve(undefined);
        }
        async $substituteVariables(folderUri, config) {
            let ws;
            const folder = await this.tb(folderUri);
            if (folder) {
                ws = {
                    uri: folder.uri,
                    name: folder.name,
                    index: folder.index,
                    toResource: () => {
                        throw new Error('Not implemented');
                    }
                };
            }
            const variableResolver = await this.bb.getResolver();
            return variableResolver.resolveAnyAsync(ws, config);
        }
        hb(adapter, session) {
            if (adapter.type === 'implementation') {
                return new DirectDebugAdapter(adapter.implementation);
            }
            return undefined;
        }
        ib() {
            return undefined;
        }
        async $startDASession(debugAdapterHandle, sessionDto) {
            const mythis = this;
            const session = await this.sb(sessionDto);
            return this.pb(this.kb(session.type), session).then(daDescriptor => {
                if (!daDescriptor) {
                    throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}' (extension might have failed to activate)`);
                }
                const adapterDescriptor = this.jb(daDescriptor);
                const da = this.hb(adapterDescriptor, session);
                if (!da) {
                    throw new Error(`Couldn't create a debug adapter for type '${session.type}'.`);
                }
                const debugAdapter = da;
                this.M.set(debugAdapterHandle, debugAdapter);
                return this.ob(session).then(tracker => {
                    if (tracker) {
                        this.N.set(debugAdapterHandle, tracker);
                    }
                    debugAdapter.onMessage(async (message) => {
                        if (message.type === 'request' && message.command === 'handshake') {
                            const request = message;
                            const response = {
                                type: 'response',
                                seq: 0,
                                command: request.command,
                                request_seq: request.seq,
                                success: true
                            };
                            if (!this.U) {
                                this.U = this.ib();
                            }
                            try {
                                if (this.U) {
                                    const signature = await this.U.sign(request.arguments.value);
                                    response.body = {
                                        signature: signature
                                    };
                                    debugAdapter.sendResponse(response);
                                }
                                else {
                                    throw new Error('no signer');
                                }
                            }
                            catch (e) {
                                response.success = false;
                                response.message = e.message;
                                debugAdapter.sendResponse(response);
                            }
                        }
                        else {
                            if (tracker && tracker.onDidSendMessage) {
                                tracker.onDidSendMessage(message);
                            }
                            // DA -> VS Code
                            message = (0, debugUtils_1.$eI)(message, true);
                            mythis.u.$acceptDAMessage(debugAdapterHandle, message);
                        }
                    });
                    debugAdapter.onError(err => {
                        if (tracker && tracker.onError) {
                            tracker.onError(err);
                        }
                        this.u.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);
                    });
                    debugAdapter.onExit((code) => {
                        if (tracker && tracker.onExit) {
                            tracker.onExit(code ?? undefined, undefined);
                        }
                        this.u.$acceptDAExit(debugAdapterHandle, code ?? undefined, undefined);
                    });
                    if (tracker && tracker.onWillStartSession) {
                        tracker.onWillStartSession();
                    }
                    return debugAdapter.startSession();
                });
            });
        }
        $sendDAMessage(debugAdapterHandle, message) {
            // VS Code -> DA
            message = (0, debugUtils_1.$dI)(message, false);
            const tracker = this.N.get(debugAdapterHandle); // TODO@AW: same handle?
            if (tracker && tracker.onWillReceiveMessage) {
                tracker.onWillReceiveMessage(message);
            }
            const da = this.M.get(debugAdapterHandle);
            da?.sendMessage(message);
        }
        $stopDASession(debugAdapterHandle) {
            const tracker = this.N.get(debugAdapterHandle);
            this.N.delete(debugAdapterHandle);
            if (tracker && tracker.onWillStopSession) {
                tracker.onWillStopSession();
            }
            const da = this.M.get(debugAdapterHandle);
            this.M.delete(debugAdapterHandle);
            if (da) {
                return da.stopSession();
            }
            else {
                return Promise.resolve(void 0);
            }
        }
        $acceptBreakpointsDelta(delta) {
            const a = [];
            const r = [];
            const c = [];
            if (delta.added) {
                for (const bpd of delta.added) {
                    const id = bpd.id;
                    if (id && !this.H.has(id)) {
                        let bp;
                        if (bpd.type === 'function') {
                            bp = new extHostTypes_1.$RO(bpd.functionName, bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage, bpd.mode);
                        }
                        else if (bpd.type === 'data') {
                            bp = new extHostTypes_1.$SO(bpd.label, bpd.dataId, bpd.canPersist, bpd.enabled, bpd.hitCondition, bpd.condition, bpd.logMessage, bpd.mode);
                        }
                        else {
                            const uri = uri_1.URI.revive(bpd.uri);
                            bp = new extHostTypes_1.$QO(new extHostTypes_1.$1N(uri, new extHostTypes_1.$NN(bpd.line, bpd.character)), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage, bpd.mode);
                        }
                        (0, extHostTypes_1.$OO)(bp, id);
                        this.H.set(id, bp);
                        a.push(bp);
                    }
                }
            }
            if (delta.removed) {
                for (const id of delta.removed) {
                    const bp = this.H.get(id);
                    if (bp) {
                        this.H.delete(id);
                        r.push(bp);
                    }
                }
            }
            if (delta.changed) {
                for (const bpd of delta.changed) {
                    if (bpd.id) {
                        const bp = this.H.get(bpd.id);
                        if (bp) {
                            if (bp instanceof extHostTypes_1.$RO && bpd.type === 'function') {
                                const fbp = bp;
                                fbp.enabled = bpd.enabled;
                                fbp.condition = bpd.condition;
                                fbp.hitCondition = bpd.hitCondition;
                                fbp.logMessage = bpd.logMessage;
                                fbp.functionName = bpd.functionName;
                            }
                            else if (bp instanceof extHostTypes_1.$QO && bpd.type === 'source') {
                                const sbp = bp;
                                sbp.enabled = bpd.enabled;
                                sbp.condition = bpd.condition;
                                sbp.hitCondition = bpd.hitCondition;
                                sbp.logMessage = bpd.logMessage;
                                sbp.location = new extHostTypes_1.$1N(uri_1.URI.revive(bpd.uri), new extHostTypes_1.$NN(bpd.line, bpd.character));
                            }
                            c.push(bp);
                        }
                    }
                }
            }
            this.rb(a, r, c);
        }
        async $acceptStackFrameFocus(focusDto) {
            let focus;
            if (focusDto) {
                const session = await this.sb(focusDto.sessionId);
                if (focusDto.kind === 'thread') {
                    focus = new extHostTypes_1.$YO(session.api, focusDto.threadId);
                }
                else {
                    focus = new extHostTypes_1.$XO(session.api, focusDto.threadId, focusDto.frameId);
                }
            }
            this.J = focus;
            this.L.fire(this.J);
        }
        $provideDebugConfigurations(configProviderHandle, folderUri, token) {
            return (0, async_1.$xh)(async () => {
                const provider = this.mb(configProviderHandle);
                if (!provider) {
                    throw new Error('no DebugConfigurationProvider found');
                }
                if (!provider.provideDebugConfigurations) {
                    throw new Error('DebugConfigurationProvider has no method provideDebugConfigurations');
                }
                const folder = await this.tb(folderUri);
                return provider.provideDebugConfigurations(folder, token);
            }).then(debugConfigurations => {
                if (!debugConfigurations) {
                    throw new Error('nothing returned from DebugConfigurationProvider.provideDebugConfigurations');
                }
                return debugConfigurations;
            });
        }
        $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration, token) {
            return (0, async_1.$xh)(async () => {
                const provider = this.mb(configProviderHandle);
                if (!provider) {
                    throw new Error('no DebugConfigurationProvider found');
                }
                if (!provider.resolveDebugConfiguration) {
                    throw new Error('DebugConfigurationProvider has no method resolveDebugConfiguration');
                }
                const folder = await this.tb(folderUri);
                return provider.resolveDebugConfiguration(folder, debugConfiguration, token);
            });
        }
        $resolveDebugConfigurationWithSubstitutedVariables(configProviderHandle, folderUri, debugConfiguration, token) {
            return (0, async_1.$xh)(async () => {
                const provider = this.mb(configProviderHandle);
                if (!provider) {
                    throw new Error('no DebugConfigurationProvider found');
                }
                if (!provider.resolveDebugConfigurationWithSubstitutedVariables) {
                    throw new Error('DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables');
                }
                const folder = await this.tb(folderUri);
                return provider.resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfiguration, token);
            });
        }
        async $provideDebugAdapter(adapterFactoryHandle, sessionDto) {
            const adapterDescriptorFactory = this.lb(adapterFactoryHandle);
            if (!adapterDescriptorFactory) {
                return Promise.reject(new Error('no adapter descriptor factory found for handle'));
            }
            const session = await this.sb(sessionDto);
            return this.pb(adapterDescriptorFactory, session).then(adapterDescriptor => {
                if (!adapterDescriptor) {
                    throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}'`);
                }
                return this.jb(adapterDescriptor);
            });
        }
        async $acceptDebugSessionStarted(sessionDto) {
            const session = await this.sb(sessionDto);
            this.y.fire(session.api);
        }
        async $acceptDebugSessionTerminated(sessionDto) {
            const session = await this.sb(sessionDto);
            if (session) {
                this.z.fire(session.api);
                this.w.delete(session.id);
            }
        }
        async $acceptDebugSessionActiveChanged(sessionDto) {
            this.D = sessionDto ? await this.sb(sessionDto) : undefined;
            this.C.fire(this.D?.api);
        }
        async $acceptDebugSessionNameChanged(sessionDto, name) {
            const session = await this.sb(sessionDto);
            session?._acceptNameChanged(name);
        }
        async $acceptDebugSessionCustomEvent(sessionDto, event) {
            const session = await this.sb(sessionDto);
            const ee = {
                session: session.api,
                event: event.event,
                body: event.body
            };
            this.F.fire(ee);
        }
        // private & dto helpers
        jb(x) {
            if (x instanceof extHostTypes_1.$TO) {
                return {
                    type: 'executable',
                    command: x.command,
                    args: x.args,
                    options: x.options
                };
            }
            else if (x instanceof extHostTypes_1.$UO) {
                return {
                    type: 'server',
                    port: x.port,
                    host: x.host
                };
            }
            else if (x instanceof extHostTypes_1.$VO) {
                return {
                    type: 'pipeServer',
                    path: x.path
                };
            }
            else if (x instanceof extHostTypes_1.$WO) {
                return {
                    type: 'implementation',
                    implementation: x.implementation
                };
            }
            else {
                throw new Error('convertToDto unexpected type');
            }
        }
        kb(type) {
            const results = this.j.filter(p => p.type === type);
            if (results.length > 0) {
                return results[0].factory;
            }
            return undefined;
        }
        lb(handle) {
            const results = this.j.filter(p => p.handle === handle);
            if (results.length > 0) {
                return results[0].factory;
            }
            return undefined;
        }
        mb(handle) {
            const results = this.g.filter(p => p.handle === handle);
            if (results.length > 0) {
                return results[0].provider;
            }
            return undefined;
        }
        nb(ed, type) {
            if (ed.contributes) {
                const debuggers = ed.contributes['debuggers'];
                if (debuggers && debuggers.length > 0) {
                    for (const dbg of debuggers) {
                        // only debugger contributions with a "label" are considered a "defining" debugger contribution
                        if (dbg.label && dbg.type) {
                            if (dbg.type === type) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        ob(session) {
            const config = session.configuration;
            const type = config.type;
            const promises = this.n
                .filter(tuple => tuple.type === type || tuple.type === '*')
                .map(tuple => (0, async_1.$xh)(() => tuple.factory.createDebugAdapterTracker(session.api)).then(p => p, err => null));
            return Promise.race([
                Promise.all(promises).then(result => {
                    const trackers = (0, arrays_1.$Gb)(result); // filter null
                    if (trackers.length > 0) {
                        return new MultiTracker(trackers);
                    }
                    return undefined;
                }),
                new Promise(resolve => setTimeout(() => resolve(undefined), 1000)),
            ]).catch(err => {
                // ignore errors
                return undefined;
            });
        }
        async pb(adapterDescriptorFactory, session) {
            // a "debugServer" attribute in the launch config takes precedence
            const serverPort = session.configuration.debugServer;
            if (typeof serverPort === 'number') {
                return Promise.resolve(new extHostTypes_1.$UO(serverPort));
            }
            if (adapterDescriptorFactory) {
                const extensionRegistry = await this.Z.getExtensionRegistry();
                return (0, async_1.$xh)(() => adapterDescriptorFactory.createDebugAdapterDescriptor(session.api, this.qb(session, extensionRegistry))).then(daDescriptor => {
                    if (daDescriptor) {
                        return daDescriptor;
                    }
                    return undefined;
                });
            }
            // fallback: use executable information from package.json
            const extensionRegistry = await this.Z.getExtensionRegistry();
            return Promise.resolve(this.qb(session, extensionRegistry));
        }
        qb(session, extensionRegistry) {
            return undefined;
        }
        rb(added, removed, changed) {
            if (added.length > 0 || removed.length > 0 || changed.length > 0) {
                this.I.fire(Object.freeze({
                    added,
                    removed,
                    changed,
                }));
            }
        }
        async sb(dto) {
            if (dto) {
                if (typeof dto === 'string') {
                    const ds = this.w.get(dto);
                    if (ds) {
                        return ds;
                    }
                }
                else {
                    let ds = this.w.get(dto.id);
                    if (!ds) {
                        const folder = await this.tb(dto.folderUri);
                        const parent = dto.parent ? this.w.get(dto.parent) : undefined;
                        ds = new $Dqc(this.u, dto.id, dto.type, dto.name, folder, dto.configuration, parent?.api);
                        this.w.set(ds.id, ds);
                        this.u.$sessionCached(ds.id);
                    }
                    return ds;
                }
            }
            throw new Error('cannot find session');
        }
        tb(_folderUri) {
            if (_folderUri) {
                const folderURI = uri_1.URI.revive(_folderUri);
                return this.Y.resolveWorkspaceFolder(folderURI);
            }
            return Promise.resolve(undefined);
        }
        ub(extensionId, id) {
            return `${extensionId}\0${id}`;
        }
        vb(extensionId, viz) {
            if (!viz) {
                return undefined;
            }
            if ('title' in viz && 'command' in viz) {
                return { type: debug_1.DebugVisualizationType.Command };
            }
            if ('treeId' in viz) {
                return { type: debug_1.DebugVisualizationType.Tree, id: `${extensionId}\0${viz.treeId}` };
            }
            throw new Error('Unsupported debug visualization type');
        }
        wb(icon) {
            const iconPathOrIconClass = this.xb(icon);
            let iconPath;
            let iconClass;
            if ('id' in iconPathOrIconClass) {
                iconClass = themables_1.ThemeIcon.asClassName(iconPathOrIconClass);
            }
            else {
                iconPath = iconPathOrIconClass;
            }
            return {
                iconPath,
                iconClass
            };
        }
        xb(iconPath) {
            if (iconPath instanceof extHostTypes_1.$LO) {
                return { id: iconPath.id };
            }
            const dark = typeof iconPath === 'object' && 'dark' in iconPath ? iconPath.dark : iconPath;
            const light = typeof iconPath === 'object' && 'light' in iconPath ? iconPath.light : iconPath;
            return {
                dark: (typeof dark === 'string' ? uri_1.URI.file(dark) : dark),
                light: (typeof light === 'string' ? uri_1.URI.file(light) : light),
            };
        }
    };
    exports.$Cqc = $Cqc;
    exports.$Cqc = $Cqc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostWorkspace_1.$Npc),
        __param(2, extHostExtensionService_1.$rqc),
        __param(3, extHostConfiguration_1.$Qpc),
        __param(4, extHostEditorTabs_1.$3pc),
        __param(5, extHostVariableResolverService_1.$uqc),
        __param(6, extHostCommands_1.$GQ),
        __param(7, extHostTesting_1.$wqc)
    ], $Cqc);
    class $Dqc {
        constructor(f, g, h, j, k, l, m) {
            this.f = f;
            this.g = g;
            this.h = h;
            this.j = j;
            this.k = k;
            this.l = l;
            this.m = m;
        }
        get api() {
            const that = this;
            return this.d ??= Object.freeze({
                id: that.g,
                type: that.h,
                get name() {
                    return that.j;
                },
                set name(name) {
                    that.j = name;
                    that.f.$setDebugSessionName(that.g, name);
                },
                parentSession: that.m,
                workspaceFolder: that.k,
                configuration: that.l,
                customRequest(command, args) {
                    return that.f.$customDebugAdapterRequest(that.g, command, args);
                },
                getDebugProtocolBreakpoint(breakpoint) {
                    return that.f.$getDebugProtocolBreakpoint(that.g, breakpoint.id);
                }
            });
        }
        get id() {
            return this.g;
        }
        get type() {
            return this.h;
        }
        _acceptNameChanged(name) {
            this.j = name;
        }
        get configuration() {
            return this.l;
        }
    }
    exports.$Dqc = $Dqc;
    class $Eqc {
        constructor(proxy) {
            this.value = Object.freeze({
                append(value) {
                    proxy.$appendDebugConsole(value);
                },
                appendLine(value) {
                    this.append(value + '\n');
                }
            });
        }
    }
    exports.$Eqc = $Eqc;
    class MultiTracker {
        constructor(d) {
            this.d = d;
        }
        onWillStartSession() {
            this.d.forEach(t => t.onWillStartSession ? t.onWillStartSession() : undefined);
        }
        onWillReceiveMessage(message) {
            this.d.forEach(t => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : undefined);
        }
        onDidSendMessage(message) {
            this.d.forEach(t => t.onDidSendMessage ? t.onDidSendMessage(message) : undefined);
        }
        onWillStopSession() {
            this.d.forEach(t => t.onWillStopSession ? t.onWillStopSession() : undefined);
        }
        onError(error) {
            this.d.forEach(t => t.onError ? t.onError(error) : undefined);
        }
        onExit(code, signal) {
            this.d.forEach(t => t.onExit ? t.onExit(code, signal) : undefined);
        }
    }
    /*
     * Call directly into a debug adapter implementation
     */
    class DirectDebugAdapter extends abstractDebugAdapter_1.$7tb {
        constructor(h) {
            super();
            this.h = h;
            h.onDidSendMessage((message) => {
                this.acceptMessage(message);
            });
        }
        startSession() {
            return Promise.resolve(undefined);
        }
        sendMessage(message) {
            this.h.handleMessage(message);
        }
        stopSession() {
            this.h.dispose();
            return Promise.resolve(undefined);
        }
    }
    let $Fqc = class $Fqc extends $Cqc {
        constructor(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver, commands, testing) {
            super(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver, commands, testing);
        }
    };
    exports.$Fqc = $Fqc;
    exports.$Fqc = $Fqc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostWorkspace_1.$Npc),
        __param(2, extHostExtensionService_1.$rqc),
        __param(3, extHostConfiguration_1.$Qpc),
        __param(4, extHostEditorTabs_1.$3pc),
        __param(5, extHostVariableResolverService_1.$uqc),
        __param(6, extHostCommands_1.$GQ),
        __param(7, extHostTesting_1.$wqc)
    ], $Fqc);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[274/*vs/workbench/api/common/extensionHostMain*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/errors*/,64/*vs/base/common/performance*/,2/*vs/base/common/uri*/,5/*vs/workbench/api/common/extHost.protocol*/,224/*vs/workbench/services/extensions/common/rpcProtocol*/,11/*vs/platform/log/common/log*/,60/*vs/platform/instantiation/common/extensions*/,74/*vs/platform/instantiation/common/serviceCollection*/,26/*vs/workbench/api/common/extHostInitDataService*/,170/*vs/platform/instantiation/common/instantiationService*/,16/*vs/workbench/api/common/extHostRpcService*/,65/*vs/workbench/api/common/extHostUriTransformerService*/,47/*vs/workbench/api/common/extHostExtensionService*/,66/*vs/workbench/api/common/extHostTelemetry*/]), function (require, exports, errors, performance, uri_1, extHost_protocol_1, rpcProtocol_1, log_1, extensions_1, serviceCollection_1, extHostInitDataService_1, instantiationService_1, extHostRpcService_1, extHostUriTransformerService_1, extHostExtensionService_1, extHostTelemetry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Grc = exports.$Frc = void 0;
    errors = __importStar(errors);
    performance = __importStar(performance);
    class $Frc {
        static async installEarlyHandler(accessor) {
            // increase number of stack frames (from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)
            Error.stackTraceLimit = 100;
            // does NOT dependent of extension information, can be installed immediately, and simply forwards
            // to the log service and main thread errors
            const logService = accessor.get(log_1.$ak);
            const rpcService = accessor.get(extHostRpcService_1.$kQ);
            const mainThreadErrors = rpcService.getProxy(extHost_protocol_1.$KN.MainThreadErrors);
            errors.setUnexpectedErrorHandler(err => {
                logService.error(err);
                const data = errors.$1(err);
                mainThreadErrors.$onUnexpectedError(data);
            });
        }
        static async installFullHandler(accessor) {
            // uses extension knowledges to correlate errors with extensions
            const logService = accessor.get(log_1.$ak);
            const rpcService = accessor.get(extHostRpcService_1.$kQ);
            const extensionService = accessor.get(extHostExtensionService_1.$rqc);
            const extensionTelemetry = accessor.get(extHostTelemetry_1.$EQ);
            const mainThreadExtensions = rpcService.getProxy(extHost_protocol_1.$KN.MainThreadExtensionService);
            const mainThreadErrors = rpcService.getProxy(extHost_protocol_1.$KN.MainThreadErrors);
            const map = await extensionService.getExtensionPathIndex();
            const extensionErrors = new WeakMap();
            // PART 1
            // set the prepareStackTrace-handle and use it as a side-effect to associate errors
            // with extensions - this works by looking up callsites in the extension path index
            function prepareStackTraceAndFindExtension(error, stackTrace) {
                if (extensionErrors.has(error)) {
                    return extensionErrors.get(error).stack;
                }
                let stackTraceMessage = '';
                let extension;
                let fileName;
                for (const call of stackTrace) {
                    stackTraceMessage += `\n\tat ${call.toString()}`;
                    fileName = call.getFileName();
                    if (!extension && fileName) {
                        extension = map.findSubstr(uri_1.URI.file(fileName));
                    }
                }
                const result = `${error.name || 'Error'}: ${error.message || ''}${stackTraceMessage}`;
                extensionErrors.set(error, { extensionIdentifier: extension?.identifier, stack: result });
                return result;
            }
            const _wasWrapped = Symbol('prepareStackTrace wrapped');
            let _prepareStackTrace = prepareStackTraceAndFindExtension;
            Object.defineProperty(Error, 'prepareStackTrace', {
                configurable: false,
                get() {
                    return _prepareStackTrace;
                },
                set(v) {
                    if (v === prepareStackTraceAndFindExtension || !v || v[_wasWrapped]) {
                        _prepareStackTrace = v || prepareStackTraceAndFindExtension;
                        return;
                    }
                    _prepareStackTrace = function (error, stackTrace) {
                        prepareStackTraceAndFindExtension(error, stackTrace);
                        return v.call(Error, error, stackTrace);
                    };
                    Object.assign(_prepareStackTrace, { [_wasWrapped]: true });
                },
            });
            // PART 2
            // set the unexpectedErrorHandler and check for extensions that have been identified as
            // having caused the error. Note that the runtime order is actually reversed, the code
            // below accesses the stack-property which triggers the code above
            errors.setUnexpectedErrorHandler(err => {
                logService.error(err);
                const errorData = errors.$1(err);
                const stackData = extensionErrors.get(err);
                if (!stackData?.extensionIdentifier) {
                    mainThreadErrors.$onUnexpectedError(errorData);
                    return;
                }
                mainThreadExtensions.$onExtensionRuntimeError(stackData.extensionIdentifier, errorData);
                const reported = extensionTelemetry.onExtensionError(stackData.extensionIdentifier, err);
                logService.trace('forwarded error to extension?', reported, stackData);
            });
        }
    }
    exports.$Frc = $Frc;
    class $Grc {
        constructor(protocol, initData, hostUtils, uriTransformer, messagePorts) {
            this.a = hostUtils;
            this.b = new rpcProtocol_1.$Udc(protocol, null, uriTransformer);
            // ensure URIs are transformed and revived
            initData = $Grc.e(initData, this.b);
            // bootstrap services
            const services = new serviceCollection_1.$Di(...(0, extensions_1.$Ss)());
            services.set(extHostInitDataService_1.$AQ, { _serviceBrand: undefined, ...initData, messagePorts });
            services.set(extHostRpcService_1.$kQ, new extHostRpcService_1.$lQ(this.b));
            services.set(extHostUriTransformerService_1.$Kpc, new extHostUriTransformerService_1.$Lpc(uriTransformer));
            services.set(extHostExtensionService_1.$pqc, hostUtils);
            const instaService = new instantiationService_1.$wr(services, true);
            instaService.invokeFunction($Frc.installEarlyHandler);
            // ugly self - inject
            this.d = instaService.invokeFunction(accessor => accessor.get(log_1.$ak));
            performance.mark(`code/extHost/didCreateServices`);
            if (this.a.pid) {
                this.d.info(`Extension host with pid ${this.a.pid} started`);
            }
            else {
                this.d.info(`Extension host started`);
            }
            this.d.trace('initData', initData);
            // ugly self - inject
            // must call initialize *after* creating the extension service
            // because `initialize` itself creates instances that depend on it
            this.c = instaService.invokeFunction(accessor => accessor.get(extHostExtensionService_1.$rqc));
            this.c.initialize();
            // install error handler that is extension-aware
            instaService.invokeFunction($Frc.installFullHandler);
        }
        async asBrowserUri(uri) {
            const mainThreadExtensionsProxy = this.b.getProxy(extHost_protocol_1.$KN.MainThreadExtensionService);
            return uri_1.URI.revive(await mainThreadExtensionsProxy.$asBrowserUri(uri));
        }
        terminate(reason) {
            this.c.terminate(reason);
        }
        static e(initData, rpcProtocol) {
            initData.extensions.allExtensions.forEach((ext) => {
                ext.extensionLocation = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(ext.extensionLocation));
            });
            initData.environment.appRoot = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.appRoot));
            const extDevLocs = initData.environment.extensionDevelopmentLocationURI;
            if (extDevLocs) {
                initData.environment.extensionDevelopmentLocationURI = extDevLocs.map(url => uri_1.URI.revive(rpcProtocol.transformIncomingURIs(url)));
            }
            initData.environment.extensionTestsLocationURI = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTestsLocationURI));
            initData.environment.globalStorageHome = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.globalStorageHome));
            initData.environment.workspaceStorageHome = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.workspaceStorageHome));
            initData.environment.extensionTelemetryLogResource = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.environment.extensionTelemetryLogResource));
            initData.nlsBaseUrl = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.nlsBaseUrl));
            initData.logsLocation = uri_1.URI.revive(rpcProtocol.transformIncomingURIs(initData.logsLocation));
            initData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);
            return initData;
        }
    }
    exports.$Grc = $Grc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[275/*vs/workbench/services/search/common/textSearchManager*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/arrays*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,42/*vs/base/common/errorMessage*/,15/*vs/base/common/network*/,19/*vs/base/common/path*/,23/*vs/base/common/resources*/,2/*vs/base/common/uri*/,44/*vs/workbench/services/search/common/search*/]), function (require, exports, arrays_1, async_1, cancellation_1, errorMessage_1, network_1, path, resources, uri_1, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Wqc = exports.$Uqc = exports.$Tqc = void 0;
    exports.$Vqc = $Vqc;
    path = __importStar(path);
    resources = __importStar(resources);
    class $Tqc {
        constructor(d, e, f) {
            this.d = d;
            this.e = e;
            this.f = f;
            this.a = null;
            this.b = false;
            this.c = 0;
        }
        get g() {
            return this.d.query;
        }
        search(onProgress, token) {
            const folderQueries = this.g.folderQueries || [];
            const tokenSource = new cancellation_1.$we(token);
            return new Promise((resolve, reject) => {
                this.a = new $Uqc(onProgress);
                let isCanceled = false;
                const onResult = (result, folderIdx) => {
                    if (isCanceled) {
                        return;
                    }
                    if (!this.b) {
                        const resultSize = this.h(result);
                        if ($Vqc(result) && typeof this.g.maxResults === 'number' && this.c + resultSize > this.g.maxResults) {
                            this.b = true;
                            isCanceled = true;
                            tokenSource.cancel();
                            result = this.j(result, this.g.maxResults - this.c);
                        }
                        const newResultSize = this.h(result);
                        this.c += newResultSize;
                        if (newResultSize > 0 || !$Vqc(result)) {
                            this.a.add(result, folderIdx);
                        }
                    }
                };
                // For each root folder
                Promise.all(folderQueries.map((fq, i) => {
                    return this.k(fq, r => onResult(r, i), tokenSource.token);
                })).then(results => {
                    tokenSource.dispose();
                    this.a.flush();
                    const someFolderHitLImit = results.some(result => !!result && !!result.limitHit);
                    resolve({
                        limitHit: this.b || someFolderHitLImit,
                        messages: results.flatMap(result => {
                            if (!result?.message) {
                                return [];
                            }
                            if (Array.isArray(result.message)) {
                                return result.message;
                            }
                            else {
                                return [result.message];
                            }
                        }),
                        stats: {
                            type: this.f
                        }
                    });
                }, (err) => {
                    tokenSource.dispose();
                    const errMsg = (0, errorMessage_1.$qj)(err);
                    reject(new Error(errMsg));
                });
            });
        }
        h(result) {
            if ($Vqc(result)) {
                return Array.isArray(result.ranges) ?
                    result.ranges.length :
                    1;
            }
            else {
                // #104400 context lines shoudn't count towards result count
                return 0;
            }
        }
        j(result, size) {
            const rangesArr = Array.isArray(result.ranges) ? result.ranges : [result.ranges];
            const matchesArr = Array.isArray(result.preview.matches) ? result.preview.matches : [result.preview.matches];
            return {
                ranges: rangesArr.slice(0, size),
                preview: {
                    matches: matchesArr.slice(0, size),
                    text: result.preview.text
                },
                uri: result.uri
            };
        }
        async k(folderQuery, onResult, token) {
            const queryTester = new search_1.$oM(this.g, folderQuery);
            const testingPs = [];
            const progress = {
                report: (result) => {
                    if (!this.l(result)) {
                        return;
                    }
                    const hasSibling = folderQuery.folder.scheme === network_1.Schemas.file ?
                        (0, search_1.$pM)(() => {
                            return this.e.readdir(resources.$fh(result.uri));
                        }) :
                        undefined;
                    const relativePath = resources.$ih(folderQuery.folder, result.uri);
                    if (relativePath) {
                        // This method is only async when the exclude contains sibling clauses
                        const included = queryTester.includedInQuery(relativePath, path.$nc(relativePath), hasSibling);
                        if ((0, async_1.$rh)(included)) {
                            testingPs.push(included.then(isIncluded => {
                                if (isIncluded) {
                                    onResult(result);
                                }
                            }));
                        }
                        else if (included) {
                            onResult(result);
                        }
                    }
                }
            };
            const searchOptions = this.n(folderQuery);
            let result;
            if (this.d.query.type === search_1.QueryType.aiText) {
                result = await this.d.provider.provideAITextSearchResults(this.d.query.contentPattern, searchOptions, progress, token);
            }
            else {
                result = await this.d.provider.provideTextSearchResults(patternInfoToQuery(this.d.query.contentPattern), searchOptions, progress, token);
            }
            if (testingPs.length) {
                await Promise.all(testingPs);
            }
            return result;
        }
        l(result) {
            if ($Vqc(result)) {
                if (Array.isArray(result.ranges)) {
                    if (!Array.isArray(result.preview.matches)) {
                        console.warn('INVALID - A text search provider match\'s`ranges` and`matches` properties must have the same type.');
                        return false;
                    }
                    if (result.preview.matches.length !== result.ranges.length) {
                        console.warn('INVALID - A text search provider match\'s`ranges` and`matches` properties must have the same length.');
                        return false;
                    }
                }
                else {
                    if (Array.isArray(result.preview.matches)) {
                        console.warn('INVALID - A text search provider match\'s`ranges` and`matches` properties must have the same length.');
                        return false;
                    }
                }
            }
            return true;
        }
        n(fq) {
            const includes = (0, search_1.$nM)(this.g.includePattern, fq.includePattern);
            const excludes = (0, search_1.$nM)(this.g.excludePattern, fq.excludePattern);
            const options = {
                folder: uri_1.URI.from(fq.folder),
                excludes,
                includes,
                useIgnoreFiles: !fq.disregardIgnoreFiles,
                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
                useParentIgnoreFiles: !fq.disregardParentIgnoreFiles,
                followSymlinks: !fq.ignoreSymlinks,
                encoding: fq.fileEncoding && this.e.toCanonicalName(fq.fileEncoding),
                maxFileSize: this.g.maxFileSize,
                maxResults: this.g.maxResults ?? search_1.$7L,
                previewOptions: this.g.previewOptions,
                afterContext: this.g.afterContext,
                beforeContext: this.g.beforeContext
            };
            if ('usePCRE2' in this.g) {
                options.usePCRE2 = this.g.usePCRE2;
            }
            return options;
        }
    }
    exports.$Tqc = $Tqc;
    function patternInfoToQuery(patternInfo) {
        return {
            isCaseSensitive: patternInfo.isCaseSensitive || false,
            isRegExp: patternInfo.isRegExp || false,
            isWordMatch: patternInfo.isWordMatch || false,
            isMultiline: patternInfo.isMultiline || false,
            pattern: patternInfo.pattern
        };
    }
    class $Uqc {
        constructor(e) {
            this.e = e;
            this.b = -1;
            this.d = null;
            this.a = new $Wqc(512, items => this.g(items));
        }
        add(data, folderIdx) {
            // Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.
            // This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search
            // providers that send results in random order. We could do this step afterwards instead.
            if (this.d && (this.b !== folderIdx || !resources.$_g(this.c, data.uri))) {
                this.f();
                this.d = null;
            }
            if (!this.d) {
                this.b = folderIdx;
                this.d = {
                    resource: data.uri,
                    results: []
                };
            }
            this.d.results.push(extensionResultToFrontendResult(data));
        }
        f() {
            const size = this.d && this.d.results ?
                this.d.results.length :
                0;
            this.a.addItem(this.d, size);
        }
        flush() {
            this.f();
            this.a.flush();
        }
        g(items) {
            this.e(items);
        }
    }
    exports.$Uqc = $Uqc;
    function extensionResultToFrontendResult(data) {
        // Warning: result from RipgrepTextSearchEH has fake Range. Don't depend on any other props beyond these...
        if ($Vqc(data)) {
            return {
                preview: {
                    matches: (0, arrays_1.$Zb)(data.preview.matches, m => ({
                        startLineNumber: m.start.line,
                        startColumn: m.start.character,
                        endLineNumber: m.end.line,
                        endColumn: m.end.character
                    })),
                    text: data.preview.text
                },
                ranges: (0, arrays_1.$Zb)(data.ranges, r => ({
                    startLineNumber: r.start.line,
                    startColumn: r.start.character,
                    endLineNumber: r.end.line,
                    endColumn: r.end.character
                }))
            };
        }
        else {
            return {
                text: data.text,
                lineNumber: data.lineNumber
            };
        }
    }
    function $Vqc(data) {
        return !!data.preview;
    }
    /**
     * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every
     * set of items collected.
     * But after that point, the callback is called with batches of maxBatchSize.
     * If the batch isn't filled within some time, the callback is also called.
     */
    class $Wqc {
        static { this.a = 4000; }
        // After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout
        static { this.b = 50; }
        constructor(g, h) {
            this.g = g;
            this.h = h;
            this.c = 0;
            this.d = [];
            this.e = 0;
        }
        addItem(item, size) {
            if (!item) {
                return;
            }
            this.j(item, size);
        }
        addItems(items, size) {
            if (!items) {
                return;
            }
            this.k(items, size);
        }
        j(item, size) {
            this.d.push(item);
            this.e += size;
            this.l();
        }
        k(item, size) {
            this.d = this.d.concat(item);
            this.e += size;
            this.l();
        }
        l() {
            if (this.c < $Wqc.b) {
                // Flush because we aren't batching yet
                this.flush();
            }
            else if (this.e >= this.g) {
                // Flush because the batch is full
                this.flush();
            }
            else if (!this.f) {
                // No timeout running, start a timeout to flush
                this.f = setTimeout(() => {
                    this.flush();
                }, $Wqc.a);
            }
        }
        flush() {
            if (this.e) {
                this.c += this.e;
                this.h(this.d);
                this.d = [];
                this.e = 0;
                if (this.f) {
                    clearTimeout(this.f);
                    this.f = 0;
                }
            }
        }
    }
    exports.$Wqc = $Wqc;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[134/*vs/workbench/api/common/extHostSearch*/], __M([1/*require*/,0/*exports*/,4/*vs/base/common/lifecycle*/,5/*vs/workbench/api/common/extHost.protocol*/,3/*vs/platform/instantiation/common/instantiation*/,270/*vs/workbench/services/search/common/fileSearchManager*/,16/*vs/workbench/api/common/extHostRpcService*/,65/*vs/workbench/api/common/extHostUriTransformerService*/,11/*vs/platform/log/common/log*/,2/*vs/base/common/uri*/,275/*vs/workbench/services/search/common/textSearchManager*/]), function (require, exports, lifecycle_1, extHost_protocol_1, instantiation_1, fileSearchManager_1, extHostRpcService_1, extHostUriTransformerService_1, log_1, uri_1, textSearchManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Yqc = exports.$Xqc = void 0;
    exports.$Zqc = $Zqc;
    exports.$Xqc = (0, instantiation_1.$Fi)('IExtHostSearch');
    let $Yqc = class $Yqc {
        constructor(n, o, q) {
            this.n = n;
            this.o = o;
            this.q = q;
            this.c = this.n.getProxy(extHost_protocol_1.$KN.MainThreadSearch);
            this.d = 0;
            this.e = new Map();
            this.g = new Set();
            this.h = new Map();
            this.i = new Set();
            this.j = new Map();
            this.k = new Set();
            this.l = new fileSearchManager_1.$Sqc();
        }
        s(scheme) {
            return this.o.transformOutgoingScheme(scheme);
        }
        registerTextSearchProvider(scheme, provider) {
            if (this.g.has(scheme)) {
                throw new Error(`a text search provider for the scheme '${scheme}' is already registered`);
            }
            this.g.add(scheme);
            const handle = this.d++;
            this.e.set(handle, provider);
            this.c.$registerTextSearchProvider(handle, this.s(scheme));
            return (0, lifecycle_1.$Sc)(() => {
                this.g.delete(scheme);
                this.e.delete(handle);
                this.c.$unregisterProvider(handle);
            });
        }
        registerAITextSearchProvider(scheme, provider) {
            if (this.i.has(scheme)) {
                throw new Error(`an AI text search provider for the scheme '${scheme}'is already registered`);
            }
            this.i.add(scheme);
            const handle = this.d++;
            this.h.set(handle, provider);
            this.c.$registerAITextSearchProvider(handle, this.s(scheme));
            return (0, lifecycle_1.$Sc)(() => {
                this.i.delete(scheme);
                this.h.delete(handle);
                this.c.$unregisterProvider(handle);
            });
        }
        registerFileSearchProvider(scheme, provider) {
            if (this.k.has(scheme)) {
                throw new Error(`a file search provider for the scheme '${scheme}' is already registered`);
            }
            this.k.add(scheme);
            const handle = this.d++;
            this.j.set(handle, provider);
            this.c.$registerFileSearchProvider(handle, this.s(scheme));
            return (0, lifecycle_1.$Sc)(() => {
                this.k.delete(scheme);
                this.j.delete(handle);
                this.c.$unregisterProvider(handle);
            });
        }
        $provideFileSearchResults(handle, session, rawQuery, token) {
            const query = $Zqc(rawQuery);
            const provider = this.j.get(handle);
            if (provider) {
                return this.l.fileSearch(query, provider, batch => {
                    this.c.$handleFileMatch(handle, session, batch.map(p => p.resource));
                }, token);
            }
            else {
                throw new Error('3 unknown provider: ' + handle);
            }
        }
        async doInternalFileSearchWithCustomCallback(query, token, handleFileMatch) {
            return { messages: [] };
        }
        $clearCache(cacheKey) {
            this.l.clearCache(cacheKey);
            return Promise.resolve(undefined);
        }
        $provideTextSearchResults(handle, session, rawQuery, token) {
            const provider = this.e.get(handle);
            if (!provider || !provider.provideTextSearchResults) {
                throw new Error(`Unknown Text Search Provider ${handle}`);
            }
            const query = $Zqc(rawQuery);
            const engine = this.t(query, provider);
            return engine.search(progress => this.c.$handleTextMatch(handle, session, progress), token);
        }
        $provideAITextSearchResults(handle, session, rawQuery, token) {
            const provider = this.h.get(handle);
            if (!provider || !provider.provideAITextSearchResults) {
                throw new Error(`Unknown AI Text Search Provider ${handle}`);
            }
            const query = $Zqc(rawQuery);
            const engine = this.v(query, provider);
            return engine.search(progress => this.c.$handleTextMatch(handle, session, progress), token);
        }
        $enableExtensionHostSearch() { }
        t(query, provider) {
            return new textSearchManager_1.$Tqc({ query, provider }, {
                readdir: resource => Promise.resolve([]),
                toCanonicalName: encoding => encoding
            }, 'textSearchProvider');
        }
        v(query, provider) {
            return new textSearchManager_1.$Tqc({ query, provider }, {
                readdir: resource => Promise.resolve([]),
                toCanonicalName: encoding => encoding
            }, 'aiTextSearchProvider');
        }
    };
    exports.$Yqc = $Yqc;
    exports.$Yqc = $Yqc = __decorate([
        __param(0, extHostRpcService_1.$kQ),
        __param(1, extHostUriTransformerService_1.$Kpc),
        __param(2, log_1.$ak)
    ], $Yqc);
    function $Zqc(rawQuery) {
        return {
            ...rawQuery, // TODO@rob ???
            ...{
                folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),
                extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(components => uri_1.URI.revive(components))
            }
        };
    }
    function reviveFolderQuery(rawFolderQuery) {
        return {
            ...rawFolderQuery,
            folder: uri_1.URI.revive(rawFolderQuery.folder)
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
define(__m[276/*vs/workbench/api/common/extHost.api.impl*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/async*/,21/*vs/base/common/cancellation*/,13/*vs/base/common/errors*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,15/*vs/base/common/network*/,35/*vs/base/common/severity*/,2/*vs/base/common/uri*/,105/*vs/editor/common/config/editorOptions*/,157/*vs/editor/common/languageSelector*/,158/*vs/editor/common/languages/languageConfiguration*/,52/*vs/editor/common/model*/,18/*vs/platform/extensions/common/extensions*/,29/*vs/platform/files/common/files*/,11/*vs/platform/log/common/log*/,62/*vs/platform/remote/common/remoteHosts*/,63/*vs/platform/telemetry/common/telemetryUtils*/,185/*vs/platform/workspace/common/editSessions*/,5/*vs/workbench/api/common/extHost.protocol*/,227/*vs/workbench/api/common/extHostAiRelatedInformation*/,256/*vs/workbench/api/common/extHostApiCommands*/,84/*vs/workbench/api/common/extHostApiDeprecationService*/,90/*vs/workbench/api/common/extHostAuthentication*/,232/*vs/workbench/api/common/extHostBulkEdits*/,233/*vs/workbench/api/common/extHostChatAgents2*/,234/*vs/workbench/api/common/extHostChatVariables*/,211/*vs/workbench/api/common/extHostClipboard*/,201/*vs/workbench/api/common/extHostCodeInsets*/,33/*vs/workbench/api/common/extHostCommands*/,235/*vs/workbench/api/common/extHostComments*/,46/*vs/workbench/api/common/extHostConfiguration*/,236/*vs/workbench/api/common/extHostCustomEditors*/,133/*vs/workbench/api/common/extHostDebugService*/,122/*vs/workbench/api/common/extHostDecorations*/,237/*vs/workbench/api/common/extHostDiagnostics*/,213/*vs/workbench/api/common/extHostDialogs*/,228/*vs/workbench/api/common/extHostDocumentContentProviders*/,238/*vs/workbench/api/common/extHostDocumentSaveParticipant*/,239/*vs/workbench/api/common/extHostDocuments*/,57/*vs/workbench/api/common/extHostDocumentsAndEditors*/,70/*vs/workbench/api/common/extHostEditorTabs*/,214/*vs/workbench/api/common/extHostEmbedding*/,229/*vs/workbench/api/common/extHostEmbeddingVector*/,47/*vs/workbench/api/common/extHostExtensionService*/,241/*vs/workbench/api/common/extHostFileSystem*/,68/*vs/workbench/api/common/extHostFileSystemConsumer*/,242/*vs/workbench/api/common/extHostFileSystemEventService*/,50/*vs/workbench/api/common/extHostFileSystemInfo*/,26/*vs/workbench/api/common/extHostInitDataService*/,257/*vs/workbench/api/common/extHostInteractive*/,215/*vs/workbench/api/common/extHostLabelService*/,243/*vs/workbench/api/common/extHostLanguageFeatures*/,244/*vs/workbench/api/common/extHostLanguageModelTools*/,94/*vs/workbench/api/common/extHostLanguageModels*/,245/*vs/workbench/api/common/extHostLanguages*/,85/*vs/workbench/api/common/extHostLocalizationService*/,86/*vs/workbench/api/common/extHostManagedSockets*/,217/*vs/workbench/api/common/extHostMessageService*/,269/*vs/workbench/api/common/extHostNotebook*/,247/*vs/workbench/api/common/extHostNotebookDocumentSaveParticipant*/,190/*vs/workbench/api/common/extHostNotebookDocuments*/,248/*vs/workbench/api/common/extHostNotebookEditors*/,258/*vs/workbench/api/common/extHostNotebookKernels*/,249/*vs/workbench/api/common/extHostNotebookRenderers*/,128/*vs/workbench/api/common/extHostOutput*/,218/*vs/workbench/api/common/extHostProfileContentHandler*/,250/*vs/workbench/api/common/extHostProgress*/,251/*vs/workbench/api/common/extHostQuickDiff*/,252/*vs/workbench/api/common/extHostQuickOpen*/,16/*vs/workbench/api/common/extHostRpcService*/,253/*vs/workbench/api/common/extHostSCM*/,134/*vs/workbench/api/common/extHostSearch*/,87/*vs/workbench/api/common/extHostSecretState*/,254/*vs/workbench/api/common/extHostShare*/,219/*vs/workbench/api/common/extHostSpeech*/,255/*vs/workbench/api/common/extHostStatusBar*/,88/*vs/workbench/api/common/extHostStorage*/,91/*vs/workbench/api/common/extHostStoragePaths*/,131/*vs/workbench/api/common/extHostTask*/,66/*vs/workbench/api/common/extHostTelemetry*/,56/*vs/workbench/api/common/extHostTerminalService*/,126/*vs/workbench/api/common/extHostTerminalShellIntegration*/,95/*vs/workbench/api/common/extHostTesting*/,259/*vs/workbench/api/common/extHostTextEditors*/,230/*vs/workbench/api/common/extHostTheming*/,260/*vs/workbench/api/common/extHostTimeline*/,261/*vs/workbench/api/common/extHostTreeViews*/,92/*vs/workbench/api/common/extHostTunnelService*/,8/*vs/workbench/api/common/extHostTypeConverters*/,7/*vs/workbench/api/common/extHostTypes*/,220/*vs/workbench/api/common/extHostUriOpener*/,65/*vs/workbench/api/common/extHostUriTransformerService*/,221/*vs/workbench/api/common/extHostUrls*/,67/*vs/workbench/api/common/extHostWebview*/,262/*vs/workbench/api/common/extHostWebviewPanels*/,263/*vs/workbench/api/common/extHostWebviewView*/,121/*vs/workbench/api/common/extHostWindow*/,45/*vs/workbench/api/common/extHostWorkspace*/,80/*vs/workbench/contrib/debug/common/debug*/,83/*vs/workbench/services/extensions/common/extensionHostProtocol*/,24/*vs/workbench/services/extensions/common/extensions*/,130/*vs/workbench/services/search/common/searchExtTypes*/]), function (require, exports, async_1, cancellation_1, errors, event_1, lifecycle_1, network_1, severity_1, uri_1, editorOptions_1, languageSelector_1, languageConfiguration, model_1, extensions_1, files, log_1, remoteHosts_1, telemetryUtils_1, editSessions_1, extHost_protocol_1, extHostAiRelatedInformation_1, extHostApiCommands_1, extHostApiDeprecationService_1, extHostAuthentication_1, extHostBulkEdits_1, extHostChatAgents2_1, extHostChatVariables_1, extHostClipboard_1, extHostCodeInsets_1, extHostCommands_1, extHostComments_1, extHostConfiguration_1, extHostCustomEditors_1, extHostDebugService_1, extHostDecorations_1, extHostDiagnostics_1, extHostDialogs_1, extHostDocumentContentProviders_1, extHostDocumentSaveParticipant_1, extHostDocuments_1, extHostDocumentsAndEditors_1, extHostEditorTabs_1, extHostEmbedding_1, extHostEmbeddingVector_1, extHostExtensionService_1, extHostFileSystem_1, extHostFileSystemConsumer_1, extHostFileSystemEventService_1, extHostFileSystemInfo_1, extHostInitDataService_1, extHostInteractive_1, extHostLabelService_1, extHostLanguageFeatures_1, extHostLanguageModelTools_1, extHostLanguageModels_1, extHostLanguages_1, extHostLocalizationService_1, extHostManagedSockets_1, extHostMessageService_1, extHostNotebook_1, extHostNotebookDocumentSaveParticipant_1, extHostNotebookDocuments_1, extHostNotebookEditors_1, extHostNotebookKernels_1, extHostNotebookRenderers_1, extHostOutput_1, extHostProfileContentHandler_1, extHostProgress_1, extHostQuickDiff_1, extHostQuickOpen_1, extHostRpcService_1, extHostSCM_1, extHostSearch_1, extHostSecretState_1, extHostShare_1, extHostSpeech_1, extHostStatusBar_1, extHostStorage_1, extHostStoragePaths_1, extHostTask_1, extHostTelemetry_1, extHostTerminalService_1, extHostTerminalShellIntegration_1, extHostTesting_1, extHostTextEditors_1, extHostTheming_1, extHostTimeline_1, extHostTreeViews_1, extHostTunnelService_1, typeConverters, extHostTypes, extHostUriOpener_1, extHostUriTransformerService_1, extHostUrls_1, extHostWebview_1, extHostWebviewPanels_1, extHostWebviewView_1, extHostWindow_1, extHostWorkspace_1, debug_1, extensionHostProtocol_1, extensions_2, searchExtTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Arc = $Arc;
    errors = __importStar(errors);
    severity_1 = __importDefault(severity_1);
    languageConfiguration = __importStar(languageConfiguration);
    files = __importStar(files);
    typeConverters = __importStar(typeConverters);
    extHostTypes = __importStar(extHostTypes);
    /**
     * This method instantiates and returns the extension API surface
     */
    function $Arc(accessor) {
        // services
        const initData = accessor.get(extHostInitDataService_1.$AQ);
        const extHostFileSystemInfo = accessor.get(extHostFileSystemInfo_1.$vpc);
        const extHostConsumerFileSystem = accessor.get(extHostFileSystemConsumer_1.$Spc);
        const extensionService = accessor.get(extHostExtensionService_1.$rqc);
        const extHostWorkspace = accessor.get(extHostWorkspace_1.$Npc);
        const extHostTelemetry = accessor.get(extHostTelemetry_1.$EQ);
        const extHostConfiguration = accessor.get(extHostConfiguration_1.$Qpc);
        const uriTransformer = accessor.get(extHostUriTransformerService_1.$Kpc);
        const rpcProtocol = accessor.get(extHostRpcService_1.$kQ);
        const extHostStorage = accessor.get(extHostStorage_1.$_pc);
        const extensionStoragePaths = accessor.get(extHostStoragePaths_1.$Tpc);
        const extHostLoggerService = accessor.get(log_1.$bk);
        const extHostLogService = accessor.get(log_1.$ak);
        const extHostTunnelService = accessor.get(extHostTunnelService_1.$gGb);
        const extHostApiDeprecation = accessor.get(extHostApiDeprecationService_1.$rpc);
        const extHostWindow = accessor.get(extHostWindow_1.$zrc);
        const extHostSecretState = accessor.get(extHostSecretState_1.$jqc);
        const extHostEditorTabs = accessor.get(extHostEditorTabs_1.$3pc);
        const extHostManagedSockets = accessor.get(extHostManagedSockets_1.$nqc);
        const extHostAuthentication = accessor.get(extHostAuthentication_1.$Bpc);
        const extHostLanguageModels = accessor.get(extHostLanguageModels_1.$gqc);
        // register addressable instances
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostFileSystemInfo, extHostFileSystemInfo);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostLogLevelServiceShape, extHostLoggerService);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostWorkspace, extHostWorkspace);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostConfiguration, extHostConfiguration);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostExtensionService, extensionService);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostStorage, extHostStorage);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTunnelService, extHostTunnelService);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostWindow, extHostWindow);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostSecretState, extHostSecretState);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTelemetry, extHostTelemetry);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostEditorTabs, extHostEditorTabs);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostManagedSockets, extHostManagedSockets);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostAuthentication, extHostAuthentication);
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostChatProvider, extHostLanguageModels);
        // automatically create and register addressable instances
        const extHostDecorations = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDecorations, accessor.get(extHostDecorations_1.$Hqc));
        const extHostDocumentsAndEditors = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDocumentsAndEditors, accessor.get(extHostDocumentsAndEditors_1.$vQ));
        const extHostCommands = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostCommands, accessor.get(extHostCommands_1.$GQ));
        const extHostTerminalService = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTerminalService, accessor.get(extHostTerminalService_1.$cqc));
        const extHostTerminalShellIntegration = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTerminalShellIntegration, accessor.get(extHostTerminalShellIntegration_1.$prc));
        const extHostDebugService = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDebugService, accessor.get(extHostDebugService_1.$Bqc));
        const extHostSearch = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostSearch, accessor.get(extHostSearch_1.$Xqc));
        const extHostTask = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTask, accessor.get(extHostTask_1.$orc));
        const extHostOutputService = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostOutputService, accessor.get(extHostOutput_1.$brc));
        const extHostLocalization = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostLocalization, accessor.get(extHostLocalizationService_1.$mqc));
        // manually create and register addressable instances
        const extHostUrls = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostUrls, new extHostUrls_1.$wrc(rpcProtocol));
        const extHostDocuments = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDocuments, new extHostDocuments_1.$ypc(rpcProtocol, extHostDocumentsAndEditors));
        const extHostDocumentContentProviders = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDocumentContentProviders, new extHostDocumentContentProviders_1.$Jqc(rpcProtocol, extHostDocumentsAndEditors, extHostLogService));
        const extHostDocumentSaveParticipant = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDocumentSaveParticipant, new extHostDocumentSaveParticipant_1.$Kqc(extHostLogService, extHostDocuments, rpcProtocol.getProxy(extHost_protocol_1.$KN.MainThreadBulkEdits)));
        const extHostNotebook = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostNotebook, new extHostNotebook_1.$1qc(rpcProtocol, extHostCommands, extHostDocumentsAndEditors, extHostDocuments, extHostConsumerFileSystem, extHostSearch, extHostLogService));
        const extHostNotebookDocuments = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostNotebookDocuments, new extHostNotebookDocuments_1.$8qc(extHostNotebook));
        const extHostNotebookEditors = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostNotebookEditors, new extHostNotebookEditors_1.$9qc(extHostLogService, extHostNotebook));
        const extHostNotebookKernels = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostNotebookKernels, new extHostNotebookKernels_1.$0qc(rpcProtocol, initData, extHostNotebook, extHostCommands, extHostLogService));
        const extHostNotebookRenderers = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostNotebookRenderers, new extHostNotebookRenderers_1.$_qc(rpcProtocol, extHostNotebook));
        const extHostNotebookDocumentSaveParticipant = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostNotebookDocumentSaveParticipant, new extHostNotebookDocumentSaveParticipant_1.$7qc(extHostLogService, extHostNotebook, rpcProtocol.getProxy(extHost_protocol_1.$KN.MainThreadBulkEdits)));
        const extHostEditors = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostEditors, new extHostTextEditors_1.$Hpc(rpcProtocol, extHostDocumentsAndEditors));
        const extHostTreeViews = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTreeViews, new extHostTreeViews_1.$urc(rpcProtocol.getProxy(extHost_protocol_1.$KN.MainThreadTreeViews), extHostCommands, extHostLogService));
        const extHostEditorInsets = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostEditorInsets, new extHostCodeInsets_1.$Ipc(rpcProtocol.getProxy(extHost_protocol_1.$KN.MainThreadEditorInsets), extHostEditors, initData.remote));
        const extHostDiagnostics = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostDiagnostics, new extHostDiagnostics_1.$xpc(rpcProtocol, extHostLogService, extHostFileSystemInfo, extHostDocumentsAndEditors));
        const extHostLanguages = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostLanguages, new extHostLanguages_1.$5qc(rpcProtocol, extHostDocuments, extHostCommands.converter, uriTransformer));
        const extHostLanguageFeatures = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostLanguageFeatures, new extHostLanguageFeatures_1.$zpc(rpcProtocol, uriTransformer, extHostDocuments, extHostCommands, extHostDiagnostics, extHostLogService, extHostApiDeprecation, extHostTelemetry));
        const extHostFileSystem = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostFileSystem, new extHostFileSystem_1.$Nqc(rpcProtocol, extHostLanguageFeatures));
        const extHostFileSystemEvent = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostFileSystemEventService, new extHostFileSystemEventService_1.$Oqc(rpcProtocol, extHostLogService, extHostDocumentsAndEditors));
        const extHostQuickOpen = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostQuickOpen, (0, extHostQuickOpen_1.$frc)(rpcProtocol, extHostWorkspace, extHostCommands));
        const extHostSCM = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostSCM, new extHostSCM_1.$hrc(rpcProtocol, extHostCommands, extHostDocuments, extHostLogService));
        const extHostQuickDiff = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostQuickDiff, new extHostQuickDiff_1.$erc(rpcProtocol, uriTransformer));
        const extHostShare = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostShare, new extHostShare_1.$irc(rpcProtocol, uriTransformer));
        const extHostComment = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostComments, (0, extHostComments_1.$Jpc)(rpcProtocol, extHostCommands, extHostDocuments));
        const extHostProgress = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostProgress, new extHostProgress_1.$drc(rpcProtocol.getProxy(extHost_protocol_1.$KN.MainThreadProgress)));
        const extHostLabelService = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostLabelService, new extHostLabelService_1.$3qc(rpcProtocol));
        const extHostTheming = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTheming, new extHostTheming_1.$rrc(rpcProtocol));
        const extHostTimeline = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTimeline, new extHostTimeline_1.$trc(rpcProtocol, extHostCommands));
        const extHostWebviews = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostWebviews, new extHostWebview_1.$Xpc(rpcProtocol, initData.remote, extHostWorkspace, extHostLogService, extHostApiDeprecation));
        const extHostWebviewPanels = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostWebviewPanels, new extHostWebviewPanels_1.$1pc(rpcProtocol, extHostWebviews, extHostWorkspace));
        const extHostCustomEditors = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostCustomEditors, new extHostCustomEditors_1.$2pc(rpcProtocol, extHostDocuments, extensionStoragePaths, extHostWebviews, extHostWebviewPanels));
        const extHostWebviewViews = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostWebviewViews, new extHostWebviewView_1.$xrc(rpcProtocol, extHostWebviews));
        const extHostTesting = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostTesting, accessor.get(extHostTesting_1.$wqc));
        const extHostUriOpeners = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostUriOpeners, new extHostUriOpener_1.$vrc(rpcProtocol));
        const extHostProfileContentHandlers = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostProfileContentHandlers, new extHostProfileContentHandler_1.$crc(rpcProtocol));
        rpcProtocol.set(extHost_protocol_1.$LN.ExtHostInteractive, new extHostInteractive_1.$2qc(rpcProtocol, extHostNotebook, extHostDocumentsAndEditors, extHostCommands, extHostLogService));
        const extHostChatAgents2 = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostChatAgents2, new extHostChatAgents2_1.$Epc(rpcProtocol, extHostLogService, extHostCommands, extHostDocuments));
        const extHostChatVariables = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostChatVariables, new extHostChatVariables_1.$Fpc(rpcProtocol));
        const extHostLanguageModelTools = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostLanguageModelTools, new extHostLanguageModelTools_1.$4qc(rpcProtocol));
        const extHostAiRelatedInformation = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostAiRelatedInformation, new extHostAiRelatedInformation_1.$qpc(rpcProtocol));
        const extHostAiEmbeddingVector = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostAiEmbeddingVector, new extHostEmbeddingVector_1.$Mqc(rpcProtocol));
        const extHostStatusBar = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostStatusBar, new extHostStatusBar_1.$lrc(rpcProtocol, extHostCommands.converter));
        const extHostSpeech = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostSpeech, new extHostSpeech_1.$jrc(rpcProtocol));
        const extHostEmbeddings = rpcProtocol.set(extHost_protocol_1.$LN.ExtHostEmbeddings, new extHostEmbedding_1.$Lqc(rpcProtocol));
        // Check that no named customers are missing
        const expected = Object.values(extHost_protocol_1.$LN);
        rpcProtocol.assertRegistered(expected);
        // Other instances
        const extHostBulkEdits = new extHostBulkEdits_1.$Dpc(rpcProtocol, extHostDocumentsAndEditors);
        const extHostClipboard = new extHostClipboard_1.$Gpc(rpcProtocol);
        const extHostMessageService = new extHostMessageService_1.$6qc(rpcProtocol, extHostLogService);
        const extHostDialogs = new extHostDialogs_1.$Iqc(rpcProtocol);
        // Register API-ish commands
        extHostApiCommands_1.$Apc.register(extHostCommands);
        return function (extension, extensionInfo, configProvider) {
            // Wraps an event with error handling and telemetry so that we know what extension fails
            // handling events. This will prevent us from reporting this as "our" error-telemetry and
            // allows for better blaming
            function _asExtensionEvent(actual) {
                return (listener, thisArgs, disposables) => {
                    const handle = actual(e => {
                        try {
                            listener.call(thisArgs, e);
                        }
                        catch (err) {
                            errors.$Z(new Error(`[ExtensionListenerError] Extension '${extension.identifier.value}' FAILED to handle event: ${err.toString()}`, { cause: err }));
                            extHostTelemetry.onExtensionError(extension.identifier, err);
                        }
                    });
                    disposables?.push(handle);
                    return handle;
                };
            }
            // Check document selectors for being overly generic. Technically this isn't a problem but
            // in practice many extensions say they support `fooLang` but need fs-access to do so. Those
            // extension should specify then the `file`-scheme, e.g. `{ scheme: 'fooLang', language: 'fooLang' }`
            // We only inform once, it is not a warning because we just want to raise awareness and because
            // we cannot say if the extension is doing it right or wrong...
            const checkSelector = (function () {
                let done = !extension.isUnderDevelopment;
                function informOnce() {
                    if (!done) {
                        extHostLogService.info(`Extension '${extension.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`);
                        done = true;
                    }
                }
                return function perform(selector) {
                    if (Array.isArray(selector)) {
                        selector.forEach(perform);
                    }
                    else if (typeof selector === 'string') {
                        informOnce();
                    }
                    else {
                        const filter = selector; // TODO: microsoft/TypeScript#42768
                        if (typeof filter.scheme === 'undefined') {
                            informOnce();
                        }
                        if (typeof filter.exclusive === 'boolean') {
                            (0, extensions_2.$gH)(extension, 'documentFiltersExclusive');
                        }
                    }
                    return selector;
                };
            })();
            const authentication = {
                getSession(providerId, scopes, options) {
                    if (typeof options?.forceNewSession === 'object' && options.forceNewSession.learnMore) {
                        (0, extensions_2.$gH)(extension, 'authLearnMore');
                    }
                    if (options?.account) {
                        (0, extensions_2.$gH)(extension, 'authGetSessions');
                    }
                    return extHostAuthentication.getSession(extension, providerId, scopes, options);
                },
                getAccounts(providerId) {
                    (0, extensions_2.$gH)(extension, 'authGetSessions');
                    return extHostAuthentication.getAccounts(providerId);
                },
                // TODO: remove this after GHPR and Codespaces move off of it
                async hasSession(providerId, scopes) {
                    (0, extensions_2.$gH)(extension, 'authSession');
                    return !!(await extHostAuthentication.getSession(extension, providerId, scopes, { silent: true }));
                },
                get onDidChangeSessions() {
                    return _asExtensionEvent(extHostAuthentication.onDidChangeSessions);
                },
                registerAuthenticationProvider(id, label, provider, options) {
                    return extHostAuthentication.registerAuthenticationProvider(id, label, provider, options);
                }
            };
            // namespace: commands
            const commands = {
                registerCommand(id, command, thisArgs) {
                    return extHostCommands.registerCommand(true, id, command, thisArgs, undefined, extension);
                },
                registerTextEditorCommand(id, callback, thisArg) {
                    return extHostCommands.registerCommand(true, id, (...args) => {
                        const activeTextEditor = extHostEditors.getActiveTextEditor();
                        if (!activeTextEditor) {
                            extHostLogService.warn('Cannot execute ' + id + ' because there is no active text editor.');
                            return undefined;
                        }
                        return activeTextEditor.edit((edit) => {
                            callback.apply(thisArg, [activeTextEditor, edit, ...args]);
                        }).then((result) => {
                            if (!result) {
                                extHostLogService.warn('Edits from command ' + id + ' were not applied.');
                            }
                        }, (err) => {
                            extHostLogService.warn('An error occurred while running command ' + id, err);
                        });
                    }, undefined, undefined, extension);
                },
                registerDiffInformationCommand: (id, callback, thisArg) => {
                    (0, extensions_2.$gH)(extension, 'diffCommand');
                    return extHostCommands.registerCommand(true, id, async (...args) => {
                        const activeTextEditor = extHostDocumentsAndEditors.activeEditor(true);
                        if (!activeTextEditor) {
                            extHostLogService.warn('Cannot execute ' + id + ' because there is no active text editor.');
                            return undefined;
                        }
                        const diff = await extHostEditors.getDiffInformation(activeTextEditor.id);
                        callback.apply(thisArg, [diff, ...args]);
                    }, undefined, undefined, extension);
                },
                executeCommand(id, ...args) {
                    return extHostCommands.executeCommand(id, ...args);
                },
                getCommands(filterInternal = false) {
                    return extHostCommands.getCommands(filterInternal);
                }
            };
            // namespace: env
            const env = {
                get machineId() { return initData.telemetryInfo.machineId; },
                get sessionId() { return initData.telemetryInfo.sessionId; },
                get language() { return initData.environment.appLanguage; },
                get appName() { return initData.environment.appName; },
                get appRoot() { return initData.environment.appRoot?.fsPath ?? ''; },
                get appHost() { return initData.environment.appHost; },
                get uriScheme() { return initData.environment.appUriScheme; },
                get clipboard() { return extHostClipboard.value; },
                get shell() {
                    return extHostTerminalService.getDefaultShell(false);
                },
                get onDidChangeShell() {
                    return _asExtensionEvent(extHostTerminalService.onDidChangeShell);
                },
                get isTelemetryEnabled() {
                    return extHostTelemetry.getTelemetryConfiguration();
                },
                get onDidChangeTelemetryEnabled() {
                    return _asExtensionEvent(extHostTelemetry.onDidChangeTelemetryEnabled);
                },
                get telemetryConfiguration() {
                    (0, extensions_2.$gH)(extension, 'telemetry');
                    return extHostTelemetry.getTelemetryDetails();
                },
                get onDidChangeTelemetryConfiguration() {
                    (0, extensions_2.$gH)(extension, 'telemetry');
                    return _asExtensionEvent(extHostTelemetry.onDidChangeTelemetryConfiguration);
                },
                get isNewAppInstall() {
                    return (0, extHostTelemetry_1.$DQ)(initData.telemetryInfo.firstSessionDate);
                },
                createTelemetryLogger(sender, options) {
                    extHostTelemetry_1.$CQ.validateSender(sender);
                    return extHostTelemetry.instantiateLogger(extension, sender, options);
                },
                openExternal(uri, options) {
                    return extHostWindow.openUri(uri, {
                        allowTunneling: !!initData.remote.authority,
                        allowContributedOpeners: options?.allowContributedOpeners,
                    });
                },
                async asExternalUri(uri) {
                    if (uri.scheme === initData.environment.appUriScheme) {
                        return extHostUrls.createAppUri(uri);
                    }
                    try {
                        return await extHostWindow.asExternalUri(uri, { allowTunneling: !!initData.remote.authority });
                    }
                    catch (err) {
                        if ((0, network_1.$Og)(uri, network_1.Schemas.http) || (0, network_1.$Og)(uri, network_1.Schemas.https)) {
                            return uri;
                        }
                        throw err;
                    }
                },
                get remoteName() {
                    return (0, remoteHosts_1.$in)(initData.remote.authority);
                },
                get remoteAuthority() {
                    (0, extensions_2.$gH)(extension, 'resolvers');
                    return initData.remote.authority;
                },
                get uiKind() {
                    return initData.uiKind;
                },
                get logLevel() {
                    return extHostLogService.getLevel();
                },
                get onDidChangeLogLevel() {
                    return _asExtensionEvent(extHostLogService.onDidChangeLogLevel);
                },
                get appQuality() {
                    (0, extensions_2.$gH)(extension, 'resolvers');
                    return initData.quality;
                },
                get appCommit() {
                    (0, extensions_2.$gH)(extension, 'resolvers');
                    return initData.commit;
                },
            };
            if (!initData.environment.extensionTestsLocationURI) {
                // allow to patch env-function when running tests
                Object.freeze(env);
            }
            // namespace: tests
            const tests = {
                createTestController(provider, label, refreshHandler) {
                    return extHostTesting.createTestController(extension, provider, label, refreshHandler);
                },
                createTestObserver() {
                    (0, extensions_2.$gH)(extension, 'testObserver');
                    return extHostTesting.createTestObserver();
                },
                runTests(provider) {
                    (0, extensions_2.$gH)(extension, 'testObserver');
                    return extHostTesting.runTests(provider);
                },
                registerTestFollowupProvider(provider) {
                    (0, extensions_2.$gH)(extension, 'testObserver');
                    return extHostTesting.registerTestFollowupProvider(provider);
                },
                get onDidChangeTestResults() {
                    (0, extensions_2.$gH)(extension, 'testObserver');
                    return _asExtensionEvent(extHostTesting.onResultsChanged);
                },
                get testResults() {
                    (0, extensions_2.$gH)(extension, 'testObserver');
                    return extHostTesting.results;
                },
            };
            // namespace: extensions
            const extensionKind = initData.remote.isRemote
                ? extHostTypes.ExtensionKind.Workspace
                : extHostTypes.ExtensionKind.UI;
            const extensions = {
                getExtension(extensionId, includeFromDifferentExtensionHosts) {
                    if (!(0, extensions_2.$fH)(extension, 'extensionsAny')) {
                        includeFromDifferentExtensionHosts = false;
                    }
                    const mine = extensionInfo.mine.getExtensionDescription(extensionId);
                    if (mine) {
                        return new extHostExtensionService_1.$sqc(extensionService, extension.identifier, mine, extensionKind, false);
                    }
                    if (includeFromDifferentExtensionHosts) {
                        const foreign = extensionInfo.all.getExtensionDescription(extensionId);
                        if (foreign) {
                            return new extHostExtensionService_1.$sqc(extensionService, extension.identifier, foreign, extensionKind /* TODO@alexdima THIS IS WRONG */, true);
                        }
                    }
                    return undefined;
                },
                get all() {
                    const result = [];
                    for (const desc of extensionInfo.mine.getAllExtensionDescriptions()) {
                        result.push(new extHostExtensionService_1.$sqc(extensionService, extension.identifier, desc, extensionKind, false));
                    }
                    return result;
                },
                get allAcrossExtensionHosts() {
                    (0, extensions_2.$gH)(extension, 'extensionsAny');
                    const local = new extensions_1.$sn(extensionInfo.mine.getAllExtensionDescriptions().map(desc => desc.identifier));
                    const result = [];
                    for (const desc of extensionInfo.all.getAllExtensionDescriptions()) {
                        const isFromDifferentExtensionHost = !local.has(desc.identifier);
                        result.push(new extHostExtensionService_1.$sqc(extensionService, extension.identifier, desc, extensionKind /* TODO@alexdima THIS IS WRONG */, isFromDifferentExtensionHost));
                    }
                    return result;
                },
                get onDidChange() {
                    if ((0, extensions_2.$fH)(extension, 'extensionsAny')) {
                        return _asExtensionEvent(event_1.Event.any(extensionInfo.mine.onDidChange, extensionInfo.all.onDidChange));
                    }
                    return _asExtensionEvent(extensionInfo.mine.onDidChange);
                }
            };
            // namespace: languages
            const languages = {
                createDiagnosticCollection(name) {
                    return extHostDiagnostics.createDiagnosticCollection(extension.identifier, name);
                },
                get onDidChangeDiagnostics() {
                    return _asExtensionEvent(extHostDiagnostics.onDidChangeDiagnostics);
                },
                getDiagnostics: (resource) => {
                    return extHostDiagnostics.getDiagnostics(resource);
                },
                getLanguages() {
                    return extHostLanguages.getLanguages();
                },
                setTextDocumentLanguage(document, languageId) {
                    return extHostLanguages.changeLanguage(document.uri, languageId);
                },
                match(selector, document) {
                    const interalSelector = typeConverters.LanguageSelector.from(selector);
                    let notebook;
                    if ((0, languageSelector_1.$xu)(interalSelector)) {
                        notebook = extHostNotebook.notebookDocuments.find(value => value.apiNotebook.getCells().find(c => c.document === document))?.apiNotebook;
                    }
                    return (0, languageSelector_1.$wu)(interalSelector, document.uri, document.languageId, true, notebook?.uri, notebook?.notebookType);
                },
                registerCodeActionsProvider(selector, provider, metadata) {
                    return extHostLanguageFeatures.registerCodeActionProvider(extension, checkSelector(selector), provider, metadata);
                },
                registerDocumentPasteEditProvider(selector, provider, metadata) {
                    (0, extensions_2.$gH)(extension, 'documentPaste');
                    return extHostLanguageFeatures.registerDocumentPasteEditProvider(extension, checkSelector(selector), provider, metadata);
                },
                registerCodeLensProvider(selector, provider) {
                    return extHostLanguageFeatures.registerCodeLensProvider(extension, checkSelector(selector), provider);
                },
                registerDefinitionProvider(selector, provider) {
                    return extHostLanguageFeatures.registerDefinitionProvider(extension, checkSelector(selector), provider);
                },
                registerDeclarationProvider(selector, provider) {
                    return extHostLanguageFeatures.registerDeclarationProvider(extension, checkSelector(selector), provider);
                },
                registerImplementationProvider(selector, provider) {
                    return extHostLanguageFeatures.registerImplementationProvider(extension, checkSelector(selector), provider);
                },
                registerTypeDefinitionProvider(selector, provider) {
                    return extHostLanguageFeatures.registerTypeDefinitionProvider(extension, checkSelector(selector), provider);
                },
                registerHoverProvider(selector, provider) {
                    return extHostLanguageFeatures.registerHoverProvider(extension, checkSelector(selector), provider, extension.identifier);
                },
                registerEvaluatableExpressionProvider(selector, provider) {
                    return extHostLanguageFeatures.registerEvaluatableExpressionProvider(extension, checkSelector(selector), provider, extension.identifier);
                },
                registerInlineValuesProvider(selector, provider) {
                    return extHostLanguageFeatures.registerInlineValuesProvider(extension, checkSelector(selector), provider, extension.identifier);
                },
                registerDocumentHighlightProvider(selector, provider) {
                    return extHostLanguageFeatures.registerDocumentHighlightProvider(extension, checkSelector(selector), provider);
                },
                registerMultiDocumentHighlightProvider(selector, provider) {
                    return extHostLanguageFeatures.registerMultiDocumentHighlightProvider(extension, checkSelector(selector), provider);
                },
                registerLinkedEditingRangeProvider(selector, provider) {
                    return extHostLanguageFeatures.registerLinkedEditingRangeProvider(extension, checkSelector(selector), provider);
                },
                registerReferenceProvider(selector, provider) {
                    return extHostLanguageFeatures.registerReferenceProvider(extension, checkSelector(selector), provider);
                },
                registerRenameProvider(selector, provider) {
                    return extHostLanguageFeatures.registerRenameProvider(extension, checkSelector(selector), provider);
                },
                registerNewSymbolNamesProvider(selector, provider) {
                    (0, extensions_2.$gH)(extension, 'newSymbolNamesProvider');
                    return extHostLanguageFeatures.registerNewSymbolNamesProvider(extension, checkSelector(selector), provider);
                },
                registerDocumentSymbolProvider(selector, provider, metadata) {
                    return extHostLanguageFeatures.registerDocumentSymbolProvider(extension, checkSelector(selector), provider, metadata);
                },
                registerWorkspaceSymbolProvider(provider) {
                    return extHostLanguageFeatures.registerWorkspaceSymbolProvider(extension, provider);
                },
                registerDocumentFormattingEditProvider(selector, provider) {
                    return extHostLanguageFeatures.registerDocumentFormattingEditProvider(extension, checkSelector(selector), provider);
                },
                registerDocumentRangeFormattingEditProvider(selector, provider) {
                    return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(extension, checkSelector(selector), provider);
                },
                registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {
                    return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(extension, checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
                },
                registerDocumentSemanticTokensProvider(selector, provider, legend) {
                    return extHostLanguageFeatures.registerDocumentSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
                },
                registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
                    return extHostLanguageFeatures.registerDocumentRangeSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
                },
                registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
                    if (typeof firstItem === 'object') {
                        return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, firstItem);
                    }
                    return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, typeof firstItem === 'undefined' ? [] : [firstItem, ...remaining]);
                },
                registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
                    return extHostLanguageFeatures.registerCompletionItemProvider(extension, checkSelector(selector), provider, triggerCharacters);
                },
                registerInlineCompletionItemProvider(selector, provider, metadata) {
                    if (provider.handleDidShowCompletionItem) {
                        (0, extensions_2.$gH)(extension, 'inlineCompletionsAdditions');
                    }
                    if (provider.handleDidPartiallyAcceptCompletionItem) {
                        (0, extensions_2.$gH)(extension, 'inlineCompletionsAdditions');
                    }
                    if (metadata) {
                        (0, extensions_2.$gH)(extension, 'inlineCompletionsAdditions');
                    }
                    return extHostLanguageFeatures.registerInlineCompletionsProvider(extension, checkSelector(selector), provider, metadata);
                },
                registerInlineEditProvider(selector, provider) {
                    (0, extensions_2.$gH)(extension, 'inlineEdit');
                    return extHostLanguageFeatures.registerInlineEditProvider(extension, checkSelector(selector), provider);
                },
                registerDocumentLinkProvider(selector, provider) {
                    return extHostLanguageFeatures.registerDocumentLinkProvider(extension, checkSelector(selector), provider);
                },
                registerColorProvider(selector, provider) {
                    return extHostLanguageFeatures.registerColorProvider(extension, checkSelector(selector), provider);
                },
                registerFoldingRangeProvider(selector, provider) {
                    return extHostLanguageFeatures.registerFoldingRangeProvider(extension, checkSelector(selector), provider);
                },
                registerSelectionRangeProvider(selector, provider) {
                    return extHostLanguageFeatures.registerSelectionRangeProvider(extension, selector, provider);
                },
                registerCallHierarchyProvider(selector, provider) {
                    return extHostLanguageFeatures.registerCallHierarchyProvider(extension, selector, provider);
                },
                registerTypeHierarchyProvider(selector, provider) {
                    return extHostLanguageFeatures.registerTypeHierarchyProvider(extension, selector, provider);
                },
                setLanguageConfiguration: (language, configuration) => {
                    return extHostLanguageFeatures.setLanguageConfiguration(extension, language, configuration);
                },
                getTokenInformationAtPosition(doc, pos) {
                    (0, extensions_2.$gH)(extension, 'tokenInformation');
                    return extHostLanguages.tokenAtPosition(doc, pos);
                },
                registerInlayHintsProvider(selector, provider) {
                    return extHostLanguageFeatures.registerInlayHintsProvider(extension, selector, provider);
                },
                createLanguageStatusItem(id, selector) {
                    return extHostLanguages.createLanguageStatusItem(extension, id, selector);
                },
                registerDocumentDropEditProvider(selector, provider, metadata) {
                    return extHostLanguageFeatures.registerDocumentOnDropEditProvider(extension, selector, provider, (0, extensions_2.$fH)(extension, 'documentPaste') ? metadata : undefined);
                }
            };
            // namespace: window
            const window = {
                get activeTextEditor() {
                    return extHostEditors.getActiveTextEditor();
                },
                get visibleTextEditors() {
                    return extHostEditors.getVisibleTextEditors();
                },
                get activeTerminal() {
                    return extHostTerminalService.activeTerminal;
                },
                get terminals() {
                    return extHostTerminalService.terminals;
                },
                async showTextDocument(documentOrUri, columnOrOptions, preserveFocus) {
                    if (uri_1.URI.isUri(documentOrUri) && documentOrUri.scheme === network_1.Schemas.vscodeRemote && !documentOrUri.authority) {
                        extHostApiDeprecation.report('workspace.showTextDocument', extension, `A URI of 'vscode-remote' scheme requires an authority.`);
                    }
                    const document = await (uri_1.URI.isUri(documentOrUri)
                        ? Promise.resolve(workspace.openTextDocument(documentOrUri))
                        : Promise.resolve(documentOrUri));
                    return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);
                },
                createTextEditorDecorationType(options) {
                    return extHostEditors.createTextEditorDecorationType(extension, options);
                },
                onDidChangeActiveTextEditor(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostEditors.onDidChangeActiveTextEditor)(listener, thisArg, disposables);
                },
                onDidChangeVisibleTextEditors(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostEditors.onDidChangeVisibleTextEditors)(listener, thisArg, disposables);
                },
                onDidChangeTextEditorSelection(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostEditors.onDidChangeTextEditorSelection)(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorOptions(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostEditors.onDidChangeTextEditorOptions)(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostEditors.onDidChangeTextEditorVisibleRanges)(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostEditors.onDidChangeTextEditorViewColumn)(listener, thisArg, disposables);
                },
                onDidCloseTerminal(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostTerminalService.onDidCloseTerminal)(listener, thisArg, disposables);
                },
                onDidOpenTerminal(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostTerminalService.onDidOpenTerminal)(listener, thisArg, disposables);
                },
                onDidChangeActiveTerminal(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostTerminalService.onDidChangeActiveTerminal)(listener, thisArg, disposables);
                },
                onDidChangeTerminalDimensions(listener, thisArg, disposables) {
                    (0, extensions_2.$gH)(extension, 'terminalDimensions');
                    return _asExtensionEvent(extHostTerminalService.onDidChangeTerminalDimensions)(listener, thisArg, disposables);
                },
                onDidChangeTerminalState(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostTerminalService.onDidChangeTerminalState)(listener, thisArg, disposables);
                },
                onDidWriteTerminalData(listener, thisArg, disposables) {
                    (0, extensions_2.$gH)(extension, 'terminalDataWriteEvent');
                    return _asExtensionEvent(extHostTerminalService.onDidWriteTerminalData)(listener, thisArg, disposables);
                },
                onDidExecuteTerminalCommand(listener, thisArg, disposables) {
                    (0, extensions_2.$gH)(extension, 'terminalExecuteCommandEvent');
                    return _asExtensionEvent(extHostTerminalService.onDidExecuteTerminalCommand)(listener, thisArg, disposables);
                },
                onDidChangeTerminalShellIntegration(listener, thisArg, disposables) {
                    (0, extensions_2.$gH)(extension, 'terminalShellIntegration');
                    return _asExtensionEvent(extHostTerminalShellIntegration.onDidChangeTerminalShellIntegration)(listener, thisArg, disposables);
                },
                onDidStartTerminalShellExecution(listener, thisArg, disposables) {
                    (0, extensions_2.$gH)(extension, 'terminalShellIntegration');
                    return _asExtensionEvent(extHostTerminalShellIntegration.onDidStartTerminalShellExecution)(listener, thisArg, disposables);
                },
                onDidEndTerminalShellExecution(listener, thisArg, disposables) {
                    (0, extensions_2.$gH)(extension, 'terminalShellIntegration');
                    return _asExtensionEvent(extHostTerminalShellIntegration.onDidEndTerminalShellExecution)(listener, thisArg, disposables);
                },
                get state() {
                    return extHostWindow.getState();
                },
                onDidChangeWindowState(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostWindow.onDidChangeWindowState)(listener, thisArg, disposables);
                },
                showInformationMessage(message, ...rest) {
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, message, rest[0], rest.slice(1));
                },
                showWarningMessage(message, ...rest) {
                    return extHostMessageService.showMessage(extension, severity_1.default.Warning, message, rest[0], rest.slice(1));
                },
                showErrorMessage(message, ...rest) {
                    return extHostMessageService.showMessage(extension, severity_1.default.Error, message, rest[0], rest.slice(1));
                },
                showQuickPick(items, options, token) {
                    return extHostQuickOpen.showQuickPick(extension, items, options, token);
                },
                showWorkspaceFolderPick(options) {
                    return extHostQuickOpen.showWorkspaceFolderPick(options);
                },
                showInputBox(options, token) {
                    return extHostQuickOpen.showInput(options, token);
                },
                showOpenDialog(options) {
                    return extHostDialogs.showOpenDialog(extension, options);
                },
                showSaveDialog(options) {
                    return extHostDialogs.showSaveDialog(options);
                },
                createStatusBarItem(alignmentOrId, priorityOrAlignment, priorityArg) {
                    let id;
                    let alignment;
                    let priority;
                    if (typeof alignmentOrId === 'string') {
                        id = alignmentOrId;
                        alignment = priorityOrAlignment;
                        priority = priorityArg;
                    }
                    else {
                        alignment = alignmentOrId;
                        priority = priorityOrAlignment;
                    }
                    return extHostStatusBar.createStatusBarEntry(extension, id, alignment, priority);
                },
                setStatusBarMessage(text, timeoutOrThenable) {
                    return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
                },
                withScmProgress(task) {
                    extHostApiDeprecation.report('window.withScmProgress', extension, `Use 'withProgress' instead.`);
                    return extHostProgress.withProgress(extension, { location: extHostTypes.ProgressLocation.SourceControl }, (progress, token) => task({ report(n) { } }));
                },
                withProgress(options, task) {
                    return extHostProgress.withProgress(extension, options, task);
                },
                createOutputChannel(name, options) {
                    return extHostOutputService.createOutputChannel(name, options, extension);
                },
                createWebviewPanel(viewType, title, showOptions, options) {
                    return extHostWebviewPanels.createWebviewPanel(extension, viewType, title, showOptions, options);
                },
                createWebviewTextEditorInset(editor, line, height, options) {
                    (0, extensions_2.$gH)(extension, 'editorInsets');
                    return extHostEditorInsets.createWebviewEditorInset(editor, line, height, options, extension);
                },
                createTerminal(nameOrOptions, shellPath, shellArgs) {
                    if (typeof nameOrOptions === 'object') {
                        if ('pty' in nameOrOptions) {
                            return extHostTerminalService.createExtensionTerminal(nameOrOptions);
                        }
                        return extHostTerminalService.createTerminalFromOptions(nameOrOptions);
                    }
                    return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);
                },
                registerTerminalLinkProvider(provider) {
                    return extHostTerminalService.registerLinkProvider(provider);
                },
                registerTerminalProfileProvider(id, provider) {
                    return extHostTerminalService.registerProfileProvider(extension, id, provider);
                },
                registerTerminalQuickFixProvider(id, provider) {
                    (0, extensions_2.$gH)(extension, 'terminalQuickFixProvider');
                    return extHostTerminalService.registerTerminalQuickFixProvider(id, extension.identifier.value, provider);
                },
                registerTreeDataProvider(viewId, treeDataProvider) {
                    return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider, extension);
                },
                createTreeView(viewId, options) {
                    return extHostTreeViews.createTreeView(viewId, options, extension);
                },
                registerWebviewPanelSerializer: (viewType, serializer) => {
                    return extHostWebviewPanels.registerWebviewPanelSerializer(extension, viewType, serializer);
                },
                registerCustomEditorProvider: (viewType, provider, options = {}) => {
                    return extHostCustomEditors.registerCustomEditorProvider(extension, viewType, provider, options);
                },
                registerFileDecorationProvider(provider) {
                    return extHostDecorations.registerFileDecorationProvider(provider, extension);
                },
                registerUriHandler(handler) {
                    return extHostUrls.registerUriHandler(extension, handler);
                },
                createQuickPick() {
                    return extHostQuickOpen.createQuickPick(extension);
                },
                createInputBox() {
                    return extHostQuickOpen.createInputBox(extension);
                },
                get activeColorTheme() {
                    return extHostTheming.activeColorTheme;
                },
                onDidChangeActiveColorTheme(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostTheming.onDidChangeActiveColorTheme)(listener, thisArg, disposables);
                },
                registerWebviewViewProvider(viewId, provider, options) {
                    return extHostWebviewViews.registerWebviewViewProvider(extension, viewId, provider, options?.webviewOptions);
                },
                get activeNotebookEditor() {
                    return extHostNotebook.activeNotebookEditor;
                },
                onDidChangeActiveNotebookEditor(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostNotebook.onDidChangeActiveNotebookEditor)(listener, thisArgs, disposables);
                },
                get visibleNotebookEditors() {
                    return extHostNotebook.visibleNotebookEditors;
                },
                get onDidChangeVisibleNotebookEditors() {
                    return _asExtensionEvent(extHostNotebook.onDidChangeVisibleNotebookEditors);
                },
                onDidChangeNotebookEditorSelection(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostNotebookEditors.onDidChangeNotebookEditorSelection)(listener, thisArgs, disposables);
                },
                onDidChangeNotebookEditorVisibleRanges(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostNotebookEditors.onDidChangeNotebookEditorVisibleRanges)(listener, thisArgs, disposables);
                },
                showNotebookDocument(document, options) {
                    return extHostNotebook.showNotebookDocument(document, options);
                },
                registerExternalUriOpener(id, opener, metadata) {
                    (0, extensions_2.$gH)(extension, 'externalUriOpener');
                    return extHostUriOpeners.registerExternalUriOpener(extension.identifier, id, opener, metadata);
                },
                registerProfileContentHandler(id, handler) {
                    (0, extensions_2.$gH)(extension, 'profileContentHandlers');
                    return extHostProfileContentHandlers.registerProfileContentHandler(extension, id, handler);
                },
                registerQuickDiffProvider(selector, quickDiffProvider, label, rootUri) {
                    (0, extensions_2.$gH)(extension, 'quickDiffProvider');
                    return extHostQuickDiff.registerQuickDiffProvider(checkSelector(selector), quickDiffProvider, label, rootUri);
                },
                get tabGroups() {
                    return extHostEditorTabs.tabGroups;
                },
                registerShareProvider(selector, provider) {
                    (0, extensions_2.$gH)(extension, 'shareProvider');
                    return extHostShare.registerShareProvider(checkSelector(selector), provider);
                }
            };
            // namespace: workspace
            const workspace = {
                get rootPath() {
                    extHostApiDeprecation.report('workspace.rootPath', extension, `Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath`);
                    return extHostWorkspace.getPath();
                },
                set rootPath(value) {
                    throw new errors.$8('rootPath');
                },
                getWorkspaceFolder(resource) {
                    return extHostWorkspace.getWorkspaceFolder(resource);
                },
                get workspaceFolders() {
                    return extHostWorkspace.getWorkspaceFolders();
                },
                get name() {
                    return extHostWorkspace.name;
                },
                set name(value) {
                    throw new errors.$8('name');
                },
                get workspaceFile() {
                    return extHostWorkspace.workspaceFile;
                },
                set workspaceFile(value) {
                    throw new errors.$8('workspaceFile');
                },
                updateWorkspaceFolders: (index, deleteCount, ...workspaceFoldersToAdd) => {
                    return extHostWorkspace.updateWorkspaceFolders(extension, index, deleteCount || 0, ...workspaceFoldersToAdd);
                },
                onDidChangeWorkspaceFolders: function (listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostWorkspace.onDidChangeWorkspace)(listener, thisArgs, disposables);
                },
                asRelativePath: (pathOrUri, includeWorkspace) => {
                    return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);
                },
                findFiles: (include, exclude, maxResults, token) => {
                    // Note, undefined/null have different meanings on "exclude"
                    return extHostWorkspace.findFiles(include, exclude, maxResults, extension.identifier, token);
                },
                findFiles2: (filePattern, options, token) => {
                    (0, extensions_2.$gH)(extension, 'findFiles2');
                    return extHostWorkspace.findFiles2(filePattern, options, extension.identifier, token);
                },
                findFiles2New: (filePattern, options, token) => {
                    (0, extensions_2.$gH)(extension, 'findFiles2New');
                    const oldOptions = {
                        exclude: options?.exclude && options.exclude.length > 0 ? options.exclude[0] : undefined,
                        useDefaultExcludes: !options?.useExcludeSettings || (options?.useExcludeSettings === searchExtTypes_1.ExcludeSettingOptions.filesExclude || options?.useExcludeSettings === searchExtTypes_1.ExcludeSettingOptions.searchAndFilesExclude),
                        useDefaultSearchExcludes: !options?.useExcludeSettings || (options?.useExcludeSettings === searchExtTypes_1.ExcludeSettingOptions.searchAndFilesExclude),
                        maxResults: options?.maxResults,
                        useIgnoreFiles: options?.useIgnoreFiles?.local,
                        useGlobalIgnoreFiles: options?.useIgnoreFiles?.global,
                        useParentIgnoreFiles: options?.useIgnoreFiles?.parent,
                        followSymlinks: options?.followSymlinks,
                    };
                    return extHostWorkspace.findFiles2(filePattern && filePattern.length > 0 ? filePattern[0] : undefined, oldOptions, extension.identifier, token);
                },
                findTextInFiles: (query, optionsOrCallback, callbackOrToken, token) => {
                    (0, extensions_2.$gH)(extension, 'findTextInFiles');
                    let options;
                    let callback;
                    if (typeof optionsOrCallback === 'object') {
                        options = optionsOrCallback;
                        callback = callbackOrToken;
                    }
                    else {
                        options = {};
                        callback = optionsOrCallback;
                        token = callbackOrToken;
                    }
                    return extHostWorkspace.findTextInFiles(query, options || {}, callback, extension.identifier, token);
                },
                findTextInFilesNew: (query, options, token) => {
                    (0, extensions_2.$gH)(extension, 'findTextInFilesNew');
                    (0, extensions_2.$gH)(extension, 'textSearchProviderNew');
                    let oldOptions = {};
                    if (options) {
                        oldOptions = {
                            include: options.include && options.include.length > 0 ? options.include[0] : undefined,
                            exclude: options.exclude && options.exclude.length > 0 ? options.exclude[0] : undefined,
                            useDefaultExcludes: options.useExcludeSettings === undefined || (options.useExcludeSettings === searchExtTypes_1.ExcludeSettingOptions.filesExclude || options.useExcludeSettings === searchExtTypes_1.ExcludeSettingOptions.searchAndFilesExclude),
                            useSearchExclude: options.useExcludeSettings === undefined || (options.useExcludeSettings === searchExtTypes_1.ExcludeSettingOptions.searchAndFilesExclude),
                            maxResults: options.maxResults,
                            useIgnoreFiles: options.useIgnoreFiles?.local,
                            useGlobalIgnoreFiles: options.useIgnoreFiles?.global,
                            useParentIgnoreFiles: options.useIgnoreFiles?.parent,
                            followSymlinks: options.followSymlinks,
                            encoding: options.encoding,
                            previewOptions: options.previewOptions ? {
                                matchLines: options.previewOptions?.matchLines ?? 100,
                                charsPerLine: options.previewOptions?.charsPerLine ?? 10000,
                            } : undefined,
                            beforeContext: options.surroundingContext,
                            afterContext: options.surroundingContext,
                        };
                    }
                    const complete = Promise.resolve(undefined);
                    const asyncIterable = new async_1.$6h(async (emitter) => {
                        const callback = async (result) => {
                            emitter.emitOne((0, searchExtTypes_1.$1L)(result));
                            return result;
                        };
                        await complete.then(e => {
                            return extHostWorkspace.findTextInFiles(query, oldOptions, callback, extension.identifier, token);
                        });
                    });
                    return {
                        results: asyncIterable,
                        complete: complete.then((e) => {
                            return {
                                limitHit: e?.limitHit ?? false
                            };
                        }),
                    };
                },
                save: (uri) => {
                    return extHostWorkspace.save(uri);
                },
                saveAs: (uri) => {
                    return extHostWorkspace.saveAs(uri);
                },
                saveAll: (includeUntitled) => {
                    return extHostWorkspace.saveAll(includeUntitled);
                },
                applyEdit(edit, metadata) {
                    return extHostBulkEdits.applyWorkspaceEdit(edit, extension, metadata);
                },
                createFileSystemWatcher: (pattern, optionsOrIgnoreCreate, ignoreChange, ignoreDelete) => {
                    let options = undefined;
                    if (typeof optionsOrIgnoreCreate === 'boolean') {
                        options = {
                            ignoreCreateEvents: Boolean(optionsOrIgnoreCreate),
                            ignoreChangeEvents: Boolean(ignoreChange),
                            ignoreDeleteEvents: Boolean(ignoreDelete),
                            correlate: false
                        };
                    }
                    else if (optionsOrIgnoreCreate) {
                        (0, extensions_2.$gH)(extension, 'createFileSystemWatcher');
                        options = {
                            ...optionsOrIgnoreCreate,
                            correlate: true
                        };
                    }
                    return extHostFileSystemEvent.createFileSystemWatcher(extHostWorkspace, extension, pattern, options);
                },
                get textDocuments() {
                    return extHostDocuments.getAllDocumentData().map(data => data.document);
                },
                set textDocuments(value) {
                    throw new errors.$8('textDocuments');
                },
                openTextDocument(uriOrFileNameOrOptions) {
                    let uriPromise;
                    const options = uriOrFileNameOrOptions;
                    if (typeof uriOrFileNameOrOptions === 'string') {
                        uriPromise = Promise.resolve(uri_1.URI.file(uriOrFileNameOrOptions));
                    }
                    else if (uri_1.URI.isUri(uriOrFileNameOrOptions)) {
                        uriPromise = Promise.resolve(uriOrFileNameOrOptions);
                    }
                    else if (!options || typeof options === 'object') {
                        uriPromise = extHostDocuments.createDocumentData(options);
                    }
                    else {
                        throw new Error('illegal argument - uriOrFileNameOrOptions');
                    }
                    return uriPromise.then(uri => {
                        if (uri.scheme === network_1.Schemas.vscodeRemote && !uri.authority) {
                            extHostApiDeprecation.report('workspace.openTextDocument', extension, `A URI of 'vscode-remote' scheme requires an authority.`);
                        }
                        return extHostDocuments.ensureDocumentData(uri).then(documentData => {
                            return documentData.document;
                        });
                    });
                },
                onDidOpenTextDocument: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostDocuments.onDidAddDocument)(listener, thisArgs, disposables);
                },
                onDidCloseTextDocument: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostDocuments.onDidRemoveDocument)(listener, thisArgs, disposables);
                },
                onDidChangeTextDocument: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostDocuments.onDidChangeDocument)(listener, thisArgs, disposables);
                },
                onDidSaveTextDocument: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostDocuments.onDidSaveDocument)(listener, thisArgs, disposables);
                },
                onWillSaveTextDocument: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostDocumentSaveParticipant.getOnWillSaveTextDocumentEvent(extension))(listener, thisArgs, disposables);
                },
                get notebookDocuments() {
                    return extHostNotebook.notebookDocuments.map(d => d.apiNotebook);
                },
                async openNotebookDocument(uriOrType, content) {
                    let uri;
                    if (uri_1.URI.isUri(uriOrType)) {
                        uri = uriOrType;
                        await extHostNotebook.openNotebookDocument(uriOrType);
                    }
                    else if (typeof uriOrType === 'string') {
                        uri = uri_1.URI.revive(await extHostNotebook.createNotebookDocument({ viewType: uriOrType, content }));
                    }
                    else {
                        throw new Error('Invalid arguments');
                    }
                    return extHostNotebook.getNotebookDocument(uri).apiNotebook;
                },
                onDidSaveNotebookDocument(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostNotebookDocuments.onDidSaveNotebookDocument)(listener, thisArg, disposables);
                },
                onDidChangeNotebookDocument(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostNotebookDocuments.onDidChangeNotebookDocument)(listener, thisArg, disposables);
                },
                onWillSaveNotebookDocument(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostNotebookDocumentSaveParticipant.getOnWillSaveNotebookDocumentEvent(extension))(listener, thisArg, disposables);
                },
                get onDidOpenNotebookDocument() {
                    return _asExtensionEvent(extHostNotebook.onDidOpenNotebookDocument);
                },
                get onDidCloseNotebookDocument() {
                    return _asExtensionEvent(extHostNotebook.onDidCloseNotebookDocument);
                },
                registerNotebookSerializer(viewType, serializer, options, registration) {
                    return extHostNotebook.registerNotebookSerializer(extension, viewType, serializer, options, (0, extensions_2.$fH)(extension, 'notebookLiveShare') ? registration : undefined);
                },
                onDidChangeConfiguration: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(configProvider.onDidChangeConfiguration)(listener, thisArgs, disposables);
                },
                getConfiguration(section, scope) {
                    scope = arguments.length === 1 ? undefined : scope;
                    return configProvider.getConfiguration(section, scope, extension);
                },
                registerTextDocumentContentProvider(scheme, provider) {
                    return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
                },
                registerTaskProvider: (type, provider) => {
                    extHostApiDeprecation.report('window.registerTaskProvider', extension, `Use the corresponding function on the 'tasks' namespace instead`);
                    return extHostTask.registerTaskProvider(extension, type, provider);
                },
                registerFileSystemProvider(scheme, provider, options) {
                    return (0, lifecycle_1.$Rc)(extHostFileSystem.registerFileSystemProvider(extension, scheme, provider, options), extHostConsumerFileSystem.addFileSystemProvider(scheme, provider, options));
                },
                get fs() {
                    return extHostConsumerFileSystem.value;
                },
                registerFileSearchProvider: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'fileSearchProvider');
                    return extHostSearch.registerFileSearchProvider(scheme, provider);
                },
                registerTextSearchProvider: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'textSearchProvider');
                    return extHostSearch.registerTextSearchProvider(scheme, provider);
                },
                registerAITextSearchProvider: (scheme, provider) => {
                    // there are some dependencies on textSearchProvider, so we need to check for both
                    (0, extensions_2.$gH)(extension, 'aiTextSearchProvider');
                    (0, extensions_2.$gH)(extension, 'textSearchProvider');
                    return extHostSearch.registerAITextSearchProvider(scheme, provider);
                },
                registerFileSearchProviderNew: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'fileSearchProviderNew');
                    return { dispose: () => { } };
                },
                registerTextSearchProviderNew: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'textSearchProviderNew');
                    return { dispose: () => { } };
                },
                registerAITextSearchProviderNew: (scheme, provider) => {
                    // there are some dependencies on textSearchProvider, so we need to check for both
                    (0, extensions_2.$gH)(extension, 'aiTextSearchProviderNew');
                    (0, extensions_2.$gH)(extension, 'textSearchProviderNew');
                    return { dispose: () => { } };
                },
                registerRemoteAuthorityResolver: (authorityPrefix, resolver) => {
                    (0, extensions_2.$gH)(extension, 'resolvers');
                    return extensionService.registerRemoteAuthorityResolver(authorityPrefix, resolver);
                },
                registerResourceLabelFormatter: (formatter) => {
                    (0, extensions_2.$gH)(extension, 'resolvers');
                    return extHostLabelService.$registerResourceLabelFormatter(formatter);
                },
                getRemoteExecServer: (authority) => {
                    (0, extensions_2.$gH)(extension, 'resolvers');
                    return extensionService.getRemoteExecServer(authority);
                },
                onDidCreateFiles: (listener, thisArg, disposables) => {
                    return _asExtensionEvent(extHostFileSystemEvent.onDidCreateFile)(listener, thisArg, disposables);
                },
                onDidDeleteFiles: (listener, thisArg, disposables) => {
                    return _asExtensionEvent(extHostFileSystemEvent.onDidDeleteFile)(listener, thisArg, disposables);
                },
                onDidRenameFiles: (listener, thisArg, disposables) => {
                    return _asExtensionEvent(extHostFileSystemEvent.onDidRenameFile)(listener, thisArg, disposables);
                },
                onWillCreateFiles: (listener, thisArg, disposables) => {
                    return _asExtensionEvent(extHostFileSystemEvent.getOnWillCreateFileEvent(extension))(listener, thisArg, disposables);
                },
                onWillDeleteFiles: (listener, thisArg, disposables) => {
                    return _asExtensionEvent(extHostFileSystemEvent.getOnWillDeleteFileEvent(extension))(listener, thisArg, disposables);
                },
                onWillRenameFiles: (listener, thisArg, disposables) => {
                    return _asExtensionEvent(extHostFileSystemEvent.getOnWillRenameFileEvent(extension))(listener, thisArg, disposables);
                },
                openTunnel: (forward) => {
                    (0, extensions_2.$gH)(extension, 'tunnels');
                    return extHostTunnelService.openTunnel(extension, forward).then(value => {
                        if (!value) {
                            throw new Error('cannot open tunnel');
                        }
                        return value;
                    });
                },
                get tunnels() {
                    (0, extensions_2.$gH)(extension, 'tunnels');
                    return extHostTunnelService.getTunnels();
                },
                onDidChangeTunnels: (listener, thisArg, disposables) => {
                    (0, extensions_2.$gH)(extension, 'tunnels');
                    return _asExtensionEvent(extHostTunnelService.onDidChangeTunnels)(listener, thisArg, disposables);
                },
                registerPortAttributesProvider: (portSelector, provider) => {
                    (0, extensions_2.$gH)(extension, 'portsAttributes');
                    return extHostTunnelService.registerPortsAttributesProvider(portSelector, provider);
                },
                registerTunnelProvider: (tunnelProvider, information) => {
                    (0, extensions_2.$gH)(extension, 'tunnelFactory');
                    return extHostTunnelService.registerTunnelProvider(tunnelProvider, information);
                },
                registerTimelineProvider: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'timeline');
                    return extHostTimeline.registerTimelineProvider(scheme, provider, extension.identifier, extHostCommands.converter);
                },
                get isTrusted() {
                    return extHostWorkspace.trusted;
                },
                requestWorkspaceTrust: (options) => {
                    (0, extensions_2.$gH)(extension, 'workspaceTrust');
                    return extHostWorkspace.requestWorkspaceTrust(options);
                },
                onDidGrantWorkspaceTrust: (listener, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostWorkspace.onDidGrantWorkspaceTrust)(listener, thisArgs, disposables);
                },
                registerEditSessionIdentityProvider: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'editSessionIdentityProvider');
                    return extHostWorkspace.registerEditSessionIdentityProvider(scheme, provider);
                },
                onWillCreateEditSessionIdentity: (listener, thisArgs, disposables) => {
                    (0, extensions_2.$gH)(extension, 'editSessionIdentityProvider');
                    return _asExtensionEvent(extHostWorkspace.getOnWillCreateEditSessionIdentityEvent(extension))(listener, thisArgs, disposables);
                },
                registerCanonicalUriProvider: (scheme, provider) => {
                    (0, extensions_2.$gH)(extension, 'canonicalUriProvider');
                    return extHostWorkspace.registerCanonicalUriProvider(scheme, provider);
                },
                getCanonicalUri: (uri, options, token) => {
                    (0, extensions_2.$gH)(extension, 'canonicalUriProvider');
                    return extHostWorkspace.provideCanonicalUri(uri, options, token);
                }
            };
            // namespace: scm
            const scm = {
                get inputBox() {
                    extHostApiDeprecation.report('scm.inputBox', extension, `Use 'SourceControl.inputBox' instead`);
                    return extHostSCM.getLastInputBox(extension); // Strict null override - Deprecated api
                },
                createSourceControl(id, label, rootUri) {
                    return extHostSCM.createSourceControl(extension, id, label, rootUri);
                }
            };
            // namespace: comments
            const comments = {
                createCommentController(id, label) {
                    return extHostComment.createCommentController(extension, id, label);
                }
            };
            // namespace: debug
            const debug = {
                get activeDebugSession() {
                    return extHostDebugService.activeDebugSession;
                },
                get activeDebugConsole() {
                    return extHostDebugService.activeDebugConsole;
                },
                get breakpoints() {
                    return extHostDebugService.breakpoints;
                },
                get activeStackItem() {
                    return extHostDebugService.activeStackItem;
                },
                registerDebugVisualizationProvider(id, provider) {
                    (0, extensions_2.$gH)(extension, 'debugVisualization');
                    return extHostDebugService.registerDebugVisualizationProvider(extension, id, provider);
                },
                registerDebugVisualizationTreeProvider(id, provider) {
                    (0, extensions_2.$gH)(extension, 'debugVisualization');
                    return extHostDebugService.registerDebugVisualizationTree(extension, id, provider);
                },
                onDidStartDebugSession(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostDebugService.onDidStartDebugSession)(listener, thisArg, disposables);
                },
                onDidTerminateDebugSession(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostDebugService.onDidTerminateDebugSession)(listener, thisArg, disposables);
                },
                onDidChangeActiveDebugSession(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostDebugService.onDidChangeActiveDebugSession)(listener, thisArg, disposables);
                },
                onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostDebugService.onDidReceiveDebugSessionCustomEvent)(listener, thisArg, disposables);
                },
                onDidChangeBreakpoints(listener, thisArgs, disposables) {
                    return _asExtensionEvent(extHostDebugService.onDidChangeBreakpoints)(listener, thisArgs, disposables);
                },
                onDidChangeActiveStackItem(listener, thisArg, disposables) {
                    return _asExtensionEvent(extHostDebugService.onDidChangeActiveStackItem)(listener, thisArg, disposables);
                },
                registerDebugConfigurationProvider(debugType, provider, triggerKind) {
                    return extHostDebugService.registerDebugConfigurationProvider(debugType, provider, triggerKind || debug_1.DebugConfigurationProviderTriggerKind.Initial);
                },
                registerDebugAdapterDescriptorFactory(debugType, factory) {
                    return extHostDebugService.registerDebugAdapterDescriptorFactory(extension, debugType, factory);
                },
                registerDebugAdapterTrackerFactory(debugType, factory) {
                    return extHostDebugService.registerDebugAdapterTrackerFactory(debugType, factory);
                },
                startDebugging(folder, nameOrConfig, parentSessionOrOptions) {
                    if (!parentSessionOrOptions || (typeof parentSessionOrOptions === 'object' && 'configuration' in parentSessionOrOptions)) {
                        return extHostDebugService.startDebugging(folder, nameOrConfig, { parentSession: parentSessionOrOptions });
                    }
                    return extHostDebugService.startDebugging(folder, nameOrConfig, parentSessionOrOptions || {});
                },
                stopDebugging(session) {
                    return extHostDebugService.stopDebugging(session);
                },
                addBreakpoints(breakpoints) {
                    return extHostDebugService.addBreakpoints(breakpoints);
                },
                removeBreakpoints(breakpoints) {
                    return extHostDebugService.removeBreakpoints(breakpoints);
                },
                asDebugSourceUri(source, session) {
                    return extHostDebugService.asDebugSourceUri(source, session);
                }
            };
            const tasks = {
                registerTaskProvider: (type, provider) => {
                    return extHostTask.registerTaskProvider(extension, type, provider);
                },
                fetchTasks: (filter) => {
                    return extHostTask.fetchTasks(filter);
                },
                executeTask: (task) => {
                    return extHostTask.executeTask(extension, task);
                },
                get taskExecutions() {
                    return extHostTask.taskExecutions;
                },
                onDidStartTask: (listeners, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostTask.onDidStartTask)(listeners, thisArgs, disposables);
                },
                onDidEndTask: (listeners, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostTask.onDidEndTask)(listeners, thisArgs, disposables);
                },
                onDidStartTaskProcess: (listeners, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostTask.onDidStartTaskProcess)(listeners, thisArgs, disposables);
                },
                onDidEndTaskProcess: (listeners, thisArgs, disposables) => {
                    return _asExtensionEvent(extHostTask.onDidEndTaskProcess)(listeners, thisArgs, disposables);
                }
            };
            // namespace: notebook
            const notebooks = {
                createNotebookController(id, notebookType, label, handler, rendererScripts) {
                    return extHostNotebookKernels.createNotebookController(extension, id, notebookType, label, handler, (0, extensions_2.$fH)(extension, 'notebookMessaging') ? rendererScripts : undefined);
                },
                registerNotebookCellStatusBarItemProvider: (notebookType, provider) => {
                    return extHostNotebook.registerNotebookCellStatusBarItemProvider(extension, notebookType, provider);
                },
                createRendererMessaging(rendererId) {
                    return extHostNotebookRenderers.createRendererMessaging(extension, rendererId);
                },
                createNotebookControllerDetectionTask(notebookType) {
                    (0, extensions_2.$gH)(extension, 'notebookKernelSource');
                    return extHostNotebookKernels.createNotebookControllerDetectionTask(extension, notebookType);
                },
                registerKernelSourceActionProvider(notebookType, provider) {
                    (0, extensions_2.$gH)(extension, 'notebookKernelSource');
                    return extHostNotebookKernels.registerKernelSourceActionProvider(extension, notebookType, provider);
                },
                onDidChangeNotebookCellExecutionState(listener, thisArgs, disposables) {
                    (0, extensions_2.$gH)(extension, 'notebookCellExecutionState');
                    return _asExtensionEvent(extHostNotebookKernels.onDidChangeNotebookCellExecutionState)(listener, thisArgs, disposables);
                }
            };
            // namespace: l10n
            const l10n = {
                t(...params) {
                    if (typeof params[0] === 'string') {
                        const key = params.shift();
                        // We have either rest args which are Array<string | number | boolean> or an array with a single Record<string, any>.
                        // This ensures we get a Record<string | number, any> which will be formatted correctly.
                        const argsFormatted = !params || typeof params[0] !== 'object' ? params : params[0];
                        return extHostLocalization.getMessage(extension.identifier.value, { message: key, args: argsFormatted });
                    }
                    return extHostLocalization.getMessage(extension.identifier.value, params[0]);
                },
                get bundle() {
                    return extHostLocalization.getBundle(extension.identifier.value);
                },
                get uri() {
                    return extHostLocalization.getBundleUri(extension.identifier.value);
                }
            };
            // namespace: interactive
            const interactive = {
                // TODO Can be deleted after another Insiders
                _version: 1,
                transferActiveChat(toWorkspace) {
                    (0, extensions_2.$gH)(extension, 'interactive');
                    return extHostChatAgents2.transferActiveChat(toWorkspace);
                }
            };
            // namespace: ai
            const ai = {
                getRelatedInformation(query, types) {
                    (0, extensions_2.$gH)(extension, 'aiRelatedInformation');
                    return extHostAiRelatedInformation.getRelatedInformation(extension, query, types);
                },
                registerRelatedInformationProvider(type, provider) {
                    (0, extensions_2.$gH)(extension, 'aiRelatedInformation');
                    return extHostAiRelatedInformation.registerRelatedInformationProvider(extension, type, provider);
                },
                registerEmbeddingVectorProvider(model, provider) {
                    (0, extensions_2.$gH)(extension, 'aiRelatedInformation');
                    return extHostAiEmbeddingVector.registerEmbeddingVectorProvider(extension, model, provider);
                }
            };
            // namespace: chat
            const chat = {
                // IMPORTANT
                // this needs to be updated whenever the API proposal changes and breaks backwards compatibility
                _version: 1,
                registerChatResponseProvider(id, provider, metadata) {
                    (0, extensions_2.$gH)(extension, 'chatProvider');
                    return extHostLanguageModels.registerLanguageModel(extension, id, provider, metadata);
                },
                registerChatVariableResolver(id, name, userDescription, modelDescription, isSlow, resolver, fullName, icon) {
                    (0, extensions_2.$gH)(extension, 'chatVariableResolver');
                    return extHostChatVariables.registerVariableResolver(extension, id, name, userDescription, modelDescription, isSlow, resolver, fullName, icon?.id);
                },
                registerMappedEditsProvider(selector, provider) {
                    (0, extensions_2.$gH)(extension, 'mappedEditsProvider');
                    return extHostLanguageFeatures.registerMappedEditsProvider(extension, selector, provider);
                },
                createChatParticipant(id, handler) {
                    return extHostChatAgents2.createChatAgent(extension, id, handler);
                },
                createDynamicChatParticipant(id, dynamicProps, handler) {
                    (0, extensions_2.$gH)(extension, 'chatParticipantPrivate');
                    return extHostChatAgents2.createDynamicChatAgent(extension, id, dynamicProps, handler);
                },
            };
            // namespace: lm
            const lm = {
                selectChatModels: (selector) => {
                    return extHostLanguageModels.selectLanguageModels(extension, selector ?? {});
                },
                onDidChangeChatModels: (listener, thisArgs, disposables) => {
                    return extHostLanguageModels.onDidChangeProviders(listener, thisArgs, disposables);
                },
                registerChatModelProvider: (id, provider, metadata) => {
                    (0, extensions_2.$gH)(extension, 'chatProvider');
                    return extHostLanguageModels.registerLanguageModel(extension, id, provider, metadata);
                },
                // --- embeddings
                get embeddingModels() {
                    (0, extensions_2.$gH)(extension, 'embeddings');
                    return extHostEmbeddings.embeddingsModels;
                },
                onDidChangeEmbeddingModels: (listener, thisArgs, disposables) => {
                    (0, extensions_2.$gH)(extension, 'embeddings');
                    return extHostEmbeddings.onDidChange(listener, thisArgs, disposables);
                },
                registerEmbeddingsProvider(embeddingsModel, provider) {
                    (0, extensions_2.$gH)(extension, 'embeddings');
                    return extHostEmbeddings.registerEmbeddingsProvider(extension, embeddingsModel, provider);
                },
                async computeEmbeddings(embeddingsModel, input, token) {
                    (0, extensions_2.$gH)(extension, 'embeddings');
                    if (typeof input === 'string') {
                        return extHostEmbeddings.computeEmbeddings(embeddingsModel, input, token);
                    }
                    else {
                        return extHostEmbeddings.computeEmbeddings(embeddingsModel, input, token);
                    }
                },
                registerTool(toolId, tool) {
                    (0, extensions_2.$gH)(extension, 'lmTools');
                    return extHostLanguageModelTools.registerTool(extension, toolId, tool);
                },
                invokeTool(toolId, parameters, token) {
                    (0, extensions_2.$gH)(extension, 'lmTools');
                    return extHostLanguageModelTools.invokeTool(toolId, parameters, token);
                },
                get tools() {
                    (0, extensions_2.$gH)(extension, 'lmTools');
                    return extHostLanguageModelTools.tools;
                },
            };
            // namespace: speech
            const speech = {
                registerSpeechProvider(id, provider) {
                    (0, extensions_2.$gH)(extension, 'speech');
                    return extHostSpeech.registerProvider(extension.identifier, id, provider);
                }
            };
            return {
                version: initData.version,
                // namespaces
                ai,
                authentication,
                commands,
                comments,
                chat,
                debug,
                env,
                extensions,
                interactive,
                l10n,
                languages,
                lm,
                notebooks,
                scm,
                speech,
                tasks,
                tests,
                window,
                workspace,
                // types
                Breakpoint: extHostTypes.$PO,
                TerminalOutputAnchor: extHostTypes.TerminalOutputAnchor,
                ChatResultFeedbackKind: extHostTypes.ChatResultFeedbackKind,
                ChatVariableLevel: extHostTypes.ChatVariableLevel,
                ChatCompletionItem: extHostTypes.$LP,
                CallHierarchyIncomingCall: extHostTypes.$bO,
                CallHierarchyItem: extHostTypes.$aO,
                CallHierarchyOutgoingCall: extHostTypes.$cO,
                CancellationError: errors.$4,
                CancellationTokenSource: cancellation_1.$we,
                CandidatePortSource: extHost_protocol_1.CandidatePortSource,
                CodeAction: extHostTypes.$0N,
                CodeActionKind: extHostTypes.$$N,
                CodeActionTriggerKind: extHostTypes.CodeActionTriggerKind,
                CodeLens: extHostTypes.$dO,
                Color: extHostTypes.$qO,
                ColorInformation: extHostTypes.$rO,
                ColorPresentation: extHostTypes.$sO,
                ColorThemeKind: extHostTypes.ColorThemeKind,
                CommentMode: extHostTypes.CommentMode,
                CommentState: extHostTypes.CommentState,
                CommentThreadCollapsibleState: extHostTypes.CommentThreadCollapsibleState,
                CommentThreadState: extHostTypes.CommentThreadState,
                CommentThreadApplicability: extHostTypes.CommentThreadApplicability,
                CommentThreadFocus: extHostTypes.CommentThreadFocus,
                CompletionItem: extHostTypes.$kO,
                CompletionItemKind: extHostTypes.CompletionItemKind,
                CompletionItemTag: extHostTypes.CompletionItemTag,
                CompletionList: extHostTypes.$lO,
                CompletionTriggerKind: extHostTypes.CompletionTriggerKind,
                ConfigurationTarget: extHostTypes.ConfigurationTarget,
                CustomExecution: extHostTypes.$AO,
                DebugAdapterExecutable: extHostTypes.$TO,
                DebugAdapterInlineImplementation: extHostTypes.$WO,
                DebugAdapterNamedPipeServer: extHostTypes.$VO,
                DebugAdapterServer: extHostTypes.$UO,
                DebugConfigurationProviderTriggerKind: debug_1.DebugConfigurationProviderTriggerKind,
                DebugConsoleMode: extHostTypes.DebugConsoleMode,
                DebugVisualization: extHostTypes.$aP,
                DecorationRangeBehavior: extHostTypes.DecorationRangeBehavior,
                Diagnostic: extHostTypes.$3N,
                DiagnosticRelatedInformation: extHostTypes.$2N,
                DiagnosticSeverity: extHostTypes.DiagnosticSeverity,
                DiagnosticTag: extHostTypes.DiagnosticTag,
                Disposable: extHostTypes.$MN,
                DocumentHighlight: extHostTypes.$6N,
                DocumentHighlightKind: extHostTypes.DocumentHighlightKind,
                MultiDocumentHighlight: extHostTypes.$7N,
                DocumentLink: extHostTypes.$pO,
                DocumentSymbol: extHostTypes.$9N,
                EndOfLine: extHostTypes.EndOfLine,
                EnvironmentVariableMutatorType: extHostTypes.EnvironmentVariableMutatorType,
                EvaluatableExpression: extHostTypes.$ZO,
                InlineValueText: extHostTypes.$1O,
                InlineValueVariableLookup: extHostTypes.$2O,
                InlineValueEvaluatableExpression: extHostTypes.$3O,
                InlineCompletionTriggerKind: extHostTypes.InlineCompletionTriggerKind,
                EventEmitter: event_1.$le,
                ExtensionKind: extHostTypes.ExtensionKind,
                ExtensionMode: extHostTypes.ExtensionMode,
                ExternalUriOpenerPriority: extHostTypes.ExternalUriOpenerPriority,
                FileChangeType: extHostTypes.FileChangeType,
                FileDecoration: extHostTypes.$cP,
                FileDecoration2: extHostTypes.$cP,
                FileSystemError: extHostTypes.$6O,
                FileType: files.FileType,
                FilePermission: files.FilePermission,
                FoldingRange: extHostTypes.$7O,
                FoldingRangeKind: extHostTypes.FoldingRangeKind,
                FunctionBreakpoint: extHostTypes.$RO,
                InlineCompletionItem: extHostTypes.$mO,
                InlineCompletionList: extHostTypes.$nO,
                Hover: extHostTypes.$4N,
                VerboseHover: extHostTypes.$5N,
                HoverVerbosityAction: extHostTypes.HoverVerbosityAction,
                IndentAction: languageConfiguration.IndentAction,
                Location: extHostTypes.$1N,
                MarkdownString: extHostTypes.$eO,
                OverviewRulerLane: model_1.OverviewRulerLane,
                ParameterInformation: extHostTypes.$fO,
                PortAutoForwardAction: extHostTypes.PortAutoForwardAction,
                Position: extHostTypes.$NN,
                ProcessExecution: extHostTypes.$yO,
                ProgressLocation: extHostTypes.ProgressLocation,
                QuickInputButtonLocation: extHostTypes.QuickInputButtonLocation,
                QuickInputButtons: extHostTypes.$bP,
                Range: extHostTypes.$ON,
                RelativePattern: extHostTypes.$NO,
                Selection: extHostTypes.$PN,
                SelectionRange: extHostTypes.$_N,
                SemanticTokens: extHostTypes.$0O,
                SemanticTokensBuilder: extHostTypes.$9O,
                SemanticTokensEdit: extHostTypes.$$O,
                SemanticTokensEdits: extHostTypes.$_O,
                SemanticTokensLegend: extHostTypes.$8O,
                ShellExecution: extHostTypes.$zO,
                ShellQuoting: extHostTypes.ShellQuoting,
                SignatureHelp: extHostTypes.$hO,
                SignatureHelpTriggerKind: extHostTypes.SignatureHelpTriggerKind,
                SignatureInformation: extHostTypes.$gO,
                SnippetString: extHostTypes.$ZN,
                SourceBreakpoint: extHostTypes.$QO,
                StandardTokenType: extHostTypes.StandardTokenType,
                StatusBarAlignment: extHostTypes.StatusBarAlignment,
                SymbolInformation: extHostTypes.$8N,
                SymbolKind: extHostTypes.SymbolKind,
                SymbolTag: extHostTypes.SymbolTag,
                Task: extHostTypes.$BO,
                TaskGroup: extHostTypes.$xO,
                TaskPanelKind: extHostTypes.TaskPanelKind,
                TaskRevealKind: extHostTypes.TaskRevealKind,
                TaskScope: extHostTypes.TaskScope,
                TerminalLink: extHostTypes.$tO,
                TerminalQuickFixTerminalCommand: extHostTypes.$vO,
                TerminalQuickFixOpener: extHostTypes.$uO,
                TerminalLocation: extHostTypes.TerminalLocation,
                TerminalProfile: extHostTypes.$wO,
                TerminalExitReason: extHostTypes.TerminalExitReason,
                TerminalShellExecutionCommandLineConfidence: extHostTypes.TerminalShellExecutionCommandLineConfidence,
                TextDocumentSaveReason: extHostTypes.TextDocumentSaveReason,
                TextEdit: extHostTypes.$VN,
                SnippetTextEdit: extHostTypes.$XN,
                TextEditorCursorStyle: editorOptions_1.TextEditorCursorStyle,
                TextEditorLineNumbersStyle: extHostTypes.TextEditorLineNumbersStyle,
                TextEditorRevealType: extHostTypes.TextEditorRevealType,
                TextEditorSelectionChangeKind: extHostTypes.TextEditorSelectionChangeKind,
                SyntaxTokenType: extHostTypes.SyntaxTokenType,
                TextDocumentChangeReason: extHostTypes.TextDocumentChangeReason,
                ThemeColor: extHostTypes.$MO,
                ThemeIcon: extHostTypes.$LO,
                TreeItem: extHostTypes.$CO,
                TreeItemCheckboxState: extHostTypes.TreeItemCheckboxState,
                TreeItemCollapsibleState: extHostTypes.TreeItemCollapsibleState,
                TypeHierarchyItem: extHostTypes.$zP,
                UIKind: extensionHostProtocol_1.UIKind,
                Uri: uri_1.URI,
                ViewColumn: extHostTypes.ViewColumn,
                WorkspaceEdit: extHostTypes.$YN,
                // proposed api types
                DocumentPasteTriggerKind: extHostTypes.DocumentPasteTriggerKind,
                DocumentDropEdit: extHostTypes.$IO,
                DocumentDropOrPasteEditKind: extHostTypes.$JO,
                DocumentPasteEdit: extHostTypes.$KO,
                InlayHint: extHostTypes.$jO,
                InlayHintLabelPart: extHostTypes.$iO,
                InlayHintKind: extHostTypes.InlayHintKind,
                RemoteAuthorityResolverError: extHostTypes.$UN,
                ResolvedAuthority: extHostTypes.$SN,
                ManagedResolvedAuthority: extHostTypes.$TN,
                SourceControlInputBoxValidationType: extHostTypes.SourceControlInputBoxValidationType,
                ExtensionRuntime: extHostTypes.ExtensionRuntime,
                TimelineItem: extHostTypes.$mP,
                NotebookRange: extHostTypes.$eP,
                NotebookCellKind: extHostTypes.NotebookCellKind,
                NotebookCellExecutionState: extHostTypes.NotebookCellExecutionState,
                NotebookCellData: extHostTypes.$fP,
                NotebookData: extHostTypes.$gP,
                NotebookRendererScript: extHostTypes.$kP,
                NotebookCellStatusBarAlignment: extHostTypes.NotebookCellStatusBarAlignment,
                NotebookEditorRevealType: extHostTypes.NotebookEditorRevealType,
                NotebookCellOutput: extHostTypes.$iP,
                NotebookCellOutputItem: extHostTypes.$hP,
                NotebookCellStatusBarItem: extHostTypes.$jP,
                NotebookControllerAffinity: extHostTypes.NotebookControllerAffinity,
                NotebookControllerAffinity2: extHostTypes.NotebookControllerAffinity2,
                NotebookEdit: extHostTypes.$WN,
                NotebookKernelSourceAction: extHostTypes.$lP,
                NotebookVariablesRequestKind: extHostTypes.NotebookVariablesRequestKind,
                PortAttributes: extHostTypes.$oP,
                LinkedEditingRanges: extHostTypes.$nP,
                TestResultState: extHostTypes.TestResultState,
                TestRunRequest: extHostTypes.$pP,
                TestMessage: extHostTypes.$qP,
                TestMessage2: extHostTypes.$qP,
                TestMessageStackFrame: extHostTypes.$sP,
                TestTag: extHostTypes.$rP,
                TestRunProfileKind: extHostTypes.TestRunProfileKind,
                TextSearchCompleteMessageType: searchExtTypes_1.TextSearchCompleteMessageType,
                DataTransfer: extHostTypes.$HO,
                DataTransferItem: extHostTypes.$DO,
                TestCoverageCount: extHostTypes.$tP,
                FileCoverage: extHostTypes.$vP,
                FileCoverage2: extHostTypes.$vP,
                StatementCoverage: extHostTypes.$wP,
                BranchCoverage: extHostTypes.$xP,
                DeclarationCoverage: extHostTypes.$yP,
                WorkspaceTrustState: extHostTypes.WorkspaceTrustState,
                LanguageStatusSeverity: extHostTypes.LanguageStatusSeverity,
                QuickPickItemKind: extHostTypes.QuickPickItemKind,
                InputBoxValidationSeverity: extHostTypes.InputBoxValidationSeverity,
                TabInputText: extHostTypes.$AP,
                TabInputTextDiff: extHostTypes.$BP,
                TabInputTextMerge: extHostTypes.$CP,
                TabInputCustom: extHostTypes.$DP,
                TabInputNotebook: extHostTypes.$FP,
                TabInputNotebookDiff: extHostTypes.$GP,
                TabInputWebview: extHostTypes.$EP,
                TabInputTerminal: extHostTypes.$HP,
                TabInputInteractiveWindow: extHostTypes.$IP,
                TabInputChat: extHostTypes.$JP,
                TabInputTextMultiDiff: extHostTypes.$KP,
                TelemetryTrustedValue: telemetryUtils_1.$xp,
                LogLevel: log_1.LogLevel,
                EditSessionIdentityMatch: editSessions_1.EditSessionIdentityMatch,
                InteractiveSessionVoteDirection: extHostTypes.InteractiveSessionVoteDirection,
                ChatCopyKind: extHostTypes.ChatCopyKind,
                InteractiveEditorResponseFeedbackKind: extHostTypes.InteractiveEditorResponseFeedbackKind,
                DebugStackFrame: extHostTypes.$XO,
                DebugThread: extHostTypes.$YO,
                RelatedInformationType: extHostTypes.RelatedInformationType,
                SpeechToTextStatus: extHostTypes.SpeechToTextStatus,
                TextToSpeechStatus: extHostTypes.TextToSpeechStatus,
                PartialAcceptTriggerKind: extHostTypes.PartialAcceptTriggerKind,
                KeywordRecognitionStatus: extHostTypes.KeywordRecognitionStatus,
                ChatResponseMarkdownPart: extHostTypes.$MP,
                ChatResponseFileTreePart: extHostTypes.$QP,
                ChatResponseAnchorPart: extHostTypes.$RP,
                ChatResponseProgressPart: extHostTypes.$SP,
                ChatResponseProgressPart2: extHostTypes.$TP,
                ChatResponseReferencePart: extHostTypes.$WP,
                ChatResponseReferencePart2: extHostTypes.$WP,
                ChatResponseCodeCitationPart: extHostTypes.$XP,
                ChatResponseWarningPart: extHostTypes.$UP,
                ChatResponseTextEditPart: extHostTypes.$YP,
                ChatResponseMarkdownWithVulnerabilitiesPart: extHostTypes.$NP,
                ChatResponseCommandButtonPart: extHostTypes.$VP,
                ChatResponseDetectedParticipantPart: extHostTypes.$OP,
                ChatResponseConfirmationPart: extHostTypes.$PP,
                ChatResponseReferencePartStatusKind: extHostTypes.ChatResponseReferencePartStatusKind,
                ChatRequestTurn: extHostTypes.$ZP,
                ChatResponseTurn: extHostTypes.$1P,
                ChatLocation: extHostTypes.ChatLocation,
                ChatRequestEditorData: extHostTypes.$2P,
                ChatRequestNotebookData: extHostTypes.$3P,
                LanguageModelChatMessageRole: extHostTypes.LanguageModelChatMessageRole,
                LanguageModelChatMessage: extHostTypes.$5P,
                LanguageModelChatMessageFunctionResultPart: extHostTypes.$4P,
                LanguageModelChatResponseTextPart: extHostTypes.$7P,
                LanguageModelChatResponseFunctionUsePart: extHostTypes.$6P,
                LanguageModelError: extHostTypes.$$P,
                NewSymbolName: extHostTypes.$5O,
                NewSymbolNameTag: extHostTypes.NewSymbolNameTag,
                NewSymbolNameTriggerKind: extHostTypes.NewSymbolNameTriggerKind,
                InlineEdit: extHostTypes.$_P,
                InlineEditTriggerKind: extHostTypes.InlineEditTriggerKind,
                ExcludeSettingOptions: searchExtTypes_1.ExcludeSettingOptions,
                TextSearchContextNew: searchExtTypes_1.$ZL,
                TextSearchMatchNew: searchExtTypes_1.$YL,
                TextSearchCompleteMessageTypeNew: searchExtTypes_1.TextSearchCompleteMessageTypeNew,
            };
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[277/*vs/workbench/api/common/extHost.common.services*/], __M([1/*require*/,0/*exports*/,60/*vs/platform/instantiation/common/extensions*/,128/*vs/workbench/api/common/extHostOutput*/,45/*vs/workbench/api/common/extHostWorkspace*/,122/*vs/workbench/api/common/extHostDecorations*/,46/*vs/workbench/api/common/extHostConfiguration*/,33/*vs/workbench/api/common/extHostCommands*/,57/*vs/workbench/api/common/extHostDocumentsAndEditors*/,56/*vs/workbench/api/common/extHostTerminalService*/,131/*vs/workbench/api/common/extHostTask*/,133/*vs/workbench/api/common/extHostDebugService*/,134/*vs/workbench/api/common/extHostSearch*/,88/*vs/workbench/api/common/extHostStorage*/,92/*vs/workbench/api/common/extHostTunnelService*/,84/*vs/workbench/api/common/extHostApiDeprecationService*/,121/*vs/workbench/api/common/extHostWindow*/,68/*vs/workbench/api/common/extHostFileSystemConsumer*/,50/*vs/workbench/api/common/extHostFileSystemInfo*/,87/*vs/workbench/api/common/extHostSecretState*/,66/*vs/workbench/api/common/extHostTelemetry*/,70/*vs/workbench/api/common/extHostEditorTabs*/,216/*vs/workbench/api/common/extHostLoggerService*/,11/*vs/platform/log/common/log*/,132/*vs/workbench/api/common/extHostVariableResolverService*/,85/*vs/workbench/api/common/extHostLocalizationService*/,86/*vs/workbench/api/common/extHostManagedSockets*/,90/*vs/workbench/api/common/extHostAuthentication*/,94/*vs/workbench/api/common/extHostLanguageModels*/,126/*vs/workbench/api/common/extHostTerminalShellIntegration*/,95/*vs/workbench/api/common/extHostTesting*/]), function (require, exports, extensions_1, extHostOutput_1, extHostWorkspace_1, extHostDecorations_1, extHostConfiguration_1, extHostCommands_1, extHostDocumentsAndEditors_1, extHostTerminalService_1, extHostTask_1, extHostDebugService_1, extHostSearch_1, extHostStorage_1, extHostTunnelService_1, extHostApiDeprecationService_1, extHostWindow_1, extHostFileSystemConsumer_1, extHostFileSystemInfo_1, extHostSecretState_1, extHostTelemetry_1, extHostEditorTabs_1, extHostLoggerService_1, log_1, extHostVariableResolverService_1, extHostLocalizationService_1, extHostManagedSockets_1, extHostAuthentication_1, extHostLanguageModels_1, extHostTerminalShellIntegration_1, extHostTesting_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    (0, extensions_1.$Rs)(extHostLocalizationService_1.$mqc, extHostLocalizationService_1.$lqc, extensions_1.InstantiationType.Delayed);
    (0, extensions_1.$Rs)(log_1.$bk, extHostLoggerService_1.$Brc, extensions_1.InstantiationType.Delayed);
    (0, extensions_1.$Rs)(extHostApiDeprecationService_1.$rpc, extHostApiDeprecationService_1.$spc, extensions_1.InstantiationType.Delayed);
    (0, extensions_1.$Rs)(extHostCommands_1.$GQ, extHostCommands_1.$FQ, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostAuthentication_1.$Bpc, extHostAuthentication_1.$Cpc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostLanguageModels_1.$gqc, extHostLanguageModels_1.$hqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostConfiguration_1.$Qpc, extHostConfiguration_1.$Opc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostFileSystemConsumer_1.$Spc, extHostFileSystemConsumer_1.$Rpc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostTesting_1.$wqc, extHostTesting_1.$xqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostDebugService_1.$Bqc, extHostDebugService_1.$Fqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostDecorations_1.$Hqc, extHostDecorations_1.$Gqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostDocumentsAndEditors_1.$vQ, extHostDocumentsAndEditors_1.$uQ, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostManagedSockets_1.$nqc, extHostManagedSockets_1.$oqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostFileSystemInfo_1.$vpc, extHostFileSystemInfo_1.$upc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostOutput_1.$brc, extHostOutput_1.$arc, extensions_1.InstantiationType.Delayed);
    (0, extensions_1.$Rs)(extHostSearch_1.$Xqc, extHostSearch_1.$Yqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostStorage_1.$_pc, extHostStorage_1.$$pc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostTask_1.$orc, extHostTask_1.$nrc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostTerminalService_1.$cqc, extHostTerminalService_1.$fqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostTerminalShellIntegration_1.$prc, extHostTerminalShellIntegration_1.$qrc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostTunnelService_1.$gGb, extHostTunnelService_1.$hGb, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostWindow_1.$zrc, extHostWindow_1.$yrc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostWorkspace_1.$Npc, extHostWorkspace_1.$Mpc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostSecretState_1.$jqc, extHostSecretState_1.$iqc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostTelemetry_1.$EQ, extHostTelemetry_1.$BQ, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostEditorTabs_1.$3pc, extHostEditorTabs_1.$4pc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostVariableResolverService_1.$uqc, extHostVariableResolverService_1.$vqc, extensions_1.InstantiationType.Eager);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[278/*vs/workbench/api/worker/extHostExtensionService*/], __M([1/*require*/,0/*exports*/,276/*vs/workbench/api/common/extHost.api.impl*/,47/*vs/workbench/api/common/extHostExtensionService*/,2/*vs/base/common/uri*/,273/*vs/workbench/api/common/extHostRequireInterceptor*/,7/*vs/workbench/api/common/extHostTypes*/,10/*vs/base/common/async*/,223/*vs/workbench/api/worker/extHostConsoleForwarder*/]), function (require, exports, extHost_api_impl_1, extHostExtensionService_1, uri_1, extHostRequireInterceptor_1, extHostTypes_1, async_1, extHostConsoleForwarder_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.$Otc = void 0;
    class WorkerRequireInterceptor extends extHostRequireInterceptor_1.$Erc {
        j() { }
        getModule(request, parent) {
            for (const alternativeModuleName of this.b) {
                const alternative = alternativeModuleName(request);
                if (alternative) {
                    request = alternative;
                    break;
                }
            }
            if (this.a.has(request)) {
                return this.a.get(request).load(request, parent, () => { throw new Error('CANNOT LOAD MODULE from here.'); });
            }
            return undefined;
        }
    }
    class $Otc extends extHostExtensionService_1.$qqc {
        constructor() {
            super(...arguments);
            this.extensionRuntime = extHostTypes_1.ExtensionRuntime.Webworker;
        }
        async vb() {
            // make sure console.log calls make it to the render
            this.h.createInstance(extHostConsoleForwarder_1.$Ntc);
            // initialize API and register actors
            const apiFactory = this.h.invokeFunction(extHost_api_impl_1.$Arc);
            this.r = this.h.createInstance(WorkerRequireInterceptor, apiFactory, { mine: this.J, all: this.L });
            await this.r.install();
            performance.mark('code/extHost/didInitAPI');
            await this.Bb();
        }
        wb(extensionDescription) {
            return extensionDescription.browser;
        }
        async xb(extension, module, activationTimesBuilder) {
            module = module.with({ path: ensureSuffix(module.path, '.js') });
            const extensionId = extension?.identifier.value;
            if (extensionId) {
                performance.mark(`code/extHost/willFetchExtensionCode/${extensionId}`);
            }
            // First resolve the extension entry point URI to something we can load using `fetch`
            // This needs to be done on the main thread due to a potential `resourceUriProvider` (workbench api)
            // which is only available in the main thread
            const browserUri = uri_1.URI.revive(await this.C.$asBrowserUri(module));
            const response = await fetch(browserUri.toString(true));
            if (extensionId) {
                performance.mark(`code/extHost/didFetchExtensionCode/${extensionId}`);
            }
            if (response.status !== 200) {
                throw new Error(response.statusText);
            }
            // fetch JS sources as text and create a new function around it
            const source = await response.text();
            // Here we append #vscode-extension to serve as a marker, such that source maps
            // can be adjusted for the extra wrapping function.
            const sourceURL = `${module.toString(true)}#vscode-extension`;
            const fullSource = `${source}\n//# sourceURL=${sourceURL}`;
            let initFn;
            try {
                initFn = new Function('module', 'exports', 'require', fullSource); // CodeQL [SM01632] js/eval-call there is no alternative until we move to ESM
            }
            catch (err) {
                if (extensionId) {
                    console.error(`Loading code for extension ${extensionId} failed: ${err.message}`);
                }
                else {
                    console.error(`Loading code failed: ${err.message}`);
                }
                console.error(`${module.toString(true)}${typeof err.line === 'number' ? ` line ${err.line}` : ''}${typeof err.column === 'number' ? ` column ${err.column}` : ''}`);
                console.error(err);
                throw err;
            }
            if (extension) {
                await this.w.initializeLocalizedMessages(extension);
            }
            // define commonjs globals: `module`, `exports`, and `require`
            const _exports = {};
            const _module = { exports: _exports };
            const _require = (request) => {
                const result = this.r.getModule(request, module);
                if (result === undefined) {
                    throw new Error(`Cannot load module '${request}'`);
                }
                return result;
            };
            try {
                activationTimesBuilder.codeLoadingStart();
                if (extensionId) {
                    performance.mark(`code/extHost/willLoadExtensionCode/${extensionId}`);
                }
                initFn(_module, _exports, _require);
                return (_module.exports !== _exports ? _module.exports : _exports);
            }
            finally {
                if (extensionId) {
                    performance.mark(`code/extHost/didLoadExtensionCode/${extensionId}`);
                }
                activationTimesBuilder.codeLoadingStop();
            }
        }
        async $setRemoteEnvironment(_env) {
            return;
        }
        async Bb(waitTimeout = 5000) {
            // debugger attaches async, waiting for it fixes #106698 and #99222
            if (!this.f.environment.isExtensionDevelopmentDebug) {
                return;
            }
            const deadline = Date.now() + waitTimeout;
            while (Date.now() < deadline && !('__jsDebugIsReady' in globalThis)) {
                await (0, async_1.$Gh)(10);
            }
        }
    }
    exports.$Otc = $Otc;
    function ensureSuffix(path, suffix) {
        return path.endsWith(suffix) ? path : path + suffix;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[279/*vs/workbench/api/worker/extHost.worker.services*/], __M([1/*require*/,0/*exports*/,73/*vs/platform/instantiation/common/descriptors*/,60/*vs/platform/instantiation/common/extensions*/,11/*vs/platform/log/common/log*/,47/*vs/workbench/api/common/extHostExtensionService*/,188/*vs/workbench/api/common/extHostLogService*/,91/*vs/workbench/api/common/extHostStoragePaths*/,278/*vs/workbench/api/worker/extHostExtensionService*/]), function (require, exports, descriptors_1, extensions_1, log_1, extHostExtensionService_1, extHostLogService_1, extHostStoragePaths_1, extHostExtensionService_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // #########################################################################
    // ###                                                                   ###
    // ### !!! PLEASE ADD COMMON IMPORTS INTO extHost.common.services.ts !!! ###
    // ###                                                                   ###
    // #########################################################################
    (0, extensions_1.$Rs)(log_1.$ak, new descriptors_1.$Ci(extHostLogService_1.$Drc, [true], true));
    (0, extensions_1.$Rs)(extHostExtensionService_1.$rqc, extHostExtensionService_2.$Otc, extensions_1.InstantiationType.Eager);
    (0, extensions_1.$Rs)(extHostStoragePaths_1.$Tpc, extHostStoragePaths_1.$Upc, extensions_1.InstantiationType.Eager);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/























define(__m[287/*vs/workbench/api/worker/extensionHostWorker*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/buffer*/,6/*vs/base/common/event*/,83/*vs/workbench/services/extensions/common/extensionHostProtocol*/,274/*vs/workbench/api/common/extensionHostMain*/,225/*vs/workbench/services/extensions/worker/polyfillNestedWorker*/,19/*vs/base/common/path*/,64/*vs/base/common/performance*/,15/*vs/base/common/network*/,2/*vs/base/common/uri*/,277/*vs/workbench/api/common/extHost.common.services*/,279/*vs/workbench/api/worker/extHost.worker.services*/]), function (require, exports, buffer_1, event_1, extensionHostProtocol_1, extensionHostMain_1, polyfillNestedWorker_1, path, performance, network_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.create = create;
    path = __importStar(path);
    performance = __importStar(performance);
    const nativeClose = self.close.bind(self);
    self.close = () => console.trace(`'close' has been blocked`);
    const nativePostMessage = postMessage.bind(self);
    self.postMessage = () => console.trace(`'postMessage' has been blocked`);
    function shouldTransformUri(uri) {
        // In principle, we could convert any URI, but we have concerns
        // that parsing https URIs might end up decoding escape characters
        // and result in an unintended transformation
        return /^(file|vscode-remote):/i.test(uri);
    }
    const nativeFetch = fetch.bind(self);
    function patchFetching(asBrowserUri) {
        self.fetch = async function (input, init) {
            if (input instanceof Request) {
                // Request object - massage not supported
                return nativeFetch(input, init);
            }
            if (shouldTransformUri(String(input))) {
                input = (await asBrowserUri(uri_1.URI.parse(String(input)))).toString(true);
            }
            return nativeFetch(input, init);
        };
        self.XMLHttpRequest = class extends XMLHttpRequest {
            open(method, url, async, username, password) {
                (async () => {
                    if (shouldTransformUri(url.toString())) {
                        url = (await asBrowserUri(uri_1.URI.parse(url.toString()))).toString(true);
                    }
                    super.open(method, url, async ?? true, username, password);
                })();
            }
        };
    }
    self.importScripts = () => { throw new Error(`'importScripts' has been blocked`); };
    // const nativeAddEventListener = addEventListener.bind(self);
    self.addEventListener = () => console.trace(`'addEventListener' has been blocked`);
    self['AMDLoader'] = undefined;
    self['NLSLoaderPlugin'] = undefined;
    self['define'] = undefined;
    self['require'] = undefined;
    self['webkitRequestFileSystem'] = undefined;
    self['webkitRequestFileSystemSync'] = undefined;
    self['webkitResolveLocalFileSystemSyncURL'] = undefined;
    self['webkitResolveLocalFileSystemURL'] = undefined;
    if (self.Worker) {
        // make sure new Worker(...) always uses blob: (to maintain current origin)
        const _Worker = self.Worker;
        Worker = function (stringUrl, options) {
            if (/^file:/i.test(stringUrl.toString())) {
                stringUrl = network_1.$Zg.uriToBrowserUri(uri_1.URI.parse(stringUrl.toString())).toString(true);
            }
            else if (/^vscode-remote:/i.test(stringUrl.toString())) {
                // Supporting transformation of vscode-remote URIs requires an async call to the main thread,
                // but we cannot do this call from within the embedded Worker, and the only way out would be
                // to use templating instead of a function in the web api (`resourceUriProvider`)
                throw new Error(`Creating workers from remote extensions is currently not supported.`);
            }
            // IMPORTANT: bootstrapFn is stringified and injected as worker blob-url. Because of that it CANNOT
            // have dependencies on other functions or variables. Only constant values are supported. Due to
            // that logic of FileAccess.asBrowserUri had to be copied, see `asWorkerBrowserUrl` (below).
            const bootstrapFnSource = (function bootstrapFn(workerUrl) {
                function asWorkerBrowserUrl(url) {
                    if (typeof url === 'string' || url instanceof URL) {
                        return String(url).replace(/^file:\/\//i, 'vscode-file://vscode-app');
                    }
                    return url;
                }
                const nativeFetch = fetch.bind(self);
                self.fetch = function (input, init) {
                    if (input instanceof Request) {
                        // Request object - massage not supported
                        return nativeFetch(input, init);
                    }
                    return nativeFetch(asWorkerBrowserUrl(input), init);
                };
                self.XMLHttpRequest = class extends XMLHttpRequest {
                    open(method, url, async, username, password) {
                        return super.open(method, asWorkerBrowserUrl(url), async ?? true, username, password);
                    }
                };
                const nativeImportScripts = importScripts.bind(self);
                self.importScripts = (...urls) => {
                    nativeImportScripts(...urls.map(asWorkerBrowserUrl));
                };
                nativeImportScripts(workerUrl);
            }).toString();
            const js = `(${bootstrapFnSource}('${stringUrl}'))`;
            options = options || {};
            options.name = `${name} -> ${options.name || path.$nc(stringUrl.toString())}`;
            const blob = new Blob([js], { type: 'application/javascript' });
            const blobUrl = URL.createObjectURL(blob);
            return new _Worker(blobUrl, options);
        };
    }
    else {
        self.Worker = class extends polyfillNestedWorker_1.$Ptc {
            constructor(stringOrUrl, options) {
                super(nativePostMessage, stringOrUrl, { name: path.$nc(stringOrUrl.toString()), ...options });
            }
        };
    }
    //#endregion ---
    const hostUtil = new class {
        constructor() {
            this.pid = undefined;
        }
        exit(_code) {
            nativeClose();
        }
    };
    class ExtensionWorker {
        constructor() {
            const channel = new MessageChannel();
            const emitter = new event_1.$le();
            let terminating = false;
            // send over port2, keep port1
            nativePostMessage(channel.port2, [channel.port2]);
            channel.port1.onmessage = event => {
                const { data } = event;
                if (!(data instanceof ArrayBuffer)) {
                    console.warn('UNKNOWN data received', data);
                    return;
                }
                const msg = buffer_1.$Ne.wrap(new Uint8Array(data, 0, data.byteLength));
                if ((0, extensionHostProtocol_1.$Cn)(msg, extensionHostProtocol_1.MessageType.Terminate)) {
                    // handle terminate-message right here
                    terminating = true;
                    onTerminate('received terminate message from renderer');
                    return;
                }
                // emit non-terminate messages to the outside
                emitter.fire(msg);
            };
            this.protocol = {
                onMessage: emitter.event,
                send: vsbuf => {
                    if (!terminating) {
                        const data = vsbuf.buffer.buffer.slice(vsbuf.buffer.byteOffset, vsbuf.buffer.byteOffset + vsbuf.buffer.byteLength);
                        channel.port1.postMessage(data, [data]);
                    }
                }
            };
        }
    }
    function connectToRenderer(protocol) {
        return new Promise(resolve => {
            const once = protocol.onMessage(raw => {
                once.dispose();
                const initData = JSON.parse(raw.toString());
                protocol.send((0, extensionHostProtocol_1.$Bn)(extensionHostProtocol_1.MessageType.Initialized));
                resolve({ protocol, initData });
            });
            protocol.send((0, extensionHostProtocol_1.$Bn)(extensionHostProtocol_1.MessageType.Ready));
        });
    }
    let onTerminate = (reason) => nativeClose();
    function isInitMessage(a) {
        return !!a && typeof a === 'object' && a.type === 'vscode.init' && a.data instanceof Map;
    }
    function create() {
        performance.mark(`code/extHost/willConnectToRenderer`);
        const res = new ExtensionWorker();
        return {
            onmessage(message) {
                if (!isInitMessage(message)) {
                    return; // silently ignore foreign messages
                }
                connectToRenderer(res.protocol).then(data => {
                    performance.mark(`code/extHost/didWaitForInitData`);
                    const extHostMain = new extensionHostMain_1.$Grc(data.protocol, data.initData, hostUtil, null, message.data);
                    patchFetching(uri => extHostMain.asBrowserUri(uri));
                    onTerminate = (reason) => extHostMain.terminate(reason);
                });
            }
        };
    }
});

}).call(this);
//# sourceMappingURL=extensionHostWorker.js.map
