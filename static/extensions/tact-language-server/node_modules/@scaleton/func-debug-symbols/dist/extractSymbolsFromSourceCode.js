"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSymbolsFromSourceCode = void 0;
const web_tree_sitter_1 = __importDefault(require("web-tree-sitter"));
const tree_sitter_func_1 = require("@scaleton/tree-sitter-func");
const crypto_1 = require("@ton/crypto");
const buffer_crc32_1 = __importDefault(require("buffer-crc32"));
const core_1 = require("@ton/core");
async function extractSymbolsFromSourceCode(snapshot) {
    await web_tree_sitter_1.default.init();
    const parser = new web_tree_sitter_1.default();
    parser.setLanguage(await (0, tree_sitter_func_1.loadFunC)());
    const { rootNode } = parser.parse(snapshot.map((entry) => entry.content).join('\n'));
    const constants = [];
    for (const child of rootNode.children) {
        if (child.type === 'constant_declarations') {
            const constant_declaration = child.child(1);
            const type = constant_declaration.childForFieldName('type').text;
            const name = constant_declaration.childForFieldName('name').text;
            const declaration = constant_declaration
                .childForFieldName('value')
                .child(0).text;
            let value = declaration;
            if (type === 'int') {
                let matches;
                if ((matches = value.match(/^"([^"]+)"([Hhcu])$/))) {
                    const mode = matches[2];
                    if (mode === 'u') {
                        // u - hex(...)
                        value = BigInt('0x' + Buffer.from(matches[1]).toString('hex')).toString();
                    }
                    else if (mode === 'h') {
                        // h - sha256(...) - first 32 bits
                        value = BigInt('0x' + (0, crypto_1.sha256_sync)(matches[1]).subarray(0, 4).toString('hex')).toString();
                    }
                    else if (mode === 'H') {
                        // H - sha256(...) - all 256 bits
                        value = BigInt('0x' + (0, crypto_1.sha256_sync)(matches[1]).toString('hex')).toString();
                    }
                    else if (mode === 'c') {
                        // c - crc32(...)
                        value = (0, buffer_crc32_1.default)(matches[1]).readUint32BE().toString();
                    }
                }
                else if ((matches = value.match(/^-?(0x[0-9a-fA-F]+|[0-9]+)$/))) {
                    const sign = value.startsWith('-') ? -1n : 1n;
                    value = (BigInt(matches[1]) * sign).toString();
                }
                else {
                    console.log('Not supported:', value);
                    continue;
                }
            }
            if (type === 'slice') {
                let matches;
                if ((matches = value.match(/^"([^"]*)"a$/))) {
                    // a - address
                    try {
                        value = (0, core_1.beginCell)()
                            .storeAddress(core_1.Address.parse(matches[1]))
                            .endCell()
                            .toString()
                            .toLowerCase();
                    }
                    catch (e) {
                        console.log('Address not supported:', value);
                        continue;
                    }
                }
                else if ((matches = value.match(/^"([0-9a-fA-F]+)"s$/))) {
                    // ascii string
                    value = `x{${matches[1].toLowerCase()}}`;
                }
                else if ((matches = value.match(/^"([^"]*)"$/))) {
                    // ascii string
                    value = (0, core_1.beginCell)()
                        .storeStringTail(matches[1])
                        .endCell()
                        .toString()
                        .toLowerCase();
                }
                else {
                    console.log('Not supported:', value);
                    continue;
                }
            }
            constants.push({
                type,
                name,
                value,
                declaration,
            });
        }
    }
    return {
        constants,
    };
}
exports.extractSymbolsFromSourceCode = extractSymbolsFromSourceCode;
